,Question,Answer
0,"class Solution {
 public:
  vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i) {
      if (const auto it = numToIndex.find(target - nums[i]);
          it != numToIndex.cend())
        return {it->second, i};
      numToIndex[nums[i]] = i;
    }

    throw;
  }
};",1
1,"class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    int carry = 0;

    while (l1 != nullptr || l2 != nullptr || carry > 0) {
      if (l1 != nullptr) {
        carry += l1->val;
        l1 = l1->next;
      }
      if (l2 != nullptr) {
        carry += l2->val;
        l2 = l2->next;
      }
      curr->next = new ListNode(carry % 10);
      carry /= 10;
      curr = curr->next;
    }

    return dummy.next;
  }
};",2
2,"class Solution {
 public:
  int lengthOfLongestSubstring(string s) {
    int ans = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      ++count[s[r]];
      while (count[s[r]] > 1)
        --count[s[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",3
3,"class Solution {
 public:
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    const int n1 = nums1.size();
    const int n2 = nums2.size();
    if (n1 > n2)
      return findMedianSortedArrays(nums2, nums1);

    int l = 0;
    int r = n1;

    while (l <= r) {
      const int partition1 = (l + r) / 2;
      const int partition2 = (n1 + n2 + 1) / 2 - partition1;
      const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1[partition1 - 1];
      const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2[partition2 - 1];
      const int minRight1 = partition1 == n1 ? INT_MAX : nums1[partition1];
      const int minRight2 = partition2 == n2 ? INT_MAX : nums2[partition2];
      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)
        return (n1 + n2) % 2 == 0
                   ? (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5
                   : max(maxLeft1, maxLeft2);
      else if (maxLeft1 > minRight2)
        r = partition1 - 1;
      else
        l = partition1 + 1;
    }

    throw;
  }
};",4
4,"class Solution {
 public:
  string longestPalindrome(string s) {
    if (s.empty())
      return """";

    // (start, end) indices of the longest palindrome in s
    pair<int, int> indices{0, 0};

    for (int i = 0; i < s.length(); ++i) {
      const auto [l1, r1] = extend(s, i, i);
      if (r1 - l1 > indices.second - indices.first)
        indices = {l1, r1};
      if (i + 1 < s.length() && s[i] == s[i + 1]) {
        const auto [l2, r2] = extend(s, i, i + 1);
        if (r2 - l2 > indices.second - indices.first)
          indices = {l2, r2};
      }
    }

    return s.substr(indices.first, indices.second - indices.first + 1);
  }

 private:
  // Returns the (start, end) indices of the longest palindrome extended from
  // the substring s[i..j].
  pair<int, int> extend(const string& s, int i, int j) {
    for (; i >= 0 && j < s.length(); --i, ++j)
      if (s[i] != s[j])
        break;
    return {i + 1, j - 1};
  }
};",5
5,"class Solution {
 public:
  string convert(string s, int numRows) {
    string ans;
    vector<vector<char>> rows(numRows);
    int k = 0;
    int direction = (numRows == 1) - 1;

    for (const char c : s) {
      rows[k].push_back(c);
      if (k == 0 || k == numRows - 1)
        direction *= -1;
      k += direction;
    }

    for (const vector<char>& row : rows)
      for (const char c : row)
        ans += c;

    return ans;
  }
};",6
6,"class Solution {
 public:
  int reverse(int x) {
    long ans = 0;

    while (x != 0) {
      ans = ans * 10 + x % 10;
      x /= 10;
    }

    return (ans < INT_MIN || ans > INT_MAX) ? 0 : ans;
  }
};",7
7,"class Solution {
 public:
  int myAtoi(string s) {
    trim(s);
    if (s.empty())
      return 0;

    const int sign = s[0] == '-' ? -1 : 1;
    if (s[0] == '+' || s[0] == '-')
      s = s.substr(1);

    long num = 0;

    for (const char c : s) {
      if (!isdigit(c))
        break;
      num = num * 10 + (c - '0');
      if (sign * num < INT_MIN)
        return INT_MIN;
      if (sign * num > INT_MAX)
        return INT_MAX;
    }

    return sign * num;
  }

 private:
  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};",8
8,"class Solution {
 public:
  bool isPalindrome(int x) {
    if (x < 0)
      return false;

    long reversed = 0;
    int y = x;

    while (y > 0) {
      reversed = reversed * 10 + y % 10;
      y /= 10;
    }

    return reversed == x;
  }
};",9
9,"class Solution {
 public:
  bool isMatch(string s, string p) {
    const int m = s.length();
    const int n = p.length();
    // dp[i][j] := true if s[0..i) matches p[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    auto isMatch = [&](int i, int j) -> bool {
      return j >= 0 && p[j] == '.' || s[i] == p[j];
    };

    for (int j = 0; j < p.length(); ++j)
      if (p[j] == '*' && dp[0][j - 1])
        dp[0][j + 1] = true;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (p[j] == '*') {
          // The minimum index of '*' is 1.
          const bool noRepeat = dp[i + 1][j - 1];
          const bool doRepeat = isMatch(i, j - 1) && dp[i][j + 1];
          dp[i + 1][j + 1] = noRepeat || doRepeat;
        } else if (isMatch(i, j)) {
          dp[i + 1][j + 1] = dp[i][j];
        }

    return dp[m][n];
  }
};",10
10,"class Solution {
 public:
  int maxArea(vector<int>& height) {
    int ans = 0;
    int l = 0;
    int r = height.size() - 1;

    while (l < r) {
      const int minHeight = min(height[l], height[r]);
      ans = max(ans, minHeight * (r - l));
      if (height[l] < height[r])
        ++l;
      else
        --r;
    }

    return ans;
  }
};",11
11,"class Solution {
 public:
  string intToRoman(int num) {
    const vector<pair<int, string>> valueSymbols{
        {1000, ""M""}, {900, ""CM""}, {500, ""D""}, {400, ""CD""}, {100, ""C""},
        {90, ""XC""},  {50, ""L""},   {40, ""XL""}, {10, ""X""},   {9, ""IX""},
        {5, ""V""},    {4, ""IV""},   {1, ""I""}};
    string ans;

    for (const auto& [value, symbol] : valueSymbols) {
      if (num == 0)
        break;
      while (num >= value) {
        num -= value;
        ans += symbol;
      }
    }

    return ans;
  }
};",12
12,"class Solution {
 public:
  int romanToInt(string s) {
    int ans = 0;
    vector<int> roman(128);

    roman['I'] = 1;
    roman['V'] = 5;
    roman['X'] = 10;
    roman['L'] = 50;
    roman['C'] = 100;
    roman['D'] = 500;
    roman['M'] = 1000;

    for (int i = 0; i + 1 < s.length(); ++i)
      if (roman[s[i]] < roman[s[i + 1]])
        ans -= roman[s[i]];
      else
        ans += roman[s[i]];

    return ans + roman[s.back()];
  }
};",13
13,"class Solution {
 public:
  string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty())
      return """";

    for (int i = 0; i < strs[0].length(); ++i)
      for (int j = 1; j < strs.size(); ++j)
        if (i == strs[j].length() || strs[j][i] != strs[0][i])
          return strs[0].substr(0, i);

    return strs[0];
  }
};",14
14,"class Solution {
 public:
  vector<vector<int>> threeSum(vector<int>& nums) {
    if (nums.size() < 3)
      return {};

    vector<vector<int>> ans;

    ranges::sort(nums);

    for (int i = 0; i + 2 < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      // Choose nums[i] as the first number in the triplet, then search the
      // remaining numbers in [i + 1, n - 1].
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r) {
        const int sum = nums[i] + nums[l] + nums[r];
        if (sum == 0) {
          ans.push_back({nums[i], nums[l++], nums[r--]});
          while (l < r && nums[l] == nums[l - 1])
            ++l;
          while (l < r && nums[r] == nums[r + 1])
            --r;
        } else if (sum < 0) {
          ++l;
        } else {
          --r;
        }
      }
    }

    return ans;
  }
};",15
15,"class Solution {
 public:
  int threeSumClosest(vector<int>& nums, int target) {
    int ans = nums[0] + nums[1] + nums[2];

    ranges::sort(nums);

    for (int i = 0; i + 2 < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      // Choose nums[i] as the first number in the triplet, then search the
      // remaining numbers in [i + 1, n - 1].
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r) {
        const int sum = nums[i] + nums[l] + nums[r];
        if (sum == target)
          return sum;
        if (abs(sum - target) < abs(ans - target))
          ans = sum;
        if (sum < target)
          ++l;
        else
          --r;
      }
    }

    return ans;
  }
};",16
16,"class Solution {
 public:
  vector<string> letterCombinations(string digits) {
    if (digits.empty())
      return {};

    vector<string> ans;

    dfs(digits, 0, """", ans);
    return ans;
  }

 private:
  const vector<string> digitToLetters{"""",    """",    ""abc"",  ""def"", ""ghi"",
                                      ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

  void dfs(const string& digits, int i, string&& path, vector<string>& ans) {
    if (i == digits.length()) {
      ans.push_back(path);
      return;
    }

    for (const char letter : digitToLetters[digits[i] - '0']) {
      path.push_back(letter);
      dfs(digits, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",17
17,"class Solution {
 public:
  vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> ans;
    vector<int> path;
    ranges::sort(nums);
    nSum(nums, 4, target, 0, nums.size() - 1, path, ans);
    return ans;
  }

 private:
  // Finds n numbers that add up to the target in [l, r].
  void nSum(const vector<int>& nums, long n, long target, int l, int r,
            vector<int>& path, vector<vector<int>>& ans) {
    if (r - l + 1 < n || target < nums[l] * n || target > nums[r] * n)
      return;
    if (n == 2) {
      // Similar to the sub procedure in 15. 3Sum
      while (l < r) {
        const int sum = nums[l] + nums[r];
        if (sum == target) {
          path.push_back(nums[l]);
          path.push_back(nums[r]);
          ans.push_back(path);
          path.pop_back();
          path.pop_back();
          ++l;
          --r;
          while (l < r && nums[l] == nums[l - 1])
            ++l;
          while (l < r && nums[r] == nums[r + 1])
            --r;
        } else if (sum < target) {
          ++l;
        } else {
          --r;
        }
      }
      return;
    }

    for (int i = l; i <= r; ++i) {
      if (i > l && nums[i] == nums[i - 1])
        continue;
      path.push_back(nums[i]);
      nSum(nums, n - 1, target - nums[i], i + 1, r, path, ans);
      path.pop_back();
    }
  }
};",18
18,"class Solution {
 public:
  ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (n--)
      fast = fast->next;
    if (fast == nullptr)
      return head->next;

    while (fast->next) {
      slow = slow->next;
      fast = fast->next;
    }
    slow->next = slow->next->next;

    return head;
  }
};",19
19,"class Solution {
 public:
  bool isValid(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == '(')
        stack.push(')');
      else if (c == '{')
        stack.push('}');
      else if (c == '[')
        stack.push(']');
      else if (stack.empty() || pop(stack) != c)
        return false;

    return stack.empty();
  }

 private:
  int pop(stack<char>& stack) {
    const int c = stack.top();
    stack.pop();
    return c;
  }
};",20
20,"class Solution {
 public:
  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2)
      return list1 ? list1 : list2;
    if (list1->val > list2->val)
      swap(list1, list2);
    list1->next = mergeTwoLists(list1->next, list2);
    return list1;
  }
};",21
21,"class Solution {
 public:
  vector<string> generateParenthesis(int n) {
    vector<string> ans;
    dfs(n, n, """", ans);
    return ans;
  }

 private:
  void dfs(int l, int r, string&& path, vector<string>& ans) {
    if (l == 0 && r == 0) {
      ans.push_back(path);
      return;
    }

    if (l > 0) {
      path.push_back('(');
      dfs(l - 1, r, move(path), ans);
      path.pop_back();
    }
    if (l < r) {
      path.push_back(')');
      dfs(l, r - 1, move(path), ans);
      path.pop_back();
    }
  }
};",22
22,"class Solution {
 public:
  ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    auto compare = [](ListNode* a, ListNode* b) { return a->val > b->val; };
    priority_queue<ListNode*, vector<ListNode*>, decltype(compare)> minHeap(
        compare);

    for (ListNode* list : lists)
      if (list != nullptr)
        minHeap.push(list);

    while (!minHeap.empty()) {
      ListNode* minNode = minHeap.top();
      minHeap.pop();
      if (minNode->next)
        minHeap.push(minNode->next);
      curr->next = minNode;
      curr = curr->next;
    }

    return dummy.next;
  }
};",23
23,"class Solution {
 public:
  ListNode* swapPairs(ListNode* head) {
    const int length = getLength(head);
    ListNode dummy(0, head);
    ListNode* prev = &dummy;
    ListNode* curr = head;

    for (int i = 0; i < length / 2; ++i) {
      ListNode* next = curr->next;
      curr->next = next->next;
      next->next = prev->next;
      prev->next = next;
      prev = curr;
      curr = curr->next;
    }

    return dummy.next;
  }

 private:
  int getLength(ListNode* head) {
    int length = 0;
    for (ListNode* curr = head; curr; curr = curr->next)
      ++length;
    return length;
  }
};",24
24,"class Solution {
 public:
  ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr)
      return nullptr;

    ListNode* tail = head;

    for (int i = 0; i < k; ++i) {
      // There are less than k nodes in the list, do nothing.
      if (tail == nullptr)
        return head;
      tail = tail->next;
    }

    ListNode* newHead = reverse(head, tail);
    head->next = reverseKGroup(tail, k);
    return newHead;
  }

 private:
  // Reverses [head, tail).
  ListNode* reverse(ListNode* head, ListNode* tail) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    while (curr != tail) {
      ListNode* next = curr->next;
      curr->next = prev;
      prev = curr;
      curr = next;
    }
    return prev;
  }
};",25
25,"class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int i = 0;

    for (const int num : nums)
      if (i < 1 || num > nums[i - 1])
        nums[i++] = num;

    return i;
  }
};",26
26,"class Solution {
 public:
  int removeElement(vector<int>& nums, int val) {
    int i = 0;

    for (const int num : nums)
      if (num != val)
        nums[i++] = num;

    return i;
  }
};",27
27,"class Solution {
 public:
  int strStr(string haystack, string needle) {
    const int m = haystack.length();
    const int n = needle.length();

    for (int i = 0; i < m - n + 1; i++)
      if (haystack.substr(i, n) == needle)
        return i;

    return -1;
  }
};",28
28,"class Solution {
 public:
  int divide(int dividend, int divisor) {
    // -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.
    if (dividend == INT_MIN && divisor == -1)
      return INT_MAX;

    const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;
    long ans = 0;
    long dvd = labs(dividend);
    long dvs = labs(divisor);

    while (dvd >= dvs) {
      long k = 1;
      while (k * 2 * dvs <= dvd)
        k *= 2;
      dvd -= k * dvs;
      ans += k;
    }

    return sign * ans;
  }
};",29
29,"class Solution {
 public:
  vector<int> findSubstring(string s, vector<string>& words) {
    if (s.empty() || words.empty())
      return {};

    const int k = words.size();
    const int n = words[0].length();
    vector<int> ans;
    unordered_map<string, int> count;

    for (const string& word : words)
      ++count[word];

    for (int i = 0; i < s.length() - k * n + 1; ++i) {
      unordered_map<string, int> seen;
      int j;
      for (j = 0; j < k; ++j) {
        const string& word = s.substr(i + j * n, n);
        if (++seen[word] > count[word])
          break;
      }
      if (j == k)
        ans.push_back(i);
    }

    return ans;
  }
};",30
30,"class Solution {
 public:
  void nextPermutation(vector<int>& nums) {
    const int n = nums.size();

    // From back to front, find the first number < nums[i + 1].
    int i;
    for (i = n - 2; i >= 0; --i)
      if (nums[i] < nums[i + 1])
        break;

    // From back to front, find the first number > nums[i], swap it with
    // nums[i].
    if (i >= 0)
      for (int j = n - 1; j > i; --j)
        if (nums[j] > nums[i]) {
          swap(nums[i], nums[j]);
          break;
        }

    // Reverse nums[i + 1..n - 1].
    reverse(nums, i + 1, n - 1);
  }

 private:
  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};",31
31,"class Solution {
 public:
  int longestValidParentheses(string s) {
    const string s2 = "")"" + s;
    // dp[i] := the length of the longest valid parentheses in the substring
    // s2[1..i]
    vector<int> dp(s2.length());

    for (int i = 1; i < s2.length(); ++i)
      if (s2[i] == ')' && s2[i - dp[i - 1] - 1] == '(')
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;

    return ranges::max(dp);
  }
};",32
32,"class Solution {
 public:
  int search(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return m;
      if (nums[l] <= nums[m]) {  // nums[l..m] are sorted.
        if (nums[l] <= target && target < nums[m])
          r = m - 1;
        else
          l = m + 1;
      } else {  // nums[m..n - 1] are sorted.
        if (nums[m] < target && target <= nums[r])
          l = m + 1;
        else
          r = m - 1;
      }
    }

    return -1;
  }
};",33
33,"class Solution {
 public:
  vector<int> searchRange(vector<int>& nums, int target) {
    const int l = ranges::lower_bound(nums, target) - nums.begin();
    if (l == nums.size() || nums[l] != target)
      return {-1, -1};
    const int r = ranges::upper_bound(nums, target) - nums.begin() - 1;
    return {l, r};
  }
};",34
34,"class Solution {
 public:
  int searchInsert(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size();

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return m;
      if (nums[m] < target)
        l = m + 1;
      else
        r = m;
    }

    return l;
  }
};",35
35,"class Solution {
 public:
  bool isValidSudoku(vector<vector<char>>& board) {
    unordered_set<string> seen;

    for (int i = 0; i < 9; ++i)
      for (int j = 0; j < 9; ++j) {
        if (board[i][j] == '.')
          continue;
        const string c(1, board[i][j]);
        if (!seen.insert(c + ""@row"" + to_string(i)).second ||
            !seen.insert(c + ""@col"" + to_string(j)).second ||
            !seen.insert(c + ""@box"" + to_string(i / 3) + to_string(j / 3))
                 .second)
          return false;
      }

    return true;
  }
};",36
36,"class Solution {
 public:
  void solveSudoku(vector<vector<char>>& board) {
    solve(board, 0);
  }

 private:
  bool solve(vector<vector<char>>& board, int s) {
    if (s == 81)
      return true;

    const int i = s / 9;
    const int j = s % 9;

    if (board[i][j] != '.')
      return solve(board, s + 1);

    for (char c = '1'; c <= '9'; ++c)
      if (isValid(board, i, j, c)) {
        board[i][j] = c;
        if (solve(board, s + 1))
          return true;
        board[i][j] = '.';
      }

    return false;
  }

  bool isValid(vector<vector<char>>& board, int row, int col, char c) {
    for (int i = 0; i < 9; ++i)
      if (board[i][col] == c || board[row][i] == c ||
          board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)
        return false;
    return true;
  }
};",37
37,"class Solution {
 public:
  string countAndSay(int n) {
    string ans = ""1"";

    while (--n) {
      string next;
      for (int i = 0; i < ans.length(); ++i) {
        int count = 1;
        while (i + 1 < ans.length() && ans[i] == ans[i + 1]) {
          ++count;
          ++i;
        }
        next += to_string(count) + ans[i];
      }
      ans = move(next);
    }

    return ans;
  }
};",38
38,"class Solution {
 public:
  vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> ans;
    ranges::sort(candidates);
    dfs(candidates, 0, target, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (target < 0)
      return;
    if (target == 0) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i < A.size(); ++i) {
      path.push_back(A[i]);
      dfs(A, i, target - A[i], move(path), ans);
      path.pop_back();
    }
  }
};",39
39,"class Solution {
 public:
  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    vector<vector<int>> ans;
    ranges::sort(candidates);
    dfs(candidates, 0, target, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (target < 0)
      return;
    if (target == 0) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i < A.size(); ++i) {
      if (i > s && A[i] == A[i - 1])
        continue;
      path.push_back(A[i]);
      dfs(A, i + 1, target - A[i], move(path), ans);
      path.pop_back();
    }
  }
};",40
40,"class Solution {
 public:
  int firstMissingPositive(vector<int>& nums) {
    const int n = nums.size();

    // Correct slot:
    // nums[i] = i + 1
    // nums[i] - 1 = i
    // nums[nums[i] - 1] = nums[i]
    for (int i = 0; i < n; ++i)
      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])
        swap(nums[i], nums[nums[i] - 1]);

    for (int i = 0; i < n; ++i)
      if (nums[i] != i + 1)
        return i + 1;

    return n + 1;
  }
};",41
41,"class Solution {
 public:
  int trap(vector<int>& height) {
    const int n = height.size();
    int ans = 0;
    vector<int> l(n);  // l[i] := max(height[0..i])
    vector<int> r(n);  // r[i] := max(height[i..n))

    for (int i = 0; i < n; ++i)
      l[i] = i == 0 ? height[i] : max(height[i], l[i - 1]);

    for (int i = n - 1; i >= 0; --i)
      r[i] = i == n - 1 ? height[i] : max(height[i], r[i + 1]);

    for (int i = 0; i < n; ++i)
      ans += min(l[i], r[i]) - height[i];

    return ans;
  }
};",42
42,"class Solution {
 public:
  string multiply(string num1, string num2) {
    string s(num1.length() + num2.length(), '0');

    for (int i = num1.length() - 1; i >= 0; --i)
      for (int j = num2.length() - 1; j >= 0; --j) {
        const int mult = (num1[i] - '0') * (num2[j] - '0');
        const int sum = mult + (s[i + j + 1] - '0');
        s[i + j] += sum / 10;
        s[i + j + 1] = '0' + sum % 10;
      }

    const int i = s.find_first_not_of('0');
    return i == string::npos ? ""0"" : s.substr(i);
  }
};",43
43,"class Solution {
 public:
  bool isMatch(string s, string p) {
    const int m = s.length();
    const int n = p.length();
    // dp[i][j] := true if s[0..i) matches p[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    auto isMatch = [&](int i, int j) -> bool {
      return j >= 0 && p[j] == '?' || s[i] == p[j];
    };

    for (int j = 0; j < p.length(); ++j)
      if (p[j] == '*')
        dp[0][j + 1] = dp[0][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (p[j] == '*') {
          const bool matchEmpty = dp[i + 1][j];
          const bool matchSome = dp[i][j + 1];
          dp[i + 1][j + 1] = matchEmpty || matchSome;
        } else if (isMatch(i, j)) {
          dp[i + 1][j + 1] = dp[i][j];
        }

    return dp[m][n];
  }
};",44
44,"class Solution {
 public:
  int jump(vector<int>& nums) {
    int ans = 0;
    int end = 0;
    int farthest = 0;

    // Start an implicit BFS.
    for (int i = 0; i < nums.size() - 1; ++i) {
      farthest = max(farthest, i + nums[i]);
      if (farthest >= nums.size() - 1) {
        ++ans;
        break;
      }
      if (i == end) {    // Visited all the items on the current level.
        ++ans;           // Increment the level.
        end = farthest;  // Make the queue size for the next level.
      }
    }

    return ans;
  }
};",45
45,"class Solution {
 public:
  vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> ans;

    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() == nums.size()) {
      ans.push_back(path);
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};",46
46,"class Solution {
 public:
  vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<vector<int>> ans;
    ranges::sort(nums);
    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() == nums.size()) {
      ans.push_back(path);
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};",47
47,"class Solution {
 public:
  void rotate(vector<vector<int>>& matrix) {
    reverse(matrix.begin(), matrix.end());
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = i + 1; j < matrix.size(); ++j)
        swap(matrix[i][j], matrix[j][i]);
  }
};",48
48,"class Solution {
 public:
  vector<vector<string>> groupAnagrams(vector<string>& strs) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> keyToAnagrams;

    for (const string& str : strs) {
      string key = str;
      ranges::sort(key);
      keyToAnagrams[key].push_back(str);
    }

    for (const auto& [_, anagrams] : keyToAnagrams)
      ans.push_back(anagrams);

    return ans;
  }
};",49
49,"class Solution {
 public:
  double myPow(double x, long n) {
    if (n == 0)
      return 1;
    if (n < 0)
      return 1 / myPow(x, -n);
    if (n % 2 == 1)
      return x * myPow(x, n - 1);
    return myPow(x * x, n / 2);
  }
};",50
50,"class Solution {
 public:
  vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> ans;
    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),
        vector<string>(n, string(n, '.')), ans);
    return ans;
  }

 private:
  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,
           vector<bool>&& diag2, vector<string>&& board,
           vector<vector<string>>& ans) {
    if (i == n) {
      ans.push_back(board);
      return;
    }

    for (int j = 0; j < n; ++j) {
      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])
        continue;
      board[i][j] = 'Q';
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;
      dfs(n, i + 1, move(cols), move(diag1), move(diag2), move(board), ans);
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;
      board[i][j] = '.';
    }
  }
};",51
51,"class Solution {
 public:
  int totalNQueens(int n) {
    int ans = 0;
    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),
        ans);
    return ans;
  }

 private:
  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,
           vector<bool>&& diag2, int& ans) {
    if (i == n) {
      ++ans;
      return;
    }

    for (int j = 0; j < n; ++j) {
      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])
        continue;
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;
      dfs(n, i + 1, move(cols), move(diag1), move(diag2), ans);
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;
    }
  }
};",52
52,"class Solution {
 public:
  int maxSubArray(vector<int>& nums) {
    // dp[i] := the maximum sum subarray ending in i
    vector<int> dp(nums.size());

    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); ++i)
      dp[i] = max(nums[i], dp[i - 1] + nums[i]);

    return ranges::max(dp);
  }
};",53
53,"class Solution {
 public:
  vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if (matrix.empty())
      return {};

    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans;
    int r1 = 0;
    int c1 = 0;
    int r2 = m - 1;
    int c2 = n - 1;

    // Repeatedly add matrix[r1..r2][c1..c2] to `ans`.
    while (ans.size() < m * n) {
      for (int j = c1; j <= c2 && ans.size() < m * n; ++j)
        ans.push_back(matrix[r1][j]);
      for (int i = r1 + 1; i <= r2 - 1 && ans.size() < m * n; ++i)
        ans.push_back(matrix[i][c2]);
      for (int j = c2; j >= c1 && ans.size() < m * n; --j)
        ans.push_back(matrix[r2][j]);
      for (int i = r2 - 1; i >= r1 + 1 && ans.size() < m * n; --i)
        ans.push_back(matrix[i][c1]);
      ++r1, ++c1, --r2, --c2;
    }

    return ans;
  }
};",54
54,"class Solution {
 public:
  bool canJump(vector<int>& nums) {
    int i = 0;

    for (int reach = 0; i < nums.size() && i <= reach; ++i)
      reach = max(reach, i + nums[i]);

    return i == nums.size();
  }
};",55
55,"class Solution {
 public:
  vector<vector<int>> merge(vector<vector<int>>& intervals) {
    vector<vector<int>> ans;

    ranges::sort(intervals);

    for (const vector<int>& interval : intervals)
      if (ans.empty() || ans.back()[1] < interval[0])
        ans.push_back(interval);
      else
        ans.back()[1] = max(ans.back()[1], interval[1]);

    return ans;
  }
};",56
56,"class Solution {
 public:
  vector<vector<int>> insert(vector<vector<int>>& intervals,
                             vector<int>& newInterval) {
    const int n = intervals.size();
    vector<vector<int>> ans;
    int i = 0;

    while (i < n && intervals[i][1] < newInterval[0])
      ans.push_back(intervals[i++]);

    // Merge overlapping intervals.
    while (i < n && intervals[i][0] <= newInterval[1]) {
      newInterval[0] = min(newInterval[0], intervals[i][0]);
      newInterval[1] = max(newInterval[1], intervals[i][1]);
      ++i;
    }

    ans.push_back(newInterval);

    while (i < n)
      ans.push_back(intervals[i++]);

    return ans;
  }
};",57
57,"class Solution {
 public:
  int lengthOfLastWord(string s) {
    int i = s.length() - 1;

    while (i >= 0 && s[i] == ' ')
      --i;
    const int lastIndex = i;
    while (i >= 0 && s[i] != ' ')
      --i;

    return lastIndex - i;
  }
};",58
58,"class Solution {
 public:
  vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> ans(n, vector<int>(n));
    int count = 1;

    for (int min = 0; min < n / 2; ++min) {
      const int max = n - min - 1;
      for (int i = min; i < max; ++i)
        ans[min][i] = count++;
      for (int i = min; i < max; ++i)
        ans[i][max] = count++;
      for (int i = max; i > min; --i)
        ans[max][i] = count++;
      for (int i = max; i > min; --i)
        ans[i][min] = count++;
    }

    if (n % 2 == 1)
      ans[n / 2][n / 2] = count;

    return ans;
  }
};",59
59,"class Solution {
 public:
  string getPermutation(int n, int k) {
    string ans;
    vector<int> nums(n);
    vector<int> fact(n + 1, 1);  // fact[i] := i!

    iota(nums.begin(), nums.end(), 1);

    for (int i = 2; i <= n; ++i)
      fact[i] = fact[i - 1] * i;

    --k;  // 0-indexed

    for (int i = n - 1; i >= 0; --i) {
      const int j = k / fact[i];
      k %= fact[i];
      ans += to_string(nums[j]);
      nums.erase(nums.begin() + j);
    }

    return ans;
  }
};",60
60,"class Solution {
 public:
  ListNode* rotateRight(ListNode* head, int k) {
    if (!head || !head->next || k == 0)
      return head;

    ListNode* tail;
    int length = 1;
    for (tail = head; tail->next; tail = tail->next)
      ++length;
    tail->next = head;  // Circle the list.

    const int t = length - k % length;
    for (int i = 0; i < t; ++i)
      tail = tail->next;
    ListNode* newHead = tail->next;
    tail->next = nullptr;

    return newHead;
  }
};",61
61,"class Solution {
 public:
  int uniquePaths(int m, int n) {
    // dp[i][j] := the number of unique paths from (0, 0) to (i, j)
    vector<vector<int>> dp(m, vector<int>(n, 1));

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

    return dp[m - 1][n - 1];
  }
};",62
62,"class Solution {
 public:
  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    const int m = obstacleGrid.size();
    const int n = obstacleGrid[0].size();
    // dp[i][j] := the number of unique paths from (0, 0) to (i, j)
    vector<vector<long>> dp(m + 1, vector<long>(n + 1, 0));
    dp[0][1] = 1;  // Can also set dp[1][0] = 1.

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (!obstacleGrid[i - 1][j - 1])
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

    return dp[m][n];
  }
};",63
63,"class Solution {
 public:
  int minPathSum(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i > 0 && j > 0)
          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
        else if (i > 0)
          grid[i][0] += grid[i - 1][0];
        else if (j > 0)
          grid[0][j] += grid[0][j - 1];

    return grid[m - 1][n - 1];
  }
};",64
64,"class Solution {
 public:
  bool isNumber(string s) {
    trim(s);
    if (s.empty())
      return false;

    bool seenNum = false;
    bool seenDot = false;
    bool seenE = false;

    for (int i = 0; i < s.length(); ++i) {
      switch (s[i]) {
        case '.':
          if (seenDot || seenE)
            return false;
          seenDot = true;
          break;
        case 'e':
        case 'E':
          if (seenE || !seenNum)
            return false;
          seenE = true;
          seenNum = false;
          break;
        case '+':
        case '-':
          if (i > 0 && s[i - 1] != 'e' && s[i - 1] != 'E')
            return false;
          seenNum = false;
          break;
        default:
          if (!isdigit(s[i]))
            return false;
          seenNum = true;
      }
    }

    return seenNum;
  }

 private:
  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};",65
65,"class Solution {
 public:
  vector<int> plusOne(vector<int>& digits) {
    for (int i = digits.size() - 1; i >= 0; --i) {
      if (digits[i] < 9) {
        ++digits[i];
        return digits;
      }
      digits[i] = 0;
    }

    digits.insert(digits.begin(), 1);
    return digits;
  }
};",66
66,"class Solution {
 public:
  string addBinary(string a, string b) {
    string ans;
    int carry = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += a[i--] - '0';
      if (j >= 0)
        carry += b[j--] - '0';
      ans += carry % 2 + '0';
      carry /= 2;
    }

    reverse(ans.begin(), ans.end());
    return ans;
  }
};",67
67,"class Solution {
 public:
  vector<string> fullJustify(vector<string>& words, size_t maxWidth) {
    vector<string> ans;
    vector<string> row;
    size_t rowLetters = 0;

    for (const string& word : words) {
      // If we place the word in this row, it will exceed the maximum width.
      // Therefore, we cannot put the word in this row and have to pad spaces
      // for each word in this row.
      if (rowLetters + row.size() + word.length() > maxWidth) {
        const int spaces = maxWidth - rowLetters;
        if (row.size() == 1) {
          // Pad all the spaces after row[0].
          for (int i = 0; i < spaces; ++i)
            row[0] += "" "";
        } else {
          // Evenly pad all the spaces to each word (expect the last one) in
          // this row.
          for (int i = 0; i < spaces; ++i)
            row[i % (row.size() - 1)] += "" "";
        }
        ans.push_back(join(row, """"));
        row.clear();
        rowLetters = 0;
      }
      row.push_back(word);
      rowLetters += word.length();
    }
    ans.push_back(ljust(join(row, "" ""), maxWidth));

    return ans;
  }

 private:
  string join(const vector<string>& words, const string& s) {
    string joined;
    for (int i = 0; i < words.size(); ++i) {
      joined += words[i];
      if (i != words.size() - 1)
        joined += s;
    }
    return joined;
  }

  string ljust(string s, int width) {
    for (int i = 0; i < s.length() - width; ++i)
      s += "" "";
    return s;
  }
};",68
68,"class Solution {
 public:
  int mySqrt(int x) {
    unsigned l = 1;
    unsigned r = x + 1u;

    while (l < r) {
      const unsigned m = (l + r) / 2;
      if (m > x / m)
        r = m;
      else
        l = m + 1;
    }

    // l := the minimum number s.t. l * l > x
    return l - 1;
  }
};",69
69,"class Solution {
 public:
  int climbStairs(int n) {
    // dp[i] := the number of ways to climb to the i-th stair
    vector<int> dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i)
      dp[i] = dp[i - 1] + dp[i - 2];

    return dp[n];
  }
};",70
70,"class Solution {
 public:
  string simplifyPath(string path) {
    string ans;
    istringstream iss(path);
    vector<string> stack;

    for (string dir; getline(iss, dir, '/');) {
      if (dir.empty() || dir == ""."")
        continue;
      if (dir == "".."") {
        if (!stack.empty())
          stack.pop_back();
      } else {
        stack.push_back(dir);
      }
    }

    for (const string& s : stack)
      ans += ""/"" + s;

    return ans.empty() ? ""/"" : ans;
  }
};",71
71,"class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int m = word1.length();
    const int n = word2.length();
    // dp[i][j] := the minimum number of operations to convert word1[0..i) to
    // word2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      dp[i][0] = i;

    for (int j = 1; j <= n; ++j)
      dp[0][j] = j;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (word1[i - 1] == word2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;

    return dp[m][n];
  }
};",72
72,"class Solution {
 public:
  void setZeroes(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    bool shouldFillFirstRow = false;
    bool shouldFillFirstCol = false;

    for (int j = 0; j < n; ++j)
      if (matrix[0][j] == 0) {
        shouldFillFirstRow = true;
        break;
      }

    for (int i = 0; i < m; ++i)
      if (matrix[i][0] == 0) {
        shouldFillFirstCol = true;
        break;
      }

    // Store the information in the first row and the first column.
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (matrix[i][j] == 0) {
          matrix[i][0] = 0;
          matrix[0][j] = 0;
        }

    // Fill 0s for the matrix except the first row and the first column.
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (matrix[i][0] == 0 || matrix[0][j] == 0)
          matrix[i][j] = 0;

    // Fill 0s for the first row if needed.
    if (shouldFillFirstRow)
      for (int j = 0; j < n; ++j)
        matrix[0][j] = 0;

    // Fill 0s for the first column if needed.
    if (shouldFillFirstCol)
      for (int i = 0; i < m; ++i)
        matrix[i][0] = 0;
  }
};",73
73,"class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.empty())
      return false;

    const int m = matrix.size();
    const int n = matrix[0].size();
    int l = 0;
    int r = m * n;

    while (l < r) {
      const int mid = (l + r) / 2;
      const int i = mid / n;
      const int j = mid % n;
      if (matrix[i][j] == target)
        return true;
      if (matrix[i][j] < target)
        l = mid + 1;
      else
        r = mid;
    }

    return false;
  }
};",74
74,"class Solution {
 public:
  void sortColors(vector<int>& nums) {
    int zero = -1;
    int one = -1;
    int two = -1;

    for (const int num : nums)
      if (num == 0) {
        nums[++two] = 2;
        nums[++one] = 1;
        nums[++zero] = 0;
      } else if (num == 1) {
        nums[++two] = 2;
        nums[++one] = 1;
      } else {
        nums[++two] = 2;
      }
  }
};",75
75,"class Solution {
 public:
  string minWindow(string s, string t) {
    vector<int> count(128);
    int required = t.length();
    int bestLeft = -1;
    int minLength = s.length() + 1;

    for (const char c : t)
      ++count[c];

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (--count[s[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 < minLength) {
          bestLeft = l;
          minLength = r - l + 1;
        }
        if (++count[s[l++]] > 0)
          ++required;
      }
    }

    return bestLeft == -1 ? """" : s.substr(bestLeft, minLength);
  }
};",76
76,"class Solution {
 public:
  vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> ans;
    dfs(n, k, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(int n, int k, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (path.size() == k) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i <= n; ++i) {
      path.push_back(i);
      dfs(n, k, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",77
77,"class Solution {
 public:
  vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ans;
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    ans.push_back(path);

    for (int i = s; i < nums.size(); ++i) {
      path.push_back(nums[i]);
      dfs(nums, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",78
78,"class Solution {
 public:
  bool exist(vector<vector<char>>& board, string word) {
    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j)
        if (dfs(board, word, i, j, 0))
          return true;
    return false;
  }

 private:
  bool dfs(vector<vector<char>>& board, const string& word, int i, int j,
           int s) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return false;
    if (board[i][j] != word[s] || board[i][j] == '*')
      return false;
    if (s == word.length() - 1)
      return true;

    const char cache = board[i][j];
    board[i][j] = '*';
    const bool isExist = dfs(board, word, i + 1, j, s + 1) ||
                         dfs(board, word, i - 1, j, s + 1) ||
                         dfs(board, word, i, j + 1, s + 1) ||
                         dfs(board, word, i, j - 1, s + 1);
    board[i][j] = cache;

    return isExist;
  }
};",79
79,"class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int i = 0;

    for (const int num : nums)
      if (i < 2 || num > nums[i - 2])
        nums[i++] = num;

    return i;
  }
};",80
80,"class Solution {
 public:
  bool search(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return true;
      if (nums[l] == nums[m] && nums[m] == nums[r]) {
        ++l;
        --r;
      } else if (nums[l] <= nums[m]) {  // nums[l..m] are sorted
        if (nums[l] <= target && target < nums[m])
          r = m - 1;
        else
          l = m + 1;
      } else {  // nums[m..n - 1] are sorted
        if (nums[m] < target && target <= nums[r])
          l = m + 1;
        else
          r = m - 1;
      }
    }

    return false;
  }
};",81
81,"class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode dummy(0, head);
    ListNode* prev = &dummy;

    while (head) {
      while (head->next && head->val == head->next->val)
        head = head->next;
      if (prev->next == head)
        prev = prev->next;
      else
        prev->next = head->next;
      head = head->next;
    }

    return dummy.next;
  }
};",82
82,"class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode* curr = head;

    while (curr) {
      while (curr->next && curr->val == curr->next->val)
        curr->next = curr->next->next;
      curr = curr->next;
    }

    return head;
  }
};",83
83,"class Solution {
 public:
  int largestRectangleArea(vector<int>& heights) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= heights.size(); ++i) {
      while (!stack.empty() &&
             (i == heights.size() || heights[stack.top()] > heights[i])) {
        const int h = heights[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};",84
84,"class Solution {
 public:
  int maximalRectangle(vector<vector<char>>& matrix) {
    if (matrix.empty())
      return 0;

    int ans = 0;
    vector<int> hist(matrix[0].size());

    for (const vector<char>& row : matrix) {
      for (int i = 0; i < row.size(); ++i)
        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;
      ans = max(ans, largestRectangleArea(hist));
    }

    return ans;
  }

 private:
  int largestRectangleArea(const vector<int>& heights) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= heights.size(); ++i) {
      while (!stack.empty() &&
             (i == heights.size() || heights[stack.top()] > heights[i])) {
        const int h = heights[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};",85
85,"class Solution {
 public:
  ListNode* partition(ListNode* head, int x) {
    ListNode beforeHead(0);
    ListNode afterHead(0);
    ListNode* before = &beforeHead;
    ListNode* after = &afterHead;

    for (; head; head = head->next)
      if (head->val < x) {
        before->next = head;
        before = head;
      } else {
        after->next = head;
        after = head;
      }

    after->next = nullptr;
    before->next = afterHead.next;

    return beforeHead.next;
  };
};",86
86,"class Solution {
 public:
  bool isScramble(string s1, string s2) {
    if (s1 == s2)
      return true;
    const string hashKey = s1 + '+' + s2;
    if (const auto it = mem.find(hashKey); it != mem.cend())
      return it->second;

    vector<int> count(128);

    for (int i = 0; i < s1.length(); ++i) {
      ++count[s1[i]];
      --count[s2[i]];
    }

    if (ranges::any_of(count, [](int c) { return c != 0; }))
      return mem[hashKey] = false;

    for (int i = 1; i < s1.length(); ++i) {
      if (isScramble(s1.substr(0, i), s2.substr(0, i)) &&
          isScramble(s1.substr(i), s2.substr(i)))
        return mem[hashKey] = true;
      if (isScramble(s1.substr(0, i), s2.substr(s2.length() - i)) &&
          isScramble(s1.substr(i), s2.substr(0, s2.length() - i)))
        return mem[hashKey] = true;
    }

    return mem[hashKey] = false;
  }

 private:
  unordered_map<string, bool> mem;
};",87
87,"class Solution {
 public:
  void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1;      // nums1's index (the actual nums)
    int j = n - 1;      // nums2's index
    int k = m + n - 1;  // nums1's index (the next filled position)

    while (j >= 0)
      if (i >= 0 && nums1[i] > nums2[j])
        nums1[k--] = nums1[i--];
      else
        nums1[k--] = nums2[j--];
  }
};",88
88,"class Solution {
 public:
  vector<int> grayCode(int n) {
    vector<int> ans{0};

    for (int i = 0; i < n; ++i)
      for (int j = ans.size() - 1; j >= 0; --j)
        ans.push_back(ans[j] | 1 << i);

    return ans;
  }
};",89
89,"class Solution {
 public:
  vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    vector<vector<int>> ans;
    ranges::sort(nums);
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    ans.push_back(path);

    for (int i = s; i < nums.size(); ++i) {
      if (i > s && nums[i] == nums[i - 1])
        continue;
      path.push_back(nums[i]);
      dfs(nums, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",90
90,"class Solution {
 public:
  int numDecodings(string s) {
    const int n = s.length();
    // dp[i] := the number of ways to decode s[i..n)
    vector<int> dp(n + 1);
    dp[n] = 1;  // """"
    dp[n - 1] = isValid(s[n - 1]);

    for (int i = n - 2; i >= 0; --i) {
      if (isValid(s[i]))
        dp[i] += dp[i + 1];
      if (isValid(s[i], s[i + 1]))
        dp[i] += dp[i + 2];
    }

    return dp[0];
  }

 private:
  bool isValid(char c) {
    return c != '0';
  }

  bool isValid(char c1, char c2) {
    return c1 == '1' || c1 == '2' && c2 < '7';
  }
};",91
91,"class Solution {
 public:
  ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == 1)
      return reverseN(head, right);

    head->next = reverseBetween(head->next, left - 1, right - 1);

    return head;
  }

 private:
  ListNode* reverseN(ListNode* head, int n) {
    if (n == 1)
      return head;

    ListNode* newHead = reverseN(head->next, n - 1);
    ListNode* headNext = head->next;
    head->next = headNext->next;
    headNext->next = head;

    return newHead;
  }
};",92
92,"class Solution {
 public:
  vector<string> restoreIpAddresses(const string& s) {
    vector<string> ans;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, vector<string>&& path,
           vector<string>& ans) {
    if (path.size() == 4 && start == s.length()) {
      ans.push_back(path[0] + ""."" + path[1] + ""."" + path[2] + ""."" + path[3]);
      return;
    }
    if (path.size() == 4 || start == s.length())
      return;

    for (int length = 1; length <= 3; ++length) {
      if (start + length > s.length())
        return;  // out-of-bounds
      if (length > 1 && s[start] == '0')
        return;  // leading '0'
      const string& num = s.substr(start, length);
      if (stoi(num) > 255)
        return;
      path.push_back(num);
      dfs(s, start + length, move(path), ans);
      path.pop_back();
    }
  }
};",93
93,"class Solution {
 public:
  vector<int> inorderTraversal(TreeNode* root) {
    vector<int> ans;
    stack<TreeNode*> stack;

    while (root || !stack.empty()) {
      while (root) {
        stack.push(root);
        root = root->left;
      }
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      root = root->right;
    }

    return ans;
  }
};",94
94,"class Solution {
 public:
  vector<TreeNode*> generateTrees(int n) {
    if (n == 0)
      return {};
    return generateTrees(1, n);
  }

 private:
  vector<TreeNode*> generateTrees(int min, int max) {
    if (min > max)
      return {nullptr};

    vector<TreeNode*> ans;

    for (int i = min; i <= max; ++i)
      for (TreeNode* left : generateTrees(min, i - 1))
        for (TreeNode* right : generateTrees(i + 1, max)) {
          ans.push_back(new TreeNode(i));
          ans.back()->left = left;
          ans.back()->right = right;
        }

    return ans;
  }
};",95
95,"class Solution {
 public:
  int numTrees(int n) {
    // dp[i] := the number of unique BST's that store values 1..i
    vector<int> dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i)
      for (int j = 0; j < i; ++j)
        dp[i] += dp[j] * dp[i - j - 1];

    return dp[n];
  }
};",96
96,"class Solution {
 public:
  bool isInterleave(string s1, string s2, string s3) {
    const int m = s1.length();
    const int n = s2.length();
    if (m + n != s3.length())
      return false;

    // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of
    // s1[0..i) and s2[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];

    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1] ||
                   dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];

    return dp[m][n];
  }
};",97
97,"class Solution {
 public:
  bool isValidBST(TreeNode* root) {
    return isValidBST(root, nullptr, nullptr);
  }

 private:
  bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
    if (root == nullptr)
      return true;
    if (minNode && root->val <= minNode->val)
      return false;
    if (maxNode && root->val >= maxNode->val)
      return false;

    return isValidBST(root->left, minNode, root) &&
           isValidBST(root->right, root, maxNode);
  }
};",98
98,"class Solution {
 public:
  void recoverTree(TreeNode* root) {
    inorder(root);
    swap(x, y);
  }

 private:
  TreeNode* pred = nullptr;
  TreeNode* x = nullptr;  // the first wrong node
  TreeNode* y = nullptr;  // the second wrong node

  void inorder(TreeNode* root) {
    if (root == nullptr)
      return;

    inorder(root->left);

    if (pred && root->val < pred->val) {
      y = root;
      if (x == nullptr)
        x = pred;
      else
        return;
    }
    pred = root;

    inorder(root->right);
  }

  void swap(TreeNode* x, TreeNode* y) {
    const int temp = x->val;
    x->val = y->val;
    y->val = temp;
  }
};",99
99,"class Solution {
 public:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};",100
100,"class Solution {
 public:
  bool isSymmetric(TreeNode* root) {
    return isSymmetric(root, root);
  }

 private:
  bool isSymmetric(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;

    return p->val == q->val &&                //
           isSymmetric(p->left, q->right) &&  //
           isSymmetric(p->right, q->left);
  }
};",101
101,"class Solution {
 public:
  vector<vector<int>> levelOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(currLevel);
    }

    return ans;
  }
};",102
102,"class Solution {
 public:
  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    deque<TreeNode*> dq{{root}};
    bool isLeftToRight = true;

    while (!dq.empty()) {
      vector<int> currLevel;
      for (int sz = dq.size(); sz > 0; --sz)
        if (isLeftToRight) {
          TreeNode* node = dq.front();
          dq.pop_front();
          currLevel.push_back(node->val);
          if (node->left)
            dq.push_back(node->left);
          if (node->right)
            dq.push_back(node->right);
        } else {
          TreeNode* node = dq.back();
          dq.pop_back();
          currLevel.push_back(node->val);
          if (node->right)
            dq.push_front(node->right);
          if (node->left)
            dq.push_front(node->left);
        }
      ans.push_back(currLevel);
      isLeftToRight = !isLeftToRight;
    }

    return ans;
  }
};",103
103,"class Solution {
 public:
  int maxDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
};",104
104,"class Solution {
 public:
  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    unordered_map<int, int> inToIndex;

    for (int i = 0; i < inorder.size(); ++i)
      inToIndex[inorder[i]] = i;

    return build(preorder, 0, preorder.size() - 1, inorder, 0,
                 inorder.size() - 1, inToIndex);
  }

 private:
  TreeNode* build(const vector<int>& preorder, int preStart, int preEnd,
                  const vector<int>& inorder, int inStart, int inEnd,
                  const unordered_map<int, int>& inToIndex) {
    if (preStart > preEnd)
      return nullptr;

    const int rootVal = preorder[preStart];
    const int rootInIndex = inToIndex.at(rootVal);
    const int leftSize = rootInIndex - inStart;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(preorder, preStart + 1, preStart + leftSize, inorder,
                       inStart, rootInIndex - 1, inToIndex);
    root->right = build(preorder, preStart + leftSize + 1, preEnd, inorder,
                        rootInIndex + 1, inEnd, inToIndex);
    return root;
  }
};",105
105,"class Solution {
 public:
  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    unordered_map<int, int> inToIndex;

    for (int i = 0; i < inorder.size(); ++i)
      inToIndex[inorder[i]] = i;

    return build(inorder, 0, inorder.size() - 1, postorder, 0,
                 postorder.size() - 1, inToIndex);
  }

 private:
  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,
                  const vector<int>& postorder, int postStart, int postEnd,
                  const unordered_map<int, int>& inToIndex) {
    if (inStart > inEnd)
      return nullptr;

    const int rootVal = postorder[postEnd];
    const int rootInIndex = inToIndex.at(rootVal);
    const int leftSize = rootInIndex - inStart;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,
                       postStart + leftSize - 1, inToIndex);
    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,
                        postStart + leftSize, postEnd - 1, inToIndex);
    return root;
  }
};",106
106,"class Solution {
 public:
  vector<vector<int>> levelOrderBottom(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(currLevel);
    }

    reverse(ans.begin(), ans.end());
    return ans;
  }
};",107
107,"class Solution {
 public:
  TreeNode* sortedArrayToBST(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
  }

 private:
  TreeNode* build(const vector<int>& nums, int l, int r) {
    if (l > r)
      return nullptr;
    const int m = (l + r) / 2;
    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));
  }
};",108
108,"class Solution {
 public:
  TreeNode* sortedListToBST(ListNode* head) {
    if (head == nullptr)
      return nullptr;
    if (!head->next)
      return new TreeNode(head->val);

    ListNode* mid = findMid(head);
    TreeNode* root = new TreeNode(mid->val);
    root->left = sortedListToBST(head);
    root->right = sortedListToBST(mid->next);

    return root;
  }

 private:
  ListNode* findMid(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
      prev = slow;
      slow = slow->next;
      fast = fast->next->next;
    }
    prev->next = nullptr;

    return slow;
  }
};",109
109,"class Solution {
 public:
  bool isBalanced(TreeNode* root) {
    if (root == nullptr)
      return true;
    return abs(maxDepth(root->left) - maxDepth(root->right)) <= 1 &&
           isBalanced(root->left) && isBalanced(root->right);
  }

 private:
  int maxDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
};",110
110,"class Solution {
 public:
  int minDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    if (root->left == nullptr)
      return minDepth(root->right) + 1;
    if (root->right == nullptr)
      return minDepth(root->left) + 1;
    return min(minDepth(root->left), minDepth(root->right)) + 1;
  }
};",111
111,"class Solution {
 public:
  bool hasPathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return false;
    if (root->val == sum && root->left == nullptr && root->right == nullptr)
      return true;
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
  }
};",112
112,"class Solution {
 public:
  vector<vector<int>> pathSum(TreeNode* root, int sum) {
    vector<vector<int>> ans;
    dfs(root, sum, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int sum, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (root == nullptr)
      return;
    if (root->val == sum && root->left == nullptr && root->right == nullptr) {
      path.push_back(root->val);
      ans.push_back(path);
      path.pop_back();
      return;
    }

    path.push_back(root->val);
    dfs(root->left, sum - root->val, move(path), ans);
    dfs(root->right, sum - root->val, move(path), ans);
    path.pop_back();
  }
};",113
113,"class Solution {
 public:
  void flatten(TreeNode* root) {
    if (root == nullptr)
      return;

    flatten(root->left);
    flatten(root->right);

    TreeNode* const left = root->left;    // flattened left
    TreeNode* const right = root->right;  // flattened right

    root->left = nullptr;
    root->right = left;

    // Connect the original right subtree to the end of the new right subtree.
    TreeNode* rightmost = root;
    while (rightmost->right)
      rightmost = rightmost->right;
    rightmost->right = right;
  }
};",114
114,"class Solution {
 public:
  int numDistinct(string s, string t) {
    const int m = s.length();
    const int n = t.length();
    vector<vector<unsigned long>> dp(m + 1, vector<unsigned long>(n + 1));

    for (int i = 0; i <= m; ++i)
      dp[i][0] = 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s[i - 1] == t[j - 1])
          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j];

    return dp[m][n];
  }
};",115
115,"class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr)
      return nullptr;
    connectTwoNodes(root->left, root->right);
    return root;
  }

 private:
  void connectTwoNodes(Node* p, Node* q) {
    if (p == nullptr)
      return;
    p->next = q;
    connectTwoNodes(p->left, p->right);
    connectTwoNodes(q->left, q->right);
    connectTwoNodes(p->right, q->left);
  }
};",116
116,"class Solution {
 public:
  Node* connect(Node* root) {
    Node* node = root;  // the node that is above the current needling

    while (node) {
      Node dummy(0);  // the dummy node before needling
      // Needle the children of the node.
      for (Node* needle = &dummy; node; node = node->next) {
        if (node->left) {  // Needle the left child.
          needle->next = node->left;
          needle = needle->next;
        }
        if (node->right) {  // Needle the right child.
          needle->next = node->right;
          needle = needle->next;
        }
      }
      node = dummy.next;  // Move the node to the next level.
    }

    return root;
  }
};",117
117,"class Solution {
 public:
  vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ans;

    for (int i = 0; i < numRows; ++i)
      ans.push_back(vector<int>(i + 1, 1));

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < ans[i].size() - 1; ++j)
        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];

    return ans;
  }
};",118
118,"class Solution {
 public:
  vector<int> getRow(int rowIndex) {
    vector<int> ans(rowIndex + 1, 1);

    for (int i = 2; i < rowIndex + 1; ++i)
      for (int j = 1; j < i; ++j)
        ans[i - j] += ans[i - j - 1];

    return ans;
  }
};",119
119,"class Solution {
 public:
  int minimumTotal(vector<vector<int>>& triangle) {
    for (int i = triangle.size() - 2; i >= 0; --i)
      for (int j = 0; j <= i; ++j)
        triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
    return triangle[0][0];
  }
};",120
120,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sellOne = 0;
    int holdOne = INT_MIN;

    for (const int price : prices) {
      sellOne = max(sellOne, holdOne + price);
      holdOne = max(holdOne, -price);
    }

    return sellOne;
  }
};",121
121,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sell = 0;
    int hold = INT_MIN;

    for (const int price : prices) {
      sell = max(sell, hold + price);
      hold = max(hold, sell - price);
    }

    return sell;
  }
};",122
122,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sellTwo = 0;
    int holdTwo = INT_MIN;
    int sellOne = 0;
    int holdOne = INT_MIN;

    for (const int price : prices) {
      sellTwo = max(sellTwo, holdTwo + price);
      holdTwo = max(holdTwo, sellOne - price);
      sellOne = max(sellOne, holdOne + price);
      holdOne = max(holdOne, -price);
    }

    return sellTwo;
  }
};",123
123,"class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int ans = INT_MIN;
    maxPathSumDownFrom(root, ans);
    return ans;
  }

 private:
  // Returns the maximum path sum starting from the current root, where
  // root->val is always included.
  int maxPathSumDownFrom(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = max(0, maxPathSumDownFrom(root->left, ans));
    const int r = max(0, maxPathSumDownFrom(root->right, ans));
    ans = max(ans, root->val + l + r);
    return root->val + max(l, r);
  }
};",124
124,"class Solution {
 public:
  bool isPalindrome(string s) {
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      while (l < r && !isalnum(s[l]))
        ++l;
      while (l < r && !isalnum(s[r]))
        --r;
      if (tolower(s[l]) != tolower(s[r]))
        return false;
      ++l;
      --r;
    }

    return true;
  }
};",125
125,"class Solution {
 public:
  vector<vector<string>> findLadders(string beginWord, string endWord,
                                     vector<string>& wordList) {
    unordered_set<string> wordSet{wordList.begin(), wordList.end()};
    if (!wordSet.count(endWord))
      return {};

    // {""hit"": [""hot""], ""hot"": [""dot"", ""lot""], ...}
    unordered_map<string, vector<string>> graph;

    // Build the graph from the beginWord to the endWord.
    if (!bfs(beginWord, endWord, wordSet, graph))
      return {};

    vector<vector<string>> ans;
    dfs(graph, beginWord, endWord, {beginWord}, ans);
    return ans;
  }

 private:
  bool bfs(const string& beginWord, const string& endWord,
           unordered_set<string>& wordSet,
           unordered_map<string, vector<string>>& graph) {
    unordered_set<string> currentLevelWords{beginWord};

    while (!currentLevelWords.empty()) {
      for (const string& word : currentLevelWords)
        wordSet.erase(word);
      unordered_set<string> nextLevelWords;
      bool reachEndWord = false;
      for (const string& parent : currentLevelWords) {
        vector<string> children;
        getChildren(parent, wordSet, children);
        for (const string& child : children) {
          if (wordSet.count(child)) {
            nextLevelWords.insert(child);
            graph[parent].push_back(child);
          }
          if (child == endWord)
            reachEndWord = true;
        }
      }
      if (reachEndWord)
        return true;
      currentLevelWords = move(nextLevelWords);
    }

    return false;
  }

  void getChildren(const string& parent, const unordered_set<string>& wordSet,
                   vector<string>& children) {
    string s(parent);

    for (int i = 0; i < s.length(); ++i) {
      const char cache = s[i];
      for (char c = 'a'; c <= 'z'; ++c) {
        if (c == cache)
          continue;
        s[i] = c;
        if (wordSet.count(s))
          children.push_back(s);
      }
      s[i] = cache;
    }
  }

  void dfs(const unordered_map<string, vector<string>>& graph,
           const string& word, const string& endWord, vector<string>&& path,
           vector<vector<string>>& ans) {
    if (word == endWord) {
      ans.push_back(path);
      return;
    }
    if (!graph.count(word))
      return;

    for (const string& child : graph.at(word)) {
      path.push_back(child);
      dfs(graph, child, endWord, move(path), ans);
      path.pop_back();
    }
  }
};",126
126,"class Solution {
 public:
  int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    unordered_set<string> wordSet(wordList.begin(), wordList.end());
    if (!wordSet.count(endWord))
      return 0;

    int ans = 0;
    queue<string> q{{beginWord}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < word.length(); ++i) {
          const char cache = word[i];
          for (char c = 'a'; c <= 'z'; ++c) {
            word[i] = c;
            if (word == endWord)
              return ans + 1;
            if (wordSet.count(word)) {
              q.push(word);
              wordSet.erase(word);
            }
          }
          word[i] = cache;
        }
      }
    }

    return 0;
  }
};",127
127,"class Solution {
 public:
  int longestConsecutive(vector<int>& nums) {
    int ans = 0;
    unordered_set<int> seen{nums.begin(), nums.end()};

    for (int num : nums) {
      // `num` is the start of a sequence.
      if (seen.count(num - 1))
        continue;
      int length = 1;
      while (seen.count(++num))
        ++length;
      ans = max(ans, length);
    }

    return ans;
  }
};",128
128,"class Solution {
 public:
  int sumNumbers(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int path, int& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      ans += path * 10 + root->val;
      return;
    }

    dfs(root->left, path * 10 + root->val, ans);
    dfs(root->right, path * 10 + root->val, ans);
  }
};",129
129,"class Solution {
 public:
  void solve(vector<vector<char>>& board) {
    if (board.empty())
      return;

    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = board.size();
    const int n = board[0].size();

    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (board[i][j] == 'O') {
            q.emplace(i, j);
            board[i][j] = '*';
          }

    // Mark the grids that stretch from the four sides with '*'.
    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (board[x][y] != 'O')
          continue;
        q.emplace(x, y);
        board[x][y] = '*';
      }
    }

    for (vector<char>& row : board)
      for (char& c : row)
        if (c == '*')
          c = 'O';
        else if (c == 'O')
          c = 'X';
  }
};",130
130,"class Solution {
 public:
  vector<vector<string>> partition(string s) {
    vector<vector<string>> ans;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, vector<string>&& path,
           vector<vector<string>>& ans) {
    if (start == s.length()) {
      ans.push_back(path);
      return;
    }

    for (int i = start; i < s.length(); ++i)
      if (isPalindrome(s, start, i)) {
        path.push_back(s.substr(start, i - start + 1));
        dfs(s, i + 1, move(path), ans);
        path.pop_back();
      }
  }

  bool isPalindrome(const string& s, int l, int r) {
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};",131
131,"class Solution {
 public:
  int minCut(string s) {
    const int n = s.length();
    // isPalindrome[i][j] := true if s[i..j] is a palindrome
    vector<vector<bool>> isPalindrome(n, vector<bool>(n, true));
    // dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]
    vector<int> dp(n, n);

    for (int l = 2; l <= n; ++l)
      for (int i = 0, j = l - 1; j < n; ++i, ++j)
        isPalindrome[i][j] = s[i] == s[j] && isPalindrome[i + 1][j - 1];

    for (int i = 0; i < n; ++i) {
      if (isPalindrome[0][i]) {
        dp[i] = 0;
        continue;
      }

      // Try all the possible partitions.
      for (int j = 0; j < i; ++j)
        if (isPalindrome[j + 1][i])
          dp[i] = min(dp[i], dp[j] + 1);
    }

    return dp.back();
  }
};",132
132,"class Solution {
 public:
  Node* cloneGraph(Node* node) {
    if (node == nullptr)
      return nullptr;

    queue<Node*> q{{node}};
    unordered_map<Node*, Node*> map{{node, new Node(node->val)}};

    while (!q.empty()) {
      Node* u = q.front();
      q.pop();
      for (Node* v : u->neighbors) {
        if (!map.count(v)) {
          map[v] = new Node(v->val);
          q.push(v);
        }
        map[u]->neighbors.push_back(map[v]);
      }
    }

    return map[node];
  }
};",133
133,"class Solution {
 public:
  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    const int gasSum = accumulate(gas.begin(), gas.end(), 0);
    const int costSum = accumulate(cost.begin(), cost.end(), 0);
    if (gasSum - costSum < 0)
      return -1;

    int ans = 0;
    int sum = 0;

    // Try to start from each index.
    for (int i = 0; i < gas.size(); ++i) {
      sum += gas[i] - cost[i];
      if (sum < 0) {
        sum = 0;
        ans = i + 1;  // Start from the next index.
      }
    }

    return ans;
  }
};",134
134,"class Solution {
 public:
  int candy(vector<int>& ratings) {
    const int n = ratings.size();
    int ans = 0;
    vector<int> l(n, 1);
    vector<int> r(n, 1);

    for (int i = 1; i < n; ++i)
      if (ratings[i] > ratings[i - 1])
        l[i] = l[i - 1] + 1;

    for (int i = n - 2; i >= 0; --i)
      if (ratings[i] > ratings[i + 1])
        r[i] = r[i + 1] + 1;

    for (int i = 0; i < n; ++i)
      ans += max(l[i], r[i]);

    return ans;
  }
};",135
135,"class Solution {
 public:
  int singleNumber(vector<int>& nums) {
    int ans = 0;

    for (const int num : nums)
      ans ^= num;

    return ans;
  }
};",136
136,"class Solution {
 public:
  int singleNumber(vector<int>& nums) {
    int ans = 0;

    for (int i = 0; i < 32; ++i) {
      int sum = 0;
      for (const int num : nums)
        sum += num >> i & 1;
      sum %= 3;
      ans |= sum << i;
    }

    return ans;
  }
};",137
137,"class Solution {
 public:
  Node* copyRandomList(Node* head) {
    if (head == nullptr)
      return nullptr;
    if (const auto it = map.find(head); it != map.cend())
      return it->second;

    Node* newNode = new Node(head->val);
    map[head] = newNode;
    newNode->next = copyRandomList(head->next);
    newNode->random = copyRandomList(head->random);
    return newNode;
  }

 private:
  unordered_map<Node*, Node*> map;
};",138
138,"class Solution {
 public:
  bool wordBreak(string s, vector<string>& wordDict) {
    return wordBreak(s, {wordDict.begin(), wordDict.end()}, {});
  }

 private:
  bool wordBreak(const string& s, const unordered_set<string>&& wordSet,
                 unordered_map<string, bool>&& mem) {
    if (wordSet.count(s))
      return true;
    if (const auto it = mem.find(s); it != mem.cend())
      return it->second;

    // 1 <= prefix.length() < s.length()
    for (int i = 1; i < s.length(); ++i) {
      const string& prefix = s.substr(0, i);
      const string& suffix = s.substr(i);
      if (wordSet.count(prefix) && wordBreak(suffix, move(wordSet), move(mem)))
        return mem[s] = true;
    }

    return mem[s] = false;
  }
};",139
139,"class Solution {
 public:
  vector<string> wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> wordSet{wordDict.begin(), wordDict.end()};
    unordered_map<string, vector<string>> mem;
    return wordBreak(s, wordSet, mem);
  }

 private:
  vector<string> wordBreak(const string& s,
                           const unordered_set<string>& wordSet,
                           unordered_map<string, vector<string>>& mem) {
    if (const auto it = mem.find(s); it != mem.cend())
      return it->second;

    vector<string> ans;

    // 1 <= prefix.length() < s.length()
    for (int i = 1; i < s.length(); ++i) {
      const string& prefix = s.substr(0, i);
      const string& suffix = s.substr(i);
      if (wordSet.count(prefix))
        for (const string& word : wordBreak(suffix, wordSet, mem))
          ans.push_back(prefix + "" "" + word);
    }

    // `wordSet` contains the whole string s, so don't add any space.
    if (wordSet.count(s))
      ans.push_back(s);

    return mem[s] = ans;
  }
};",140
140,"class Solution {
 public:
  bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast)
        return true;
    }

    return false;
  }
};",141
141,"class Solution {
 public:
  ListNode* detectCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast) {
        slow = head;
        while (slow != fast) {
          slow = slow->next;
          fast = fast->next;
        }
        return slow;
      }
    }

    return nullptr;
  }
};",142
142,"class Solution {
 public:
  void reorderList(ListNode* head) {
    if (!head || !head->next)
      return;

    ListNode* mid = findMid(head);
    ListNode* reversed = reverse(mid);
    merge(head, reversed);
  }

 private:
  ListNode* findMid(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
      prev = slow;
      slow = slow->next;
      fast = fast->next->next;
    }
    prev->next = nullptr;

    return slow;
  }

  ListNode* reverse(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr) {
      ListNode* next = curr->next;
      curr->next = prev;
      prev = curr;
      curr = next;
    }

    return prev;
  }

  void merge(ListNode* l1, ListNode* l2) {
    while (l2) {
      ListNode* next = l1->next;
      l1->next = l2;
      l1 = l2;
      l2 = next;
    }
  }
};",143
143,"class Solution {
 public:
  vector<int> preorderTraversal(TreeNode* root) {
    vector<int> ans;
    preorder(root, ans);
    return ans;
  }

 private:
  void preorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr)
      return;

    ans.push_back(root->val);
    preorder(root->left, ans);
    preorder(root->right, ans);
  }
};",144
144,"class Solution {
 public:
  vector<int> postorderTraversal(TreeNode* root) {
    vector<int> ans;
    postorder(root, ans);
    return ans;
  }

 private:
  void postorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr)
      return;

    postorder(root->left, ans);
    postorder(root->right, ans);
    ans.push_back(root->val);
  }
};",145
145,get(key: int),146
146,"class Solution {
 public:
  ListNode* insertionSortList(ListNode* head) {
    ListNode dummy(0);
    ListNode* prev = &dummy;  // the last and thus largest of the sorted list

    while (head != nullptr) {       // the current inserting node
      ListNode* next = head->next;  // Cache the next inserting node.
      if (prev->val >= head->val)
        prev = &dummy;  // Move `prev` to the front.
      while (prev->next && prev->next->val < head->val)
        prev = prev->next;
      head->next = prev->next;
      prev->next = head;
      head = next;  // Update the current inserting node.
    }

    return dummy.next;
  }
};",147
147,"class Solution {
 public:
  ListNode* sortList(ListNode* head) {
    const int length = getLength(head);
    ListNode dummy(0, head);

    for (int k = 1; k < length; k *= 2) {
      ListNode* curr = dummy.next;
      ListNode* tail = &dummy;
      while (curr) {
        ListNode* l = curr;
        ListNode* r = split(l, k);
        curr = split(r, k);
        auto [mergedHead, mergedTail] = merge(l, r);
        tail->next = mergedHead;
        tail = mergedTail;
      }
    }

    return dummy.next;
  }

 private:
  int getLength(ListNode* head) {
    int length = 0;
    for (ListNode* curr = head; curr; curr = curr->next)
      ++length;
    return length;
  }

  ListNode* split(ListNode* head, int k) {
    while (--k && head)
      head = head->next;
    ListNode* rest = head ? head->next : nullptr;
    if (head != nullptr)
      head->next = nullptr;
    return rest;
  }

  pair<ListNode*, ListNode*> merge(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &dummy;

    while (l1 && l2) {
      if (l1->val > l2->val)
        swap(l1, l2);
      tail->next = l1;
      l1 = l1->next;
      tail = tail->next;
    }
    tail->next = l1 ? l1 : l2;
    while (tail->next)
      tail = tail->next;

    return {dummy.next, tail};
  }
};",148
148,"class Solution {
 public:
  int maxPoints(vector<vector<int>>& points) {
    int ans = 0;

    for (int i = 0; i < points.size(); ++i) {
      unordered_map<pair<int, int>, int, PairHash> slopeCount;
      const vector<int> p1{points[i]};
      int samePoints = 1;
      int maxPoints = 0;  // the maximum number of points with the same slope
      for (int j = i + 1; j < points.size(); ++j) {
        const vector<int> p2{points[j]};
        if (p1 == p2)
          ++samePoints;
        else
          maxPoints = max(maxPoints, ++slopeCount[getSlope(p1, p2)]);
      }
      ans = max(ans, samePoints + maxPoints);
    }

    return ans;
  }

 private:
  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {
    const int dx = p[0] - q[0];
    const int dy = p[1] - q[1];
    if (dx == 0)
      return {0, p[0]};
    if (dy == 0)
      return {p[1], 0};
    const int d = __gcd(dx, dy);
    return {dx / d, dy / d};
  }

  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",149
149,"class Solution {
 public:
  int evalRPN(vector<string>& tokens) {
    stack<long> stack;
    const unordered_map<string, function<long(long, long)>> op{
        {""+"", std::plus<long>()},
        {""-"", std::minus<long>()},
        {""*"", std::multiplies<long>()},
        {""/"", std::divides<long>()}};

    for (const string& token : tokens)
      if (op.count(token)) {
        const long b = stack.top();
        stack.pop();
        const long a = stack.top();
        stack.pop();
        stack.push(op.at(token)(a, b));
      } else {
        stack.push(stoi(token));
      }

    return stack.top();
  }
};",150
150,"class Solution {
 public:
  string reverseWords(string s) {
    reverse(s.begin(), s.end());        // Reverse the whole string.
    reverseWords(s, s.length());        // Reverse each word.
    return cleanSpaces(s, s.length());  // Clean up the spaces.
  }

 private:
  void reverseWords(string& s, int n) {
    int i = 0;
    int j = 0;

    while (i < n) {
      while (i < j || i < n && s[i] == ' ')  // Skip the spaces.
        ++i;
      while (j < i || j < n && s[j] != ' ')  // Skip the spaces.
        ++j;
      reverse(s.begin() + i, s.begin() + j);  // Reverse the word.
    }
  }

  // Trim leading, trailing, and middle spaces
  string cleanSpaces(string& s, int n) {
    int i = 0;
    int j = 0;

    while (j < n) {
      while (j < n && s[j] == ' ')  // Skip the spaces.
        ++j;
      while (j < n && s[j] != ' ')  // Keep non spaces
        s[i++] = s[j++];
      while (j < n && s[j] == ' ')  // Skip the spaces.
        ++j;
      if (j < n)  // Keep only one space.
        s[i++] = ' ';
    }

    return s.substr(0, i);
  }
};",151
151,"class Solution {
 public:
  int maxProduct(vector<int>& nums) {
    int ans = nums[0];
    int dpMin = nums[0];  // the minimum so far
    int dpMax = nums[0];  // the maximum so far

    for (int i = 1; i < nums.size(); ++i) {
      const int num = nums[i];
      const int prevMin = dpMin;  // dpMin[i - 1]
      const int prevMax = dpMax;  // dpMax[i - 1]
      if (num < 0) {
        dpMin = min(prevMax * num, num);
        dpMax = max(prevMin * num, num);
      } else {
        dpMin = min(prevMin * num, num);
        dpMax = max(prevMax * num, num);
      }
      ans = max(ans, dpMax);
    }

    return ans;
  }
};",152
152,"class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] < nums[r])
        r = m;
      else
        l = m + 1;
    }

    return nums[l];
  }
};",153
153,"class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] == nums[r])
        --r;
      else if (nums[m] < nums[r])
        r = m;
      else
        l = m + 1;
    }

    return nums[l];
  }
};",154
154,"class MinStack {
 public:
  void push(int x) {
    if (stack.empty())
      stack.emplace(x, x);
    else
      stack.emplace(x, min(x, stack.top().second));
  }

  void pop() {
    stack.pop();
  }

  int top() {
    return stack.top().first;
  }

  int getMin() {
    return stack.top().second;
  }

 private:
  stack<pair<int, int>> stack;  // {x, min}
};",155
155,"class Solution {
 public:
  TreeNode* upsideDownBinaryTree(TreeNode* root) {
    if (root == nullptr || root->left == nullptr)
      return root;

    TreeNode* newRoot = upsideDownBinaryTree(root->left);
    root->left->left = root->right;  // 2's left = 3 (root's right)
    root->left->right = root;        // 2's right = 1 (root)
    root->left = nullptr;
    root->right = nullptr;
    return newRoot;
  }
};",156
156,"/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char *buf4);
 */

class Solution {
 public:
  /**
   * @param buf Destination buffer
   * @param n   Number of characters to read
   * @return    The number of actual characters read
   */
  int read(char* buf, int n) {
    char* buf4 = new char[4];
    int i4 = 0;  // buf4's index
    int n4 = 0;  // buf4's size
    int i = 0;   // buf's index

    while (i < n) {
      if (i4 == n4) {      // All the characters in the buf4 are consumed.
        i4 = 0;            // Reset the buf4's index.
        n4 = read4(buf4);  // Read <= 4 characters from the file to the buf4.
        if (n4 == 0)       // Reach the EOF.
          return i;
      }
      buf[i++] = buf4[i4++];
    }

    return i;
  }
};",157
157,"/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char *buf4);
 */

class Solution {
 public:
  /**
   * @param buf Destination buffer
   * @param n   Number of characters to read
   * @return    The number of actual characters read
   */
  int read(char* buf, int n) {
    int i = 0;  // buf's index

    while (i < n) {
      if (i4 == n4) {      // All the characters in the buf4 are consumed.
        i4 = 0;            // Reset the buf4's index.
        n4 = read4(buf4);  // Read <= 4 characters from the file to the buf4.
        if (n4 == 0)       // Reach the EOF.
          return i;
      }
      buf[i++] = buf4[i4++];
    }

    return i;
  }

 private:
  char* buf4 = new char[4];
  int i4 = 0;  // buf4's index
  int n4 = 0;  // buf4's size
};",158
158,"class Solution {
 public:
  int lengthOfLongestSubstringTwoDistinct(string s) {
    int ans = 0;
    int distinct = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r]] == 1)
        ++distinct;
      while (distinct == 3)
        if (--count[s[l++]] == 0)
          --distinct;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",159
159,"class Solution {
 public:
  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    ListNode* a = headA;
    ListNode* b = headB;

    while (a != b) {
      a = a == nullptr ? headB : a->next;
      b = b == nullptr ? headA : b->next;
    }

    return a;
  }
};",160
160,"class Solution {
 public:
  bool isOneEditDistance(string s, string t) {
    const int m = s.length();
    const int n = t.length();
    if (m > n)  // Make sure that |s| <= |t|.
      return isOneEditDistance(t, s);

    for (int i = 0; i < m; ++i)
      if (s[i] != t[i]) {
        if (m == n)
          return s.substr(i + 1) == t.substr(i + 1);  // Replace s[i] with t[i].
        return s.substr(i) == t.substr(i + 1);        // Delete t[i].
      }

    return m + 1 == n;  // Delete t[-1].
  }
};",161
161,"class Solution {
 public:
  int findPeakElement(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] >= nums[m + 1])
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",162
162,"class Solution {
 public:
  vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {
    if (nums.empty())
      return {getRange(lower, upper)};

    vector<string> ans;

    if (nums.front() > lower)
      ans.push_back(getRange(lower, nums.front() - 1));

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1] + 1)
        ans.push_back(getRange(nums[i - 1] + 1, nums[i] - 1));

    if (nums.back() < upper)
      ans.push_back(getRange(nums.back() + 1, upper));

    return ans;
  }

 private:
  string getRange(int lo, int hi) {
    if (lo == hi)
      return to_string(lo);
    return to_string(lo) + ""->"" + to_string(hi);
  }
};",163
163,"struct Bucket {
  int min;
  int max;
};

class Solution {
 public:
  int maximumGap(vector<int>& nums) {
    if (nums.size() < 2)
      return 0;

    const int mini = ranges::min(nums);
    const int maxi = ranges::max(nums);
    if (mini == maxi)
      return 0;

    const int gap = ceil((maxi - mini) / (double)(nums.size() - 1));
    const int bucketSize = (maxi - mini) / gap + 1;
    vector<Bucket> buckets(bucketSize, {INT_MAX, INT_MIN});

    for (const int num : nums) {
      const int i = (num - mini) / gap;
      buckets[i].min = min(buckets[i].min, num);
      buckets[i].max = max(buckets[i].max, num);
    }

    int ans = 0;
    int prevMax = mini;

    for (const Bucket& bucket : buckets) {
      if (bucket.min == INT_MAX)
        continue;  // empty bucket
      ans = max(ans, bucket.min - prevMax);
      prevMax = bucket.max;
    }

    return ans;
  }
};",164
164,"class Solution {
 public:
  int compareVersion(string version1, string version2) {
    istringstream iss1(version1);
    istringstream iss2(version2);
    int v1;
    int v2;
    char dotChar;

    while (bool(iss1 >> v1) + bool(iss2 >> v2)) {
      if (v1 < v2)
        return -1;
      if (v1 > v2)
        return 1;
      iss1 >> dotChar;
      iss2 >> dotChar;
      v1 = 0;
      v2 = 0;
    }

    return 0;
  };
};",165
165,"class Solution {
 public:
  string fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0)
      return ""0"";

    string ans;

    if (numerator < 0 ^ denominator < 0)
      ans += ""-"";

    long n = labs(numerator);
    long d = labs(denominator);
    ans += to_string(n / d);

    if (n % d == 0)
      return ans;

    ans += '.';
    unordered_map<int, int> seen;

    for (long r = n % d; r; r %= d) {
      if (const auto it = seen.find(r); it != seen.cend()) {
        ans.insert(it->second, 1, '(');
        ans += ')';
        break;
      }
      seen[r] = ans.size();
      r *= 10;
      ans += to_string(r / d);
    }

    return ans;
  }
};",166
166,"class Solution {
 public:
  vector<int> twoSum(vector<int>& numbers, int target) {
    int l = 0;
    int r = numbers.size() - 1;

    while (numbers[l] + numbers[r] != target)
      if (numbers[l] + numbers[r] < target)
        ++l;
      else
        --r;

    return {l + 1, r + 1};
  }
};",167
167,"class Solution {
 public:
  string convertToTitle(int n) {
    return n == 0 ? """"
                  : convertToTitle((n - 1) / 26) + (char)('A' + ((n - 1) % 26));
  }
};",168
168,"class Solution {
 public:
  int majorityElement(vector<int>& nums) {
    int ans;
    int count = 0;

    for (const int num : nums) {
      if (count == 0)
        ans = num;
      count += num == ans ? 1 : -1;
    }

    return ans;
  }
};",169
169,"class TwoSum {
 public:
  void add(int number) {
    ++count[number];
  }

  bool find(int value) {
    for (const auto& [key, freq] : count) {
      const int remain = value - key;
      if (key == remain && freq > 1)
        return true;
      if (key != remain && count.count(remain))
        return true;
    }

    return false;
  }

 private:
  unordered_map<int, int> count;
};",170
170,"class Solution {
 public:
  int titleToNumber(string s) {
    return accumulate(s.begin(), s.end(), 0,
                      [](int a, int b) { return a * 26 + (b - 'A' + 1); });
  }
};",171
171,"class Solution {
 public:
  int trailingZeroes(int n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};",172
172,next(),173
173,"class Solution {
 public:
  int calculateMinimumHP(vector<vector<int>>& dungeon) {
    const int m = dungeon.size();
    const int n = dungeon[0].size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
    dp[m][n - 1] = 1;
    dp[m - 1][n] = 1;

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
        dp[i][j] = max(dp[i][j], 1);
      }

    return dp[0][0];
  }
};",174
174,"SELECT
  Person.firstName,
  Person.lastName,
  Address.city,
  Address.state
FROM Person
LEFT JOIN Address
  USING (personId);",175
175,"WITH
  RankedEmployees AS (
    SELECT *, DENSE_RANK() OVER(ORDER BY salary DESC) AS `rank`
    FROM Employee
  )
SELECT MAX(salary) AS SecondHighestSalary
FROM RankedEmployees
WHERE `rank` = 2;",176
176,"CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  RETURN (
    WITH
      RankedEmployees AS (
        SELECT *, DENSE_RANK() OVER(ORDER BY salary DESC) AS `rank`
        FROM Employee
      )
    SELECT MAX(salary) AS SecondHighestSalary
    FROM RankedEmployees
    WHERE `rank` = N
  );
END",177
177,"SELECT
  score,
  DENSE_RANK() OVER(ORDER BY score DESC) AS `rank`
FROM Scores;",178
178,"class Solution {
 public:
  string largestNumber(vector<int>& nums) {
    string ans;

    ranges::sort(nums, [](int a, int b) {
      return to_string(a) + to_string(b) > to_string(b) + to_string(a);
    });

    for (const int num : nums)
      ans += to_string(num);

    return ans[0] == '0' ? ""0"" : ans;
  }
};",179
179,"WITH
  LogsNeighbors AS (
    SELECT
      *,
      LAG(num) OVER(ORDER BY id) AS prev_num,
      LEAD(num) OVER(ORDER BY id) AS next_num
    FROM LOGS
  )
SELECT DISTINCT num AS ConsecutiveNums
FROM LogsNeighbors
WHERE
  num = prev_num
  AND num = next_num;",180
180,"SELECT Worker.name AS Employee
FROM Employee AS Worker
INNER JOIN Employee AS Manager
  ON (Worker.managerId = Manager.id)
WHERE Worker.salary > Manager.salary;",181
181,"SELECT email
FROM Person
GROUP BY 1
HAVING COUNT(*) > 1;",182
182,"SELECT Customers.name AS Customers
FROM Customers
LEFT JOIN Orders
  ON (Customers.id = Orders.customerId)
WHERE Orders.id IS NULL;",183
183,"WITH
  EmployeesWithMaxSalaryInDepartment AS (
    SELECT
      Department.name AS department,
      Employee.name AS employee,
      Employee.salary,
      MAX(Employee.salary) OVER(
        PARTITION BY Employee.departmentId
      ) AS max_salary
    FROM Employee
    LEFT JOIN Department
      ON (Employee.departmentId = Department.id)
  )
SELECT
  department AS Department,
  employee AS Employee,
  salary AS Salary
FROM EmployeesWithMaxSalaryInDepartment
WHERE salary = max_salary;",184
184,"WITH
  EmployeesWithRankInDepartment AS (
    SELECT
      Department.name AS department,
      Employee.name AS employee,
      Employee.salary,
      DENSE_RANK() OVER(
        PARTITION BY Employee.departmentId
        ORDER BY Employee.salary DESC
      ) AS `rank`
    FROM Department
    INNER JOIN Employee
      ON (Department.id = Employee.departmentId )
  )
SELECT
  department AS Department,
  employee AS Employee,
  salary AS Salary
FROM EmployeesWithRankInDepartment
WHERE `rank` <= 3;",185
185,"class Solution {
 public:
  void reverseWords(vector<char>& s) {
    reverse(s.begin(), s.end());  // Reverse the whole string.
    reverseWords(s, s.size());    // Reverse each word.
  }

 private:
  void reverseWords(vector<char>& s, int n) {
    int i = 0;
    int j = 0;

    while (i < n) {
      while (i < j || i < n && s[i] == ' ')  // Skip the spaces.
        ++i;
      while (j < i || j < n && s[j] != ' ')  // Skip the spaces.
        ++j;
      reverse(s.begin() + i, s.begin() + j);  // Reverse the word.
    }
  }
};",186
186,"class Solution {
 public:
  vector<string> findRepeatedDnaSequences(string s) {
    unordered_set<string> ans;
    unordered_set<string_view> seen;
    const string_view sv(s);

    for (int i = 0; i + 10 <= s.length(); ++i) {
      if (seen.count(sv.substr(i, 10)))
        ans.insert(s.substr(i, 10));
      seen.insert(sv.substr(i, 10));
    }

    return {ans.begin(), ans.end()};
  }
};",187
187,"class Solution {
 public:
  int maxProfit(int k, vector<int>& prices) {
    if (k >= prices.size() / 2) {
      int sell = 0;
      int hold = INT_MIN;

      for (const int price : prices) {
        sell = max(sell, hold + price);
        hold = max(hold, sell - price);
      }

      return sell;
    }

    vector<int> sell(k + 1);
    vector<int> hold(k + 1, INT_MIN);

    for (const int price : prices)
      for (int i = k; i > 0; --i) {
        sell[i] = max(sell[i], hold[i] + price);
        hold[i] = max(hold[i], sell[i - 1] - price);
      }

    return sell[k];
  }
};",188
188,"class Solution {
 public:
  void rotate(vector<int>& nums, int k) {
    k %= nums.size();
    reverse(nums, 0, nums.size() - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.size() - 1);
  }

 private:
  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};",189
189,"class Solution {
 public:
  uint32_t reverseBits(uint32_t n) {
    uint32_t ans = 0;

    for (int i = 0; i < 32; ++i)
      if (n >> i & 1)
        ans |= 1 << 31 - i;

    return ans;
  }
};",190
190,"class Solution {
 public:
  int hammingWeight(uint32_t n) {
    int ans = 0;

    for (int i = 0; i < 32; ++i)
      if ((n >> i) & 1)
        ++ans;

    return ans;
  }
};",191
191,"cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -r | awk '{ print $2, $1 }'",192
192,"grep -e ""^[0-9]\{3\}\-[0-9]\{3\}\-[0-9]\{4\}$"" -e ""^([0-9]\{3\}) [0-9]\{3\}\-[0-9]\{4\}$"" file.txt",193
193,"awk '{
  for (i = 1; i <= NF; ++i) {
    if (NR == 1) {
      arr[i] = $i;
    } else {
      arr[i] = arr[i] "" "" $i;
    }
  }
} END {
  for (i = 1; i <= NF; ++i) {
    print arr[i];
  }
}' file.txt",194
194,awk 'NR == 10' file.txt,195
195,"DELETE P2
FROM Person AS P1
INNER JOIN Person AS P2
  ON (P1.email = P2.email)
WHERE P1.id < P2.id;",196
196,"SELECT Today.id
FROM Weather AS Today
INNER JOIN Weather AS Yesterday
  ON (DATE_SUB(Today.recordDate, INTERVAL 1 DAY) = Yesterday.recordDate)
WHERE Today.temperature > Yesterday.temperature;",197
197,"class Solution {
 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    if (nums.size() == 1)
      return nums[0];

    // dp[i] := the maximum money of robbing nums[0..i]
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for (int i = 2; i < nums.size(); ++i)
      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);

    return dp.back();
  }
};",198
198,"class Solution {
 public:
  vector<int> rightSideView(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        if (i == size - 1)
          ans.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
    }

    return ans;
  }
};",199
199,"class Solution {
 public:
  int numIslands(vector<vector<char>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;

    auto bfs = [&](int r, int c) {
      queue<pair<int, int>> q{{{r, c}}};
      grid[r][c] = '2';  // Mark '2' as visited.
      while (!q.empty()) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] != '1')
            continue;
          q.emplace(x, y);
          grid[x][y] = '2';  // Mark '2' as visited.
        }
      }
    };

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '1') {
          bfs(i, j);
          ++ans;
        }

    return ans;
  }
};",200
200,"class Solution {
 public:
  int rangeBitwiseAnd(int m, int n) {
    int shiftBits = 0;

    while (m != n) {
      m >>= 1;
      n >>= 1;
      ++shiftBits;
    }

    return m << shiftBits;
  }
};",201
201,"class Solution {
 public:
  bool isHappy(int n) {
    int slow = squaredSum(n);
    int fast = squaredSum(squaredSum(n));

    while (slow != fast) {
      slow = squaredSum(slow);
      fast = squaredSum(squaredSum(fast));
    }

    return slow == 1;
  }

 private:
  int squaredSum(int n) {
    int sum = 0;
    while (n) {
      sum += pow(n % 10, 2);
      n /= 10;
    }
    return sum;
  };
};",202
202,"class Solution {
 public:
  ListNode* removeElements(ListNode* head, int val) {
    ListNode dummy(0, head);
    ListNode* prev = &dummy;

    for (; head; head = head->next)
      if (head->val != val) {
        prev->next = head;
        prev = prev->next;
      }
    prev->next = nullptr;  // In case that the last value equals `val`.

    return dummy.next;
  }
};",203
203,"class Solution {
 public:
  int countPrimes(int n) {
    if (n <= 2)
      return 0;
    const vector<bool> isPrime = sieveEratosthenes(n);
    return ranges::count(isPrime, true);
  }

 private:
  vector<bool> sieveEratosthenes(int n) {
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    return isPrime;
  }
};",204
204,"class Solution {
 public:
  bool isIsomorphic(string s, string t) {
    vector<int> charToIndex_s(128);
    vector<int> charToIndex_t(128);

    for (int i = 0; i < s.length(); ++i) {
      if (charToIndex_s[s[i]] != charToIndex_t[t[i]])
        return false;
      charToIndex_s[s[i]] = i + 1;
      charToIndex_t[t[i]] = i + 1;
    }

    return true;
  }
};",205
205,"class Solution {
 public:
  ListNode* reverseList(ListNode* head) {
    if (!head || !head->next)
      return head;

    ListNode* newHead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
  }
};",206
206,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> graph(numCourses);
    vector<State> states(numCourses);

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[1];
      const int v = prerequisite[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < numCourses; ++i)
      if (hasCycle(graph, i, states))
        return false;

    return true;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u,
                vector<State>& states) {
    if (states[u] == State::kVisiting)
      return true;
    if (states[u] == State::kVisited)
      return false;

    states[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, states))
        return true;
    states[u] = State::kVisited;

    return false;
  }
};",207
207,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool search(const string& word) {
    shared_ptr<TrieNode> node = find(word);
    return node && node->isWord;
  }

  bool startsWith(const string& prefix) {
    return find(prefix) != nullptr;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  shared_ptr<TrieNode> find(const string& prefix) {
    shared_ptr<TrieNode> node = root;
    for (const char c : prefix) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return nullptr;
      node = node->children[i];
    }
    return node;
  }
};",208
208,"class Solution {
 public:
  int minSubArrayLen(int s, vector<int>& nums) {
    int ans = INT_MAX;
    int sum = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum >= s) {
        ans = min(ans, r - l + 1);
        sum -= nums[l++];
      }
    }

    return ans < INT_MAX ? ans : 0;
  }
};",209
209,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> ans;
    vector<vector<int>> graph(numCourses);
    vector<State> states(numCourses);

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[1];
      const int v = prerequisite[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < numCourses; ++i)
      if (hasCycle(graph, i, states, ans))
        return {};

    reverse(ans.begin(), ans.end());
    return ans;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& states,
                vector<int>& ans) {
    if (states[u] == State::kVisiting)
      return true;
    if (states[u] == State::kVisited)
      return false;

    states[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, states, ans))
        return true;
    states[u] = State::kVisited;
    ans.push_back(u);

    return false;
  }
};",210
210,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class WordDictionary {
 public:
  void addWord(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool search(const string& word) {
    return dfs(word, 0, root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  bool dfs(const string& word, int s, shared_ptr<TrieNode> node) {
    if (s == word.length())
      return node->isWord;
    if (word[s] != '.') {
      shared_ptr<TrieNode> next = node->children[word[s] - 'a'];
      return next ? dfs(word, s + 1, next) : false;
    }

    // If word[s] == '.', then search all the 26 children.
    for (int i = 0; i < 26; ++i)
      if (node->children[i] && dfs(word, s + 1, node->children[i]))
        return true;

    return false;
  }
};",211
211,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    vector<string> ans;

    for (const string& word : words)
      insert(word);

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j)
        dfs(board, i, j, root, ans);

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  void dfs(vector<vector<char>>& board, int i, int j, shared_ptr<TrieNode> node,
           vector<string>& ans) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return;
    if (board[i][j] == '*')
      return;

    const char c = board[i][j];
    shared_ptr<TrieNode> child = node->children[c - 'a'];
    if (child == nullptr)
      return;
    if (child->word != nullptr) {
      ans.push_back(*child->word);
      child->word = nullptr;
    }

    board[i][j] = '*';
    dfs(board, i + 1, j, child, ans);
    dfs(board, i - 1, j, child, ans);
    dfs(board, i, j + 1, child, ans);
    dfs(board, i, j - 1, child, ans);
    board[i][j] = c;
  }
};",212
212,"class Solution {
 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    if (nums.size() == 1)
      return nums[0];

    auto rob = [&](int l, int r) {
      int prev1 = 0;  // dp[i - 1]
      int prev2 = 0;  // dp[i - 2]

      for (int i = l; i <= r; ++i) {
        const int dp = max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = dp;
      }

      return prev1;
    };

    return max(rob(0, nums.size() - 2), rob(1, nums.size() - 1));
  }
};",213
213,"class Solution {
 public:
  string shortestPalindrome(string s) {
    string t = s;
    reverse(t.begin(), t.end());

    const string_view sv_s(s);
    const string_view sv_t(t);

    for (int i = 0; i < s.length(); ++i)
      if (sv_s.substr(0, s.length() - i) == sv_t.substr(i))
        return t.substr(0, i) + s;

    return t + s;
  }
};",214
214,"class Solution {
 public:
  int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int num : nums) {
      minHeap.push(num);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    return minHeap.top();
  }
};",215
215,"class Solution {
 public:
  vector<vector<int>> combinationSum3(int k, int n) {
    vector<vector<int>> ans;
    dfs(k, n, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(int k, int n, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (k == 0 && n == 0) {
      ans.push_back(path);
      return;
    }
    if (k == 0 || n <= 0)
      return;

    for (int i = s; i <= 9; ++i) {
      path.push_back(i);
      dfs(k - 1, n - i, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",216
216,"class Solution {
 public:
  bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;

    for (const int num : nums)
      if (!seen.insert(num).second)
        return true;

    return false;
  }
};",217
217,"class Solution {
 public:
  vector<vector<int>> getSkyline(const vector<vector<int>>& buildings) {
    const int n = buildings.size();
    if (n == 0)
      return {};
    if (n == 1) {
      const int left = buildings[0][0];
      const int right = buildings[0][1];
      const int height = buildings[0][2];
      return {{left, height}, {right, 0}};
    }

    const vector<vector<int>> left =
        getSkyline({buildings.begin(), buildings.begin() + n / 2});
    const vector<vector<int>> right =
        getSkyline({buildings.begin() + n / 2, buildings.end()});
    return merge(left, right);
  }

 private:
  vector<vector<int>> merge(const vector<vector<int>>& left,
                            const vector<vector<int>>& right) {
    vector<vector<int>> ans;
    int i = 0;  // left's index
    int j = 0;  // right's index
    int leftY = 0;
    int rightY = 0;

    while (i < left.size() && j < right.size())
      // Choose the point with the smaller x.
      if (left[i][0] < right[j][0]) {
        leftY = left[i][1];  // Update the ongoing `leftY`.
        addPoint(ans, left[i][0], max(left[i++][1], rightY));
      } else {
        rightY = right[j][1];  // Update the ongoing `rightY`.
        addPoint(ans, right[j][0], max(right[j++][1], leftY));
      }

    while (i < left.size())
      addPoint(ans, left[i][0], left[i++][1]);

    while (j < right.size())
      addPoint(ans, right[j][0], right[j++][1]);

    return ans;
  }

  void addPoint(vector<vector<int>>& ans, int x, int y) {
    if (!ans.empty() && ans.back()[0] == x) {
      ans.back()[1] = y;
      return;
    }
    if (!ans.empty() && ans.back()[1] == y)
      return;
    ans.push_back({x, y});
  }
};",218
218,"class Solution {
 public:
  bool containsNearbyDuplicate(vector<int>& nums, int k) {
    unordered_set<int> seen;

    for (int i = 0; i < nums.size(); ++i) {
      if (!seen.insert(nums[i]).second)
        return true;
      if (i >= k)
        seen.erase(nums[i - k]);
    }

    return false;
  }
};",219
219,"class Solution {
 public:
  bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff,
                                     int valueDiff) {
    set<long> window;

    for (int i = 0; i < nums.size(); ++i) {
      if (const auto it =
              window.lower_bound(static_cast<long>(nums[i]) - valueDiff);
          it != window.cend() && *it - nums[i] <= valueDiff)
        return true;
      window.insert(nums[i]);
      if (i >= indexDiff)
        window.erase(nums[i - indexDiff]);
    }

    return false;
  }
};",220
220,"class Solution {
 public:
  int maximalSquare(vector<vector<char>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    int maxLength = 0;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (i == 0 || j == 0 || matrix[i][j] == '0')
          dp[i][j] = matrix[i][j] == '1' ? 1 : 0;
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        maxLength = max(maxLength, dp[i][j]);
      }

    return maxLength * maxLength;
  }
};",221
221,"class Solution {
 public:
  int countNodes(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
  }
};",222
222,"class Solution {
 public:
  int computeArea(long A, long B, long C, long D,  //
                  long E, long F, long G, long H) {
    const long x = max(A, E) < min(C, G) ? (min(C, G) - max(A, E)) : 0;
    const long y = max(B, F) < min(D, H) ? (min(D, H) - max(B, F)) : 0;
    return (C - A) * (D - B) + (G - E) * (H - F) - x * y;
  }
};",223
223,"class Solution {
 public:
  int calculate(string s) {
    int ans = 0;
    int num = 0;
    int sign = 1;
    stack<int> stack{{sign}};  // stack.top() := the current environment's sign

    for (const char c : s)
      if (isdigit(c))
        num = num * 10 + (c - '0');
      else if (c == '(')
        stack.push(sign);
      else if (c == ')')
        stack.pop();
      else if (c == '+' || c == '-') {
        ans += sign * num;
        sign = (c == '+' ? 1 : -1) * stack.top();
        num = 0;
      }

    return ans + sign * num;
  }
};",224
224,"class MyStack {
 public:
  void push(int x) {
    q.push(x);
    for (int i = 0; i < q.size() - 1; ++i) {
      q.push(q.front());
      q.pop();
    }
  }

  int pop() {
    const int val = q.front();
    q.pop();
    return val;
  }

  int top() {
    return q.front();
  }

  bool empty() {
    return q.empty();
  }

 private:
  queue<int> q;
};",225
225,"class Solution {
 public:
  TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;

    TreeNode* const left = root->left;
    TreeNode* const right = root->right;
    root->left = invertTree(right);
    root->right = invertTree(left);
    return root;
  }
};",226
226,"class Solution {
 public:
  int calculate(string s) {
    stack<int> nums;
    stack<char> ops;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c)) {
        int num = c - '0';
        while (i + 1 < s.length() && isdigit(s[i + 1])) {
          num = num * 10 + (s[i + 1] - '0');
          ++i;
        }
        nums.push(num);
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        while (!ops.empty() && compare(ops.top(), c))
          nums.push(calculate(pop(ops), pop(nums), pop(nums)));
        ops.push(c);
      }
    }

    while (!ops.empty())
      nums.push(calculate(pop(ops), pop(nums), pop(nums)));

    return nums.top();
  }

 private:
  int calculate(char op, int b, int a) {
    switch (op) {
      case '+':
        return a + b;
      case '-':
        return a - b;
      case '*':
        return a * b;
      case '/':
        return a / b;
    }
    throw;
  }

  // Returns true if priority(op1) >= priority(op2).
  bool compare(char op1, char op2) {
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }

  char pop(stack<char>& ops) {
    const char op = ops.top();
    ops.pop();
    return op;
  }

  int pop(stack<int>& nums) {
    const int num = nums.top();
    nums.pop();
    return num;
  }
};",227
227,"class Solution {
 public:
  vector<string> summaryRanges(vector<int>& nums) {
    vector<string> ans;

    for (int i = 0; i < nums.size(); ++i) {
      const int begin = nums[i];
      while (i + 1 < nums.size() && nums[i] == nums[i + 1] - 1)
        ++i;
      const int end = nums[i];
      if (begin == end)
        ans.push_back(to_string(begin));
      else
        ans.push_back(to_string(begin) + ""->"" + to_string(end));
    }

    return ans;
  }
};",228
228,"class Solution {
 public:
  vector<int> majorityElement(vector<int>& nums) {
    vector<int> ans;
    int candidate1 = 0;
    int candidate2 = 1;   // any number different from candidate1
    int countSoFar1 = 0;  // the number of candidate1 so far
    int countSoFar2 = 0;  // the number of candidate2 so far

    for (const int num : nums)
      if (num == candidate1) {
        ++countSoFar1;
      } else if (num == candidate2) {
        ++countSoFar2;
      } else if (countSoFar1 == 0) {  // Assign the new candidate.
        candidate1 = num;
        ++countSoFar1;
      } else if (countSoFar2 == 0) {  // Assign the new candidate.
        candidate2 = num;
        ++countSoFar2;
      } else {  // Meet a new number, so pair with the previous counts.
        --countSoFar1;
        --countSoFar2;
      }

    const int count1 = ranges::count(nums, candidate1);
    const int count2 = ranges::count(nums, candidate2);

    if (count1 > nums.size() / 3)
      ans.push_back(candidate1);
    if (count2 > nums.size() / 3)
      ans.push_back(candidate2);
    return ans;
  }
};",229
229,"class Solution {
 public:
  int kthSmallest(TreeNode* root, int k) {
    const int leftCount = countNodes(root->left);

    if (leftCount == k - 1)
      return root->val;
    if (leftCount >= k)
      return kthSmallest(root->left, k);
    return kthSmallest(root->right, k - 1 - leftCount);  // leftCount < k
  }

 private:
  int countNodes(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
  }
};",230
230,"class Solution {
 public:
  bool isPowerOfTwo(int n) {
    return n < 0 ? false : __builtin_popcountll(n) == 1;
  }
};",231
231,push(x),232
232,"class Solution {
 public:
  int countDigitOne(int n) {
    int ans = 0;

    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {
      const long divisor = pow10 * 10;
      const int quotient = n / divisor;
      const int remainder = n % divisor;
      if (quotient > 0)
        ans += quotient * pow10;
      if (remainder >= pow10)
        ans += min(remainder - pow10 + 1, pow10);
    }

    return ans;
  }
};",233
233,"class Solution {
 public:
  bool isPalindrome(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
    }

    if (fast != nullptr)
      slow = slow->next;
    slow = reverseList(slow);

    while (slow) {
      if (slow->val != head->val)
        return false;
      slow = slow->next;
      head = head->next;
    }

    return true;
  }

 private:
  ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;

    while (head) {
      ListNode* next = head->next;
      head->next = prev;
      prev = head;
      head = next;
    }

    return prev;
  }
};",234
234,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root->val > max(p->val, q->val))
      return lowestCommonAncestor(root->left, p, q);
    if (root->val < min(p->val, q->val))
      return lowestCommonAncestor(root->right, p, q);
    return root;
  }
};",235
235,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q)
      return root;
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    if (left != nullptr && right != nullptr)
      return root;
    return left == nullptr ? right : left;
  }
};",236
236,"class Solution {
 public:
  void deleteNode(ListNode* node) {
    node->val = node->next->val;
    node->next = node->next->next;
  }
};",237
237,"class Solution {
 public:
  vector<int> productExceptSelf(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);        // Can also use `nums` as the ans array.
    vector<int> prefix(n, 1);  // prefix product
    vector<int> suffix(n, 1);  // suffix product

    for (int i = 1; i < n; ++i)
      prefix[i] = prefix[i - 1] * nums[i - 1];

    for (int i = n - 2; i >= 0; --i)
      suffix[i] = suffix[i + 1] * nums[i + 1];

    for (int i = 0; i < n; ++i)
      ans[i] = prefix[i] * suffix[i];

    return ans;
  }
};",238
238,"class Solution {
 public:
  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> ans;
    deque<int> maxQ;

    for (int i = 0; i < nums.size(); ++i) {
      while (!maxQ.empty() && maxQ.back() < nums[i])
        maxQ.pop_back();
      maxQ.push_back(nums[i]);
      if (i >= k && nums[i - k] == maxQ.front())  // out-of-bounds
        maxQ.pop_front();
      if (i >= k - 1)
        ans.push_back(maxQ.front());
    }

    return ans;
  }
};",239
239,"class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int r = 0;
    int c = matrix[0].size() - 1;

    while (r < matrix.size() && c >= 0) {
      if (matrix[r][c] == target)
        return true;
      if (matrix[r][c] > target)
        --c;
      else
        ++r;
    }

    return false;
  }
};",240
240,"class Solution {
 public:
  vector<int> diffWaysToCompute(string expression) {
    return ways(expression, {});
  }

 private:
  vector<int> ways(const string& s, unordered_map<string, vector<int>>&& mem) {
    if (const auto it = mem.find(s); it != mem.cend())
      return it->second;

    vector<int> ans;

    for (int i = 0; i < s.length(); ++i)
      if (ispunct(s[i]))
        for (const int a : ways(s.substr(0, i), move(mem)))
          for (const int b : ways(s.substr(i + 1), move(mem)))
            if (s[i] == '+')
              ans.push_back(a + b);
            else if (s[i] == '-')
              ans.push_back(a - b);
            else
              ans.push_back(a * b);

    return mem[s] = (ans.empty() ? vector<int>{stoi(s)} : ans);
  }
};",241
241,"class Solution {
 public:
  bool isAnagram(string s, string t) {
    if (s.length() != t.length())
      return false;

    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (const char c : t) {
      if (count[c - 'a'] == 0)
        return false;
      --count[c - 'a'];
    }

    return true;
  }
};",242
242,"class Solution {
 public:
  int shortestDistance(vector<string>& wordsDict, string word1, string word2) {
    int ans = wordsDict.size();
    int index1 = -1;  // wordsDict[index1] == word1
    int index2 = -1;  // wordsDict[index2] == word2

    for (int i = 0; i < wordsDict.size(); ++i) {
      if (wordsDict[i] == word1) {
        index1 = i;
        if (index2 != -1)
          ans = min(ans, index1 - index2);
      }
      if (wordsDict[i] == word2) {
        index2 = i;
        if (index1 != -1)
          ans = min(ans, index2 - index1);
      }
    }

    return ans;
  }
};",243
243,"shortest(word1: str, word2: str)",244
244,"class Solution {
 public:
  int shortestWordDistance(vector<string>& words, string word1, string word2) {
    const bool isSame = word1 == word2;
    int ans = INT_MAX;
    // If word1 == word2, index1 is the newest index.
    int index1 = words.size();
    // If word1 == word2, index2 is the previous index.
    int index2 = -words.size();

    for (int i = 0; i < words.size(); ++i) {
      if (words[i] == word1) {
        if (isSame)
          index2 = index1;
        index1 = i;
      } else if (words[i] == word2) {
        index2 = i;
      }
      ans = min(ans, abs(index1 - index2));
    }

    return ans;
  }
};",245
245,"class Solution {
 public:
  bool isStrobogrammatic(string num) {
    const vector<char> rotated{'0', '1', 'x', 'x', 'x',
                               'x', '9', 'x', '8', '6'};
    int l = 0;
    int r = num.length() - 1;

    while (l <= r)
      if (num[l++] != rotated[num[r--] - '0'])
        return false;

    return true;
  }
};",246
246,"class Solution {
 public:
  vector<string> findStrobogrammatic(int n) {
    return helper(n, n);
  }

 private:
  vector<string> helper(int n, int k) {
    if (n == 0)
      return {""""};
    if (n == 1)
      return {""0"", ""1"", ""8""};

    vector<string> ans;

    for (const string& inner : helper(n - 2, k)) {
      if (n < k)
        ans.push_back(""0"" + inner + ""0"");
      ans.push_back(""1"" + inner + ""1"");
      ans.push_back(""6"" + inner + ""9"");
      ans.push_back(""8"" + inner + ""8"");
      ans.push_back(""9"" + inner + ""6"");
    }

    return ans;
  }
};",247
247,"class Solution {
 public:
  int strobogrammaticInRange(string low, string high) {
    int ans = 0;

    for (int n = low.length(); n <= high.length(); ++n) {
      string s(n, ' ');
      dfs(low, high, s, 0, n - 1, ans);
    }

    return ans;
  }

 private:
  const vector<pair<char, char>> pairs{
      {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};

  void dfs(const string& low, const string& high, string& s, int l, int r,
           int& ans) {
    if (l > r) {
      if (s.length() == low.length() && s < low)
        return;
      if (s.length() == high.length() && s > high)
        return;
      ++ans;
      return;
    }

    for (const auto& [leftDigit, rightDigit] : pairs) {
      if (l == r && leftDigit != rightDigit)
        continue;
      s[l] = leftDigit;
      s[r] = rightDigit;
      if (s.length() > 1 && s[0] == '0')
        continue;
      dfs(low, high, s, l + 1, r - 1, ans);
    }
  }
};",248
248,"class Solution {
 public:
  vector<vector<string>> groupStrings(vector<string>& strings) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> keyToStrings;

    for (const string& s : strings)
      keyToStrings[getKey(s)].push_back(s);

    for (const auto& [_, strings] : keyToStrings)
      ans.push_back(strings);

    return ans;
  }

 private:
  // Returns the key of 's' by pairwise calculation of differences.
  // e.g. getKey(""abc"") -> ""1,1"" because diff(a, b) = 1 and diff(b, c) = 1.
  string getKey(const string& s) {
    string key;

    for (int i = 1; i < s.length(); ++i) {
      const int diff = (s[i] - s[i - 1] + 26) % 26;
      key += to_string(diff) + "","";
    }

    return key;
  }
};",249
249,"class Solution {
 public:
  int countUnivalSubtrees(TreeNode* root) {
    int ans = 0;
    isUnival(root, INT_MAX, ans);
    return ans;
  }

 private:
  bool isUnival(TreeNode* root, int val, int& ans) {
    if (root == nullptr)
      return true;

    if (isUnival(root->left, root->val, ans) &
        isUnival(root->right, root->val, ans)) {
      ++ans;
      return root->val == val;
    }

    return false;
  }
};",250
250,"class Vector2D {
 public:
  Vector2D(vector<vector<int>>& vec) {
    for (const vector<int>& A : vec)
      for (const int a : A)
        this->vec.push_back(a);
  }

  int next() {
    return vec[i++];
  }

  bool hasNext() {
    return i < vec.size();
  }

 private:
  vector<int> vec;
  int i = 0;
};",251
251,"class Solution {
 public:
  bool canAttendMeetings(vector<vector<int>>& intervals) {
    ranges::sort(intervals);

    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i - 1][1] > intervals[i][0])
        return false;

    return true;
  }
};",252
252,"class Solution {
 public:
  int minMeetingRooms(vector<vector<int>>& intervals) {
    ranges::sort(intervals);

    // Store the end times of each room.
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const vector<int>& interval : intervals) {
      // There's no overlap, so we can reuse the same room.
      if (!minHeap.empty() && interval[0] >= minHeap.top())
        minHeap.pop();
      minHeap.push(interval[1]);
    }

    return minHeap.size();
  }
};",253
253,"class Solution {
 public:
  vector<vector<int>> getFactors(int n) {
    vector<vector<int>> ans;
    dfs(n, 2, {}, ans);  // The minimum factor is 2.
    return ans;
  }

 private:
  void dfs(int n, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (n <= 1) {
      if (path.size() > 1)
        ans.push_back(path);
      return;
    }

    for (int i = s; i <= n; ++i)
      if (n % i == 0) {
        path.push_back(i);
        dfs(n / i, i, move(path), ans);
        path.pop_back();
      }
  }
};",254
254,"class Solution {
 public:
  bool verifyPreorder(vector<int>& preorder) {
    int i = 0;
    dfs(preorder, i, INT_MIN, INT_MAX);
    return i == preorder.size();
  }

 private:
  void dfs(const vector<int>& preorder, int& i, int min, int max) {
    if (i == preorder.size())
      return;
    if (preorder[i] < min || preorder[i] > max)
      return;

    const int val = preorder[i++];
    dfs(preorder, i, min, val);
    dfs(preorder, i, val, max);
  }
};",255
255,"class Solution {
 public:
  int minCost(vector<vector<int>>& costs) {
    for (int i = 1; i < costs.size(); ++i) {
      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);
      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);
      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);
    }

    return ranges::min(costs.back());
  }
};",256
256,"class Solution {
 public:
  vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> ans;
    dfs(root, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, vector<string>&& path, vector<string>& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      ans.push_back(join(path) + to_string(root->val));
      return;
    }

    path.push_back(to_string(root->val) + ""->"");
    dfs(root->left, move(path), ans);
    dfs(root->right, move(path), ans);
    path.pop_back();
  }

  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  }
};",257
257,"class Solution {
 public:
  int addDigits(int num) {
    return 1 + (num - 1) % 9;
  }
};",258
258,"class Solution {
 public:
  int threeSumSmaller(vector<int>& nums, int target) {
    if (nums.size() < 3)
      return 0;

    int ans = 0;

    ranges::sort(nums);

    for (int i = 0; i + 2 < nums.size(); ++i) {
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r)
        if (nums[i] + nums[l] + nums[r] < target) {
          // (nums[i], nums[l], nums[r])
          // (nums[i], nums[l], nums[r - 1])
          // ...,
          // (nums[i], nums[l], nums[l + 1])
          ans += r - l;
          ++l;
        } else {
          --r;
        }
    }

    return ans;
  }
};",259
259,"class Solution {
 public:
  vector<int> singleNumber(vector<int>& nums) {
    const int xors = accumulate(nums.begin(), nums.end(), 0, bit_xor<>());
    const int lowbit = xors & -xors;
    vector<int> ans(2);

    // Seperate `nums` into two groups by `lowbit`.
    for (const int num : nums)
      if (num & lowbit)
        ans[0] ^= num;
      else
        ans[1] ^= num;

    return ans;
  }
};",260
260,"class Solution {
 public:
  bool validTree(int n, vector<vector<int>>& edges) {
    if (n == 0 || edges.size() != n - 1)
      return false;

    vector<vector<int>> graph(n);
    queue<int> q{{0}};
    unordered_set<int> seen{{0}};

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u])
        if (!seen.count(v)) {
          q.push(v);
          seen.insert(v);
        }
    }

    return seen.size() == n;
  }
};",261
261,"SELECT
  Trips.request_at AS Day,
  ROUND(SUM(Trips.status != 'completed') / COUNT(*), 2) AS 'Cancellation Rate'
FROM Trips
INNER JOIN Users AS Clients
  ON (Trips.client_id = Clients.users_id)
INNER JOIN Users AS Drivers
  ON (Trips.driver_id = Drivers.users_id)
WHERE Clients.banned = 'No'
  AND Drivers.banned = 'No'
  AND Trips.request_at BETWEEN '2013-10-01' AND '2013-10-03'
GROUP BY 1;",262
262,"class Solution {
 public:
  bool isUgly(int n) {
    if (n == 0)
      return false;

    for (const int prime : {2, 3, 5})
      while (n % prime == 0)
        n /= prime;

    return n == 1;
  }
};",263
263,"class Solution {
 public:
  int nthUglyNumber(int n) {
    vector<int> uglyNums{1};
    int i2 = 0;
    int i3 = 0;
    int i5 = 0;

    while (uglyNums.size() < n) {
      const int next2 = uglyNums[i2] * 2;
      const int next3 = uglyNums[i3] * 3;
      const int next5 = uglyNums[i5] * 5;
      const int next = min({next2, next3, next5});
      if (next == next2)
        ++i2;
      if (next == next3)
        ++i3;
      if (next == next5)
        ++i5;
      uglyNums.push_back(next);
    }

    return uglyNums.back();
  }
};",264
264,"class Solution {
 public:
  int minCostII(vector<vector<int>>& costs) {
    int prevIndex = -1;  // the previous minimum index
    int prevMin1 = 0;    // the minimum cost so far
    int prevMin2 = 0;    // the second minimum cost so far

    for (const vector<int>& cost : costs) {  // O(n)
      // the painted index that will achieve the minimum cost after painting the
      // current house
      int index = -1;
      // the minimum cost after painting the current house
      int min1 = INT_MAX;
      // the second minimum cost after painting the current house
      int min2 = INT_MAX;
      for (int i = 0; i < cost.size(); ++i) {  // O(k)
        const int theCost = cost[i] + (i == prevIndex ? prevMin2 : prevMin1);
        if (theCost < min1) {
          index = i;
          min2 = min1;
          min1 = theCost;
        } else if (theCost < min2) {  // min1 <= theCost < min2
          min2 = theCost;
        }
      }
      prevIndex = index;
      prevMin1 = min1;
      prevMin2 = min2;
    }

    return prevMin1;
  }
};",265
265,"class Solution {
 public:
  bool canPermutePalindrome(string s) {
    unordered_set<char> seen;

    for (const char c : s)
      if (!seen.insert(c).second)
        seen.erase(c);

    return seen.size() <= 1;
  }
};",266
266,"class Solution {
 public:
  vector<string> generatePalindromes(string s) {
    int odd = 0;
    unordered_map<char, int> count;

    for (const char c : s)
      ++count[c];

    // Count odd ones.
    for (const auto& [_, value] : count)
      if (value & 1)
        ++odd;

    // Can't form any palindrome.
    if (odd > 1)
      return {};

    vector<string> ans;
    vector<char> candidates;
    string mid;

    // Get the mid and the candidates characters.
    for (const auto& [key, value] : count) {
      if (value & 1)
        mid += key;
      for (int i = 0; i < value / 2; ++i)
        candidates.push_back(key);
    }

    // Backtrack to generate the ans strings.
    dfs(candidates, mid, vector<bool>(candidates.size()), """", ans);
    return ans;
  }

 private:
  // Generates all the unique palindromes from the candidates.
  void dfs(const vector<char>& candidates, const string& mid,
           vector<bool>&& used, string&& path, vector<string>& ans) {
    if (path.length() == candidates.size()) {
      string secondHalf = path;
      reverse(secondHalf.begin(), secondHalf.end());
      ans.push_back(path + mid + secondHalf);
      return;
    }

    for (int i = 0; i < candidates.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(candidates[i]);
      dfs(candidates, mid, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};",267
267,"class Solution {
 public:
  int missingNumber(vector<int>& nums) {
    int ans = nums.size();

    for (int i = 0; i < nums.size(); ++i)
      ans ^= i ^ nums[i];

    return ans;
  }
};",268
268,"class Solution {
 public:
  string alienOrder(vector<string>& words) {
    unordered_map<char, unordered_set<char>> graph;
    vector<int> inDegrees(26);
    buildGraph(graph, words, inDegrees);
    return topology(graph, inDegrees);
  }

 private:
  void buildGraph(unordered_map<char, unordered_set<char>>& graph,
                  const vector<string>& words, vector<int>& inDegrees) {
    // Create a node for each character in each word.
    for (const string& word : words)
      for (const char c : word)
        if (!graph.count(c))
          graph[c] = unordered_set<char>();

    for (int i = 1; i < words.size(); ++i) {
      const string& first = words[i - 1];
      const string& second = words[i];
      const int length = min(first.length(), second.length());
      for (int j = 0; j < length; ++j) {
        const char u = first[j];
        const char v = second[j];
        if (u != v) {
          if (!graph[u].count(v)) {
            graph[u].insert(v);
            ++inDegrees[v - 'a'];
          }
          break;  // The order of characters after this are meaningless.
        }
        // e.g. first = ""ab"", second = ""a"" -> invalid
        if (j == length - 1 && first.length() > second.length()) {
          graph.clear();
          return;
        }
      }
    }
  }

  string topology(unordered_map<char, unordered_set<char>>& graph,
                  vector<int>& inDegrees) {
    string s;
    queue<char> q;

    for (const auto& [c, _] : graph)
      if (inDegrees[c - 'a'] == 0)
        q.push(c);

    while (!q.empty()) {
      const char u = q.front();
      q.pop();
      s += u;
      for (const char v : graph[u])
        if (--inDegrees[v - 'a'] == 0)
          q.push(v);
    }

    // e.g. words = [""z"", ""x"", ""y"", ""x""]
    return s.length() == graph.size() ? s : """";
  }
};",269
269,"class Solution {
 public:
  int closestValue(TreeNode* root, double target) {
    // If target < root->val, search the left subtree.
    if (target < root->val && root->left) {
      const int left = closestValue(root->left, target);
      if (abs(left - target) < abs(root->val - target))
        return left;
    }

    // If target > root->val, search the right subtree.
    if (target > root->val && root->right) {
      const int right = closestValue(root->right, target);
      if (abs(right - target) < abs(root->val - target))
        return right;
    }

    return root->val;
  }
};",270
270,"class Codec {
 public:
  // Encodes a list of strings to a single string.
  string encode(vector<string>& strs) {
    string encoded;

    for (const string& s : strs)
      encoded += to_string(s.length()) + '/' + s;

    return encoded;
  }

  // Decodes a single string to a list of strings.
  vector<string> decode(string s) {
    vector<string> decoded;

    for (int i = 0; i < s.length();) {
      const int slash = s.find('/', i);
      const int length = stoi(s.substr(i, slash - i));
      i = slash + length + 1;
      decoded.push_back(s.substr(slash + 1, i - slash - 1));
    }

    return decoded;
  }
};",271
271,"class Solution {
 public:
  vector<int> closestKValues(TreeNode* root, double target, int k) {
    deque<int> dq;

    inorder(root, dq);

    while (dq.size() > k)
      if (abs(dq.front() - target) > abs(dq.back() - target))
        dq.pop_front();
      else
        dq.pop_back();

    return {dq.begin(), dq.end()};
  }

 private:
  void inorder(TreeNode* root, deque<int>& dq) {
    if (root == nullptr)
      return;

    inorder(root->left, dq);
    dq.push_back(root->val);
    inorder(root->right, dq);
  }
};",272
272,"class Solution {
 public:
  string numberToWords(int num) {
    if (num == 0)
      return ""Zero"";
    return helper(num);
  }

 private:
  const vector<string> belowTwenty{
      """",        ""One"",     ""Two"",       ""Three"",    ""Four"",
      ""Five"",    ""Six"",     ""Seven"",     ""Eight"",    ""Nine"",
      ""Ten"",     ""Eleven"",  ""Twelve"",    ""Thirteen"", ""Fourteen"",
      ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""};
  const vector<string> tens{"""",      """",      ""Twenty"",  ""Thirty"", ""Forty"",
                            ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""};

  string helper(int num) {
    string s;

    if (num < 20)
      s = belowTwenty.at(num);
    else if (num < 100)
      s = tens.at(num / 10) + "" "" + belowTwenty.at(num % 10);
    else if (num < 1000)
      s = helper(num / 100) + "" Hundred "" + helper(num % 100);
    else if (num < 1000000)
      s = helper(num / 1000) + "" Thousand "" + helper(num % 1000);
    else if (num < 1000000000)
      s = helper(num / 1000000) + "" Million "" + helper(num % 1000000);
    else
      s = helper(num / 1000000000) + "" Billion "" + helper(num % 1000000000);

    trim(s);
    return s;
  }

  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};",273
273,"class Solution {
 public:
  int hIndex(vector<int>& citations) {
    const int n = citations.size();
    int accumulate = 0;
    vector<int> count(n + 1);

    for (const int citation : citations)
      ++count[min(citation, n)];

    // To find the maximum h-index, loop from the back to the front.
    // i := the candidate's h-index
    for (int i = n; i >= 0; --i) {
      accumulate += count[i];
      if (accumulate >= i)
        return i;
    }

    throw;
  }
};",274
274,"class Solution {
 public:
  int hIndex(vector<int>& citations) {
    const int n = citations.size();
    int l = 0;
    int r = n;

    while (l < r) {
      const int m = (l + r) / 2;
      if (citations[m] >= n - m)
        r = m;
      else
        l = m + 1;
    }

    return n - l;
  }
};",275
275,"class Solution {
 public:
  int numWays(int n, int k) {
    if (n == 0)
      return 0;
    if (n == 1)
      return k;
    if (n == 2)
      return k * k;

    // dp[i] := the number of ways to paint n posts with k colors
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = k;
    dp[2] = k * k;

    for (int i = 3; i <= n; ++i)
      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1);

    return dp[n];
  }
};",276
276,"class Solution {
 public:
  int findCelebrity(int n) {
    int candidate = 0;

    // Everyone knows the celebrity.
    for (int i = 1; i < n; ++i)
      if (knows(candidate, i))
        candidate = i;

    // The candidate knows nobody and everyone knows the celebrity.
    for (int i = 0; i < n; ++i) {
      if (i < candidate && knows(candidate, i) || !knows(i, candidate))
        return -1;
      if (i > candidate && !knows(i, candidate))
        return -1;
    }

    return candidate;
  }
};",277
277,"bool isBadVersion(int version);

class Solution {
 public:
  int firstBadVersion(int n) {
    int l = 1;
    int r = n;

    while (l < r) {
      const int m = l + (r - l) / 2;
      if (isBadVersion(m))
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",278
278,"class Solution {
 public:
  int numSquares(int n) {
    vector<int> dp(n + 1, n);  // 1^2 x n
    dp[0] = 0;                 // no way
    dp[1] = 1;                 // 1^2

    for (int i = 2; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        dp[i] = min(dp[i], dp[i - j * j] + 1);

    return dp[n];
  }
};",279
279,"class Solution {
 public:
  void wiggleSort(vector<int>& nums) {
    // 1. If i is even, then nums[i] <= nums[i - 1].
    // 2. If i is odd, then nums[i] >= nums[i - 1].
    for (int i = 1; i < nums.size(); ++i)
      if ((!(i & 1) && nums[i] > nums[i - 1]) ||
          ((i & 1) && nums[i] < nums[i - 1]))
        swap(nums[i], nums[i - 1]);
  }
};",280
280,next(),281
281,"class Solution {
 public:
  vector<string> addOperators(string num, int target) {
    vector<string> ans;
    dfs(num, target, 0, 0, 0, {}, ans);
    return ans;
  }

 private:
  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  }

  void dfs(const string& num, int target, int start, long prev, long eval,
           vector<string>&& path, vector<string>& ans) {
    if (start == num.length()) {
      if (eval == target)
        ans.push_back(join(path));
      return;
    }

    for (int i = start; i < num.length(); ++i) {
      if (i > start && num[start] == '0')
        return;
      const string& s = num.substr(start, i - start + 1);
      const long curr = stol(s);
      if (start == 0) {
        path.push_back(s);
        dfs(num, target, i + 1, curr, curr, move(path), ans);
        path.pop_back();
      } else {
        for (const string& op : {""+"", ""-"", ""*""}) {
          path.push_back(op + s);
          if (op == ""+"")
            dfs(num, target, i + 1, curr, eval + curr, move(path), ans);
          else if (op == ""-"")
            dfs(num, target, i + 1, -curr, eval - curr, move(path), ans);
          else
            dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr,
                move(path), ans);
          path.pop_back();
        }
      }
    }
  }
};",282
282,"class Solution {
 public:
  void moveZeroes(vector<int>& nums) {
    int i = 0;
    for (const int num : nums)
      if (num != 0)
        nums[i++] = num;

    while (i < nums.size())
      nums[i++] = 0;
  }
};",283
283,"class PeekingIterator : public Iterator {
 public:
  PeekingIterator(const vector<int>& nums) : Iterator(nums) {}

  // Returns the next element in the iteration without advancing the iterator.
  int peek() {
    // Iterator(*this) makes a copy of current iterator, then call next on the
    // Copied iterator to get the next value without affecting current iterator
    return Iterator(*this).next();
  }

  // hasNext() and next() should behave the same as in the Iterator interface.
  // Override them if needed.
  int next() {
    return Iterator::next();
  }

  bool hasNext() const {
    return Iterator::hasNext();
  }
};",284
284,"class Solution {
 public:
  TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    if (root == nullptr)
      return nullptr;
    if (root->val <= p->val)
      return inorderSuccessor(root->right, p);

    TreeNode* left = inorderSuccessor(root->left, p);
    return left ? left : root;
  }
};",285
285,"class Solution {
 public:
  void wallsAndGates(vector<vector<int>>& rooms) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = rooms.size();
    const int n = rooms[0].size();
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (rooms[i][j] == 0)
          q.emplace(i, j);

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (rooms[x][y] != INT_MAX)
          continue;
        rooms[x][y] = rooms[i][j] + 1;
        q.emplace(x, y);
      }
    }
  }
};",286
286,"class Solution {
 public:
  int findDuplicate(vector<int>& nums) {
    int slow = nums[nums[0]];
    int fast = nums[nums[nums[0]]];

    while (slow != fast) {
      slow = nums[slow];
      fast = nums[nums[fast]];
    }

    slow = nums[0];

    while (slow != fast) {
      slow = nums[slow];
      fast = nums[fast];
    }

    return slow;
  }
};",287
287,isUnique(word: str),288
288,"class Solution {
 public:
  void gameOfLife(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int ones = 0;
        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)
          for (int y = max(0, j - 1); y < min(n, j + 2); ++y)
            ones += board[x][y] & 1;
        // Any live cell with two or three live neighbors lives on to the next
        // generation.
        if (board[i][j] == 1 && (ones == 3 || ones == 4))
          board[i][j] |= 0b10;
        // Any dead cell with exactly three live neighbors becomes a live cell,
        // as if by reproduction.
        if (board[i][j] == 0 && ones == 3)
          board[i][j] |= 0b10;
      }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        board[i][j] >>= 1;
  }
};",289
289,"class Solution {
 public:
  bool wordPattern(string pattern, string str) {
    const int n = pattern.length();
    istringstream iss(str);
    vector<int> charToIndex(128);
    unordered_map<string, int> stringToIndex;

    int i = 0;
    for (string word; iss >> word; ++i) {
      if (i == n)  // out-of-bounds
        return false;
      if (charToIndex[pattern[i]] != stringToIndex[word])
        return false;
      charToIndex[pattern[i]] = i + 1;
      stringToIndex[word] = i + 1;
    }

    return i == n;
  }
};",290
290,"class Solution {
 public:
  bool wordPatternMatch(string pattern, string s) {
    return isMatch(pattern, 0, s, 0, unordered_map<char, string>(),
                   unordered_set<string>());
  }

 private:
  bool isMatch(const string& pattern, int i, const string& s, int j,
               unordered_map<char, string>&& charToString,
               unordered_set<string>&& seen) {
    if (i == pattern.length() && j == s.length())
      return true;
    if (i == pattern.length() || j == s.length())
      return false;

    const char c = pattern[i];

    if (const auto it = charToString.find(c); it != charToString.cend()) {
      const string& t = it->second;
      // See if we can match t with s[j..n).
      if (s.substr(j).find(t) == string::npos)
        return false;

      // If there's a match, continue to match the rest.
      return isMatch(pattern, i + 1, s, j + t.length(), move(charToString),
                     move(seen));
    }

    for (int k = j; k < s.length(); ++k) {
      const string& t = s.substr(j, k - j + 1);

      // This string is mapped by another character.
      if (seen.count(t))
        continue;

      charToString[c] = t;
      seen.insert(t);

      if (isMatch(pattern, i + 1, s, k + 1, move(charToString), move(seen)))
        return true;

      // Backtrack.
      charToString.erase(c);
      seen.erase(t);
    }

    return false;
  }
};",291
291,"class Solution {
 public:
  bool canWinNim(int n) {
    return n % 4 != 0;
  }
};",292
292,"class Solution {
 public:
  vector<string> generatePossibleNextMoves(string currentState) {
    vector<string> ans;

    for (int i = 0; i + 1 < currentState.length(); ++i)
      if (currentState[i] == '+' && currentState[i + 1] == '+')
        ans.push_back(currentState.substr(0, i) + ""--"" +
                      currentState.substr(i + 2));

    return ans;
  }
};",293
293,"class Solution {
 public:
  bool canWin(string currentState) {
    const auto it = mem.find(currentState);
    if (it == mem.cend())
      return it->second;

    // If any of currentState[i:i + 2] == ""++"" and your friend can't win after
    // changing currentState[i:i + 2] to ""--"" (or ""-""), then you can win.
    for (int i = 0; i + 1 < currentState.length(); ++i)
      if (currentState[i] == '+' && currentState[i + 1] == '+' &&
          !canWin(currentState.substr(0, i) + '-' + currentState.substr(i + 2)))
        return mem[currentState] = true;

    return mem[currentState] = false;
  }

 private:
  unordered_map<string, bool> mem;
};",294
294,"class MedianFinder {
 public:
  void addNum(int num) {
    if (maxHeap.empty() || num <= maxHeap.top())
      maxHeap.push(num);
    else
      minHeap.push(num);

    // Balance the two heaps s.t.
    // |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1.
    if (maxHeap.size() < minHeap.size())
      maxHeap.push(minHeap.top()), minHeap.pop();
    else if (maxHeap.size() - minHeap.size() > 1)
      minHeap.push(maxHeap.top()), maxHeap.pop();
  }

  double findMedian() {
    if (maxHeap.size() == minHeap.size())
      return (maxHeap.top() + minHeap.top()) / 2.0;
    return maxHeap.top();
  }

 private:
  priority_queue<int> maxHeap;
  priority_queue<int, vector<int>, greater<>> minHeap;
};",295
295,"class Solution {
 public:
  int minTotalDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> I;  // i indices s.t. grid[i][j] == 1
    vector<int> J;  // j indices s.t. grid[i][j] == 1

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j])
          I.push_back(i);

    for (int j = 0; j < n; ++j)
      for (int i = 0; i < m; ++i)
        if (grid[i][j])
          J.push_back(j);

    // sum(i - median(I)) + sum(j - median(J))
    return minTotalDistance(I) + minTotalDistance(J);
  }

 private:
  int minTotalDistance(const vector<int>& grid) {
    int sum = 0;
    int i = 0;
    int j = grid.size() - 1;
    while (i < j)
      sum += grid[j--] - grid[i++];
    return sum;
  }
};",296
296,"class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(TreeNode* root) {
    if (root == nullptr)
      return """";

    string s;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      TreeNode* node = q.front();
      q.pop();
      if (node != nullptr) {
        s += to_string(node->val) + "" "";
        q.push(node->left);
        q.push(node->right);
      } else {
        s += ""n "";
      }
    }

    return s;
  }

  // Decodes your encoded data to tree.
  TreeNode* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    string word;
    iss >> word;
    TreeNode* root = new TreeNode(stoi(word));
    queue<TreeNode*> q{{root}};

    while (iss >> word) {
      TreeNode* node = q.front();
      q.pop();
      if (word != ""n"") {
        node->left = new TreeNode(stoi(word));
        q.push(node->left);
      }
      iss >> word;
      if (word != ""n"") {
        node->right = new TreeNode(stoi(word));
        q.push(node->right);
      }
    }

    return root;
  }
};",297
297,"class Solution {
 public:
  int longestConsecutive(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return dfs(root, root->val, 0, 0);
  }

 private:
  int dfs(TreeNode* root, int target, int length, int maxLength) {
    if (root == nullptr)
      return maxLength;
    if (root->val == target)
      maxLength = max(maxLength, ++length);
    else
      length = 1;
    return max(dfs(root->left, root->val + 1, length, maxLength),
               dfs(root->right, root->val + 1, length, maxLength));
  }
};",298
298,"class Solution {
 public:
  string getHint(string secret, string guess) {
    int A = 0;
    int B = 0;
    vector<int> count1(10);
    vector<int> count2(10);

    for (int i = 0; i < secret.length(); ++i)
      if (secret[i] == guess[i])
        ++A;
      else {
        ++count1[secret[i] - '0'];
        ++count2[guess[i] - '0'];
      }

    for (int i = 0; i < 10; ++i)
      B += min(count1[i], count2[i]);

    return to_string(A) + ""A"" + to_string(B) + ""B"";
  }
};",299
299,"class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
    if (nums.empty())
      return 0;

    // dp[i] := the length of LIS ending in nums[i]
    vector<int> dp(nums.size(), 1);

    for (int i = 1; i < nums.size(); ++i)
      for (int j = 0; j < i; ++j)
        if (nums[j] < nums[i])
          dp[i] = max(dp[i], dp[j] + 1);

    return ranges::max(dp);
  }
};",300
300,"class Solution {
 public:
  vector<string> removeInvalidParentheses(string s) {
    vector<string> ans;
    const auto [l, r] = getLeftAndRightCounts(s);
    dfs(s, 0, l, r, ans);
    return ans;
  }

 private:
  // Similar to 921. Minimum Add to Make Parentheses Valid
  // Returns how many '(' and ')' need to be deleted.
  pair<int, int> getLeftAndRightCounts(const string& s) {
    int l = 0;
    int r = 0;

    for (const char c : s)
      if (c == '(')
        ++l;
      else if (c == ')') {
        if (l == 0)
          ++r;
        else
          --l;
      }

    return {l, r};
  }

  void dfs(const string& s, int start, int l, int r, vector<string>& ans) {
    if (l == 0 && r == 0 && isValid(s)) {
      ans.push_back(s);
      return;
    }

    for (int i = start; i < s.length(); ++i) {
      if (i > start && s[i] == s[i - 1])
        continue;
      if (l > 0 && s[i] == '(')  // Delete s[i].
        dfs(s.substr(0, i) + s.substr(i + 1), i, l - 1, r, ans);
      if (r > 0 && s[i] == ')')  // Delete s[i].
        dfs(s.substr(0, i) + s.substr(i + 1), i, l, r - 1, ans);
    }
  }

  bool isValid(const string& s) {
    int opened = 0;  // the number of '(' - # of ')'
    for (const char c : s) {
      if (c == '(')
        ++opened;
      else if (c == ')')
        --opened;
      if (opened < 0)
        return false;
    }
    return true;  // opened == 0
  }
};",301
301,"class Solution {
 public:
  int minArea(vector<vector<char>>& image, int x, int y) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = image.size();
    const int n = image[0].size();
    vector<int> topLeft{x, y};
    vector<int> bottomRight{x, y};
    queue<pair<int, int>> q{{{x, y}}};
    image[x][y] = '2';  // Mark as visited.

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        const int r = i + dx;
        const int c = j + dy;
        if (r < 0 || r == m || c < 0 || c == n)
          continue;
        if (image[r][c] != '1')
          continue;
        topLeft[0] = min(topLeft[0], r);
        topLeft[1] = min(topLeft[1], c);
        bottomRight[0] = max(bottomRight[0], r);
        bottomRight[1] = max(bottomRight[1], c);
        q.emplace(r, c);
        image[r][c] = '2';
      }
    }

    const int width = bottomRight[1] - topLeft[1] + 1;
    const int height = bottomRight[0] - topLeft[0] + 1;
    return width * height;
  }
};",302
302,"class NumArray {
 public:
  NumArray(vector<int>& nums) : prefix(nums.size() + 1) {
    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);
  }

  int sumRange(int left, int right) {
    return prefix[right + 1] - prefix[left];
  }

 private:
  vector<int> prefix;
};",303
303,"class NumMatrix {
 public:
  NumMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty())
      return;

    const int m = matrix.size();
    const int n = matrix[0].size();
    // prefix[i][j] := the sum of matrix[0..i)[0..j)
    prefix.resize(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];
  }

  int sumRegion(int row1, int col1, int row2, int col2) {
    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] -
           prefix[row2 + 1][col1] + prefix[row1][col1];
  }

 private:
  vector<vector<int>> prefix;
};",304
304,"class UnionFind {
 public:
  vector<int> id;

  UnionFind(int n) : id(n, -1), rank(n) {}

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> rank;
};

class Solution {
 public:
  vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    vector<int> ans;
    vector<vector<bool>> seen(m, vector<bool>(n));
    UnionFind uf(m * n);
    int count = 0;

    for (const vector<int>& p : positions) {
      const int i = p[0];
      const int j = p[1];
      if (seen[i][j]) {
        ans.push_back(count);
        continue;
      }
      seen[i][j] = true;
      const int id = getId(i, j, n);
      uf.id[id] = id;
      ++count;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        const int neighborId = getId(x, y, n);
        if (uf.id[neighborId] == -1)  // water
          continue;
        const int currentRoot = uf.find(id);
        const int neighborRoot = uf.find(neighborId);
        if (currentRoot != neighborRoot) {
          uf.unionByRank(currentRoot, neighborRoot);
          --count;
        }
      }
      ans.push_back(count);
    }

    return ans;
  }

 private:
  int getId(int i, int j, int n) {
    return i * n + j;
  }
};",305
305,"class Solution {
 public:
  bool isAdditiveNumber(string num) {
    const int n = num.length();

    // num[0..i] = firstNum
    for (int i = 0; i < n / 2; ++i) {
      if (i > 0 && num[0] == '0')
        return false;
      const long firstNum = stol(num.substr(0, i + 1));
      // num[i + 1..j] = secondNum
      // |thirdNum| >= max(|firstNum|, |secondNum|)
      for (int j = i + 1; max(i, j - i) < n - j; ++j) {
        if (j > i + 1 && num[i + 1] == '0')
          break;
        const long secondNum = stol(num.substr(i + 1, j - i));
        if (dfs(num, firstNum, secondNum, j + 1))
          return true;
      }
    }

    return false;
  }

 private:
  bool dfs(const string& num, long firstNum, long secondNum, long s) {
    if (s == num.length())
      return true;

    const long thirdNum = firstNum + secondNum;
    const string& thirdNumStr = to_string(thirdNum);
    return num.find(thirdNumStr, s) == s &&
           dfs(num, secondNum, thirdNum, s + thirdNumStr.length());
  }
};",306
306,"update(index: int, val: int)",307
307,"class FenwickTree {
 public:
  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}

  void update(int row, int col, int delta) {
    for (int i = row; i < sums.size(); i += lowbit(i))
      for (int j = col; j < sums[0].size(); j += lowbit(j))
        sums[i][j] += delta;
  }

  int get(int row, int col) {
    int sum = 0;
    for (int i = row; i > 0; i -= lowbit(i))
      for (int j = col; j > 0; j -= lowbit(j))
        sum += sums[i][j];
    return sum;
  }

 private:
  vector<vector<int>> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class NumMatrix {
 public:
  NumMatrix(vector<vector<int>>& matrix)
      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = 0; j < matrix[0].size(); ++j)
        tree.update(i + 1, j + 1, matrix[i][j]);
  }

  void update(int row, int col, int val) {
    tree.update(row + 1, col + 1, val - matrix[row][col]);
    matrix[row][col] = val;
  }

  int sumRegion(int row1, int col1, int row2, int col2) {
    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -
           tree.get(row2 + 1, col1) + tree.get(row1, col1);
  }

 private:
  vector<vector<int>> matrix;
  FenwickTree tree;
};",308
308,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sell = 0;
    int hold = INT_MIN;
    int prev = 0;

    for (const int price : prices) {
      const int cache = sell;
      sell = max(sell, hold + price);
      hold = max(hold, prev - price);
      prev = cache;
    }

    return sell;
  }
};",309
309,"class Solution {
 public:
  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
    if (n == 1 || edges.empty())
      return {0};

    vector<int> ans;
    unordered_map<int, unordered_set<int>> graph;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].insert(v);
      graph[v].insert(u);
    }

    for (const auto& [label, children] : graph)
      if (children.size() == 1)
        ans.push_back(label);

    while (n > 2) {
      n -= ans.size();
      vector<int> nextLeaves;
      for (const int leaf : ans) {
        const int u = *graph[leaf].begin();
        graph[u].erase(leaf);
        if (graph[u].size() == 1)
          nextLeaves.push_back(u);
      }
      ans = nextLeaves;
    }

    return ans;
  }
};",310
310,"class Solution {
 public:
  vector<vector<int>> multiply(vector<vector<int>>& mat1,
                               vector<vector<int>>& mat2) {
    const int m = mat1.size();
    const int n = mat2.size();
    const int l = mat2[0].size();
    vector<vector<int>> ans(m, vector<int>(l));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < l; ++j)
        for (int k = 0; k < n; ++k)
          ans[i][j] += mat1[i][k] * mat2[k][j];

    return ans;
  }
};",311
311,"class Solution {
 public:
  int maxCoins(vector<int>& nums) {
    const int n = nums.size();
    vector<vector<int>> mem(n + 2, vector<int>(n + 2));
    nums.insert(nums.begin(), 1);
    nums.insert(nums.end(), 1);
    return maxCoins(nums, 1, n, mem);
  }

 private:
  // Returns maxCoins(nums[i..j]).
  int maxCoins(const vector<int>& nums, int i, int j,
               vector<vector<int>>& mem) {
    if (i > j)
      return 0;
    if (mem[i][j] > 0)
      return mem[i][j];

    for (int k = i; k <= j; ++k)
      mem[i][j] = max(mem[i][j], maxCoins(nums, i, k - 1, mem) +
                                     maxCoins(nums, k + 1, j, mem) +
                                     nums[i - 1] * nums[k] * nums[j + 1]);

    return mem[i][j];
  }
};",312
312,"class Solution {
 public:
  int nthSuperUglyNumber(int n, vector<int>& primes) {
    const int k = primes.size();
    vector<int> indices(k);
    vector<int> uglyNums{1};

    while (uglyNums.size() < n) {
      vector<int> nexts(k);
      for (int i = 0; i < k; ++i)
        nexts[i] = uglyNums[indices[i]] * primes[i];
      const int next = ranges::min(nexts);
      for (int i = 0; i < k; ++i)
        if (next == nexts[i])
          ++indices[i];
      uglyNums.push_back(next);
    }

    return uglyNums.back();
  }
};",313
313,"class Solution {
 public:
  vector<vector<int>> verticalOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> range(2);
    getRange(root, range, 0);  // Get the leftmost and the rightmost x index.

    vector<vector<int>> ans(range[1] - range[0] + 1);
    queue<pair<TreeNode*, int>> q{{{root, -range[0]}}};  // (TreeNode, x)

    while (!q.empty()) {
      const auto [node, x] = q.front();
      q.pop();
      ans[x].push_back(node->val);
      if (node->left)
        q.emplace(node->left, x - 1);
      if (node->right)
        q.emplace(node->right, x + 1);
    }

    return ans;
  }

 private:
  void getRange(TreeNode* root, vector<int>& range, int x) {
    if (root == nullptr)
      return;

    range[0] = min(range[0], x);
    range[1] = max(range[1], x);

    getRange(root->left, range, x - 1);
    getRange(root->right, range, x + 1);
  }
};",314
314,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  vector<int> countSmaller(vector<int>& nums) {
    vector<int> ans(nums.size());
    const unordered_map<int, int> ranks = getRanks(nums);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const int num = nums[i];
      ans[i] = tree.get(ranks.at(num) - 1);
      tree.update(ranks.at(num), 1);
    }

    return ans;
  }

 private:
  unordered_map<int, int> getRanks(const vector<int>& nums) {
    unordered_map<int, int> ranks;
    set<int> sorted(nums.begin(), nums.end());
    int rank = 0;
    for (const int num : sorted)
      ranks[num] = ++rank;
    return ranks;
  }
};",315
315,"class Solution {
 public:
  string removeDuplicateLetters(string s) {
    string ans;
    vector<int> count(128);
    vector<bool> used(128);

    for (const char c : s)
      ++count[c];

    for (const char c : s) {
      --count[c];
      if (used[c])
        continue;
      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {
        used[ans.back()] = false;
        ans.pop_back();
      }
      used[c] = true;
      ans.push_back(c);
    }

    return ans;
  }
};",316
316,"class Solution {
 public:
  int shortestDistance(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    const int nBuildings = getBuildingsCount(grid);
    int ans = INT_MAX;
    // dist[i][j] := the total distance of grid[i][j] (0) to reach all the
    // buildings (1)
    vector<vector<int>> dist(m, vector<int>(n));
    // reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach
    vector<vector<int>> reachCount(m, vector<int>(n));

    auto bfs = [&](int row, int col) -> bool {
      queue<pair<int, int>> q{{{row, col}}};
      vector<vector<bool>> seen(m, vector<bool>(n));
      seen[row][col] = true;
      int depth = 0;
      int seenBuildings = 1;

      while (!q.empty()) {
        ++depth;
        for (int sz = q.size(); sz > 0; --sz) {
          const auto [i, j] = q.front();
          q.pop();
          for (const auto& [dx, dy] : dirs) {
            const int x = i + dx;
            const int y = j + dy;
            if (x < 0 || x == m || y < 0 || y == n)
              continue;
            if (seen[x][y])
              continue;
            seen[x][y] = true;
            if (!grid[x][y]) {
              dist[x][y] += depth;
              ++reachCount[x][y];
              q.emplace(x, y);
            } else if (grid[x][y] == 1) {
              ++seenBuildings;
            }
          }
        }
      }

      return seenBuildings == nBuildings;
    };

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)  // BFS from this building.
          if (!bfs(i, j))
            return -1;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (reachCount[i][j] == nBuildings)
          ans = min(ans, dist[i][j]);

    return ans == INT_MAX ? -1 : ans;
  }

 private:
  int getBuildingsCount(vector<vector<int>>& grid) {
    return accumulate(grid.begin(), grid.end(), 0, [](int s, vector<int>& row) {
      return s + ranges::count(row, 1);
    });
  }
};",317
317,"class Solution {
 public:
  int maxProduct(vector<string>& words) {
    size_t ans = 0;
    vector<int> masks;

    for (const string& word : words)
      masks.push_back(getMask(word));

    for (int i = 0; i < words.size(); ++i)
      for (int j = 0; j < i; ++j)
        if ((masks[i] & masks[j]) == 0)
          ans = max(ans, words[i].length() * words[j].length());

    return ans;
  }

 private:
  int getMask(const string& word) {
    int mask = 0;
    for (const char c : word)
      mask |= 1 << c - 'a';
    return mask;
  }
};",318
318,"class Solution {
 public:
  int bulbSwitch(int n) {
    // The k-th bulb can only be switched when k % i == 0.
    // So, we can rephrase the problem:
    // To find number of numbers <= n that have odd factors.
    // Obviously, only square numbers have odd factor(s).
    // e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10
    return sqrt(n);
  }
};",319
319,"class Solution {
 public:
  vector<string> generateAbbreviations(string word) {
    vector<string> ans;
    dfs(word, 0, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& word, int i, int count, vector<string>&& path,
           vector<string>& ans) {
    if (i == word.length()) {
      ans.push_back(join(path) + getCountString(count));
      return;
    }

    // Abbreviate the word[i].
    dfs(word, i + 1, count + 1, move(path), ans);
    // Keep the word[i], so consume the count as a string
    path.push_back(getCountString(count) + word[i]);
    // Reset the count to 0.
    dfs(word, i + 1, 0, move(path), ans);
    path.pop_back();
  }

  string getCountString(int count) {
    return count > 0 ? to_string(count) : """";
  }

  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  };
};",320
320,"class Solution {
 public:
  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;

    for (int k1 = 0; k1 <= k; ++k1) {
      const int k2 = k - k1;
      if (k1 > nums1.size() || k2 > nums2.size())
        continue;
      ans = max(ans, merge(maxArray(nums1, k1), maxArray(nums2, k2)));
    }

    return ans;
  }

 private:
  vector<int> maxArray(const vector<int>& nums, int k) {
    vector<int> res;
    int toPop = nums.size() - k;
    for (const int num : nums) {
      while (!res.empty() && res.back() < num && toPop-- > 0)
        res.pop_back();
      res.push_back(num);
    }
    return {res.begin(), res.begin() + k};
  }

  // Merges nums1 and nums2.
  vector<int> merge(const vector<int>& nums1, const vector<int>& nums2) {
    vector<int> res;
    auto s1 = nums1.cbegin();
    auto s2 = nums2.cbegin();
    while (s1 != nums1.cend() || s2 != nums2.cend())
      if (lexicographical_compare(s1, nums1.cend(), s2, nums2.cend()))
        res.push_back(*s2++);
      else
        res.push_back(*s1++);
    return res;
  }
};",321
321,"class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
    // dp[i] := the minimum number of coins to make up i
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;

    for (const int coin : coins)
      for (int i = coin; i <= amount; ++i)
        dp[i] = min(dp[i], dp[i - coin] + 1);

    return dp[amount] == amount + 1 ? -1 : dp[amount];
  }
};",322
322,"class Solution {
 public:
  int countComponents(int n, vector<vector<int>>& edges) {
    int ans = 0;
    vector<vector<int>> graph(n);
    unordered_set<int> seen;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i)
      if (!seen.count(i)) {
        bfs(graph, i, seen);
        ++ans;
      }

    return ans;
  }

 private:
  void bfs(const vector<vector<int>>& graph, int node,
           unordered_set<int>& seen) {
    queue<int> q{{node}};
    seen.insert(node);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u])
        if (!seen.count(v)) {
          q.push(v);
          seen.insert(v);
        }
    }
  }
};",323
323,"class Solution {
 public:
  void wiggleSort(vector<int>& nums) {
    const int n = nums.size();
    const auto it = nums.begin() + n / 2;
    nth_element(nums.begin(), it, nums.end());
    const int median = *it;

// index-rewiring
#define A(i) nums[(1 + 2 * i) % (n | 1)]

    for (int i = 0, j = 0, k = n - 1; i <= k;)
      if (A(i) > median)
        swap(A(i++), A(j++));
      else if (A(i) < median)
        swap(A(i), A(k--));
      else
        ++i;
  }
};",324
324,"class Solution {
 public:
  int maxSubArrayLen(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      const int target = prefix - k;
      if (const auto it = prefixToIndex.find(target);
          it != prefixToIndex.cend())
        ans = max(ans, i - it->second);
      if (!prefixToIndex.count(prefix))
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};",325
325,"class Solution {
 public:
  bool isPowerOfThree(int n) {
    return n > 0 && static_cast<int>(pow(3, 19)) % n == 0;
  }
};",326
326,"class Solution {
 public:
  int countRangeSum(vector<int>& nums, int lower, int upper) {
    const int n = nums.size();
    int ans = 0;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    mergeSort(prefix, 0, n, lower, upper, ans);
    return ans;
  }

 private:
  void mergeSort(vector<long>& prefix, int l, int r, int lower, int upper,
                 int& ans) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(prefix, l, m, lower, upper, ans);
    mergeSort(prefix, m + 1, r, lower, upper, ans);
    merge(prefix, l, m, r, lower, upper, ans);
  }

  void merge(vector<long>& prefix, int l, int m, int r, int lower, int upper,
             int& ans) {
    int lo = m + 1;  // the first index s.t. prefix[lo] - prefix[i] >= lower
    int hi = m + 1;  // the first index s.t. prefix[hi] - prefix[i] > upper

    // For each index i in range [l, m], add hi - lo to `ans`.
    for (int i = l; i <= m; ++i) {
      while (lo <= r && prefix[lo] - prefix[i] < lower)
        ++lo;
      while (hi <= r && prefix[hi] - prefix[i] <= upper)
        ++hi;
      ans += hi - lo;
    }

    vector<long> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (prefix[i] < prefix[j])
        sorted[k++] = prefix[i++];
      else
        sorted[k++] = prefix[j++];

    // Put the possible remaining left part into the sorted array.
    while (i <= m)
      sorted[k++] = prefix[i++];

    // Put the possible remaining right part into the sorted array.
    while (j <= r)
      sorted[k++] = prefix[j++];

    copy(sorted.begin(), sorted.end(), prefix.begin() + l);
  }
};",327
327,"class Solution {
 public:
  ListNode* oddEvenList(ListNode* head) {
    ListNode oddHead(0);
    ListNode evenHead(0);
    ListNode* odd = &oddHead;
    ListNode* even = &evenHead;

    for (int isOdd = 0; head; head = head->next)
      if (isOdd ^= 1) {
        odd->next = head;
        odd = odd->next;
      } else {
        even->next = head;
        even = even->next;
      }

    odd->next = evenHead.next;
    even->next = nullptr;
    return oddHead.next;
  }
};",328
328,"class Solution {
 public:
  int longestIncreasingPath(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;
    vector<vector<int>> mem(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans = max(ans, dfs(matrix, i, j, INT_MIN, mem));

    return ans;
  }

 private:
  // mem[i][j] := the LIP starting from matrix[i][j]
  int dfs(const vector<vector<int>>& matrix, int i, int j, int prev,
          vector<vector<int>>& mem) {
    if (i < 0 || i == matrix.size() || j < 0 || j == matrix[0].size())
      return 0;
    if (matrix[i][j] <= prev)
      return 0;
    int& ans = mem[i][j];
    if (ans > 0)
      return ans;

    const int curr = matrix[i][j];
    return ans = 1 + max({dfs(matrix, i + 1, j, curr, mem),
                          dfs(matrix, i - 1, j, curr, mem),
                          dfs(matrix, i, j + 1, curr, mem),
                          dfs(matrix, i, j - 1, curr, mem)});
  }
};",329
329,"class Solution {
 public:
  int minPatches(vector<int>& nums, int n) {
    int ans = 0;
    int i = 0;      // nums' index
    long miss = 1;  // the minimum sum in [1, n] we might miss

    while (miss <= n)
      if (i < nums.size() && nums[i] <= miss) {
        miss += nums[i++];
      } else {
        // Greedily add `miss` itself to increase the range from
        // [1, miss) to [1, 2 * miss).
        miss += miss;
        ++ans;
      }

    return ans;
  }
};",330
330,"class Solution {
 public:
  bool isValidSerialization(string preorder) {
    int degree = 1;  // out-degree (children) - in-degree (parent)
    istringstream iss(preorder);

    for (string node; getline(iss, node, ',');) {
      if (--degree < 0)
        return false;
      if (node != ""#"")
        degree += 2;
    }

    return degree == 0;
  }
};",331
331,"class Solution {
 public:
  vector<string> findItinerary(vector<vector<string>>& tickets) {
    vector<string> ans;
    unordered_map<string, multiset<string>> graph;

    for (const vector<string>& ticket : tickets)
      graph[ticket[0]].insert(ticket[1]);

    dfs(graph, ""JFK"", ans);
    reverse(ans.begin(), ans.end());
    return ans;
  }

 private:
  void dfs(unordered_map<string, multiset<string>>& graph, const string& u,
           vector<string>& ans) {
    while (graph.count(u) && !graph[u].empty()) {
      const string v = *graph[u].begin();
      graph[u].erase(graph[u].begin());
      dfs(graph, v, ans);
    }
    ans.push_back(u);
  }
};",332
332,"struct T {
  int min;   // the minimum value in the subtree
  int max;   // the maximum value in the subtree
  int size;  // the size of the subtree
};

class Solution {
 public:
  int largestBSTSubtree(TreeNode* root) {
    return dfs(root).size;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {INT_MAX, INT_MIN, 0};

    T l = dfs(root->left);
    T r = dfs(root->right);

    if (l.max < root->val && root->val < r.min)
      return {min(l.min, root->val), max(r.max, root->val),
              1 + l.size + r.size};

    // Mark one as invalid, but still record the size of children.
    // Return (-INF, INF) because no node will be > INT or < -INF.
    return {INT_MIN, INT_MAX, max(l.size, r.size)};
  }
};",333
333,"class Solution {
 public:
  bool increasingTriplet(vector<int>& nums) {
    int first = INT_MAX;
    int second = INT_MAX;

    for (const int num : nums)
      if (num <= first)
        first = num;
      else if (num <= second)  // first < num <= second
        second = num;
      else
        return true;  // first < second < num (third)

    return false;
  }
};",334
334,"class Solution {
 public:
  bool isSelfCrossing(vector<int>& x) {
    if (x.size() <= 3)
      return false;

    for (int i = 3; i < x.size(); ++i) {
      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])
        return true;
      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])
        return true;
      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] &&
          x[i - 1] <= x[i - 3] && x[i - 3] <= x[i - 1] + x[i - 5])
        return true;
    }

    return false;
  }
};",335
335,"class Solution {
 public:
  vector<vector<int>> palindromePairs(vector<string>& words) {
    vector<vector<int>> ans;
    unordered_map<string, int> map;  // {reversed word: its index}

    for (int i = 0; i < words.size(); ++i) {
      string word = words[i];
      reverse(word.begin(), word.end());
      map[word] = i;
    }

    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      // a special case to prevent duplicate calculation
      if (const auto it = map.find("""");
          it != map.cend() && it->second != i && isPalindrome(word))
        ans.push_back({i, it->second});
      for (int j = 1; j <= word.length(); ++j) {
        const string& l = word.substr(0, j);
        const string& r = word.substr(j);
        if (const auto it = map.find(l);
            it != map.cend() && it->second != i && isPalindrome(r))
          ans.push_back({i, it->second});
        if (const auto it = map.find(r);
            it != map.cend() && it->second != i && isPalindrome(l))
          ans.push_back({it->second, i});
      }
    }

    return ans;
  }

 private:
  bool isPalindrome(const string& word) {
    int l = 0;
    int r = word.length() - 1;
    while (l < r)
      if (word[l++] != word[r--])
        return false;
    return true;
  }
};",336
336,"struct T {
  int robRoot;
  int notRobRoot;
};

class Solution {
 public:
  int rob(TreeNode* root) {
    const auto& [robRoot, notRobRoot] = robOrNotRob(root);
    return max(robRoot, notRobRoot);
  }

 private:
  T robOrNotRob(TreeNode* root) {
    if (root == nullptr)
      return {0, 0};
    const T l = robOrNotRob(root->left);
    const T r = robOrNotRob(root->right);
    return {root->val + l.notRobRoot + r.notRobRoot,
            max(l.robRoot, l.notRobRoot) + max(r.robRoot, r.notRobRoot)};
  }
};",337
337,"class Solution {
 public:
  vector<int> countBits(int n) {
    // f(i) := i's number of 1s in bitmask
    // f(i) = f(i / 2) + i % 2
    vector<int> ans(n + 1);

    for (int i = 1; i <= n; ++i)
      ans[i] = ans[i / 2] + (i & 1);

    return ans;
  }
};",338
338,"class Solution {
 public:
  int depthSum(vector<NestedInteger>& nestedList) {
    int ans = 0;
    int depth = 0;
    queue<NestedInteger> q;

    addIntegers(q, nestedList);

    while (!q.empty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        const NestedInteger ni = q.front();
        q.pop();
        if (ni.isInteger())
          ans += ni.getInteger() * depth;
        else
          addIntegers(q, ni.getList());
      }
    }

    return ans;
  }

 private:
  void addIntegers(queue<NestedInteger>& q,
                   const vector<NestedInteger>& nestedList) {
    for (const NestedInteger& ni : nestedList)
      q.push(ni);
  }
};",339
339,"class Solution {
 public:
  int lengthOfLongestSubstringKDistinct(string s, int k) {
    int ans = 0;
    int distinct = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r]] == 1)
        ++distinct;
      while (distinct == k + 1)
        if (--count[s[l++]] == 0)
          --distinct;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",340
340,"class NestedIterator {
 public:
  NestedIterator(vector<NestedInteger>& nestedList) {
    addInteger(nestedList);
  }

  int next() {
    const int num = q.front();
    q.pop();
    return num;
  }

  bool hasNext() {
    return !q.empty();
  }

 private:
  queue<int> q;

  void addInteger(const vector<NestedInteger>& nestedList) {
    for (const NestedInteger& ni : nestedList)
      if (ni.isInteger())
        q.push(ni.getInteger());
      else
        addInteger(ni.getList());
  }
};",341
341,"class Solution {
 public:
  bool isPowerOfFour(int n) {
    // Why (4^n - 1) % 3 == 0?
    // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are
    // three consecutive numbers; among one of them, there must be a multiple
    // of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.
    // Therefore, 4^n - 1 is a multiple of 3.
    return n > 0 && __builtin_popcountll(n) == 1 && (n - 1) % 3 == 0;
  }
};",342
342,"class Solution {
 public:
  int integerBreak(int n) {
    // If an optimal product contains a factor f >= 4, then we can replace it
    // with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,
    // we never need a factor >= 4, meaning we only need factors 1, 2, and 3
    // (and 1 is wasteful).
    // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.
    if (n == 2)  // 1 * 1
      return 1;
    if (n == 3)  // 1 * 2
      return 2;

    int ans = 1;

    while (n > 4) {
      n -= 3;
      ans *= 3;
    }
    ans *= n;

    return ans;
  }
};",343
343,"class Solution {
 public:
  void reverseString(vector<char>& s) {
    int l = 0;
    int r = s.size() - 1;

    while (l < r)
      swap(s[l++], s[r--]);
  }
};",344
344,"class Solution {
 public:
  string reverseVowels(string s) {
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      while (l < r && !isVowel(s[l]))
        ++l;
      while (l < r && !isVowel(s[r]))
        --r;
      swap(s[l++], s[r--]);
    }

    return s;
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }
};",345
345,"class MovingAverage {
 public:
  MovingAverage(int size) : size(size) {}

  double next(int val) {
    if (q.size() == size)
      sum -= q.front(), q.pop();
    sum += val;
    q.push(val);
    return sum / q.size();
  }

 private:
  int size;
  double sum = 0;
  queue<int> q;
};",346
346,"struct T {
  int num;
  int freq;
  T(int num, int freq) : num(num), freq(freq) {}
};

class Solution {
 public:
  vector<int> topKFrequent(vector<int>& nums, int k) {
    const int n = nums.size();
    vector<int> ans;
    unordered_map<int, int> count;
    auto compare = [](const T& a, const T& b) { return a.freq > b.freq; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count) {
      minHeap.emplace(num, freq);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    while (!minHeap.empty())
      ans.push_back(minHeap.top().num), minHeap.pop();

    return ans;
  }
};",347
347,"class TicTacToe {
 public:
  TicTacToe(int n) : n(n), rows(n), cols(n) {}

  /**
   * Player {player} makes a move at ({row}, {col}).
   *
   * @param row    The row of the board.
   * @param col    The column of the board.
   * @param player The player, can be either 1 or 2.
   * @return The current winning condition, can be either:
   *         0: No one wins.
   *         1: Player 1 wins.
   *         2: Player 2 wins.
   */
  int move(int row, int col, int player) {
    const int toAdd = player == 1 ? 1 : -1;
    const int target = player == 1 ? n : -n;

    if (row == col) {
      diag += toAdd;
      if (diag == target)
        return player;
    }

    if (row + col == n - 1) {
      antiDiag += toAdd;
      if (antiDiag == target)
        return player;
    }

    rows[row] += toAdd;
    if (rows[row] == target)
      return player;

    cols[col] += toAdd;
    if (cols[col] == target)
      return player;

    return 0;
  }

 private:
  const int n;
  // Record count('X') - count('O').
  vector<int> rows;
  vector<int> cols;
  int diag = 0;
  int antiDiag = 0;
};",348
348,"class Solution {
 public:
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_set<int> set{nums1.begin(), nums1.end()};

    for (const int num : nums2)
      if (set.erase(num))
        ans.push_back(num);

    return ans;
  }
};",349
349,"class Solution {
 public:
  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size())
      return intersect(nums2, nums1);

    vector<int> ans;
    unordered_map<int, int> count;

    for (const int num : nums1)
      ++count[num];

    for (const int num : nums2)
      if (const auto it = count.find(num);
          it != count.cend() && it->second-- > 0)
        ans.push_back(num);

    return ans;
  }
};",350
350,"class Solution {
 public:
  int numberOfPatterns(int m, int n) {
    int ans = 0;
    vector<vector<int>> across(10, vector<int>(10));
    vector<bool> seen(10);

    across[1][3] = across[3][1] = 2;
    across[1][7] = across[7][1] = 4;
    across[3][9] = across[9][3] = 6;
    across[7][9] = across[9][7] = 8;
    across[1][9] = across[9][1] = across[2][8] = across[8][2] = across[3][7] =
        across[7][3] = across[4][6] = across[6][4] = 5;

    ans += dfs(m, n, 1, 1, seen, across) * 4;  // 1, 3, 7, 9 are symmetric
    ans += dfs(m, n, 2, 1, seen, across) * 4;  // 2, 4, 6, 8 are symmetric
    ans += dfs(m, n, 5, 1, seen, across);      // 5
    return ans;
  }

 private:
  int dfs(int m, int n, int u, int depth, vector<bool>& seen,
          const vector<vector<int>>& across) {
    if (depth > n)
      return 0;

    seen[u] = true;
    int ans = depth >= m ? 1 : 0;

    for (int v = 1; v <= 9; ++v) {
      if (v == u || seen[v])
        continue;
      const int acrossed = across[u][v];
      if (acrossed == 0 || seen[acrossed])
        ans += dfs(m, n, v, depth + 1, seen, across);
    }

    seen[u] = false;
    return ans;
  }
};",351
351,"class SummaryRanges {
 public:
  void addNum(int val) {
    if (intervals.count(val))
      return;

    const int lo = lowerKey(val);
    const int hi = higherKey(val);

    // {lo, intervals[lo][1]} + val + {hi, intervals[hi][1]} = {lo,
    // intervals[hi][1]}
    if (lo >= 0 && hi >= 0 && intervals[lo][1] + 1 == val && val + 1 == hi) {
      intervals[lo][1] = intervals[hi][1];
      intervals.erase(hi);
      // {lo, intervals[lo][1]} + val = {lo, val}
      // Prevent adding duplicate entry by using '>=' instead of '=='.
    } else if (lo >= 0 && intervals[lo][1] + 1 >= val) {
      intervals[lo][1] = max(intervals[lo][1], val);
    } else if (hi >= 0 && val + 1 == hi) {
      // val + {hi, intervals[hi][1]} = {val, intervals[hi][1]}
      intervals[val] = {val, intervals[hi][1]};
      intervals.erase(hi);
    } else {
      intervals[val] = {val, val};
    }
  }

  vector<vector<int>> getIntervals() {
    vector<vector<int>> res;
    for (const auto& [_, interval] : intervals)
      res.push_back(interval);
    return res;
  }

 private:
  map<int, vector<int>> intervals;  // {start: (start, end)}

  // Returns the maximum key in `intervals` < `key`.
  int lowerKey(int key) {
    auto it = intervals.lower_bound(key);
    if (it == intervals.begin())
      return -1;
    return (--it)->first;
  }

  // Returns the minimum key in `intervals` > `key`.
  int higherKey(int key) {
    const auto it = intervals.upper_bound(key);
    if (it == intervals.cend())
      return -1;
    return it->first;
  }
};",352
352,"class SnakeGame {
 public:
  /** Initialize your data structure here.
     @param width - screen width
     @param height - screen height
     @param food - A list of food positions
     E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the
     second is at [1,0]. */
  SnakeGame(int width, int height, vector<vector<int>>& food)
      : width(width), height(height), food(food) {
    lookup.insert(getId(0, 0));
    body.push_back(getId(0, 0));
  }

  /** Moves the snake.
      @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down
      @return The game's score after the move. Return -1 if game over.
      Game over when snake crosses the screen boundary or bites its body. */
  int move(string direction) {
    // the old head's position
    int i = body.front() / width;
    int j = body.front() % width;

    // Update the head's position and check if it's out-of-bounds.
    if (direction == ""U"" && --i < 0)
      return -1;
    if (direction == ""L"" && --j < 0)
      return -1;
    if (direction == ""R"" && ++j == width)
      return -1;
    if (direction == ""D"" && ++i == height)
      return -1;

    const int newHead = getId(i, j);

    // Case 1: Eat food and increase the size by 1.
    if (k < food.size() && i == food[k][0] && j == food[k][1]) {
      lookup.insert(newHead);
      body.push_front(newHead);
      ++k;
      return ++score;
    }

    // Case 2: new head != old tail and eat body!
    if (newHead != body.back() && lookup.count(newHead))
      return -1;

    // Case 3: normal case
    // Remove the old tail first, then add new head because new head may be in
    // old tail's position.
    lookup.erase(body.back());
    lookup.insert(newHead);
    body.pop_back();
    body.push_front(newHead);
    return score;
  }

 private:
  int width;
  int height;
  int score = 0;
  int k = 0;  // food's index
  vector<vector<int>> food;
  unordered_set<int> lookup;
  deque<int> body;  // snake's body

  int getId(int i, int j) {
    return i * width + j;
  }
};",353
353,"class Solution {
 public:
  int maxEnvelopes(vector<vector<int>>& envelopes) {
    ranges::sort(envelopes, [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });

    // Same as 300. Longest Increasing Subsequence
    int ans = 0;
    vector<int> dp(envelopes.size());

    for (const vector<int>& e : envelopes) {
      int l = 0;
      int r = ans;
      while (l < r) {
        const int m = (l + r) / 2;
        if (dp[m] >= e[1])
          r = m;
        else
          l = m + 1;
      }
      dp[l] = e[1];
      if (l == ans)
        ++ans;
    }

    return ans;
  }
};",354
354,"struct Tweet {
  int id;
  int time;
  Tweet* next = nullptr;
  Tweet(int id, int time) : id(id), time(time) {}
};

struct User {
  int id;
  unordered_set<int> followeeIds;
  Tweet* tweetHead = nullptr;

  User() {}

  User(int id) : id(id) {
    follow(id);
  }

  void follow(int followeeId) {
    followeeIds.insert(followeeId);
  }

  void unfollow(int followeeId) {
    followeeIds.erase(followeeId);
  }

  void post(int tweetId, int time) {
    Tweet* oldTweetHead = tweetHead;
    tweetHead = new Tweet(tweetId, time);
    tweetHead->next = oldTweetHead;
  }
};

class Twitter {
 public:
  /** Compose a new tweet. */
  void postTweet(int userId, int tweetId) {
    if (!users.count(userId))
      users[userId] = User(userId);
    users[userId].post(tweetId, time++);
  }

  /**
   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in
   * the news feed must be posted by users who the user followed or by the user
   * herself. Tweets must be ordered from most recent to least recent.
   */
  vector<int> getNewsFeed(int userId) {
    if (!users.count(userId))
      return {};

    vector<int> newsFeed;

    auto compare = [](const Tweet* a, const Tweet* b) {
      return a->time < b->time;
    };
    priority_queue<Tweet*, vector<Tweet*>, decltype(compare)> maxHeap(compare);

    for (const int followeeId : users[userId].followeeIds) {
      Tweet* tweetHead = users[followeeId].tweetHead;
      if (tweetHead != nullptr)
        maxHeap.push(tweetHead);
    }

    int count = 0;
    while (!maxHeap.empty() && count++ < 10) {
      Tweet* tweet = maxHeap.top();
      maxHeap.pop();
      newsFeed.push_back(tweet->id);
      if (tweet->next)
        maxHeap.push(tweet->next);
    }

    return newsFeed;
  }

  /**
   * Follower follows a followee.
   * If the operation is invalid, it should be a no-op.
   */
  void follow(int followerId, int followeeId) {
    if (followerId == followeeId)
      return;
    if (!users.count(followerId))
      users[followerId] = User(followerId);
    if (!users.count(followeeId))
      users[followeeId] = User(followeeId);
    users[followerId].follow(followeeId);
  }

  /**
   * Follower unfollows a followee.
   * If the operation is invalid, it should be a no-op.
   */
  void unfollow(int followerId, int followeeId) {
    if (followerId == followeeId)
      return;
    if (const auto it = users.find(followerId);
        it != users.cend() && users.count(followeeId))
      it->second.unfollow(followeeId);
  }

 private:
  int time = 0;
  unordered_map<int, User> users;  // {userId: User}
};",355
355,"class Solution {
 public:
  bool isReflected(vector<vector<int>>& points) {
    int minX = INT_MAX;
    int maxX = INT_MIN;
    unordered_set<pair<int, int>, PairHash> seen;

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      minX = min(minX, x);
      maxX = max(maxX, x);
      seen.insert({x, y});
    }

    const int sum = minX + maxX;
    // (leftX + rightX) / 2 = (minX + maxX) / 2
    //  leftX = minX + maxX - rightX
    // rightX = minX + maxX - leftX

    for (const vector<int>& p : points)
      if (!seen.count({sum - p[0], p[1]}))
        return false;

    return true;
  }

 private:
  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",356
356,"class Solution {
 public:
  int countNumbersWithUniqueDigits(int n) {
    if (n == 0)
      return 1;

    int ans = 10;
    int uniqueDigits = 9;

    for (int availableNum = 9; n > 1 && availableNum > 0; --n, --availableNum) {
      uniqueDigits *= availableNum;
      ans += uniqueDigits;
    }

    return ans;
  }
};",357
357,"class Solution {
 public:
  string rearrangeString(string s, int k) {
    const int n = s.length();
    string ans;
    vector<int> count(26);
    // valid[i] := the leftmost index ('a' + i) can appear
    vector<int> valid(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (int i = 0; i < n; ++i) {
      const char c = getBestLetter(count, valid, i);
      if (c == '*')
        return """";
      ans += c;
      --count[c - 'a'];
      valid[c - 'a'] = i + k;
    }

    return ans;
  }

 private:
  // Returns the valid letter that has the most count.
  char getBestLetter(const vector<int>& count, const vector<int>& valid,
                     int index) {
    int maxCount = -1;
    char bestLetter = '*';

    for (char c = 'a'; c <= 'z'; ++c)
      if (count[c - 'a'] > 0 && count[c - 'a'] > maxCount &&
          index >= valid[c - 'a']) {
        bestLetter = c;
        maxCount = count[c - 'a'];
      }

    return bestLetter;
  }
};",358
358,"shouldPrintMessage(timestamp: int, message: str)",359
359,"class Solution {
 public:
  vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {
    const int n = nums.size();
    const bool upward = a > 0;
    vector<int> ans(n);
    vector<int> quad;

    for (const int num : nums)
      quad.push_back(f(num, a, b, c));

    int i = upward ? n - 1 : 0;
    for (int l = 0, r = n - 1; l <= r;)
      if (upward)  // is the maximum in the both ends
        ans[i--] = quad[l] > quad[r] ? quad[l++] : quad[r--];
      else  // is the minimum in the both ends
        ans[i++] = quad[l] < quad[r] ? quad[l++] : quad[r--];

    return ans;
  }

 private:
  // The concavity of f only depends on a's sign.
  int f(int x, int a, int b, int c) {
    return (a * x + b) * x + c;
  }
};",360
360,"class Solution {
 public:
  int maxKilledEnemies(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int enemyCount = 0;
    // dp[i][j] := the maximum enemies grid[i][j] can kill
    vector<vector<int>> dp(m, vector<int>(n));

    auto update = [&](int i, int j) {
      if (grid[i][j] == '0')
        dp[i][j] += enemyCount;
      else if (grid[i][j] == 'E')
        ++enemyCount;
      else  // grid[i][j] == 'W'
        enemyCount = 0;
    };

    // Extend the four directions, if meet 'W', need to start over from 0.
    for (int i = 0; i < m; ++i) {
      enemyCount = 0;
      for (int j = 0; j < n; ++j)
        update(i, j);
      enemyCount = 0;
      for (int j = n - 1; j >= 0; --j)
        update(i, j);
    }

    for (int j = 0; j < n; ++j) {
      enemyCount = 0;
      for (int i = 0; i < m; ++i)
        update(i, j);
      enemyCount = 0;
      for (int i = m - 1; i >= 0; --i)
        update(i, j);
    }

    return accumulate(dp.begin(), dp.end(), 0,
                      [](int subtotal, const vector<int>& row) {
      return max(subtotal, ranges::max(row));
    });
  }
};",361
361,hit(timestamp: int),362
362,"class Solution {
 public:
  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = INT_MIN;

    for (int baseCol = 0; baseCol < n; ++baseCol) {
      // sums[i] := sum(matrix[i][baseCol..j])
      vector<int> sums(m, 0);
      for (int j = baseCol; j < n; ++j) {
        for (int i = 0; i < m; ++i)
          sums[i] += matrix[i][j];
        // Find the maximum sum <= k of all the subarrays.
        set<int> accumulate{0};
        int prefix = 0;
        for (const int sum : sums) {
          prefix += sum;
          if (const auto it = accumulate.lower_bound(prefix - k);
              it != accumulate.cend())
            ans = max(ans, prefix - *it);
          accumulate.insert(prefix);
        }
      }
    }

    return ans;
  }
};",363
363,"class Solution {
 public:
  int depthSumInverse(vector<NestedInteger>& nestedList) {
    int ans = 0;
    int prevSum = 0;
    queue<NestedInteger> q{{nestedList.begin(), nestedList.end()}};

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const NestedInteger ni = q.front();
        q.pop();
        if (ni.isInteger())
          prevSum += ni.getInteger();
        else {
          for (const NestedInteger nextNi : ni.getList())
            q.push(nextNi);
        }
      }
      ans += prevSum;
    }

    return ans;
  }
};",364
364,"class Solution {
 public:
  bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    return targetCapacity == 0 ||
           jug1Capacity + jug2Capacity >= targetCapacity &&
               targetCapacity % __gcd(jug1Capacity, jug2Capacity) == 0;
  }
};",365
365,"class Solution {
 public:
  vector<vector<int>> findLeaves(TreeNode* root) {
    vector<vector<int>> ans;
    depth(root, ans);
    return ans;
  }

 private:
  // Returns the depth of the root (0-indexed).
  int depth(TreeNode* root, vector<vector<int>>& ans) {
    if (root == nullptr)
      return -1;

    const int l = depth(root->left, ans);
    const int r = depth(root->right, ans);
    const int h = 1 + max(l, r);
    if (ans.size() == h)  // Meet a leaf.
      ans.push_back({});

    ans[h].push_back(root->val);
    return h;
  }
};",366
366,"class Solution {
 public:
  bool isPerfectSquare(int num) {
    long l = 1;
    long r = num;

    while (l < r) {
      const long m = (l + r) / 2;
      if (m >= num / m)
        r = m;
      else
        l = m + 1;
    }

    return l * l == num;
  }
};",367
367,"class Solution {
 public:
  vector<int> largestDivisibleSubset(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans;
    // sizeEndsAt[i] := the maximum size ends in nums[i]
    vector<int> sizeEndsAt(n, 1);
    // prevIndex[i] := the best index s.t.
    // 1. nums[i] % nums[prevIndex[i]] == 0 and
    // 2. can increase the size of the subset
    vector<int> prevIndex(n, -1);
    int maxSize = 0;  // Max size of the subset
    int index = -1;   // Track the best ending index

    ranges::sort(nums);

    // Fix the maximum ending number in the subset.
    for (int i = 0; i < n; ++i) {
      for (int j = i - 1; j >= 0; --j)
        if (nums[i] % nums[j] == 0 && sizeEndsAt[i] < sizeEndsAt[j] + 1) {
          sizeEndsAt[i] = sizeEndsAt[j] + 1;
          prevIndex[i] = j;
        }
      // Find a new subset that has a bigger size.
      if (maxSize < sizeEndsAt[i]) {
        maxSize = sizeEndsAt[i];
        index = i;  // Update the best ending index.
      }
    }

    // Loop from the back to the front.
    while (index != -1) {
      ans.push_back(nums[index]);
      index = prevIndex[index];
    }

    return ans;
  }
};",368
368,"class Solution {
 public:
  ListNode* plusOne(ListNode* head) {
    if (head == nullptr)
      return new ListNode(1);
    if (addOne(head) == 1)
      return new ListNode(1, head);
    return head;
  }

 private:
  int addOne(ListNode* node) {
    const int carry = node->next ? addOne(node->next) : 1;
    const int sum = node->val + carry;
    node->val = sum % 10;
    return sum / 10;
  }
};",369
369,"class Solution {
 public:
  vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
    vector<int> ans;
    vector<int> line(length);
    int prefix = 0;

    for (const vector<int>& update : updates) {
      const int start = update[0];
      const int end = update[1];
      const int inc = update[2];
      line[start] += inc;
      if (end + 1 < length)
        line[end + 1] -= inc;
    }

    for (const int diff : line) {
      prefix += diff;
      ans.push_back(prefix);
    }

    return ans;
  }
};",370
370,"class Solution {
 public:
  int getSum(unsigned a, unsigned b) {
    while (b > 0) {                  // Still have carry bits.
      const unsigned carry = a & b;  // Record the carry bits.
      a ^= b;  // ^ works like + without handling carry bits.
      b = carry << 1;
    }
    return a;
  }
};",371
371,"class Solution {
 public:
  int superPow(int a, vector<int>& b) {
    int ans = 1;

    a %= kMod;
    for (const int i : b)
      ans = modPow(ans, 10) * modPow(a, i) % kMod;

    return ans;
  }

 private:
  static constexpr int kMod = 1337;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",372
372,"struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}
};

class Solution {
 public:
  vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2,
                                     int k) {
    vector<vector<int>> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back({nums1[i], nums2[j]});
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};",373
373,"/**
 * Forward declaration of guess API.
 * (The problem description is not clear, so I translate it into follows.)
 *
 * @param traget num
 *        guess num
 *
 * @return -1 if guess num >  target num
 *          0 if guess num == target num
 *          1 if guess num <  target num
 */

class Solution {
 public:
  int guessNumber(int n) {
    int l = 1;
    int r = n;

    // Find the first guess number that >= the target number
    while (l < r) {
      const int m = l + (r - l) / 2;
      if (guess(m) <= 0)  // -1, 0
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",374
374,"class Solution {
 public:
  int getMoneyAmount(int n) {
    vector<vector<int>> mem(n + 1, vector<int>(n + 1, INT_MAX));
    return getMoneyAmount(1, n, mem);
  }

 private:
  // Returns the minimum money you need to guarantee a win of picking i..j.
  int getMoneyAmount(int i, int j, vector<vector<int>>& mem) {
    if (i >= j)
      return 0;
    if (mem[i][j] != INT_MAX)
      return mem[i][j];

    for (int k = i; k <= j; ++k)
      mem[i][j] = min(mem[i][j], max(getMoneyAmount(i, k - 1, mem),
                                     getMoneyAmount(k + 1, j, mem)) +
                                     k);

    return mem[i][j];
  }
};",375
375,"class Solution {
 public:
  int wiggleMaxLength(vector<int>& nums) {
    int increasing = 1;
    int decreasing = 1;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1])
        increasing = decreasing + 1;
      else if (nums[i] < nums[i - 1])
        decreasing = increasing + 1;

    return max(increasing, decreasing);
  }
};",376
376,"class Solution {
 public:
  int combinationSum4(vector<int>& nums, int target) {
    vector<unsigned long long> dp(target + 1);
    dp[0] = 1;

    for (int i = 1; i <= target; ++i)
      for (const int num : nums)
        if (i >= num)
          dp[i] += dp[i - num];

    return dp[target];
  }
};",377
377,"struct T {
  int i;
  int j;
  int num;  // matrix[i][j]
  T(int i, int j, int num) : i(i), j(j), num(num) {}
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& matrix, int k) {
    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < matrix.size(); ++i)
      minHeap.emplace(i, 0, matrix[i][0]);

    while (k-- > 1) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      if (j + 1 < matrix[0].size())
        minHeap.emplace(i, j + 1, matrix[i][j + 1]);
    }

    return minHeap.top().num;
  }
};",378
378,"class PhoneDirectory {
 public:
  PhoneDirectory(int maxNumbers) : next(maxNumbers) {
    for (int i = 0; i < maxNumbers - 1; ++i)
      next[i] = i + 1;
    next.back() = 0;
  }

  int get() {
    if (next[number] == -1)
      return -1;
    const int ans = number;
    number = next[number];
    next[ans] = -1;  // Mark as used.
    return ans;
  }

  bool check(int number) {
    return next[number] != -1;
  }

  void release(int number) {
    if (next[number] != -1)
      return;
    next[number] = this->number;
    this->number = number;
  }

 private:
  int number = 0;    // the current possible available number
  vector<int> next;  // the next available numbers
};",379
379,"class RandomizedSet {
 public:
  bool insert(int val) {
    if (valToIndex.count(val))
      return false;
    valToIndex[val] = vals.size();
    vals.push_back(val);
    return true;
  }

  bool remove(int val) {
    if (!valToIndex.count(val))
      return false;
    const int index = valToIndex[val];
    // The order of the following two lines is important when vals.size() == 1.
    valToIndex[vals.back()] = index;
    valToIndex.erase(val);
    vals[index] = vals.back();
    vals.pop_back();
    return true;
  }

  int getRandom() {
    const int index = rand() % vals.size();
    return vals[index];
  }

 private:
  unordered_map<int, int> valToIndex;  // {val: index in vals}
  vector<int> vals;
};",380
380,"struct Item {
  int val;
  int indexInMap;
  Item(int val, int indexInMap) : val(val), indexInMap(indexInMap) {}
};

class RandomizedCollection {
 public:
  /** Inserts a value to the collection. Returns true if the collection did not
   * already contain the specified element. */
  bool insert(int val) {
    valToIndices[val].push_back(items.size());
    items.emplace_back(val, valToIndices[val].size() - 1);
    return valToIndices[val].size() == 1;
  }

  /** Removes a value from the collection. Returns true if the collection
   * contained the specified element. */
  bool remove(int val) {
    if (!valToIndices.count(val))
      return false;

    const int index = valToIndices[val].back();
    valToIndices[items.back().val][items.back().indexInMap] = index;
    valToIndices[val].pop_back();
    if (valToIndices[val].empty())
      valToIndices.erase(val);
    items[index] = items.back();
    items.pop_back();
    return true;
  }

  /** Get a random element from the collection. */
  int getRandom() {
    const int index = rand() % items.size();
    return items[index].val;
  }

 private:
  unordered_map<int, vector<int>> valToIndices;
  vector<Item> items;
};",381
381,"class Solution {
 public:
  /** @param head The linked list's head.
      Note that the head is guaranteed to be not null, so it contains at least
     one node. */
  Solution(ListNode* head) : head(head) {}

  /** Returns a random node's value. */
  int getRandom() {
    int res = -1;
    int i = 1;

    for (ListNode* curr = head; curr; curr = curr->next, ++i)
      if (rand() % i == 0)
        res = curr->val;

    return res;
  }

 private:
  ListNode* head;
};",382
382,"class Solution {
 public:
  // Similar to 0242. Valid Anagram
  bool canConstruct(string ransomNote, string magazine) {
    vector<int> count(26);

    for (const char c : magazine)
      ++count[c - 'a'];

    for (const char c : ransomNote) {
      if (count[c - 'a'] == 0)
        return false;
      --count[c - 'a'];
    }

    return true;
  }
};",383
383,"class Solution {
 public:
  Solution(vector<int>& nums) : nums(move(nums)) {}

  /** Resets the array to its original configuration and return it. */
  vector<int> reset() {
    return nums;
  }

  /** Returns a random shuffling of the array. */
  vector<int> shuffle() {
    vector<int> A(nums);
    for (int i = A.size() - 1; i > 0; --i) {
      const int j = rand() % (i + 1);
      swap(A[i], A[j]);
    }
    return A;
  }

 private:
  vector<int> nums;
};",384
384,"class Solution {
 public:
  NestedInteger deserialize(string s) {
    if (s[0] != '[')
      return NestedInteger(stoi(s));

    stack<NestedInteger> stack;
    int start;  // the start index of a number

    for (int i = 0; i < s.length(); ++i) {
      switch (s[i]) {
        case '[':
          stack.push(NestedInteger());
          start = i + 1;
          break;
        case ',':
          if (i > start) {
            const int num = stoi(s.substr(start, i));
            stack.top().add(NestedInteger(num));
          }
          start = i + 1;
          break;
        case ']':
          NestedInteger popped = stack.top();
          stack.pop();
          if (i > start) {
            const int num = stoi(s.substr(start, i));
            popped.add(NestedInteger(num));
          }
          if (stack.empty())
            return popped;
          else
            stack.top().add(popped);
          start = i + 1;
          break;
      }
    }

    throw;
  }
};",385
385,"class Solution {
 public:
  vector<int> lexicalOrder(int n) {
    vector<int> ans;
    int curr = 1;

    while (ans.size() < n) {
      ans.push_back(curr);
      if (curr * 10 <= n) {
        curr *= 10;
      } else {
        while (curr % 10 == 9 || curr == n)
          curr /= 10;
        ++curr;
      }
    }

    return ans;
  }
};",386
386,"class Solution {
 public:
  int firstUniqChar(string s) {
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (int i = 0; i < s.length(); ++i)
      if (count[s[i] - 'a'] == 1)
        return i;

    return -1;
  }
};",387
387,"struct T {
  int depth;
  size_t length;
  T(int depth, size_t length) : depth(depth), length(length) {}
};

class Solution {
 public:
  int lengthLongestPath(string input) {
    size_t ans = 0;
    stack<T> stack{{{-1, 0}}};  // placeholder
    istringstream iss(input);

    for (string token; getline(iss, token, '\n');) {
      const int depth = ranges::count(token, '\t');
      token.erase(remove(token.begin(), token.end(), '\t'), token.end());
      while (depth <= stack.top().depth)
        stack.pop();
      if (isFile(token))
        ans = max(ans, stack.top().length + token.length());
      else  // directory + '/'
        stack.emplace(depth, stack.top().length + token.length() + 1);
    }

    return ans;
  }

 private:
  bool isFile(const string& token) {
    return token.find('.') != string::npos;
  }
};",388
388,"class Solution {
 public:
  char findTheDifference(string s, string t) {
    const char sXors = accumulate(s.begin(), s.end(), 0, bit_xor<>());
    const char tXors = accumulate(t.begin(), t.end(), 0, bit_xor<>());
    return sXors ^ tXors;
  }
};",389
389,"class Solution {
 public:
  int lastRemaining(int n) {
    return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));
  }
};",390
390,"class Solution {
 public:
  bool isRectangleCover(vector<vector<int>>& rectangles) {
    int area = 0;
    int x1 = INT_MAX;
    int y1 = INT_MAX;
    int x2 = INT_MIN;
    int y2 = INT_MIN;
    unordered_set<string> corners;

    for (const vector<int>& r : rectangles) {
      area += (r[2] - r[0]) * (r[3] - r[1]);
      x1 = min(x1, r[0]);
      y1 = min(y1, r[1]);
      x2 = max(x2, r[2]);
      y2 = max(y2, r[3]);

      // the four points of the current rectangle
      const vector<string> points{to_string(r[0]) + "" "" + to_string(r[1]),
                                  to_string(r[0]) + "" "" + to_string(r[3]),
                                  to_string(r[2]) + "" "" + to_string(r[1]),
                                  to_string(r[2]) + "" "" + to_string(r[3])};
      for (const string& point : points)
        if (!corners.insert(point).second)
          corners.erase(point);
    }

    if (corners.size() != 4)
      return false;
    if (!corners.count(to_string(x1) + "" "" + to_string(y1)) ||
        !corners.count(to_string(x1) + "" "" + to_string(y2)) ||
        !corners.count(to_string(x2) + "" "" + to_string(y1)) ||
        !corners.count(to_string(x2) + "" "" + to_string(y2)))
      return false;
    return area == (x2 - x1) * (y2 - y1);
  }
};",391
391,"class Solution {
 public:
  bool isSubsequence(string s, string t) {
    if (s.empty())
      return true;

    int i = 0;
    for (const char c : t)
      if (s[i] == c && ++i == s.length())
        return true;

    return false;
  }
};",392
392,"class Solution {
 public:
  bool validUtf8(vector<int>& data) {
    int followedBytes = 0;

    for (const int d : data)
      if (followedBytes == 0) {
        if ((d >> 3) == 0b11110)
          followedBytes = 3;
        else if ((d >> 4) == 0b1110)
          followedBytes = 2;
        else if ((d >> 5) == 0b110)
          followedBytes = 1;
        else if ((d >> 7) == 0b0)
          followedBytes = 0;
        else
          return false;
      } else {
        if ((d >> 6) != 0b10)
          return false;
        --followedBytes;
      }

    return followedBytes == 0;
  }
};",393
393,"class Solution {
 public:
  string decodeString(string s) {
    stack<pair<string, int>> stack;  // (prevStr, repeatCount)
    string currStr;
    int currNum = 0;

    for (const char c : s)
      if (isdigit(c)) {
        currNum = currNum * 10 + (c - '0');
      } else {
        if (c == '[') {
          stack.emplace(currStr, currNum);
          currStr = """";
          currNum = 0;
        } else if (c == ']') {
          const auto [prevStr, n] = stack.top();
          stack.pop();
          currStr = prevStr + getRepeatedStr(currStr, n);
        } else {
          currStr += c;
        }
      }

    return currStr;
  }

 private:
  // Returns s * n.
  string getRepeatedStr(const string& s, int n) {
    string repeat;
    while (n--)
      repeat += s;
    return repeat;
  }
};",394
394,"class Solution {
 public:
  int longestSubstring(string s, int k) {
    int ans = 0;
    for (int n = 1; n <= 26; ++n)
      ans = max(ans, longestSubstringWithNUniqueLetters(s, k, n));
    return ans;
  }

 private:
  int longestSubstringWithNUniqueLetters(const string& s, int k, int n) {
    int res = 0;
    int uniqueLetters = 0;       // the number of unique letters
    int lettersHavingKFreq = 0;  // the number of letters having frequency >= k
    vector<int> count(26);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r] - 'a'] == 1)
        ++uniqueLetters;
      if (count[s[r] - 'a'] == k)
        ++lettersHavingKFreq;
      while (uniqueLetters > n) {
        if (count[s[l] - 'a'] == k)
          --lettersHavingKFreq;
        if (--count[s[l] - 'a'] == 0)
          --uniqueLetters;
        ++l;
      }
      // Since both the number of unique letters and the number of letters
      // having frequency >= k are equal to n, this is a valid window.
      if (lettersHavingKFreq == n)  // Implicit: uniqueLetters == n
        res = max(res, r - l + 1);
    }

    return res;
  }
};",395
395,"class Solution {
 public:
  int maxRotateFunction(vector<int>& nums) {
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    int f = 0;

    // Calculate F(0) first.
    for (int i = 0; i < nums.size(); ++i)
      f += i * nums[i];

    int ans = f;

    for (int i = nums.size() - 1; i > 0; --i) {
      f += sum - nums.size() * nums[i];
      ans = max(ans, f);
    }

    return ans;
  }
};",396
396,"class Solution {
 public:
  int integerReplacement(long n) {
    int ans = 0;

    for (; n > 1; ++ans)
      if ((n & 1) == 0)  // `n` ends in 0.
        n >>= 1;
      else if (n == 3 || ((n >> 1) & 1) == 0)  // `n` = 3 or ends in 0b01.
        --n;
      else  // `n` ends in 0b11.
        ++n;

    return ans;
  }
};",397
397,"class Solution {
 public:
  Solution(vector<int>& nums) : nums(move(nums)) {}

  int pick(int target) {
    int ans = -1;
    int range = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == target && rand() % ++range == 0)
        ans = i;

    return ans;
  }

 private:
  vector<int> nums;
};",398
398,"class Solution {
 public:
  vector<double> calcEquation(vector<vector<string>>& equations,
                              vector<double>& values,
                              vector<vector<string>>& queries) {
    vector<double> ans;
    // graph[A][B] := A / B
    unordered_map<string, unordered_map<string, double>> graph;

    for (int i = 0; i < equations.size(); ++i) {
      const string& A = equations[i][0];
      const string& B = equations[i][1];
      graph[A][B] = values[i];
      graph[B][A] = 1 / values[i];
    }

    for (const vector<string>& query : queries) {
      const string& A = query[0];
      const string& C = query[1];
      if (!graph.count(A) || !graph.count(C))
        ans.push_back(-1);
      else
        ans.push_back(divide(graph, A, C, unordered_set<string>()));
    }

    return ans;
  }

 private:
  // Returns A / C.
  double divide(
      const unordered_map<string, unordered_map<string, double>>& graph,
      const string& A, const string& C, unordered_set<string>&& seen) {
    if (A == C)
      return 1.0;

    seen.insert(A);

    // value := A / B
    for (const auto& [B, value] : graph.at(A)) {
      if (seen.count(B))
        continue;
      const double res = divide(graph, B, C, move(seen));  // B / C
      if (res > 0)                                         // valid result
        return value * res;  // A / C = (A / B) * (B / C)
    }

    return -1;  // invalid result
  }
};",399
399,"class Solution {
 public:
  int findNthDigit(int n) {
    int digitSize = 1;
    int startNum = 1;
    long count = 9;

    while (digitSize * count < n) {
      n -= digitSize * count;
      ++digitSize;
      startNum *= 10;
      count *= 10;
    }

    const int targetNum = startNum + (n - 1) / digitSize;
    const int index = (n - 1) % digitSize;
    return to_string(targetNum)[index] - '0';
  }
};",400
400,"class Solution {
 public:
  vector<string> readBinaryWatch(int turnedOn) {
    vector<string> ans;
    dfs(turnedOn, 0, 0, 0, ans);
    return ans;
  }

 private:
  static constexpr int hours[4] = {1, 2, 4, 8};
  static constexpr int minutes[6] = {1, 2, 4, 8, 16, 32};

  void dfs(int turnedOn, int s, int h, int m, vector<string>& ans) {
    if (turnedOn == 0) {
      string time = to_string(h) + "":"" + (m < 10 ? ""0"" : """") + to_string(m);
      ans.push_back(time);
      return;
    }

    for (int i = s; i < 4 + 6; ++i)
      if (i < 4 && h + hours[i] < 12)
        dfs(turnedOn - 1, i + 1, h + hours[i], m, ans);
      else if (i >= 4 && m + minutes[i - 4] < 60)
        dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4], ans);
  }
};",401
401,"class Solution {
 public:
  string removeKdigits(string num, int k) {
    if (num.length() == k)
      return ""0"";

    string ans;
    vector<char> stack;

    for (int i = 0; i < num.length(); ++i) {
      while (k > 0 && !stack.empty() && stack.back() > num[i]) {
        stack.pop_back();
        --k;
      }
      stack.push_back(num[i]);
    }

    while (k-- > 0)
      stack.pop_back();

    for (const char c : stack) {
      if (c == '0' && ans.empty())
        continue;
      ans += c;
    }

    return ans.empty() ? ""0"" : ans;
  }
};",402
402,"class Solution {
 public:
  bool canCross(vector<int>& stones) {
    const int n = stones.size();
    // dp[i][j] := true if a frog can make a size j jump to stones[i]
    vector<vector<bool>> dp(n, vector<bool>(n + 1));
    dp[0][0] = true;

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const int k = stones[i] - stones[j];
        if (k > n)
          continue;
        for (const int x : {k - 1, k, k + 1})
          if (0 <= x && x <= n)
            dp[i][k] = dp[i][k] || dp[j][x];
      }

    return ranges::any_of(dp.back(), [](bool val) { return val; });
  }
};",403
403,"class Solution {
 public:
  int sumOfLeftLeaves(TreeNode* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;

    if (root->left) {
      if (root->left->left == nullptr && root->left->right == nullptr)
        ans += root->left->val;
      else
        ans += sumOfLeftLeaves(root->left);
    }
    ans += sumOfLeftLeaves(root->right);

    return ans;
  }
};",404
404,"class Solution {
 public:
  string toHex(unsigned num) {
    if (num == 0)
      return ""0"";

    constexpr char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    string ans;

    while (num != 0) {
      ans += hex[num & 0xf];
      num >>= 4;
    }

    return {ans.rbegin(), ans.rend()};
  }
};",405
405,"class Solution {
 public:
  vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    vector<vector<int>> ans;

    ranges::sort(people, [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];
    });

    for (const vector<int>& p : people)
      ans.insert(ans.begin() + p[1], p);

    return ans;
  }
};",406
406,"struct T {
  int i;
  int j;
  int h;  // heightMap[i][j] or the height after filling water
  T(int i, int j, int h) : i(i), j(j), h(h) {}
};

class Solution {
 public:
  int trapRainWater(vector<vector<int>>& heightMap) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = heightMap.size();
    const int n = heightMap[0].size();
    int ans = 0;
    auto compare = [](const T& a, const T& b) { return a.h > b.h; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i) {
      minHeap.emplace(i, 0, heightMap[i][0]);
      minHeap.emplace(i, n - 1, heightMap[i][n - 1]);
      seen[i][0] = true;
      seen[i][n - 1] = true;
    }

    for (int j = 1; j < n - 1; ++j) {
      minHeap.emplace(0, j, heightMap[0][j]);
      minHeap.emplace(m - 1, j, heightMap[m - 1][j]);
      seen[0][j] = true;
      seen[m - 1][j] = true;
    }

    while (!minHeap.empty()) {
      const auto [i, j, h] = minHeap.top();
      minHeap.pop();
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        if (heightMap[x][y] < h) {
          ans += h - heightMap[x][y];
          minHeap.emplace(x, y, h);  // Fill water in grid[x][y].
        } else {
          minHeap.emplace(x, y, heightMap[x][y]);
        }
        seen[x][y] = true;
      }
    }

    return ans;
  }
};",407
407,"class Solution {
 public:
  bool validWordAbbreviation(const string& word, const string& abbr) {
    int i = 0;  // word's index
    int j = 0;  // abbr's index

    while (i < word.length() && j < abbr.length()) {
      if (word[i] == abbr[j]) {
        ++i;
        ++j;
        continue;
      }
      if (abbr[j] <= '0' || abbr[j] > '9')
        return false;
      int num = 0;
      while (j < abbr.length() && isdigit(abbr[j])) {
        num = num * 10 + abbr[j] - '0';
        ++j;
      }
      i += num;
    }

    return i == word.length() && j == abbr.length();
  }
};",408
408,"class Solution {
 public:
  int longestPalindrome(string s) {
    int ans = 0;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const int freq : count)
      ans += freq % 2 == 0 ? freq : freq - 1;

    const bool hasOddCount = ranges::any_of(count, [](int c) { return c & 1; });
    return ans + hasOddCount;
  }
};",409
409,"class Solution {
 public:
  int splitArray(vector<int>& nums, int k) {
    const int n = nums.size();
    vector<vector<int>> mem(n + 1, vector<int>(k + 1, INT_MAX));
    vector<int> prefix(n + 1);
    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);
    return splitArray(nums, n, k, prefix, mem);
  }

 private:
  // Returns the minimum of the maximum sum to split the first i numbers into k
  // groups.
  int splitArray(const vector<int>& nums, int i, int k,
                 const vector<int>& prefix, vector<vector<int>>& mem) {
    if (k == 1)
      return prefix[i];
    if (mem[i][k] < INT_MAX)
      return mem[i][k];

    // Try all the possible partitions.
    for (int j = k - 1; j < i; ++j)
      mem[i][k] = min(mem[i][k], max(splitArray(nums, j, k - 1, prefix, mem),
                                     prefix[i] - prefix[j]));

    return mem[i][k];
  }
};",410
410,"class Solution {
 public:
  string minAbbreviation(string target, vector<string>& dictionary) {
    const int m = target.length();
    vector<int> masks;

    for (const string& word : dictionary) {
      if (word.length() != m)
        continue;
      masks.push_back(getMask(target, word));
    }

    if (masks.empty())
      return to_string(m);

    vector<string> abbrs;

    const int maxCand = pow(2, m);
    // all the candidate representation of the target
    for (int cand = 0; cand < maxCand; ++cand)
      // All the masks have at lease one bit different from the candidate.
      if (ranges::all_of(masks, [cand](int mask) { return cand & mask; }))
        abbrs.push_back(getAbbr(target, cand));

    string ans = target;

    for (const string& abbr : abbrs)
      if (getAbbrLen(abbr) < getAbbrLen(ans))
        ans = abbr;

    return ans;
  }

 private:
  int getMask(const string& target, const string& word) {
    const int m = target.length();
    // mask[i] = 0 := target[i] == word[i]
    // mask[i] = 1 := target[i] != word[i]
    // e.g. target = ""apple""
    //        word = ""blade""
    //        mask =  11110
    int mask = 0;
    for (int i = 0; i < m; ++i)
      if (word[i] != target[i])
        mask |= 1 << m - 1 - i;
    return mask;
  }

  string getAbbr(const string& target, int cand) {
    const int m = target.length();
    string abbr;
    int replacedCount = 0;
    for (int i = 0; i < m; ++i)
      if (cand >> m - 1 - i & 1) {
        // If cand[i] = 1, `abbr` should show the original character.
        if (replacedCount > 0)
          abbr += to_string(replacedCount);
        abbr += target[i];
        replacedCount = 0;
      } else {
        // If cand[i] = 0, `abbr` can be replaced.
        ++replacedCount;
      }
    if (replacedCount > 0)
      abbr += to_string(replacedCount);
    return abbr;
  }

  int getAbbrLen(const string& abbr) {
    int abbrLen = 0;
    int i = 0;
    int j = 0;
    while (i < abbr.length()) {
      if (isalpha(abbr[j]))
        ++j;
      else
        while (j < abbr.length() && isdigit(abbr[j]))
          ++j;
      ++abbrLen;
      i = j;
    }
    return abbrLen;
  }
};",411
411,"class Solution {
 public:
  vector<string> fizzBuzz(int n) {
    vector<string> ans;

    for (int i = 1; i <= n; ++i) {
      string s;
      if (i % 3 == 0)
        s += ""Fizz"";
      if (i % 5 == 0)
        s += ""Buzz"";
      ans.push_back(s.empty() ? to_string(i) : s);
    }

    return ans;
  }
};",412
412,"class Solution {
 public:
  int numberOfArithmeticSlices(vector<int>& nums) {
    const int n = nums.size();
    if (n < 3)
      return 0;

    vector<int> dp(
        n);  // dp[i] := the number of arithmetic slices ending in index i

    for (int i = 2; i < nums.size(); ++i)
      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])
        dp[i] = dp[i - 1] + 1;

    return accumulate(dp.begin(), dp.end(), 0);
  }
};",413
413,"class Solution {
 public:
  int thirdMax(vector<int>& nums) {
    long max1 = LONG_MIN;  // the maximum
    long max2 = LONG_MIN;  // the second maximum
    long max3 = LONG_MIN;  // the third maximum

    for (const int num : nums)
      if (num > max1) {
        max3 = max2;
        max2 = max1;
        max1 = num;
      } else if (max1 > num && num > max2) {
        max3 = max2;
        max2 = num;
      } else if (max2 > num && num > max3) {
        max3 = num;
      }

    return max3 == LONG_MIN ? max1 : max3;
  }
};",414
414,"class Solution {
 public:
  string addStrings(string num1, string num2) {
    string ans;
    int carry = 0;
    int i = num1.length() - 1;
    int j = num2.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += num1[i--] - '0';
      if (j >= 0)
        carry += num2[j--] - '0';
      ans += carry % 10 + '0';
      carry /= 10;
    }

    reverse(ans.begin(), ans.end());
    return ans;
  }
};",415
415,"class Solution {
 public:
  bool canPartition(vector<int>& nums) {
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum & 1)
      return false;
    return knapsack(nums, sum / 2);
  }

 private:
  bool knapsack(const vector<int>& nums, int subsetSum) {
    const int n = nums.size();
    // dp[i][j] := true if j can be formed by nums[0..i)
    vector<vector<bool>> dp(n + 1, vector<bool>(subsetSum + 1));
    dp[0][0] = true;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 0; j <= subsetSum; ++j)
        if (j < num)
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j] || dp[i - 1][j - num];
    }

    return dp[n][subsetSum];
  }
};",416
416,"class Solution {
 public:
  vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = heights.size();
    const int n = heights[0].size();
    vector<vector<int>> ans;
    queue<pair<int, int>> qP;
    queue<pair<int, int>> qA;
    vector<vector<bool>> seenP(m, vector<bool>(n));
    vector<vector<bool>> seenA(m, vector<bool>(n));

    auto bfs = [&](queue<pair<int, int>>& q, vector<vector<bool>>& seen) {
      while (!q.empty()) {
        const auto [i, j] = q.front();
        q.pop();
        const int h = heights[i][j];
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || heights[x][y] < h)
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    };

    for (int i = 0; i < m; ++i) {
      qP.emplace(i, 0);
      qA.emplace(i, n - 1);
      seenP[i][0] = true;
      seenA[i][n - 1] = true;
    }

    for (int j = 0; j < n; ++j) {
      qP.emplace(0, j);
      qA.emplace(m - 1, j);
      seenP[0][j] = true;
      seenA[m - 1][j] = true;
    }

    bfs(qP, seenP);
    bfs(qA, seenA);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (seenP[i][j] && seenA[i][j])
          ans.push_back({i, j});

    return ans;
  }
};",417
417,"class Solution {
 public:
  int wordsTyping(vector<string>& sentence, int rows, int cols) {
    const string& combined = getCombined(sentence);
    const int n = combined.length();
    int i = 0;  // (i % n) points to the index of combined in each row

    while (rows--) {
      i += cols;
      if (combined[i % n] == ' ') {
        ++i;
      } else {
        while (i > 0 && combined[(i - 1) % n] != ' ')
          --i;
      }
    }

    return i / n;
  }

 private:
  string getCombined(const vector<string>& sentence) {
    string combined;
    for (const string& word : sentence)
      combined += (word + ' ');
    return combined;
  }
};",418
418,"class Solution {
 public:
  int countBattleships(vector<vector<char>>& board) {
    int ans = 0;

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j) {
        if (board[i][j] == '.')
          continue;
        if (i > 0 && board[i - 1][j] == 'X')
          continue;
        if (j > 0 && board[i][j - 1] == 'X')
          continue;
        ++ans;
      }

    return ans;
  }
};",419
419,"class Solution {
 public:
  int strongPasswordChecker(string password) {
    const int n = password.length();
    const int missing = getMissing(password);
    // the number of replacements to deal with 3 repeating characters
    int replaces = 0;
    // the number of sequences that can be substituted with 1 deletions,
    // (3k)-seqs
    int oneSeq = 0;
    // the number of sequences that can be substituted with 2 deletions,
    // (3k + 1)-seqs
    int twoSeq = 0;

    for (int i = 2; i < n;)
      if (password[i] == password[i - 1] &&
          password[i - 1] == password[i - 2]) {
        int length = 2;  // the length of the repeating password
        while (i < n && password[i] == password[i - 1]) {
          ++length;
          ++i;
        }
        replaces += length / 3;  // 'aaaaaaa' -> 'aaxaaxa'
        if (length % 3 == 0)
          ++oneSeq;
        if (length % 3 == 1)
          ++twoSeq;
      } else {
        ++i;
      }

    if (n < 6)
      return max(6 - n, missing);
    if (n <= 20)
      return max(replaces, missing);

    const int deletes = n - 20;
    // Each replacement in (3k)-seqs can be substituted with 1 deletions.
    replaces -= min(oneSeq, deletes);
    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.
    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;
    // Each replacement in other seqs can be substituted with 3 deletions.
    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;
    return deletes + max(replaces, missing);
  }

 private:
  int getMissing(const string& password) {
    return 3 -  //
           ranges::any_of(password, [](char c) { return isupper(c); }) -
           ranges::any_of(password, [](char c) { return islower(c); }) -
           ranges::any_of(password, [](char c) { return isdigit(c); });
  }
};",420
420,"class Solution {
 public:
  int findMaximumXOR(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    if (maxNum == 0)
      return 0;
    const int maxBit = static_cast<int>(log2(maxNum));
    int ans = 0;
    int prefixMask = 0;  // Grows like: 10000 -> 11000 -> ... -> 11111.

    // If ans is 11100 when i = 2, it means that before we reach the last two
    // bits, 11100 is the maximum XOR we have, and we're going to explore if we
    // can get another two 1s and put them into `ans`.
    for (int i = maxBit; i >= 0; --i) {
      prefixMask |= 1 << i;
      unordered_set<int> prefixes;
      // We only care about the left parts,
      // If i = 2, nums = {1110, 1011, 0111}
      //    -> prefixes = {1100, 1000, 0100}
      for (const int num : nums)
        prefixes.insert(num & prefixMask);
      // If i = 1 and before this iteration, the ans is 10100, it means that we
      // want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for
      // XOR of two prefixes = candidate.
      const int candidate = ans | 1 << i;
      for (const int prefix : prefixes)
        if (prefixes.count(prefix ^ candidate)) {
          ans = candidate;
          break;
        }
    }

    return ans;
  }
};",421
421,"class Solution {
 public:
  bool validWordSquare(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i)
      for (int j = 0; j < words[i].size(); ++j) {
        if (words.size() <= j || words[j].size() <= i)  // out-of-bounds
          return false;
        if (words[i][j] != words[j][i])
          return false;
      }
    return true;
  }
};",422
422,"class Solution {
 public:
  string originalDigits(string s) {
    string ans;
    vector<int> count(10);

    for (const char c : s) {
      if (c == 'z')
        ++count[0];
      if (c == 'o')
        ++count[1];
      if (c == 'w')
        ++count[2];
      if (c == 'h')
        ++count[3];
      if (c == 'u')
        ++count[4];
      if (c == 'f')
        ++count[5];
      if (c == 'x')
        ++count[6];
      if (c == 's')
        ++count[7];
      if (c == 'g')
        ++count[8];
      if (c == 'i')
        ++count[9];
    }

    count[1] -= count[0] + count[2] + count[4];
    count[3] -= count[8];
    count[5] -= count[4];
    count[7] -= count[6];
    count[9] -= count[5] + count[6] + count[8];

    for (int i = 0; i < 10; ++i)
      for (int j = 0; j < count[i]; ++j)
        ans += i + '0';

    return ans;
  }
};",423
423,"class Solution {
 public:
  int characterReplacement(string s, int k) {
    int ans = 0;
    int maxCount = 0;
    vector<int> count(26);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      maxCount = max(maxCount, ++count[s[r] - 'A']);
      while (maxCount + k < r - l + 1)
        --count[s[l++] - 'A'];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",424
424,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  vector<const string*> startsWith;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  Trie(const vector<string>& words) {
    for (const string& word : words)
      insert(word);
  }

  vector<const string*> findBy(const string& prefix) {
    shared_ptr<TrieNode> node = root;
    for (const char c : prefix) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return {};
      node = node->children[i];
    }
    return node->startsWith;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      node->startsWith.push_back(&word);
    }
  }
};

class Solution {
 public:
  vector<vector<string>> wordSquares(vector<string>& words) {
    if (words.empty())
      return {};

    const int n = words[0].length();
    vector<vector<string>> ans;
    vector<string> path;
    Trie trie(words);

    for (const string& word : words) {
      path.push_back(word);
      dfs(trie, n, path, ans);
      path.pop_back();
    }

    return ans;
  }

 private:
  void dfs(Trie& trie, const int n, vector<string>& path,
           vector<vector<string>>& ans) {
    if (path.size() == n) {
      ans.push_back(path);
      return;
    }

    const string prefix = getPrefix(path);

    for (const string* s : trie.findBy(prefix)) {
      path.push_back(*s);
      dfs(trie, n, path, ans);
      path.pop_back();
    }
  }

  // e.g. path = [""wall"",
  //              ""area""]
  //    prefix =  ""le..""
  string getPrefix(const vector<string>& path) {
    string prefix;
    const int index = path.size();
    for (const string& s : path)
      prefix += s[index];
    return prefix;
  }
};",425
425,"class Solution {
 public:
  Node* treeToDoublyList(Node* root) {
    if (root == nullptr)
      return nullptr;

    Node* leftHead = treeToDoublyList(root->left);
    Node* rightHead = treeToDoublyList(root->right);
    root->left = root;
    root->right = root;
    return connect(connect(leftHead, root), rightHead);
  }

 private:
  Node* connect(Node* node1, Node* node2) {
    if (node1 == nullptr)
      return node2;
    if (node2 == nullptr)
      return node1;

    Node* tail1 = node1->left;
    Node* tail2 = node2->left;

    // Connect node1's tail with node2.
    tail1->right = node2;
    node2->left = tail1;

    // Connect node2's tail with node1.
    tail2->right = node1;
    node1->left = tail2;
    return node1;
  }
};",426
426,"class Solution {
 public:
  Node* construct(vector<vector<int>>& grid) {
    return helper(grid, 0, 0, grid.size());
  }

 private:
  Node* helper(const vector<vector<int>>& grid, int i, int j, int w) {
    if (allSame(grid, i, j, w))
      return new Node(grid[i][j], true);

    Node* node = new Node(true, false);
    node->topLeft = helper(grid, i, j, w / 2);
    node->topRight = helper(grid, i, j + w / 2, w / 2);
    node->bottomLeft = helper(grid, i + w / 2, j, w / 2);
    node->bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);
    return node;
  }

  bool allSame(const vector<vector<int>>& grid, int i, int j, int w) {
    return all_of(grid.begin() + i, grid.begin() + i + w,
                  [&](const vector<int>& row) {
      return all_of(row.begin() + j, row.begin() + j + w,
                    [&](int num) { return num == grid[i][j]; });
    });
  }
};",427
427,"class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(Node* root) {
    if (root == nullptr)
      return """";

    string s;
    queue<Node*> q{{root}};
    s += to_string(root->val) + "" "";

    while (!q.empty())
      for (int sz = q.size(); sz > 0; --sz) {
        Node* node = q.front();
        q.pop();
        if (node->children.empty()) {
          s += ""n"";
        } else {
          for (Node* child : node->children) {
            q.push(child);
            s += to_string(child->val) + ""#"";
          }
        }
        s += "" "";
      }

    return s;
  }

  // Decodes your encoded data to tree.
  Node* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    string word;
    iss >> word;
    Node* root = new Node(stoi(word));
    queue<Node*> q{{root}};

    while (iss >> word) {
      Node* parent = q.front();
      q.pop();
      vector<string> kids = getKids(word);
      vector<Node*> children;
      for (const string& kid : kids) {
        if (kid == ""n"")
          continue;
        Node* child = new Node(stoi(kid));
        children.push_back(child);
        q.push(child);
      }
      parent->children = children;
    }

    return root;
  }

 private:
  vector<string> getKids(const string& word) {
    vector<string> kids;
    for (int i = 0, j = 0; j < word.length(); ++j)
      if (word[j] == '#') {
        kids.push_back(word.substr(i, j - i));
        i = j + 1;
      }
    return kids;
  }
};",428
428,"class Solution {
 public:
  vector<vector<int>> levelOrder(Node* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<Node*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        Node* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        for (Node* child : node->children)
          q.push(child);
      }
      ans.push_back(currLevel);
    }

    return ans;
  }
};",429
429,"class Solution {
 public:
  Node* flatten(Node* head, Node* rest = nullptr) {
    if (head == nullptr)
      return rest;

    head->next = flatten(head->child, flatten(head->next, rest));
    if (head->next)
      head->next->prev = head;
    head->child = nullptr;
    return head;
  }
};",430
430,"class Codec {
 public:
  // Encodes an n-ary tree to a binary tree.
  TreeNode* encode(Node* root) {
    if (root == nullptr)
      return nullptr;

    TreeNode* rootTreeNode = new TreeNode(root->val);
    queue<pair<Node*, TreeNode*>> q{{{root, rootTreeNode}}};

    while (!q.empty()) {
      const auto [parentNode, parentTreeNode] = q.front();
      q.pop();
      TreeNode* prevTreeNode = nullptr;
      TreeNode* headTreeNode = nullptr;
      for (Node* child : parentNode->children) {
        TreeNode* currTreeNode = new TreeNode(child->val);
        if (prevTreeNode != nullptr)
          prevTreeNode->right = currTreeNode;
        else
          headTreeNode = currTreeNode;
        prevTreeNode = currTreeNode;
        q.emplace(child, currTreeNode);
      }
      parentTreeNode->left = headTreeNode;
    }

    return rootTreeNode;
  }

  // Decodes your binary tree to an n-ary tree.
  Node* decode(TreeNode* root) {
    if (root == nullptr)
      return nullptr;

    Node* rootNode = new Node(root->val);
    queue<pair<Node*, TreeNode*>> q{{{rootNode, root}}};

    while (!q.empty()) {
      const auto [parentNode, parentTreeNode] = q.front();
      q.pop();
      TreeNode* sibling = parentTreeNode->left;
      while (sibling) {
        Node* currNode = new Node(sibling->val);
        parentNode->children.push_back(currNode);
        q.emplace(currNode, sibling);
        sibling = sibling->right;
      }
    }

    return rootNode;
  }
};",431
431,"class AllOne {
 public:
  void inc(string key) {
    const auto it = keyToIterator.find(key);

    // Doesn't find the key.
    if (it == keyToIterator.cend()) {
      if (l.empty() || l.front().value > 1)
        l.push_front({1, {key}});
      else
        l.front().keys.insert(key);
      keyToIterator[key] = l.begin();
      return;
    }

    const auto lit = it->second;  // list iterator
    auto nit = next(lit);         // next iterator

    if (nit == l.end() || nit->value > lit->value + 1)
      nit = l.insert(nit, {lit->value + 1, {key}});
    else  // nit->value == lit->value + 1
      nit->keys.insert(key);
    keyToIterator[key] = nit;  // Reset the mapping.

    // Remove the key in the keys set.
    lit->keys.erase(key);
    if (lit->keys.empty())
      l.erase(lit);
  }

  void dec(string key) {
    const auto it = keyToIterator.find(key);

    // Doens't find the key.
    if (it == keyToIterator.cend())
      return;

    const auto lit = it->second;  // list iterator

    if (lit->value == 1) {
      // no need to find the previous iterator in this case.
      keyToIterator.erase(key);
    } else {
      auto pit = prev(lit);  // the previous iterator

      if (lit == l.begin() || pit->value < lit->value - 1)
        pit = l.insert(lit, {lit->value - 1, {key}});
      else  // pit->value == lit-value - 1
        pit->keys.insert(key);
      keyToIterator[key] = pit;  // Reset the mapping.
    }

    // Remove the key in the keys set.
    lit->keys.erase(key);
    if (lit->keys.empty())
      l.erase(lit);
  }

  string getMaxKey() {
    return l.empty() ? """" : *l.back(.cbegin().keys);
  }

  string getMinKey() {
    return l.empty() ? """" : *l.front(.cbegin().keys);
  }

 private:
  struct Node {
    int value;
    unordered_set<string> keys;
  };

  list<Node> l;
  unordered_map<string, list<Node>::iterator> keyToIterator;
};",432
432,"class Solution {
 public:
  int minMutation(string start, string end, vector<string>& bank) {
    unordered_set<string> bankSet{bank.begin(), bank.end()};
    if (!bankSet.count(end))
      return -1;

    int ans = 0;
    queue<string> q{{start}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int j = 0; j < word.length(); ++j) {
          const char cache = word[j];
          for (const char c : {'A', 'C', 'G', 'T'}) {
            word[j] = c;
            if (word == end)
              return ans;
            if (bankSet.count(word)) {
              bankSet.erase(word);
              q.push(word);
            }
          }
          word[j] = cache;
        }
      }
    }

    return -1;
  }
};",433
433,"class Solution {
 public:
  int countSegments(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i)
      if (s[i] != ' ' && (i == 0 || s[i - 1] == ' '))
        ++ans;

    return ans;
  }
};",434
434,"class Solution {
 public:
  int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    if (intervals.empty())
      return 0;

    ranges::sort(intervals,
                 [](const auto& a, const auto& b) { return a[1] < b[1]; });

    int ans = 0;
    int currentEnd = intervals[0][1];

    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i][0] >= currentEnd)
        currentEnd = intervals[i][1];
      else
        ++ans;

    return ans;
  }
};",435
435,"class Solution {
 public:
  vector<int> findRightInterval(vector<vector<int>>& intervals) {
    vector<int> ans;
    map<int, int> startToIndex;

    for (int i = 0; i < intervals.size(); ++i)
      startToIndex[intervals[i][0]] = i;

    for (const vector<int>& interval : intervals) {
      const auto it = startToIndex.lower_bound(interval[1]);
      if (it == startToIndex.cend())
        ans.push_back(-1);
      else
        ans.push_back(it->second);
    }

    return ans;
  }
};",436
436,"class Solution {
 public:
  int pathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;
    return dfs(root, sum) +            //
           pathSum(root->left, sum) +  //
           pathSum(root->right, sum);
  }

 private:
  int dfs(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;
    return (sum == root->val) +                //
           dfs(root->left, sum - root->val) +  //
           dfs(root->right, sum - root->val);
  }
};",437
437,"class Solution {
 public:
  vector<int> findAnagrams(string s, string p) {
    vector<int> ans;
    vector<int> count(128);
    int required = p.length();

    for (const char c : p)
      ++count[c];

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (--count[s[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 == p.length())
          ans.push_back(l);
        if (++count[s[l++]] > 0)
          ++required;
      }
    }

    return ans;
  }
};",438
438,"class Solution {
 public:
  string parseTernary(string expression) {
    const char c = expression[i];

    if (i + 1 == expression.length() || expression[i + 1] == ':') {
      i += 2;  // Skip ':'s.
      return string(1, c);
    }

    i += 2;  // Skip '?'s.
    const string& first = parseTernary(expression);
    const string& second = parseTernary(expression);
    return c == 'T' ? first : second;
  }

 private:
  int i = 0;
};",439
439,"class Solution {
 public:
  int findKthNumber(long n, int k) {
    auto getGap = [&n](long a, long b) {
      long gap = 0;
      while (a <= n) {
        gap += min(n + 1, b) - a;
        a *= 10;
        b *= 10;
      }
      return gap;
    };

    long currNum = 1;

    for (int i = 1; i < k;) {
      long gap = getGap(currNum, currNum + 1);
      if (i + gap <= k) {
        i += gap;
        ++currNum;
      } else {
        ++i;
        currNum *= 10;
      }
    }

    return currNum;
  }
};",440
440,"class Solution {
 public:
  int arrangeCoins(long n) {
    return (-1 + sqrt(8 * n + 1)) / 2;
  }
};",441
441,"class Solution {
 public:
  vector<int> findDuplicates(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums) {
      nums[abs(num) - 1] *= -1;
      if (nums[abs(num) - 1] > 0)
        ans.push_back(abs(num));
    }

    return ans;
  }
};",442
442,"class Solution {
 public:
  int compress(vector<char>& chars) {
    int ans = 0;

    for (int i = 0; i < chars.size();) {
      const char letter = chars[i];
      int count = 0;
      while (i < chars.size() && chars[i] == letter) {
        ++count;
        ++i;
      }
      chars[ans++] = letter;
      if (count > 1)
        for (const char c : to_string(count))
          chars[ans++] = c;
    }

    return ans;
  }
};",443
443,"class Solution {
 public:
  bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {
    if (seqs.empty())
      return false;

    const int n = org.size();
    vector<vector<int>> graph(n);
    vector<int> inDegrees(n);

    // Build the graph.
    for (const vector<int>& seq : seqs) {
      if (seq.size() == 1 && seq[0] < 1 || seq[0] > n)
        return false;
      for (int i = 0; i + 1 < seq.size(); ++i) {
        const int u = seq[i];
        const int v = seq[i + 1];
        if (u < 1 || u > n || v < 1 || v > n)
          return false;
        graph[u - 1].push_back(v - 1);
        ++inDegrees[v - 1];
      }
    }

    // Perform topological sorting.
    queue<int> q;

    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        q.push(i);

    int i = 0;  // org's index

    while (!q.empty()) {
      if (q.size() > 1)
        return false;
      const int u = q.front();
      q.pop();
      if (u != org[i] - 1)
        return false;
      ++i;
      for (const int v : graph[u])
        if (--inDegrees[v] == 0)
          q.push(v);
    }

    return i == n;
  }
};",444
444,"class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    stack<ListNode*> stack1;
    stack<ListNode*> stack2;

    while (l1) {
      stack1.push(l1);
      l1 = l1->next;
    }

    while (l2) {
      stack2.push(l2);
      l2 = l2->next;
    }

    ListNode* head = nullptr;
    int carry = 0;

    while (carry || !stack1.empty() || !stack2.empty()) {
      if (!stack1.empty())
        carry += stack1.top()->val, stack1.pop();
      if (!stack2.empty())
        carry += stack2.top()->val, stack2.pop();
      ListNode* node = new ListNode(carry % 10);
      node->next = head;
      head = node;
      carry /= 10;
    }

    return head;
  }
};",445
445,"class Solution {
 public:
  int numberOfArithmeticSlices(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][j] := the number of subsequences end in nums[j] nums[i]
    vector<vector<int>> dp(n, vector<int>(n));
    unordered_map<long, vector<int>> numToIndices;

    for (int i = 0; i < n; ++i)
      numToIndices[nums[i]].push_back(i);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const long target = nums[j] * 2L - nums[i];
        if (const auto it = numToIndices.find(target);
            it != numToIndices.cend())
          for (const int k : it->second)
            if (k < j)
              dp[i][j] += (dp[j][k] + 1);
        ans += dp[i][j];
      }

    return ans;
  }
};",446
446,"class Solution {
 public:
  int numberOfBoomerangs(vector<vector<int>>& points) {
    int ans = 0;

    for (const vector<int>& p : points) {
      unordered_map<int, int> distCount;
      for (const vector<int>& q : points) {
        const int dist = getDist(p, q);
        ++distCount[dist];
      }
      for (const auto& [_, freq] : distCount)
        ans += freq * (freq - 1);  // C(freq, 2)
    }

    return ans;
  }

 private:
  int getDist(const vector<int>& p, const vector<int>& q) {
    return pow(p[0] - q[0], 2) + pow(p[1] - q[1], 2);
  }
};",447
447,"class Solution {
 public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums) {
      const int index = abs(num) - 1;
      nums[index] = -abs(nums[index]);
    }

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > 0)
        ans.push_back(i + 1);

    return ans;
  }
};",448
448,"class Codec {
 public:
  string serialize(TreeNode* root) {
    if (root == nullptr)
      return """";

    string s;

    serialize(root, s);
    return s;
  }

  TreeNode* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    queue<int> q;

    for (string s; iss >> s;)
      q.push(stoi(s));

    return deserialize(INT_MIN, INT_MAX, q);
  }

 private:
  void serialize(TreeNode* root, string& s) {
    if (root == nullptr)
      return;

    s += to_string(root->val) + "" "";
    serialize(root->left, s);
    serialize(root->right, s);
  }

  TreeNode* deserialize(int min, int max, queue<int>& q) {
    if (q.empty())
      return nullptr;

    const int val = q.front();
    if (val < min || val > max)
      return nullptr;

    q.pop();
    TreeNode* root = new TreeNode(val);
    root->left = deserialize(min, val, q);
    root->right = deserialize(val, max, q);
    return root;
  }
};",449
449,"class Solution {
 public:
  TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr)
      return nullptr;
    if (root->val == key) {
      if (root->left == nullptr)
        return root->right;
      if (root->right == nullptr)
        return root->left;
      TreeNode* minNode = getMin(root->right);
      root->right = deleteNode(root->right, minNode->val);
      minNode->left = root->left;
      minNode->right = root->right;
      root = minNode;
    } else if (root->val < key) {
      root->right = deleteNode(root->right, key);
    } else {  // root->val > key
      root->left = deleteNode(root->left, key);
    }
    return root;
  }

 private:
  TreeNode* getMin(TreeNode* node) {
    while (node->left)
      node = node->left;
    return node;
  }
};",450
450,"class Solution {
 public:
  string frequencySort(string s) {
    const int n = s.length();
    string ans;
    vector<int> count(128);
    // buckets[i] := characters that appear i times in s
    vector<vector<char>> buckets(n + 1);

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < 128; ++i) {
      const int freq = count[i];
      if (freq > 0)
        buckets[freq].push_back((char)i);
    }

    for (int freq = n; freq > 0; --freq)
      for (const char c : buckets[freq])
        ans += string(freq, c);

    return ans;
  }
};",451
451,"class Solution {
 public:
  int findMinArrowShots(vector<vector<int>>& points) {
    ranges::sort(points,
                 [](const auto& a, const auto& b) { return a[1] < b[1]; });

    int ans = 1;
    int arrowX = points[0][1];

    for (int i = 1; i < points.size(); ++i)
      if (points[i][0] > arrowX) {
        arrowX = points[i][1];
        ++ans;
      }

    return ans;
  }
};",452
452,"class Solution {
 public:
  int minMoves(vector<int>& nums) {
    const int min = ranges::min(nums);
    return accumulate(nums.begin(), nums.end(), 0,
                      [&](int a, int b) { return a + (b - min); });
  }
};",453
453,"class Solution {
 public:
  int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                   vector<int>& nums4) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int a : nums1)
      for (const int b : nums2)
        ++count[a + b];

    for (const int c : nums3)
      for (const int d : nums4)
        if (const auto it = count.find(-c - d); it != count.cend())
          ans += it->second;

    return ans;
  }
};",454
454,"class Solution {
 public:
  int findContentChildren(vector<int>& g, vector<int>& s) {
    ranges::sort(g);
    ranges::sort(s);

    int i = 0;
    for (int j = 0; j < s.size() && i < g.size(); ++j)
      if (g[i] <= s[j])
        ++i;

    return i;
  }
};",455
455,"class Solution {
 public:
  bool find132pattern(vector<int>& nums) {
    stack<int> stack;  // a decreasing stack
    int ak = INT_MIN;  // We want to find a seq ai < ak < aj.

    for (int i = nums.size() - 1; i >= 0; --i) {
      // If ai < ak, we're done because ai must < aj.
      if (nums[i] < ak)
        return true;
      while (!stack.empty() && stack.top() < nums[i])
        ak = stack.top(), stack.pop();
      stack.push(nums[i]);  // `nums[i]` is a candidate of aj.
    }

    return false;
  }
};",456
456,"class Solution {
 public:
  bool circularArrayLoop(vector<int>& nums) {
    const int n = nums.size();
    if (n < 2)
      return false;

    auto advance = [&](int i) {
      const int val = (i + nums[i]) % n;
      return i + nums[i] >= 0 ? val : n + val;
    };

    for (int i = 0; i < n; ++i) {
      if (nums[i] == 0)
        continue;
      int slow = i;
      int fast = advance(slow);
      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {
        if (slow == fast) {
          if (slow == advance(slow))
            break;
          return true;
        }
        slow = advance(slow);
        fast = advance(advance(fast));
      }

      slow = i;
      const int sign = nums[i];
      while (sign * nums[slow] > 0) {
        const int next = advance(slow);
        nums[slow] = 0;
        slow = next;
      }
    }

    return false;
  }
};",457
457,"class Solution {
 public:
  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    const int base = minutesToTest / minutesToDie + 1;
    int ans = 0;
    for (int x = 1; x < buckets; x *= base)
      ++ans;
    return ans;
  }
};",458
458,"class Solution {
 public:
  bool repeatedSubstringPattern(string s) {
    const string ss = s + s;
    return ss.substr(1, ss.length() - 2).find(s) != string::npos;
  }
};",459
459,"struct Node {
  int key;
  int value;
  int freq;
  list<int>::const_iterator it;
};

class LFUCache {
 public:
  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}

  int get(int key) {
    const auto it = keyToNode.find(key);
    if (it == keyToNode.cend())
      return -1;

    Node& node = it->second;
    touch(node);
    return node.value;
  }

  void put(int key, int value) {
    if (capacity == 0)
      return;
    if (const auto it = keyToNode.find(key); it != keyToNode.cend()) {
      Node& node = it->second;
      node.value = value;
      touch(node);
      return;
    }

    if (keyToNode.size() == capacity) {
      // Evict an LRU key from `minFreq` list.
      const int keyToEvict = freqToList[minFreq].back();
      freqToList[minFreq].pop_back();
      keyToNode.erase(keyToEvict);
    }

    minFreq = 1;
    freqToList[1].push_front(key);
    keyToNode[key] = {key, value, 1, freqToList[1].cbegin()};
  }

 private:
  int capacity;
  int minFreq;
  unordered_map<int, Node> keyToNode;
  unordered_map<int, list<int>> freqToList;

  void touch(Node& node) {
    // Update the node's frequency.
    const int prevFreq = node.freq;
    const int newFreq = ++node.freq;

    // Remove the iterator from `prevFreq`'s list
    freqToList[prevFreq].erase(node.it);
    if (freqToList[prevFreq].empty()) {
      freqToList.erase(prevFreq);
      // Update `minFreq` if needed.
      if (prevFreq == minFreq)
        ++minFreq;
    }

    // Insert the key to the front of `newFreq`'s list.
    freqToList[newFreq].push_front(node.key);
    node.it = freqToList[newFreq].cbegin();
  }
};",460
460,"class Solution {
 public:
  int hammingDistance(int x, int y) {
    int ans = 0;

    while (x || y) {
      ans += (x & 1) ^ (y & 1);
      x >>= 1;
      y >>= 1;
    }

    return ans;
  }
};",461
461,"class Solution {
 public:
  int minMoves2(vector<int>& nums) {
    const int n = nums.size();
    nth_element(nums.begin(), nums.begin() + n / 2, nums.end());
    const int median = nums[n / 2];
    return accumulate(nums.begin(), nums.end(), 0,
                      [&](int a, int b) { return a + abs(b - median); });
  }
};",462
462,"class Solution {
 public:
  int islandPerimeter(vector<vector<int>>& grid) {
    int islands = 0;
    int neighbors = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j]) {
          ++islands;
          if (i - 1 >= 0 && grid[i - 1][j])
            ++neighbors;
          if (j - 1 >= 0 && grid[i][j - 1])
            ++neighbors;
        }

    return islands * 4 - neighbors * 2;
  }
};",463
463,"class Solution {
 public:
  bool canIWin(int maxChoosableInteger, int desiredTotal) {
    if (desiredTotal <= 0)
      return true;

    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;
    if (sum < desiredTotal)
      return false;

    unordered_map<int, bool> mem;
    return canIWin(desiredTotal, 0, maxChoosableInteger, mem);
  }

 private:
  // Returns true if the first player can we, where `used` represents the used
  // numbers.
  bool canIWin(int total, int used, const int& maxChoosableInteger,
               unordered_map<int, bool>& mem) {
    if (total <= 0)
      return false;
    if (const auto it = mem.find(used); it != mem.cend())
      return it->second;

    for (int i = 1; i <= maxChoosableInteger; ++i) {
      if (used >> i & 1)  // Integer i is used.
        continue;
      if (!canIWin(total - i, used | 1 << i, maxChoosableInteger, mem))
        return true;
    }

    return mem[used] = false;
  }
};",464
464,"class Solution {
 public:
  int minTransfers(vector<vector<int>>& transactions) {
    vector<int> balance(21);
    vector<int> debts;

    for (const vector<int>& t : transactions) {
      const int from = t[0];
      const int to = t[1];
      const int amount = t[2];
      balance[from] -= amount;
      balance[to] += amount;
    }

    for (const int b : balance)
      if (b > 0)
        debts.push_back(b);

    return dfs(debts, 0);
  }

 private:
  int dfs(vector<int>& debts, int s) {
    while (s < debts.size() && !debts[s])
      ++s;
    if (s == debts.size())
      return 0;

    int ans = INT_MAX;

    for (int i = s + 1; i < debts.size(); ++i)
      if (debts[i] * debts[s] < 0) {
        debts[i] += debts[s];  // `debts[s]` is settled.
        ans = min(ans, 1 + dfs(debts, s + 1));
        debts[i] -= debts[s];  // Backtrack.
      }

    return ans;
  }
};",465
465,"struct Record {
  int count;
  int nextIndex;
  Record(int count, int nextIndex) : count(count), nextIndex(nextIndex) {}
};

class Solution {
 public:
  int getMaxRepetitions(string s1, int n1, string s2, int n2) {
    // [count(s1 matches s2[i..n)), next index of s2[i..n)]
    vector<Record> records;

    for (int i = 0; i < s2.length(); ++i) {
      int count = 0;
      int nextIndex = i;
      for (int j = 0; j < s1.length(); ++j)
        if (s2[nextIndex] == s1[j])
          if (++nextIndex == s2.length()) {  // There's a match.
            ++count;
            nextIndex = 0;
          }
      records.emplace_back(count, nextIndex);
    }

    int matches = 0;  // `s1` matches `s2`.
    int index = 0;

    while (n1--) {
      matches += records[index].count;
      index = records[index].nextIndex;
    }

    return matches / n2;  // `s1` matches `s2`.
  }
};",466
466,"class Solution {
 public:
  int findSubstringInWraproundString(string p) {
    int maxLength = 1;
    // count[i] := the number of substrings ending in ('a' + i)
    vector<int> count(26);

    for (int i = 0; i < p.length(); ++i) {
      if (i > 0 && (p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25))
        ++maxLength;
      else
        maxLength = 1;
      const int index = p[i] - 'a';
      count[index] = max(count[index], maxLength);
    }

    return accumulate(count.begin(), count.end(), 0);
  }
};",467
467,"class Solution {
 public:
  string validIPAddress(string IP) {
    string digit;
    istringstream iss(IP);

    if (ranges::count(IP, '.') == 3) {
      for (int i = 0; i < 4; ++i)  // Make sure that we have four parts.
        if (!getline(iss, digit, '.') || !isIPv4(digit))
          return ""Neither"";
      return ""IPv4"";
    }

    if (ranges::count(IP, ':') == 7) {
      for (int i = 0; i < 8; ++i)  // Make sure that we have eight parts.
        if (!getline(iss, digit, ':') || !isIPv6(digit))
          return ""Neither"";
      return ""IPv6"";
    }

    return ""Neither"";
  }

 private:
  static inline string validIPv6Chars = ""0123456789abcdefABCDEF"";

  bool isIPv4(const string& digit) {
    if (digit.empty() || digit.length() > 3)
      return false;
    if (digit.length() > 1 && digit[0] == '0')
      return false;

    for (const char c : digit)
      if (c < '0' || c > '9')
        return false;

    const int num = stoi(digit);
    return 0 <= num && num <= 255;
  }

  bool isIPv6(const string& digit) {
    if (digit.empty() || digit.length() > 4)
      return false;

    for (const char c : digit)
      if (validIPv6Chars.find(c) == string::npos)
        return false;

    return true;
  }
};",468
468,"class Solution {
 public:
  bool isConvex(vector<vector<int>>& points) {
    auto getCross = [](const vector<int>& p, const vector<int>& q,
                       const vector<int>& r) -> int {
      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]);
    };

    const int n = points.size();
    long sign = 0;

    for (int i = 0; i < points.size(); ++i) {
      const int cross =
          getCross(points[i], points[(i + 1) % n], points[(i + 2) % n]);
      if (cross == 0)  // p, q, r are collinear.
        continue;
      if (sign == 0)  // Find the first cross that's not 0.
        sign = cross;
      else if (cross * sign < 0)
        return false;
    }

    return true;
  }
};",469
469,"// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
 public:
  int rand10() {
    int num = 40;

    while (num >= 40)
      num = (rand7() - 1) * 7 + rand7() - 1;

    return num % 10 + 1;
  }
};",470
470,"class Solution {
 public:
  string encode(string s) {
    const int n = s.length();
    vector<vector<string>> mem(n, vector<string>(n));
    return encode(s, 0, n - 1);
  }

 private:
  // Returns the shortest encoded string of s[i..j].
  string encode(const string& s, int i, int j, vector<vector<string>>& mem) {
    if (!mem[i][j].empty())
      return mem[i][j];

    const string& curr = s.substr(i, j - i + 1);
    mem[i][j] = curr;

    if (mem[i][j].length() < 5)
      return mem[i][j];

    // Try all the possible partitions.
    for (int k = i; k < j; ++k) {
      const string& l = encode(s, i, k, mem);
      const string& r = encode(s, k + 1, j, mem);
      if (l.length() + r.length() < mem[i][j].length())
        mem[i][j] = l + r;
    }

    // Try to compress the string.
    // e.g. s = aabaabaab -> 3[aab]
    for (int k = i; k <= j; ++k) {
      const string& pattern = s.substr(i, k - i + 1);
      if (curr.length() % pattern.length() == 0 &&
          regex_replace(curr, regex(pattern), """").empty()) {
        const string& candidate = to_string(curr.length() / pattern.length()) +
                                  '[' + encode(s, i, k, mem) + ']';
        if (candidate.length() < mem[i][j].length())
          mem[i][j] = candidate;
      }
    }

    return mem[i][j];
  }
};",471
471,"class Solution {
 public:
  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
    vector<string> ans;
    unordered_set<string> wordSet{words.begin(), words.end()};
    unordered_map<string, bool> mem;

    for (const string& word : words)
      if (isConcat(word, wordSet, mem))
        ans.push_back(word);

    return ans;
  }

 private:
  bool isConcat(const string& s, const unordered_set<string>& wordSet,
                unordered_map<string, bool>& mem) {
    if (const auto it = mem.find(s); it != mem.cend())
      return it->second;

    for (int i = 1; i < s.length(); ++i) {
      const string prefix = s.substr(0, i);
      const string suffix = s.substr(i);
      if (wordSet.count(prefix) &&
          (wordSet.count(suffix) || isConcat(suffix, wordSet, mem)))
        return mem[s] = true;
    }

    return mem[s] = false;
  }
};",472
472,"class Solution {
 public:
  bool makesquare(vector<int>& matchsticks) {
    if (matchsticks.size() < 4)
      return false;

    const int perimeter = accumulate(matchsticks.begin(), matchsticks.end(), 0);
    if (perimeter % 4 != 0)
      return false;

    ranges::sort(matchsticks, greater<int>());
    return dfs(matchsticks, 0, vector<int>(4, perimeter / 4));
  }

 private:
  bool dfs(const vector<int>& matchsticks, int selected, vector<int>&& edges) {
    if (selected == matchsticks.size())
      return ranges::all_of(edges, [](int edge) { return edge == 0; });

    for (int i = 0; i < 4; ++i) {
      if (matchsticks[selected] > edges[i])
        continue;
      edges[i] -= matchsticks[selected];
      if (dfs(matchsticks, selected + 1, move(edges)))
        return true;
      edges[i] += matchsticks[selected];
    }

    return false;
  }
};",473
473,"class Solution {
 public:
  int findMaxForm(vector<string>& strs, int m, int n) {
    // dp[i][j] := the maximum size of the subset given i 0s and j 1s are
    // available
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (const string& s : strs) {
      const int count0 = ranges::count(s, '0');
      const int count1 = s.length() - count0;
      for (int i = m; i >= count0; --i)
        for (int j = n; j >= count1; --j)
          dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1);
    }

    return dp[m][n];
  }
};",474
474,"class Solution {
 public:
  int findRadius(vector<int>& houses, vector<int>& heaters) {
    ranges::sort(houses);
    ranges::sort(heaters);

    int ans = 0;
    int i = 0;  // heaters' index (currently used)

    for (const int house : houses) {
      while (i + 1 < heaters.size() &&
             house - heaters[i] > heaters[i + 1] - house)
        ++i;  // The next heater is better.
      ans = max(ans, abs(heaters[i] - house));
    }

    return ans;
  }
};",475
475,"class Solution {
 public:
  int findComplement(long num) {
    for (long i = 1; i <= num; i <<= 1)
      num ^= i;
    return num;
  }
};",476
476,"class Solution {
 public:
  int totalHammingDistance(vector<int>& nums) {
    constexpr int kMaxMask = 1 << 30;
    int ans = 0;

    for (int mask = 1; mask < kMaxMask; mask <<= 1) {
      const int ones =
          ranges::count_if(nums, [mask](int num) { return num & mask; });
      const int zeros = nums.size() - ones;
      ans += ones * zeros;
    }

    return ans;
  }
};",477
477,"class Solution {
 public:
  Solution(double radius, double x_center, double y_center)
      : radius(radius), x_center(x_center), y_center(y_center) {}

  vector<double> randPoint() {
    const double length = sqrt(distribution(generator)) * radius;
    const double degree = distribution(generator) * 2 * M_PI;
    const double x = x_center + length * cos(degree);
    const double y = y_center + length * sin(degree);
    return {x, y};
  }

 private:
  const double radius;
  const double x_center;
  const double y_center;
  default_random_engine generator;
  uniform_real_distribution<double> distribution =
      uniform_real_distribution<double>(0.0, 1.0);
};",478
478,"class Solution {
 public:
  int largestPalindrome(int n) {
    if (n == 1)
      return 9;

    constexpr int kMod = 1337;
    const int upper = pow(10, n) - 1;
    const int lower = pow(10, n - 1) - 1;

    for (int i = upper; i > lower; --i) {
      const long cand = getPalindromeCandidate(i);
      for (long j = upper; j * j >= cand; --j)
        if (cand % j == 0)
          return cand % kMod;
    }

    throw;
  }

 private:
  long getPalindromeCandidate(int i) {
    string reversed = to_string(i);
    reverse(reversed.begin(), reversed.end());
    return stol(to_string(i) + reversed);
  }
};",479
479,"class Solution {
 public:
  vector<double> medianSlidingWindow(vector<int>& nums, int k) {
    vector<double> ans;
    multiset<double> window(nums.begin(), nums.begin() + k);
    auto it = next(window.begin(), (k - 1) / 2);

    for (int i = k;; ++i) {
      const double median = k & 1 ? *it : (*it + *next(it)) / 2.0;
      ans.push_back(median);
      if (i == nums.size())
        break;
      window.insert(nums[i]);
      if (nums[i] < *it)
        --it;
      if (nums[i - k] <= *it)
        ++it;
      window.erase(window.lower_bound(nums[i - k]));
    }

    return ans;
  }
};",480
480,"class Solution {
 public:
  int magicalString(int n) {
    string s = "" 122"";

    for (int i = 3; i <= n; ++i)
      if (i & 1)
        s.append(s[i] - '0', '1');
      else
        s.append(s[i] - '0', '2');

    return count(s.begin(), s.begin() + n + 1, '1');
  }
};",481
481,"class Solution {
 public:
  string licenseKeyFormatting(string s, int k) {
    string ans;
    int length = 0;

    for (int i = s.length() - 1; i >= 0; --i) {
      if (s[i] == '-')
        continue;
      if (length > 0 && length % k == 0)
        ans += ""-"";
      ans += toupper(s[i]);
      ++length;
    }

    return {ans.rbegin(), ans.rend()};
  }
};",482
482,"class Solution {
 public:
  string smallestGoodBase(string n) {
    const long num = stol(n);

    for (int m = log2(num); m >= 2; --m) {
      const int k = pow(num, 1.0 / m);
      long sum = 1;
      long prod = 1;
      for (int i = 0; i < m; ++i) {
        prod *= k;
        sum += prod;
      }
      if (sum == num)
        return to_string(k);
    }

    return to_string(num - 1);
  }
};",483
483,"class Solution {
 public:
  vector<int> findPermutation(string s) {
    vector<int> ans;
    stack<int> stack;

    for (int i = 0; i < s.length(); ++i) {
      stack.push(i + 1);
      if (s[i] == 'I')
        while (!stack.empty())
          ans.push_back(stack.top()), stack.pop();
    }
    stack.push(s.length() + 1);

    while (!stack.empty())
      ans.push_back(stack.top()), stack.pop();

    return ans;
  }
};",484
484,"class Solution {
 public:
  int findMaxConsecutiveOnes(vector<int>& nums) {
    int ans = 0;
    int sum = 0;

    for (const int num : nums)
      if (num == 1)
        ans = max(ans, ++sum);
      else
        sum = 0;

    return ans;
  }
};",485
485,"class Solution {
 public:
  bool PredictTheWinner(vector<int>& nums) {
    const int n = nums.size();
    // dp[i][j] := the maximum number you can get more than your opponent in
    // nums[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = nums[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] >= 0;
  }
};",486
486,"class Solution {
 public:
  int findMaxConsecutiveOnes(vector<int>& nums) {
    int ans = 0;
    int zeros = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        ++zeros;
      while (zeros == 2)
        if (nums[l++] == 0)
          --zeros;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",487
487,"class Solution {
 public:
  int findMinStep(string board, string hand) {
    const int ans = dfs(board + ""#"", hand, {});
    return ans == INT_MAX ? -1 : ans;
  }

 private:
  int dfs(string&& board, const string& hand,
          unordered_map<string, int>&& mem) {
    const string hashKey = board + '#' + hand;
    if (const auto it = mem.find(hashKey); it != mem.cend())
      return it->second;
    board = deDup(board);
    if (board == ""#"")
      return 0;

    unordered_set<char> boardSet = unordered_set(board.begin(), board.end());

    string hs;  // hand that is in board
    for (const char h : hand)
      if (boardSet.count(h))
        hs += h;
    if (hs.empty())  // infeasible
      return INT_MAX;

    int ans = INT_MAX;

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < hs.size(); ++j) {
        // Place hs[j] in board[i].
        const string& newHand = hs.substr(0, j) + hs.substr(j + 1);
        string newBoard = board.substr(0, i) + hs[j] + board.substr(i);
        const int res = dfs(move(newBoard), newHand, move(mem));
        if (res < INT_MAX)
          ans = min(ans, 1 + res);
      }

    return mem[hashKey] = ans;
  }

  string deDup(string board) {
    int start = 0;  // the start index of a color sequenece
    for (int i = 0; i < board.size(); ++i)
      if (board[i] != board[start]) {
        if (i - start >= 3)
          return deDup(board.substr(0, start) + board.substr(i));
        start = i;  // Meet a new sequence.
      }
    return board;
  }
};",488
488,"/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * class Robot {
 *  public:
 *   // Returns true if the cell in front is open and robot moves into the cell.
 *   // Returns false if the cell in front is blocked and robot stays in the
 *   // Current cell. bool move();
 *
 *   // Robot will stay in the same cell after calling turnLeft/turnRight.
 *   // Each turn will be 90 degrees.
 *   void turnLeft();
 *   void turnRight();
 *
 *   // Clean the current cell.
 *   void clean();
 * };
 */

class Solution {
 public:
  void cleanRoom(Robot& robot) {
    dfs(robot, 0, 0, 0, unordered_set<pair<int, int>, PairHash>());
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };

  void dfs(Robot& robot, int i, int j, int d,
           unordered_set<pair<int, int>, PairHash>&& seen) {
    seen.insert({i, j});
    robot.clean();

    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <
    // The order is important since the idea is always turning right.
    for (int k = 0; k < 4; ++k) {
      const int newD = (d + k) % 4;
      const int x = i + dirs[newD][0];
      const int y = j + dirs[newD][1];
      if (!seen.count({x, y}) && robot.move()) {
        dfs(robot, x, y, newD, move(seen));
        // Go back to the previous cell.
        robot.turnRight();
        robot.turnRight();
        robot.move();
        // Go back to the original direction.
        robot.turnRight();
        robot.turnRight();
      }
      robot.turnRight();  // Always turn the robot clockwise.
    }
  }
};",489
489,"class Solution {
 public:
  bool hasPath(vector<vector<int>>& maze, vector<int>& start,
               vector<int>& destination) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = maze.size();
    const int n = maze[0].size();
    queue<pair<int, int>> q{{{start[0], start[1]}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[start[0]][start[1]] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        int x = i;
        int y = j;
        while (isValid(maze, x + dx, y + dy)) {
          x += dx;
          y += dy;
        }
        if (x == destination[0] && y == destination[1])
          return true;
        if (seen[x][y])
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

 private:
  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return 0 <= x && x < maze.size() && 0 <= y && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};",490
490,"class Solution {
 public:
  vector<vector<int>> findSubsequences(vector<int>& nums) {
    vector<vector<int>> ans;
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() > 1)
      ans.push_back(path);

    unordered_set<int> used;

    for (int i = s; i < nums.size(); ++i) {
      if (used.count(nums[i]))
        continue;
      if (path.empty() || nums[i] >= path.back()) {
        used.insert(nums[i]);
        path.push_back(nums[i]);
        dfs(nums, i + 1, move(path), ans);
        path.pop_back();
      }
    }
  }
};",491
491,"class Solution {
 public:
  vector<int> constructRectangle(int area) {
    int width = sqrt(area);

    while (area % width)
      --width;

    return {area / width, width};
  }
};",492
492,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int reversePairs(vector<int>& nums) {
    int ans = 0;
    unordered_map<long, int> ranks;
    getRanks(nums, ranks);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const long num = nums[i];
      ans += tree.get(ranks[num] - 1);
      tree.update(ranks[num * 2], 1);
    }

    return ans;
  }

 private:
  void getRanks(const vector<int>& nums, unordered_map<long, int>& ranks) {
    set<long> sorted(nums.begin(), nums.end());
    for (const long num : nums)
      sorted.insert(num * 2);
    int rank = 0;
    for (const long num : sorted)
      ranks[num] = ++rank;
  }
};",493
493,"class Solution {
 public:
  int findTargetSumWays(vector<int>& nums, int target) {
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum < abs(target) || (sum + target) & 1)
      return 0;
    return knapsack(nums, (sum + target) / 2);
  }

 private:
  int knapsack(const vector<int>& nums, int target) {
    const int n = nums.size();
    // dp[i][j] := the number of ways to sum to j by nums[0..i)
    vector<vector<int>> dp(n + 1, vector<int>(target + 1));
    dp[0][0] = 1;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 0; j <= target; ++j)
        if (j < num)
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num];
    }

    return dp[n][target];
  }
};",494
494,"class Solution {
 public:
  int findPoisonedDuration(vector<int>& timeSeries, int duration) {
    if (duration == 0)
      return 0;

    int ans = 0;

    for (int i = 0; i + 1 < timeSeries.size(); ++i)
      ans += min(timeSeries[i + 1] - timeSeries[i], duration);

    return ans + duration;
  }
};",495
495,"class Solution {
 public:
  vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_map<int, int> numToNextGreater;
    stack<int> stack;  // a decreasing stack

    for (const int num : nums2) {
      while (!stack.empty() && stack.top() < num)
        numToNextGreater[stack.top()] = num, stack.pop();
      stack.push(num);
    }

    for (const int num : nums1)
      if (const auto it = numToNextGreater.find(num);
          it != numToNextGreater.cend())
        ans.push_back(it->second);
      else
        ans.push_back(-1);

    return ans;
  }
};",496
496,pick(),497
497,"class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans(m * n);
    int d = 1;  // left-bottom -> right-top
    int row = 0;
    int col = 0;

    for (int i = 0; i < m * n; ++i) {
      ans[i] = matrix[row][col];
      row -= d;
      col += d;
      // out-of-bounds
      if (row == m)
        row = m - 1, col += 2, d = -d;
      if (col == n)
        col = n - 1, row += 2, d = -d;
      if (row < 0)
        row = 0, d = -d;
      if (col < 0)
        col = 0, d = -d;
    }

    return ans;
  }
};",498
498,"class Solution {
 public:
  string findShortestWay(vector<vector<int>>& maze, vector<int>& ball,
                         vector<int>& hole) {
    string ans = ""impossible"";
    dfs(maze, ball[0], ball[1], hole, 0, 0, 0, INT_MAX, """", ans);
    return ans;
  }

 private:
  void dfs(vector<vector<int>>& maze, int i, int j, const vector<int>& hole,
           int dx, int dy, int steps, int&& minSteps, string&& path,
           string& ans) {
    if (steps >= minSteps)
      return;

    if (dx != 0 || dy != 0) {  // Both are zeros for the initial ball position.
      while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 &&
             j + dy < maze[0].size() && maze[i + dx][j + dy] != 1) {
        i += dx;
        j += dy;
        ++steps;
        if (i == hole[0] && j == hole[1] && steps < minSteps) {
          minSteps = steps;
          ans = path;
        }
      }
    }

    if (maze[i][j] == 0 || steps + 2 < maze[i][j]) {
      maze[i][j] = steps + 2;  // +2 because maze[i][j] == 0 || 1.
      if (dx == 0)
        dfs(maze, i, j, hole, 1, 0, steps, move(minSteps), path + ""d"", ans);
      if (dy == 0)
        dfs(maze, i, j, hole, 0, -1, steps, move(minSteps), path + ""l"", ans);
      if (dy == 0)
        dfs(maze, i, j, hole, 0, 1, steps, move(minSteps), path + ""r"", ans);
      if (dx == 0)
        dfs(maze, i, j, hole, -1, 0, steps, move(minSteps), path + ""u"", ans);
    }
  }
};",499
499,"class Solution {
 public:
  vector<string> findWords(vector<string>& words) {
    vector<string> ans;
    const vector<int> rows{2, 3, 3, 2, 1, 2, 2, 2, 1, 2, 2, 2, 3,
                           3, 1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 3};

    for (const string& word : words) {
      string lowerWord = word;
      ranges::transform(lowerWord, lowerWord.begin(), ::tolower);
      const int row = rows[lowerWord[0] - 'a'];
      const bool isValid = ranges::all_of(
          lowerWord, [&](int c) { return rows[c - 'a'] == row; });
      if (isValid)
        ans.push_back(word);
    }

    return ans;
  }
};",500
500,"class Solution {
 public:
  vector<int> findMode(TreeNode* root) {
    vector<int> ans;
    int count = 0;
    int maxCount = 0;

    inorder(root, count, maxCount, ans);
    return ans;
  }

 private:
  TreeNode* pred = nullptr;

  void inorder(TreeNode* root, int& count, int& maxCount, vector<int>& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, count, maxCount, ans);
    updateCount(root, count, maxCount, ans);
    inorder(root->right, count, maxCount, ans);
  }

  void updateCount(TreeNode* root, int& count, int& maxCount,
                   vector<int>& ans) {
    if (pred && pred->val == root->val)
      ++count;
    else
      count = 1;

    if (count > maxCount) {
      maxCount = count;
      ans = {root->val};
    } else if (count == maxCount) {
      ans.push_back(root->val);
    }

    pred = root;
  }
};",501
501,"struct T {
  int pro;
  int cap;
  T(int pro, int cap) : pro(pro), cap(cap) {}
};

class Solution {
 public:
  int findMaximizedCapital(int k, int W, vector<int>& Profits,
                           vector<int>& Capital) {
    auto compareC = [](const T& a, const T& b) { return a.cap > b.cap; };
    auto compareP = [](const T& a, const T& b) { return a.pro < b.pro; };
    priority_queue<T, vector<T>, decltype(compareC)> minHeap(compareC);
    priority_queue<T, vector<T>, decltype(compareP)> maxHeap(compareP);

    for (int i = 0; i < Capital.size(); ++i)
      minHeap.emplace(Profits[i], Capital[i]);

    while (k--) {
      while (!minHeap.empty() && minHeap.top().cap <= W)
        maxHeap.push(minHeap.top()), minHeap.pop();
      if (maxHeap.empty())
        break;
      W += maxHeap.top().pro, maxHeap.pop();
    }

    return W;
  }
};",502
502,"class Solution {
 public:
  vector<int> nextGreaterElements(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n, -1);
    stack<int> stack;  // a decreasing stack storing indices

    for (int i = 0; i < n * 2; ++i) {
      const int num = nums[i % n];
      while (!stack.empty() && nums[stack.top()] < num)
        ans[stack.top()] = num, stack.pop();
      if (i < n)
        stack.push(i);
    }

    return ans;
  }
};",503
503,"class Solution {
 public:
  string convertToBase7(int num) {
    if (num < 0)
      return ""-"" + convertToBase7(-num);
    if (num < 7)
      return to_string(num);
    return convertToBase7(num / 7) + to_string(num % 7);
  }
};",504
504,"class Solution {
 public:
  int shortestDistance(vector<vector<int>>& maze, vector<int>& start,
                       vector<int>& destination) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = maze.size();
    const int n = maze[0].size();
    queue<pair<int, int>> q{{{start[0], start[1]}}};
    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
    dist[start[0]][start[1]] = 0;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        int x = i;
        int y = j;
        int steps = dist[i][j];
        while (isValid(maze, x + dx, y + dy)) {
          x += dx;
          y += dy;
          ++steps;
        }
        if (steps < dist[x][y]) {
          dist[x][y] = steps;
          if (x == destination[0] && y == destination[1])
            continue;
          q.emplace(x, y);
        }
      }
    }

    return dist[destination[0]][destination[1]] == INT_MAX
               ? -1
               : dist[destination[0]][destination[1]];
  }

 private:
  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return x >= 0 && x < maze.size() && y >= 0 && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};",505
505,"class Solution {
 public:
  vector<string> findRelativeRanks(vector<int>& nums) {
    const int n = nums.size();
    vector<string> ans(n);
    vector<int> indices(n);

    iota(indices.begin(), indices.end(), 0);

    ranges::sort(indices,
                 [&](const int a, const int b) { return nums[a] > nums[b]; });

    for (int i = 0; i < n; ++i)
      if (i == 0)
        ans[indices[0]] = ""Gold Medal"";
      else if (i == 1)
        ans[indices[1]] = ""Silver Medal"";
      else if (i == 2)
        ans[indices[2]] = ""Bronze Medal"";
      else
        ans[indices[i]] = to_string(i + 1);

    return ans;
  }
};",506
506,"class Solution {
 public:
  bool checkPerfectNumber(int num) {
    if (num == 1)
      return false;

    int sum = 1;

    for (int i = 2; i <= sqrt(num); ++i)
      if (num % i == 0)
        sum += i + num / i;

    return sum == num;
  }
};",507
507,"class Solution {
 public:
  vector<int> findFrequentTreeSum(TreeNode* root) {
    vector<int> ans;
    unordered_map<int, int> count;
    int maxCount = 0;

    sumDownFrom(root, count);

    for (const auto& [_, freq] : count)
      maxCount = max(maxCount, freq);

    for (const auto& [sum, freq] : count)
      if (freq == maxCount)
        ans.push_back(sum);

    return ans;
  }

 private:
  int sumDownFrom(TreeNode* root, unordered_map<int, int>& count) {
    if (root == nullptr)
      return 0;

    const int sum = root->val + sumDownFrom(root->left, count) +
                    sumDownFrom(root->right, count);
    ++count[sum];
    return sum;
  }
};",508
508,"class Solution {
 public:
  int fib(int n) {
    if (n < 2)
      return n;

    vector<int> dp{0, 0, 1};

    for (int i = 2; i <= n; ++i) {
      dp[0] = dp[1];
      dp[1] = dp[2];
      dp[2] = dp[0] + dp[1];
    }

    return dp.back();
  }
};",509
509,"class Solution {
 public:
  Node* inorderSuccessor(Node* node) {
    // The successor is somewhere lower in the right subtree.
    if (node->right) {
      node = node->right;
      while (node->left)
        node = node->left;
      return node;
    }

    // The successor is somewhere upper in the tree.
    while (node->parent && node->parent->left != node)
      node = node->parent;
    return node->parent;
  }
};",510
510,"SELECT player_id, MIN(event_date) AS first_login
FROM Activity
GROUP BY 1;",511
511,"SELECT DISTINCT
  player_id,
  FIRST_VALUE(device_id) OVER(
    PARTITION by player_id
    ORDER BY event_date
  ) AS device_id
FROM Activity;",512
512,"class Solution {
 public:
  int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> q{{root}};
    TreeNode* node = nullptr;

    while (!q.empty()) {
      node = q.front();
      q.pop();
      if (node->right)
        q.push(node->right);
      if (node->left)
        q.push(node->left);
    }

    return node->val;
  }
};",513
513,"class Solution {
 public:
  int findRotateSteps(string ring, string key) {
    return dfs(ring, key, 0, {}) + key.length();
  }

 private:
  // Returns the number of rotates of ring to match key[index..n).
  int dfs(const string& ring, const string& key, int index,
          unordered_map<string, int>&& mem) {
    if (index == key.length())
      return 0;
    // Add the index to prevent duplication.
    const string hashKey = ring + to_string(index);
    if (const auto it = mem.find(hashKey); it != mem.cend())
      return it->second;

    int ans = INT_MAX;

    // For each ring[i] == key[index], we rotate the ring to match the ring[i]
    // with the key[index], then recursively match the newRing with the
    // key[index + 1..n).
    for (size_t i = 0; i < ring.length(); ++i)
      if (ring[i] == key[index]) {
        const int minRotates = min(i, ring.length() - i);
        const string& newRing = ring.substr(i) + ring.substr(0, i);
        const int remainingRotates = dfs(newRing, key, index + 1, move(mem));
        ans = min(ans, minRotates + remainingRotates);
      }

    return mem[hashKey] = ans;
  }
};",514
514,"class Solution {
 public:
  vector<int> largestValues(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      int maxi = INT_MIN;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        maxi = max(maxi, node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(maxi);
    }

    return ans;
  }
};",515
515,"class Solution {
 public:
  int longestPalindromeSubseq(string s) {
    const int n = s.length();
    vector<vector<int>> mem(n, vector<int>(n));
    return lps(s, 0, n - 1, mem);
  }

 private:
  // Returns the length of LPS(s[i..j]).
  int lps(const string& s, int i, int j, vector<vector<int>>& mem) {
    if (i > j)
      return 0;
    if (i == j)
      return 1;
    if (mem[i][j] > 0)
      return mem[i][j];
    if (s[i] == s[j])
      return mem[i][j] = 2 + lps(s, i + 1, j - 1, mem);
    return mem[i][j] = max(lps(s, i + 1, j, mem), lps(s, i, j - 1, mem));
  }
};",516
516,"class Solution {
 public:
  int findMinMoves(vector<int>& machines) {
    const int dresses = accumulate(machines.begin(), machines.end(), 0);
    if (dresses % machines.size() != 0)
      return -1;

    int ans = 0;
    int inout = 0;
    const int average = dresses / machines.size();

    for (const int dress : machines) {
      inout += dress - average;
      ans = max({ans, abs(inout), dress - average});
    }

    return ans;
  }
};",517
517,"class Solution {
 public:
  int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1);
    dp[0] = 1;

    for (const int coin : coins)
      for (int i = coin; i <= amount; ++i)
        dp[i] += dp[i - coin];

    return dp[amount];
  }
};",518
518,"class Solution {
 public:
  Solution(int n_rows, int n_cols)
      : rows(n_rows), cols(n_cols), total(n_rows * n_cols) {}

  vector<int> flip() {
    // All the candidates are used out.
    if (used.size() == total)
      return {};
    int index = rand() % total;
    while (used.count(index))
      index = ++index % total;
    used.insert(index);
    return {index / cols, index % cols};
  }

  void reset() {
    used = {};
  }

 private:
  unordered_set<int> used;
  int rows;
  int cols;
  int total;
};",519
519,"class Solution {
 public:
  bool detectCapitalUse(string word) {
    for (int i = 1; i < word.length(); ++i)
      if (isupper(word[1]) != isupper(word[i]) ||
          islower(word[0]) && isupper(word[i]))
        return false;
    return true;
  }
};",520
520,"class Solution {
 public:
  int findLUSlength(string a, string b) {
    return a == b ? -1 : max(a.length(), b.length());
  }
};",521
521,"class Solution {
 public:
  int findLUSlength(vector<string>& strs) {
    unordered_set<string> seen;
    unordered_set<string> duplicates;

    for (const string& str : strs)
      if (seen.count(str))
        duplicates.insert(str);
      else
        seen.insert(str);

    ranges::sort(strs, [](const string& a, const string& b) {
      return a.length() > b.length();
    });

    for (int i = 0; i < strs.size(); ++i) {
      if (duplicates.count(strs[i]))
        continue;
      bool isASubsequence = false;
      for (int j = 0; j < i; ++j)
        isASubsequence |= isSubsequence(strs[i], strs[j]);
      if (!isASubsequence)
        return strs[i].length();
    }

    return -1;
  }

 private:
  // Returns true if a is a subsequence of b.
  bool isSubsequence(const string& a, const string& b) {
    int i = 0;
    for (const char c : b)
      if (i < a.length() && c == a[i])
        ++i;
    return i == a.length();
  };
};",522
522,"class Solution {
 public:
  bool checkSubarraySum(vector<int>& nums, int k) {
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      if (k != 0)
        prefix %= k;
      if (const auto it = prefixToIndex.find(prefix);
          it != prefixToIndex.cend()) {
        if (i - it->second > 1)
          return true;
      } else {
        // Set a new key if it's absent because the previous index is better.
        prefixToIndex[prefix] = i;
      }
    }

    return false;
  }
};",523
523,"class Solution {
 public:
  string findLongestWord(string s, vector<string>& d) {
    string ans;

    for (const string& word : d)
      if (isSubsequence(word, s))
        if (word.length() > ans.length() ||
            word.length() == ans.length() && word.compare(ans) < 0)
          ans = word;

    return ans;
  }

 private:
  // Returns true if a is a subsequence of b.
  bool isSubsequence(const string& a, const string& b) {
    int i = 0;
    for (const char c : b)
      if (i < a.length() && c == a[i])
        ++i;
    return i == a.length();
  };
};",524
524,"class Solution {
 public:
  int findMaxLength(vector<int>& nums) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i] ? 1 : -1;
      if (const auto it = prefixToIndex.find(prefix);
          it != prefixToIndex.cend())
        ans = max(ans, i - it->second);
      else
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};",525
525,"class Solution {
 public:
  int countArrangement(int n) {
    return dfs(n, 1, string(n + 1, 'x'), {});
  }

 private:
  int dfs(int n, int num, string&& filled, unordered_map<string, int>&& mem) {
    if (num == n + 1)
      return 1;
    if (const auto it = mem.find(filled); it != mem.cend())
      return it->second;

    int count = 0;

    for (int i = 1; i <= n; ++i)
      if (filled[i] == 'x' && (num % i == 0 || i % num == 0)) {
        filled[i] = 'o';
        count += dfs(n, num + 1, move(filled), move(mem));
        filled[i] = 'x';
      }

    return mem[filled] = count;
  }
};",526
526,"class Solution {
 public:
  vector<string> wordsAbbreviation(vector<string>& words) {
    const int n = words.size();
    vector<string> ans;
    // prefix[i] := ans[i] takes words[i][0..prefix[i]]
    vector<int> prefix(n);

    for (const string& word : words)
      ans.push_back(getAbbrev(word, 0));

    for (int i = 0; i < n; ++i) {
      while (true) {
        vector<int> dupeIndices;
        for (int j = i + 1; j < n; ++j)
          if (ans[i] == ans[j])
            dupeIndices.push_back(j);
        if (dupeIndices.empty())
          break;
        dupeIndices.push_back(i);
        for (const int index : dupeIndices)
          ans[index] = getAbbrev(words[index], ++prefix[index]);
      }
    }

    return ans;
  }

 private:
  string getAbbrev(const string& s, int prefixIndex) {
    const int n = s.length();
    const int num = n - (prefixIndex + 1) - 1;
    const int numLength = num < 10 ? 1 : num < 100 ? 2 : 3;
    const int abbrevLength = (prefixIndex + 1) + numLength + 1;
    if (abbrevLength >= n)
      return s;
    return s.substr(0, prefixIndex + 1) + to_string(num) + s.back();
  }
};",527
527,pickIndex(),528
528,"class Solution {
 public:
  vector<vector<char>> updateBoard(vector<vector<char>>& board,
                                   vector<int>& click) {
    const int i = click[0];
    const int j = click[1];
    if (board[i][j] == 'M') {
      board[i][j] = 'X';
      return board;
    }

    dfs(board, i, j);
    return board;
  }

 private:
  static constexpr int dirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                     {0, 1},   {1, -1}, {1, 0},  {1, 1}};

  void dfs(vector<vector<char>>& board, int i, int j) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return;
    if (board[i][j] != 'E')
      return;

    const int minesCount = getMinesCount(board, i, j);
    board[i][j] = minesCount == 0 ? 'B' : '0' + minesCount;

    if (minesCount == 0)
      for (const auto& [dx, dy] : dirs)
        dfs(board, i + dx, j + dy);
  }

  int getMinesCount(const vector<vector<char>>& board, int i, int j) {
    int minesCount = 0;
    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == board.size() || y < 0 || y == board[0].size())
        continue;
      if (board[x][y] == 'M')
        ++minesCount;
    }
    return minesCount;
  }
};",529
529,"class Solution {
 public:
  // Similar to 94. Binary Tree Inorder Traversal
  int getMinimumDifference(TreeNode* root) {
    int ans = INT_MAX;
    int prev = -1;
    stack<TreeNode*> stack;

    while (root || !stack.empty()) {
      while (root) {
        stack.push(root);
        root = root->left;
      }
      root = stack.top(), stack.pop();
      if (prev >= 0)
        ans = min(ans, root->val - prev);
      prev = root->val;
      root = root->right;
    }

    return ans;
  }
};",530
530,"class Solution {
 public:
  int findLonelyPixel(vector<vector<char>>& picture) {
    const int m = picture.size();
    const int n = picture[0].size();
    int ans = 0;
    vector<int> rows(m);  // rows[i] := the number of B's in rows i
    vector<int> cols(n);  // cols[i] := the number of B's in cols i

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (picture[i][j] == 'B') {
          ++rows[i];
          ++cols[j];
        }

    for (int i = 0; i < m; ++i)
      if (rows[i] == 1)  // Only have to examine the rows if rows[i] == 1.
        for (int j = 0; j < n; ++j)
          // After meeting a 'B' in this rows, break and search the next row.
          if (picture[i][j] == 'B') {
            if (cols[j] == 1)
              ++ans;
            break;
          }

    return ans;
  }
};",531
531,"class Solution {
 public:
  int findPairs(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i)
      numToIndex[nums[i]] = i;

    for (int i = 0; i < nums.size(); ++i) {
      const int target = nums[i] + k;
      if (const auto it = numToIndex.find(target);
          it != numToIndex.cend() && it->second != i) {
        ++ans;
        numToIndex.erase(target);
      }
    }

    return ans;
  }
};",532
532,"class Solution {
 public:
  int findBlackPixel(vector<vector<char>>& picture, int target) {
    const int m = picture.size();
    const int n = picture[0].size();
    int ans = 0;
    vector<int> rows(m);
    vector<int> cols(n);
    vector<string> rowStrings(m);
    unordered_map<string, int> countRowStrings;

    for (int i = 0; i < m; ++i) {
      string s;
      for (int j = 0; j < n; ++j) {
        if (picture[i][j] == 'B') {
          ++rows[i];
          ++cols[j];
        }
        s += picture[i][j];
      }
      rowStrings[i] = s;
      ++countRowStrings[s];
    }

    for (int i = 0; i < m; ++i)
      if (rows[i] == target && countRowStrings[rowStrings[i]] == target)
        for (int j = 0; j < n; ++j)
          if (picture[i][j] == 'B' && cols[j] == target)
            ++ans;

    return ans;
  }
};",533
533,"SELECT
  Activity.player_id,
  Activity.event_date,
  SUM(PrevActivity.games_played) AS games_played_so_far
FROM Activity
INNER JOIN Activity AS PrevActivity
  ON (
    Activity.player_id = PrevActivity.player_id
    AND Activity.event_date >= PrevActivity.event_date)
GROUP BY 1, 2
ORDER BY 1, 2;",534
534,"class Solution {
 public:
  string encode(string longUrl) {
    while (!urlToCode.count(longUrl)) {
      string code;
      for (int i = 0; i < 6; ++i)
        code += alphabets[rand() % alphabets.size()];
      if (!codeToUrl.count(code)) {
        codeToUrl[code] = longUrl;
        urlToCode[longUrl] = code;
        return ""http://tinyurl.com/"" + code;
      }
    }

    throw;
  }

  string decode(string shortUrl) {
    return codeToUrl[shortUrl.substr(19)];
  }

 private:
  const string alphabets =
      ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"";
  unordered_map<string, string> urlToCode;
  unordered_map<string, string> codeToUrl;
};",535
535,"class Solution {
 public:
  TreeNode* str2tree(string s) {
    if (s.empty())
      return nullptr;
    int i = 0;
    return str2tree(s, i);
  }

 private:
  TreeNode* str2tree(const string& s, int& i) {
    const int start = i;  // the start index of `val`
    if (s[i] == '-')
      ++i;
    while (i < s.length() && isdigit(s[i]))
      ++i;

    const int val = stoi(s.substr(start, i - start));
    TreeNode* root = new TreeNode(val);

    // the left child
    if (i < s.length() && s[i] == '(') {
      ++i;  // '('
      root->left = str2tree(s, i);
      ++i;  // ')'
    }

    // the right child
    if (i < s.length() && s[i] == '(') {
      ++i;  // '('
      root->right = str2tree(s, i);
      ++i;  // ')'
    }

    return root;
  }
};",536
536,"class Solution {
 public:
  string complexNumberMultiply(string a, string b) {
    const auto& [A, B] = getRealAndImag(a);
    const auto& [C, D] = getRealAndImag(b);
    return to_string(A * C - B * D) + ""+"" + to_string(A * D + B * C) + ""i"";
  }

 private:
  pair<int, int> getRealAndImag(const string& s) {
    const string& real = s.substr(0, s.find_first_of('+'));
    const string& imag = s.substr(s.find_first_of('+') + 1);
    return {stoi(real), stoi(imag)};
  };
};",537
537,"class Solution {
 public:
  TreeNode* convertBST(TreeNode* root) {
    int prefix = 0;
    reversedInorder(root, prefix);
    return root;
  }

 private:
  void reversedInorder(TreeNode* root, int& prefix) {
    if (root == nullptr)
      return;

    reversedInorder(root->right, prefix);
    prefix += root->val;
    root->val = prefix;
    reversedInorder(root->left, prefix);
  }
};",538
538,"class Solution {
 public:
  int findMinDifference(vector<string>& timePoints) {
    int ans = 24 * 60;
    int first = 24 * 60;
    vector<bool> bucket(24 * 60);

    for (const string& time : timePoints) {
      const int num = stoi(time.substr(0, 2)) * 60 + stoi(time.substr(3));
      first = min(first, num);
      if (bucket[num])
        return 0;
      bucket[num] = true;
    }

    int prev = first;

    for (int i = first + 1; i < bucket.size(); ++i)
      if (bucket[i]) {
        ans = min(ans, i - prev);
        prev = i;
      }

    return min(ans, 24 * 60 - prev + first);
  }
};",539
539,"class Solution {
 public:
  int singleNonDuplicate(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      int m = (l + r) / 2;
      if (m & 1)
        --m;
      if (nums[m] == nums[m + 1])
        l = m + 2;
      else
        r = m;
    }

    return nums[l];
  }
};",540
540,"class Solution {
 public:
  string reverseStr(string s, int k) {
    for (size_t i = 0; i < s.length(); i += 2 * k) {
      int l = i;
      int r = min(i + k - 1, s.length() - 1);
      while (l < r)
        swap(s[l++], s[r--]);
    }

    return s;
  }
};",541
541,"class Solution {
 public:
  vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = mat.size();
    const int n = mat[0].size();
    queue<pair<int, int>> q;
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 0) {
          q.emplace(i, j);
          seen[i][j] = true;
        }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        mat[x][y] = mat[i][j] + 1;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return mat;
  }
};",542
542,"class Solution {
 public:
  int diameterOfBinaryTree(TreeNode* root) {
    int ans = 0;
    maxDepth(root, ans);
    return ans;
  }

 private:
  int maxDepth(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = maxDepth(root->left, ans);
    const int r = maxDepth(root->right, ans);
    ans = max(ans, l + r);
    return 1 + max(l, r);
  }
};",543
543,"class Solution {
 public:
  string findContestMatch(int n) {
    vector<string> matches(n);

    for (int i = 0; i < n; ++i)
      matches[i] = to_string(i + 1);

    return generateMatches(matches);
  }

 private:
  string generateMatches(const vector<string>& matches) {
    if (matches.size() == 1)
      return matches[0];

    vector<string> nextMatches;

    for (int i = 0; i < matches.size() / 2; ++i)
      nextMatches.push_back(""("" + matches[i] + "","" +
                            matches[matches.size() - 1 - i] + "")"");

    return generateMatches(nextMatches);
  }
};",544
544,"class Solution {
 public:
  vector<int> boundaryOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return {};
    vector<int> ans{root->val};
    dfs(root->left, true, false, ans);
    dfs(root->right, false, true, ans);
    return ans;
  }

 private:
  // 1. root->left is left boundary if root is left boundary.
  //    root->right if left boundary if root->left == nullptr.
  // 2. Same applys for right boundary.
  // 3. If root is left boundary, add it before 2 children - preorder.
  //    If root is right boundary, add it after 2 children - postorder.
  // 4. A leaf that is neighter left/right boundary belongs to the bottom.
  void dfs(TreeNode* root, bool lb, bool rb, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (lb)
      ans.push_back(root->val);
    if (!lb && !rb && root->left == nullptr && root->right != nullptr)
      ans.push_back(root->val);

    dfs(root->left, lb, rb && root->right == nullptr, ans);
    dfs(root->right, lb && root->left == nullptr, rb, ans);
    if (rb)
      ans.push_back(root->val);
  }
};",545
545,"class Solution {
 public:
  int removeBoxes(vector<int>& boxes) {
    const int n = boxes.size();
    vector<vector<vector<int>>> mem(n, vector<vector<int>>(n, vector<int>(n)));
    return removeBoxes(boxes, 0, n - 1, 0, mem);
  }

 private:
  // Returns the maximum score of boxes[i..j] if k boxes eqaul to boxes[j].
  int removeBoxes(const vector<int>& boxes, int i, int j, int k,
                  vector<vector<vector<int>>>& mem) {
    if (i > j)
      return 0;
    if (mem[i][j][k] > 0)
      return mem[i][j][k];

    int r = j;
    int sameBoxes = k + 1;
    while (r > 0 && boxes[r - 1] == boxes[r]) {
      --r;
      ++sameBoxes;
    }
    mem[i][j][k] = removeBoxes(boxes, i, r - 1, 0, mem) + sameBoxes * sameBoxes;

    for (int p = i; p < r; ++p)
      if (boxes[p] == boxes[r])
        mem[i][j][k] =
            max(mem[i][j][k], removeBoxes(boxes, i, p, sameBoxes, mem) +
                                  removeBoxes(boxes, p + 1, r - 1, 0, mem));

    return mem[i][j][k];
  }
};",546
546,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int findCircleNum(vector<vector<int>>& isConnected) {
    const int n = isConnected.size();
    UnionFind uf(n);

    for (int i = 0; i < n; ++i)
      for (int j = i; j < n; ++j)
        if (isConnected[i][j] == 1)
          uf.unionByRank(i, j);

    return uf.getCount();
  }
};",547
547,"class Solution {
 public:
  bool splitArray(vector<int>& nums) {
    const int n = nums.size();
    if (n < 7)
      return false;

    vector<int> prefix(n);

    partial_sum(nums.begin(), nums.end(), prefix.begin());

    for (int j = 3; j < n - 3; ++j) {
      unordered_set<int> seen;
      for (int i = 1; i < j - 1; ++i)
        if (prefix[i - 1] == prefix[j - 1] - prefix[i])
          seen.insert(prefix[i - 1]);
      for (int k = j + 2; k < n - 1; ++k)
        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&
            seen.count(prefix[k - 1] - prefix[j]))
          return true;
    }

    return false;
  }
};",548
548,"struct T {
  int inc;  // the length of longest incrementing branch
  int dec;  // the length of longest decrementing branch
};

class Solution {
 public:
  int longestConsecutive(TreeNode* root) {
    int ans = 0;
    longestPath(root, ans);
    return ans;
  }

 private:
  T longestPath(TreeNode* root, int& ans) {
    if (root == nullptr)
      return {0, 0};

    int inc = 1;
    int dec = 1;

    if (root->left) {
      T l = longestPath(root->left, ans);
      if (root->val + 1 == root->left->val)
        inc = l.inc + 1;
      else if (root->val - 1 == root->left->val)
        dec = l.dec + 1;
    }

    if (root->right) {
      T r = longestPath(root->right, ans);
      if (root->val + 1 == root->right->val)
        inc = max(inc, r.inc + 1);
      else if (root->val - 1 == root->right->val)
        dec = max(dec, r.dec + 1);
    }

    ans = max(ans, inc + dec - 1);
    return {inc, dec};
  }
};",549
549,"WITH
  Players AS (
    SELECT player_id, MIN(event_date) AS first_login
    FROM Activity
    GROUP BY 1
  )
SELECT ROUND(
    COUNT(Players.player_id) / (
      SELECT COUNT(DISTINCT Activity.player_id)
      FROM Activity
    ),
    2
  ) AS fraction
FROM Players
INNER JOIN Activity
  ON (
    Players.player_id = Activity.player_id
    AND DATEDIFF(Players.first_login, Activity.event_date) = -1)",550
550,"class Solution {
 public:
  bool checkRecord(string s) {
    int countA = 0;
    int countL = 0;

    for (const char c : s) {
      if (c == 'A' && ++countA > 1)
        return false;
      if (c != 'L')
        countL = 0;
      else if (++countL > 2)
        return false;
    }

    return true;
  }
};",551
551,"class Solution {
 public:
  int checkRecord(int n) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := the length so far with i A's and the last letters are j L's
    vector<vector<long>> dp(2, vector<long>(3));
    dp[0][0] = 1;

    while (n--) {
      const auto prev(dp);

      // Append a P.
      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % kMod;

      // Append an L.
      dp[0][1] = prev[0][0];

      // Append an L.
      dp[0][2] = prev[0][1];

      // Append an A or append a P.
      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +  //
                  prev[1][0] + prev[1][1] + prev[1][2]) %
                 kMod;

      // Append an L.
      dp[1][1] = prev[1][0];

      // Append an L.
      dp[1][2] = prev[1][1];
    }

    return accumulate(dp.begin(), dp.end(), 0, [](int s, vector<long>& row) {
      return (s + accumulate(row.begin(), row.end(), 0L)) % kMod;
    });
  }
};",552
552,"class Solution {
 public:
  string optimalDivision(vector<int>& nums) {
    string ans = to_string(nums[0]);

    if (nums.size() == 1)
      return ans;
    if (nums.size() == 2)
      return ans + ""/"" + to_string(nums[1]);

    ans += ""/("" + to_string(nums[1]);
    for (int i = 2; i < nums.size(); ++i)
      ans += ""/"" + to_string(nums[i]);
    ans += "")"";
    return ans;
  }
};",553
553,"class Solution {
 public:
  int leastBricks(vector<vector<int>>& wall) {
    int maxCount = 0;
    unordered_map<int, int> count;

    for (const vector<int>& row : wall) {
      int prefix = 0;
      for (int i = 0; i < row.size() - 1; ++i) {
        prefix += row[i];
        maxCount = max(maxCount, ++count[prefix]);
      }
    }

    return wall.size() - maxCount;
  }
};",554
554,"class Solution {
 public:
  string splitLoopedString(vector<string>& strs) {
    string ans;
    vector<string> sortedStrs;

    for (const string& s : strs)
      sortedStrs.push_back(max(s, {s.rbegin(), s.rend()}));

    for (int i = 0; i < sortedStrs.size(); ++i)
      for (const string& s :
           {sortedStrs[i], {sortedStrs[i].rbegin(), sortedStrs[i].rend()}})
        for (int j = 0; j <= s.length(); ++j)
          ans = max(ans, s.substr(j) + join(sortedStrs, i) + s.substr(0, j));

    return ans;
  }

 private:
  string reversed(const string& s) {
    string r = s;
    reverse(r.begin(), r.end());
    return r;
  }

  string join(const vector<string>& sortedStrs, int i) {
    string joined;
    for (int j = i + 1; j < sortedStrs.size(); ++j)
      joined += sortedStrs[j];
    for (int j = 0; j < i; ++j)
      joined += sortedStrs[j];
    return joined;
  }
};",555
555,"class Solution {
 public:
  int nextGreaterElement(int n) {
    const string& s = nextPermutation(to_string(n));
    const long ans = stol(s);
    return ans > INT_MAX || ans <= n ? -1 : ans;
  }

 private:
  // Similar to 31. Next Permutation
  string nextPermutation(string s) {
    const int n = s.length();

    int i;
    for (i = n - 2; i >= 0; --i)
      if (s[i] < s[i + 1])
        break;

    if (i >= 0) {
      for (int j = n - 1; j > i; --j)
        if (s[j] > s[i]) {
          swap(s[i], s[j]);
          break;
        }
    }

    reverse(s, i + 1, n - 1);
    return s;
  }

  void reverse(string& s, int l, int r) {
    while (l < r)
      swap(s[l++], s[r--]);
  }
};",556
556,"class Solution {
 public:
  string reverseWords(string s) {
    int i = 0;
    int j = 0;

    while (i < s.length()) {
      while (i < j || i < s.length() && s[i] == ' ')
        ++i;
      while (j < i || j < s.length() && s[j] != ' ')
        ++j;
      reverse(s.begin() + i, s.begin() + j);
    }

    return s;
  }
};",557
557,"class Solution {
 public:
  Node* intersect(Node* quadTree1, Node* quadTree2) {
    if (quadTree1->isLeaf)
      return quadTree1->val ? quadTree1 : quadTree2;
    if (quadTree2->isLeaf)
      return quadTree2->val ? quadTree2 : quadTree1;

    Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);
    Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);
    Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
    Node* bottomRight =
        intersect(quadTree1->bottomRight, quadTree2->bottomRight);

    if (topLeft->val == topRight->val &&        //
        topLeft->val == bottomLeft->val &&      //
        topLeft->val == bottomRight->val &&     //
        topLeft->isLeaf && topRight->isLeaf &&  //
        bottomLeft->isLeaf && bottomRight->isLeaf)
      return new Node(topLeft->val, true);
    return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);
  }
};",558
558,"class Solution {
 public:
  int maxDepth(Node* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;

    for (Node* child : root->children)
      ans = max(ans, maxDepth(child));

    return 1 + ans;
  }
};",559
559,"class Solution {
 public:
  int subarraySum(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> count{{0, 1}};  // {prefix sum: count}

    for (const int num : nums) {
      prefix += num;
      const int target = prefix - k;
      if (const auto it = count.find(target); it != count.cend())
        ans += it->second;
      ++count[prefix];
    }

    return ans;
  }
};",560
560,"class Solution {
 public:
  int arrayPairSum(vector<int>& nums) {
    int ans = 0;

    ranges::sort(nums);

    for (int i = 0; i < nums.size(); i += 2)
      ans += nums[i];

    return ans;
  }
};",561
561,"class Solution {
 public:
  int longestLine(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    // dp[i][j][0] := horizontal
    // dp[i][j][1] := vertical
    // dp[i][j][2] := diagonal
    // dp[i][j][3] := anti-diagonal
    vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(4)));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 1) {
          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;
          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;
          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;
          dp[i][j][3] = (i > 0 && j < n - 1) ? dp[i - 1][j + 1][3] + 1 : 1;
          ans = max(ans, ranges::max(dp[i][j]));
        }

    return ans;
  }
};",562
562,"class Solution {
 public:
  int findTilt(TreeNode* root) {
    int ans = 0;
    sum(root, ans);
    return ans;
  }

 private:
  int sum(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = sum(root->left, ans);
    const int r = sum(root->right, ans);
    ans += abs(l - r);
    return root->val + l + r;
  }
};",563
563,"class Solution {
 public:
  string nearestPalindromic(string n) {
    const auto& [prevPalindrome, nextPalindrome] = getPalindromes(n);
    return abs(prevPalindrome - stol(n)) <= abs(nextPalindrome - stol(n))
               ? to_string(prevPalindrome)
               : to_string(nextPalindrome);
  }

 private:
  pair<long, long> getPalindromes(const string& s) {
    const long num = stol(s);
    const int n = s.length();
    pair<long, long> palindromes;
    const string& half = s.substr(0, (n + 1) / 2);
    const string& reversedHalf = reversed(half.substr(0, n / 2));
    const long candidate = stol(half + reversedHalf);

    if (candidate < num)
      palindromes.first = candidate;
    else {
      const string& prevHalf = to_string(stol(half) - 1);
      const string& reversedPrevHalf = reversed(prevHalf.substr(0, n / 2));
      if (n % 2 == 0 && stol(prevHalf) == 0)
        palindromes.first = 9;
      else if (n % 2 == 0 && (stol(prevHalf) + 1) % 10 == 0)
        palindromes.first = stol(prevHalf + '9' + reversedPrevHalf);
      else
        palindromes.first = stol(prevHalf + reversedPrevHalf);
    }

    if (candidate > num)
      palindromes.second = candidate;
    else {
      const string& nextHalf = to_string(stol(half) + 1);
      const string& reversedNextHalf = reversed(nextHalf.substr(0, n / 2));
      palindromes.second = stol(nextHalf + reversedNextHalf);
    }

    return palindromes;
  }

  string reversed(const string& s) {
    return {s.rbegin(), s.rend()};
  }
};",564
564,"class Solution {
 public:
  int arrayNesting(vector<int>& nums) {
    int ans = 0;

    for (const int num : nums) {
      if (num == -1)
        continue;
      int index = num;
      int count = 0;
      while (nums[index] != -1) {
        const int cache = index;
        index = nums[index];
        nums[cache] = -1;
        ++count;
      }
      ans = max(ans, count);
    }

    return ans;
  }
};",565
565,"class Solution {
 public:
  vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
    if (nums.empty() || r * c != nums.size() * nums[0].size())
      return nums;

    vector<vector<int>> ans(r, vector<int>(c));
    int k = 0;

    for (const vector<int>& row : nums)
      for (const int num : row) {
        ans[k / c][k % c] = num;
        ++k;
      }

    return ans;
  }
};",566
566,"class Solution {
 public:
  bool checkInclusion(string s1, string s2) {
    vector<int> count(26);
    int required = s1.length();

    for (const char c : s1)
      ++count[c - 'a'];

    for (int l = 0, r = 0; r < s2.length(); ++r) {
      if (--count[s2[r] - 'a'] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 == s1.length())
          return true;
        if (++count[s2[l++] - 'a'] > 0)
          ++required;
      }
    }

    return false;
  }
};",567
567,"class Solution {
 public:
  int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {
    vector<vector<int>> mem(days.size(), vector<int>(days[0].size(), INT_MIN));
    return maxVacationDays(flights, days, 0, 0, mem);
  }

 private:
  // Returns the number of vacations that can be taken from the i-th city and
  // the k-th week.
  int maxVacationDays(const vector<vector<int>>& flights,
                      const vector<vector<int>>& days, int i, int k,
                      vector<vector<int>>& mem) {
    if (k == days[0].size())
      return 0;
    if (mem[i][k] != INT_MIN)
      return mem[i][k];

    // Stay at the j-th city or fly from the i-th city to the j-th city.
    for (int j = 0; j < flights.size(); ++j)
      if (j == i || flights[i][j] == 1)
        mem[i][k] = max(mem[i][k], days[j][k] + maxVacationDays(flights, days,
                                                                j, k + 1, mem));

    return mem[i][k];
  }
};",568
568,"WITH
  EmployeesWithRowNumberInCompany AS (
    SELECT
      id,
      company,
      salary,
      ROW_NUMBER() OVER(
        PARTITION BY company
        ORDER BY salary
      ) AS `row_number`,
      COUNT(*) OVER(PARTITION BY company) AS `count`
    FROM Employee
  )
SELECT id, company, salary
FROM EmployeesWithRowNumberInCompany
WHERE
  `row_number` >= `count` / 2
  AND `row_number` <= `count` / 2 + 1;",569
569,"SELECT Manager.name
FROM Employee
INNER JOIN Employee AS Manager
  ON (Employee.managerId = Manager.id)
GROUP BY Manager.id
HAVING COUNT(*) >= 5;",570
570,"WITH
  NumbersMetadata AS (
    SELECT
      *,
      SUM(frequency) OVER(ORDER BY num) AS running_frequency,
      (SUM(frequency) OVER()) / 2 AS median_frequency
    FROM Numbers
  )
SELECT AVG(num) AS median
FROM NumbersMetadata
WHERE median_frequency BETWEEN running_frequency - frequency AND running_frequency;",571
571,"class Solution {
 public:
  bool isSubtree(TreeNode* s, TreeNode* t) {
    if (s == nullptr)
      return false;
    if (isSameTree(s, t))
      return true;
    return isSubtree(s->left, t) || isSubtree(s->right, t);
  }

 private:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};",572
572,"class Solution {
 public:
  int minDistance(int height, int width, vector<int>& tree,
                  vector<int>& squirrel, vector<vector<int>>& nuts) {
    int totDist = 0;
    int maxSave = INT_MIN;

    for (const vector<int>& nut : nuts) {
      totDist += dist(nut, tree) * 2;
      maxSave = max(maxSave, dist(nut, tree) - dist(nut, squirrel));
    }

    return totDist - maxSave;
  }

 private:
  int dist(const vector<int>& a, const vector<int>& b) {
    return abs(a[0] - b[0]) + abs(a[1] - b[1]);
  }
};",573
573,"SELECT Candidate.name
FROM Candidate
INNER JOIN Vote
  ON (Candidate.id = Vote.candidateId)
GROUP BY Candidate.id
ORDER BY COUNT(*) DESC
LIMIT 1;",574
574,"class Solution {
 public:
  int distributeCandies(vector<int>& candies) {
    bitset<200001> bitset;

    for (const int candy : candies)
      bitset.set(candy + 100000);

    return min(candies.size() / 2, bitset.count());
  }
};",575
575,"class Solution {
 public:
  int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
    vector<vector<vector<int>>> mem(maxMove + 1,
                                    vector<vector<int>>(m, vector<int>(n, -1)));
    return findPaths(m, n, maxMove, startRow, startColumn, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of paths to move the ball at (i, j) out-of-bounds with k
  // moves.
  int findPaths(int m, int n, int k, int i, int j,
                vector<vector<vector<int>>>& mem) {
    if (i < 0 || i == m || j < 0 || j == n)
      return 1;
    if (k == 0)
      return 0;
    if (mem[k][i][j] != -1)
      return mem[k][i][j];
    return mem[k][i][j] = (findPaths(m, n, k - 1, i + 1, j, mem) * 1LL +
                           findPaths(m, n, k - 1, i - 1, j, mem) +
                           findPaths(m, n, k - 1, i, j + 1, mem) +
                           findPaths(m, n, k - 1, i, j - 1, mem)) %
                          kMod;
  }
};",576
576,"SELECT Employee.name, Bonus.bonus
FROM Employee
LEFT JOIN Bonus
  USING (empId)
WHERE IFNULL(Bonus.bonus, 0) < 1000;",577
577,"SELECT question_id AS survey_log
FROM SurveyLog
GROUP BY 1
ORDER BY
  COUNT(answer_id) / COUNT(*) DESC,
  question_id ASC
LIMIT 1;",578
578,"WITH
  CurrMonth AS (
    SELECT
      *,
      MAX(month) OVER(PARTITION BY id) AS max_month
    FROM Employee
  )
SELECT
  CurrMonth.id,
  CurrMonth.month,
  SUM(PrevMonth.salary) AS salary
FROM CurrMonth
INNER JOIN Employee AS PrevMonth
  ON (CurrMonth.id = PrevMonth.id AND CurrMonth.month - PrevMonth.month BETWEEN 0 AND 2)
WHERE CurrMonth.month != CurrMonth.max_month
GROUP BY 1, 2
ORDER BY 1, 2 DESC;",579
579,"SELECT
  Department.dept_name,
  COUNT(Student.student_id) AS student_number
FROM Department
LEFT JOIN Student
  USING (dept_id)
GROUP BY 1
ORDER BY 2 DESC, 1;",580
580,"class Solution {
 public:
  int findUnsortedSubarray(vector<int>& nums) {
    const int n = nums.size();
    int mini = INT_MAX;
    int maxi = INT_MIN;
    bool meetDecrease = false;
    bool meetIncrease = false;

    for (int i = 1; i < n; ++i) {
      if (nums[i] < nums[i - 1])
        meetDecrease = true;
      if (meetDecrease)
        mini = min(mini, nums[i]);
    }

    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] > nums[i + 1])
        meetIncrease = true;
      if (meetIncrease)
        maxi = max(maxi, nums[i]);
    }

    int l;
    for (l = 0; l < n; ++l)
      if (nums[l] > mini)
        break;

    int r;
    for (r = n - 1; r >= 0; --r)
      if (nums[r] < maxi)
        break;

    return l < r ? r - l + 1 : 0;
  }
};",581
581,"class Solution {
 public:
  vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
    vector<int> ans;
    unordered_map<int, vector<int>> tree;

    for (int i = 0; i < pid.size(); ++i) {
      if (ppid[i] == 0)
        continue;
      tree[ppid[i]].push_back(pid[i]);
    }

    dfs(tree, kill, ans);
    return ans;
  }

 private:
  void dfs(const unordered_map<int, vector<int>>& tree, int u,
           vector<int>& ans) {
    ans.push_back(u);
    if (!tree.count(u))
      return;
    for (const int v : tree.at(u))
      dfs(tree, v, ans);
  }
};",582
582,"class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int k = lcs(word1, word2);
    return (word1.length() - k) + (word2.length() - k);
  }

 private:
  int lcs(const string& A, const string& B) {
    const int m = A.length();
    const int n = B.length();
    // dp[i][j] := the length of LCS(A[0..i), B[0..j))
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (A[i - 1] == B[j - 1])
          dp[i][j] = 1 + dp[i - 1][j - 1];
        else
          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);

    return dp[m][n];
  }
};",583
583,"SELECT name
FROM Customer
WHERE referee_id IS NULL OR referee_id != 2;",584
584,"WITH
  InsuranceWithCounts AS (
    SELECT
      tiv_2016,
      COUNT(*) OVER(PARTITION by tiv_2015) AS tiv_2015_count,
      COUNT(*) OVER(PARTITION by lat, lon) AS city_count
    FROM Insurance
  )
SELECT ROUND(SUM(tiv_2016), 2) AS tiv_2016
FROM InsuranceWithCounts
WHERE tiv_2015_count > 1
  AND city_count = 1;",585
585,"SELECT customer_number
FROM Orders
GROUP BY 1
ORDER BY COUNT(*) DESC
LIMIT 1;",586
586,"// Monotone Chain
class Solution {
 public:
  vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
    vector<vector<int>> hull;

    ranges::sort(trees, [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });

    // Build the lower hull: left-to-right scan.
    for (const vector<int>& tree : trees) {
      while (hull.size() > 1 &&
             cross(hull.back(), hull[hull.size() - 2], tree) > 0)
        hull.pop_back();
      hull.push_back(tree);
    }
    hull.pop_back();

    // Build the upper hull: right-to-left scan.
    for (int i = trees.size() - 1; i >= 0; --i) {
      while (hull.size() > 1 &&
             cross(hull.back(), hull[hull.size() - 2], trees[i]) > 0)
        hull.pop_back();
      hull.push_back(trees[i]);
    }

    // Remove the redundant elements from the stack.
    ranges::sort(hull, [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });
    hull.erase(unique(hull.begin(), hull.end(),
                      [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] && a[1] == b[1];
    }),
               hull.end());
    return hull;
  }

 private:
  int cross(const vector<int>& p, const vector<int>& q, const vector<int>& r) {
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
  }
};",587
587,"struct TrieNode {
  map<string, shared_ptr<TrieNode>> children;  // lexicographical
  bool isFile = false;
  string content;
};

class FileSystem {
 public:
  vector<string> ls(string path) {
    auto [node, lastDir] = createDirAndGetPair(path);
    if (node->isFile)
      return {lastDir};

    vector<string> ans;

    for (const auto& [file, _] : node->children)
      ans.push_back(file);

    return ans;
  }

  void mkdir(string path) {
    createDirAndGetPair(path);
  }

  void addContentToFile(string filePath, string content) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    node->isFile = true;
    node->content += content;
  }

  string readContentFromFile(string filePath) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    return node->content;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  // e.g. createDirAndGetPair(""/a//b"") -> {TrieNode b, string ""b""}
  pair<shared_ptr<TrieNode>, string> createDirAndGetPair(const string& path) {
    const vector<string> dirs = getDirs(path);
    shared_ptr<TrieNode> node = root;

    for (const string& dir : dirs) {
      if (!node->children.count(dir))
        node->children[dir] = make_shared<TrieNode>();
      node = node->children[dir];
    }

    return {node, dirs.empty() ? """" : dirs.back()};
  }

  // e.g. getDirs(""/a//b"") -> [""a"", ""b""]
  vector<string> getDirs(const string& path) {
    vector<string> dirs;
    istringstream iss(path);

    for (string dir; getline(iss, dir, '/');)
      if (!dir.empty())  // Make sure that ""/a//b"" == ""/a/b"".
        dirs.push_back(dir);

    return dirs;
  }
};",588
588,"class Solution {
 public:
  vector<int> preorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (auto it = root->children.rbegin(); it != root->children.rend(); ++it)
        stack.push(*it);
    }

    return ans;
  }
};",589
589,"class Solution {
 public:
  vector<int> postorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (Node* child : root->children)
        stack.push(child);
    }

    reverse(ans.begin(), ans.end());
    return ans;
  }
};",590
590,"class Solution {
 public:
  bool isValid(string code) {
    if (code[0] != '<' || code.back() != '>')
      return false;

    stack<string> stack;

    for (int i = 0; i < code.length(); ++i) {
      int closeIndex = 0;
      if (stack.empty() && containsTag)
        return false;
      if (code[i] == '<') {
        // It's inside a tag, so check if it's a cdata.
        if (!stack.empty() && code[i + 1] == '!') {
          closeIndex = code.find(""]]>"", i + 2);
          if (closeIndex == string::npos ||
              !isValidCdata(code.substr(i + 2, closeIndex - i - 2)))
            return false;
        } else if (code[i + 1] == '/') {  // the end tag
          closeIndex = code.find('>', i + 2);
          if (closeIndex == string::npos ||
              !isValidTagName(stack, code.substr(i + 2, closeIndex - i - 2),
                              true))
            return false;
        } else {  // the start tag
          closeIndex = code.find('>', i + 1);
          if (closeIndex == string::npos ||
              !isValidTagName(stack, code.substr(i + 1, closeIndex - i - 1),
                              false))
            return false;
        }
        i = closeIndex;
      }
    }

    return stack.empty() && containsTag;
  }

 private:
  bool containsTag = false;

  bool isValidCdata(const string& s) {
    return s.find(""[CDATA["") == 0;
  }

  bool isValidTagName(stack<string>& stack, const string& tagName,
                      bool isEndTag) {
    if (tagName.empty() || tagName.length() > 9)
      return false;

    for (const char c : tagName)
      if (!isupper(c))
        return false;

    if (isEndTag) {
      if (stack.empty())
        return false;
      if (stack.top() != tagName)
        return false;
      stack.pop();
      return true;
    }

    containsTag = true;
    stack.push(tagName);
    return true;
  }
};",591
591,"class Solution {
 public:
  string fractionAddition(string expression) {
    istringstream iss(expression);
    char _;
    int a;
    int b;
    int A = 0;
    int B = 1;

    // Init: A / B = 0 / 1
    // A / B + a / b = (Ab + aB) / Bb
    // So, in each round, set A = Ab + aB, B = Bb.
    while (iss >> a >> _ >> b) {
      A = A * b + a * B;
      B *= b;
      const int g = abs(__gcd(A, B));
      A /= g;
      B /= g;
    }

    return to_string(A) + ""/"" + to_string(B);
  }
};",592
592,"class Solution {
 public:
  bool validSquare(vector<int>& p1, vector<int>& p2,  //
                   vector<int>& p3, vector<int>& p4) {
    unordered_set<int> distSet;
    vector<vector<int>> points{p1, p2, p3, p4};

    for (int i = 0; i < 4; ++i)
      for (int j = i + 1; j < 4; ++j)
        distSet.insert(dist(points[i], points[j]));

    return !distSet.count(0) && distSet.size() == 2;
  }

 private:
  int dist(vector<int>& p1, vector<int>& p2) {
    return (p1[0] - p2[0]) * (p1[0] - p2[0]) +
           (p1[1] - p2[1]) * (p1[1] - p2[1]);
  }
};",593
593,"class Solution {
 public:
  int findLHS(vector<int>& nums) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      if (const auto it = count.find(num + 1); it != count.cend())
        ans = max(ans, freq + it->second);

    return ans;
  }
};",594
594,"SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;",595
595,"SELECT class
FROM Courses
GROUP BY 1
HAVING COUNT(*) >= 5;",596
596,"WITH
  Request AS (
    SELECT COUNT(DISTINCT sender_id, send_to_id) AS `count`
    FROM FriendRequest
  ),
  Accepted AS (
    SELECT IFNULL(COUNT(DISTINCT requester_id, accepter_id), 0) AS `count`
    FROM RequestAccepted
  )
SELECT IF(
    `Request`.count = 0,
    0,
    ROUND(Accepted.`count` / Request.`count`, 2)
  ) AS accept_rate
FROM Request, Accepted;",597
597,"class Solution {
 public:
  int maxCount(int m, int n, vector<vector<int>>& ops) {
    int minY = m;
    int minX = n;

    for (const vector<int>& op : ops) {
      minY = min(minY, op[0]);
      minX = min(minX, op[1]);
    }

    return minX * minY;
  }
};",598
598,"class Solution {
 public:
  vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
    vector<string> ans;
    unordered_map<string, int> restaurantToIndex;
    int minSum = INT_MAX;

    for (int i = 0; i < list1.size(); ++i)
      restaurantToIndex[list1[i]] = i;

    for (int i = 0; i < list2.size(); ++i) {
      const string& restaurant = list2[i];
      if (const auto it = restaurantToIndex.find(restaurant);
          it != restaurantToIndex.cend()) {
        const int sum = it->second + i;
        if (sum < minSum) {
          minSum = sum;
          ans = {restaurant};
        } else if (sum == minSum) {
          ans.push_back(restaurant);
        }
      }
    }

    return ans;
  }
};",599
599,"class Solution {
 public:
  int findIntegers(int num) {
    string bits;
    for (; num; num >>= 1)
      bits += to_string(num & 1);

    const int n = bits.length();
    vector<int> zero(n, 1);
    vector<int> one(n, 1);

    for (int i = 1; i < n; ++i) {
      zero[i] = zero[i - 1] + one[i - 1];
      one[i] = zero[i - 1];
    }

    int ans = zero[n - 1] + one[n - 1];

    for (int i = n - 2; i >= 0; --i) {
      // The numbers > num and <= 2^n - 1 are invalid.
      if (bits[i] == '1' && bits[i + 1] == '1')
        break;
      if (bits[i] == '0' && bits[i + 1] == '0')
        ans -= one[i];
    }

    return ans;
  }
};",600
600,"WITH
  StadiumNeighbors AS (
    SELECT
      id,
      visit_date,
      people,
      LAG(people, 1) OVER(ORDER BY id) AS prev_people_1,
      LAG(people, 2) OVER(ORDER BY id) AS prev_people_2,
      LEAD(people, 1) OVER(ORDER BY id) AS next_people_1,
      LEAD(people, 2) OVER(ORDER BY id) AS next_people_2
    FROM Stadium
  )
SELECT
  id,
  visit_date,
  people
FROM StadiumNeighbors
WHERE
  people >= 100 AND (
    prev_people_1 >= 100 AND prev_people_2 >= 100
    OR prev_people_1 >= 100 AND next_people_1 >= 100
    OR next_people_1 >= 100 AND next_people_2 >= 100
  )
ORDER BY visit_date;",601
601,"WITH
  AllIds AS (
    SELECT requester_id AS id FROM RequestAccepted
    UNION ALL
    SELECT accepter_id FROM RequestAccepted
  )
SELECT
  id,
  COUNT(*) AS num
FROM AllIds
GROUP BY 1
ORDER BY 2 DESC
LIMIT 1;",602
602,"WITH CinemaNeighbors AS (
  SELECT
    *,
    LAG(free) OVER(ORDER BY seat_id) AS prev_free,
    LEAD(free) OVER(ORDER BY seat_id) AS next_free
  FROM Cinema
)
SELECT seat_id
FROM CinemaNeighbors
WHERE free = 1
  AND (prev_free = 1 OR next_free = 1)
ORDER BY 1;",603
603,"next(), hasNext()",604
604,"class Solution {
 public:
  bool canPlaceFlowers(vector<int>& flowerbed, int n) {
    if (n == 0)
      return true;

    for (int i = 0; i < flowerbed.size(); ++i)
      if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) &&
          (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {
        flowerbed[i] = 1;
        if (--n == 0)
          return true;
      }

    return false;
  }
};",605
605,"class Solution {
 public:
  string tree2str(TreeNode* t) {
    return dfs(t);
  }

 private:
  string dfs(TreeNode* root) {
    if (root == nullptr)
      return """";

    const string& rootStr = to_string(root->val);
    if (root->right)
      return rootStr + ""("" + dfs(root->left) + "")("" + dfs(root->right) + "")"";
    if (root->left)
      return rootStr + ""("" + dfs(root->left) + "")"";
    return rootStr + """";
  }
};",606
606,"SELECT SalesPerson.name
FROM Orders
INNER JOIN Company
  ON (Orders.com_id = Company.com_id AND Company.name = 'RED')
RIGHT JOIN SalesPerson
  USING (sales_id)
WHERE Orders.sales_id IS NULL;",607
607,"SELECT DISTINCT Parent.id,
  (
    CASE
      WHEN Parent.p_id IS NULL THEN 'Root'
      WHEN Parent.p_id IS NOT NULL AND Child.p_id IS NOT NULL THEN 'Inner'
      WHEN Parent.p_id IS NOT NULL AND Child.p_id IS NULL THEN 'Leaf'
    END
  ) AS type
FROM Tree AS Parent
LEFT JOIN Tree AS Child
  ON (Parent.id = Child.p_id);",608
608,"class Solution {
 public:
  vector<vector<string>> findDuplicate(vector<string>& paths) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> contentToFilePaths;

    for (const string& path : paths) {
      istringstream iss(path);
      string rootPath;
      iss >> rootPath;  // ""root/d1/d2/.../dm""

      string fileAndContent;
      while (iss >> fileAndContent) {  // ""fn.txt(fn_content)""
        const int l = fileAndContent.find('(');
        const int r = fileAndContent.find(')');
        // ""fn.txt""
        const string file = fileAndContent.substr(0, l);
        // ""fn_content""
        const string content = fileAndContent.substr(l + 1, r - l - 1);
        // ""root/d1/d2/.../dm/fn.txt""
        const string filePath = rootPath + '/' + file;
        contentToFilePaths[content].push_back(filePath);
      }
    }

    for (const auto& [_, filePaths] : contentToFilePaths)
      if (filePaths.size() > 1)
        ans.push_back(filePaths);

    return ans;
  }
};",609
609,"SELECT
  *,
  IF(x + y > z AND x + z > y AND y + z > x, 'Yes', 'No') AS triangle
FROM Triangle;",610
610,"class Solution {
 public:
  int triangleNumber(vector<int>& nums) {
    if (nums.size() < 3)
      return 0;

    int ans = 0;

    ranges::sort(nums);

    for (int k = nums.size() - 1; k > 1; --k) {
      int i = 0;
      int j = k - 1;
      while (i < j)
        if (nums[i] + nums[j] > nums[k]) {
          // (nums[i], nums[j], nums[k])
          // (nums[i + 1], nums[j], nums[k])
          // ...
          // (nums[j - 1], nums[j], nums[k])
          ans += j - i;
          --j;
        } else {
          ++i;
        }
    }

    return ans;
  }
};",611
611,"SELECT ROUND(
    MIN(SQRT(POW(P1.x - P2.x, 2) + POW(P1.y - P2.y, 2))),
    2
  ) AS shortest
FROM Point2D AS P1
LEFT JOIN Point2D AS P2
  ON (P1.x, P1.y) != (P2.x, P2.y);",612
612,"SELECT MIN(P1.x - P2.x) AS shortest
FROM Point AS P1, Point AS P2
WHERE P1.x > P2.x;",613
613,"SELECT
  Follower.follower,
  COUNT(DISTINCT Followee.follower) AS num
FROM Follow AS Follower
INNER JOIN Follow AS Followee
  ON (Follower.follower = Followee.followee)
GROUP BY 1
ORDER BY 1;",614
614,"WITH
  AvgSalary AS (
    SELECT DISTINCT
      DATE_FORMAT(pay_date, '%Y-%m') AS pay_month,
      Employee.department_id,
      AVG(amount) OVER(
        PARTITION BY Employee.department_id,
        Salary.pay_date
      ) AS department_avg_salary,
      AVG(amount) OVER(PARTITION BY Salary.pay_date) AS company_avg_salary
    FROM Salary
    INNER JOIN Employee
      USING (employee_id)
  )
SELECT DISTINCT
  pay_month,
  department_id,
  (
    CASE
      WHEN department_avg_salary > company_avg_salary THEN 'higher'
      WHEN department_avg_salary < company_avg_salary THEN 'lower'
      ELSE 'same'
    END
  ) AS comparison
FROM AvgSalary;",615
615,"class Solution {
 public:
  string addBoldTag(string s, vector<string>& words) {
    const int n = s.length();
    string ans;
    // bold[i] := true if s[i] should be bolded
    vector<bool> bold(n);

    int boldEnd = -1;  // s[i:boldEnd] should be bolded
    for (int i = 0; i < n; ++i) {
      for (const string& word : words)
        if (s.substr(i).find(word) == 0)  // StartsWith
          boldEnd = max(boldEnd, i + static_cast<int>(word.length()));
      bold[i] = boldEnd > i;
    }

    // Construct the string with the bold tags.
    int i = 0;
    while (i < n)
      if (bold[i]) {
        int j = i;
        while (j < n && bold[j])
          ++j;
        // `s[i..j)` should be bolded.
        ans += ""<b>"" + s.substr(i, j - i) + ""</b>"";
        i = j;
      } else {
        ans += s[i++];
      }

    return ans;
  }
};",616
616,"class Solution {
 public:
  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr && root2 == nullptr)
      return nullptr;
    const int val = (root1 == nullptr ? 0 : root1->val) +
                    (root2 == nullptr ? 0 : root2->val);
    TreeNode* root = new TreeNode(val);
    root->left = mergeTrees(root1 == nullptr ? nullptr : root1->left,
                            root2 == nullptr ? nullptr : root2->left);
    root->right = mergeTrees(root1 == nullptr ? nullptr : root1->right,
                             root2 == nullptr ? nullptr : root2->right);
    return root;
  }
};",617
617,"WITH
  StudentWithIdInContinent AS (
    SELECT
      *,
      ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name) AS id
    FROM Student
  )
SELECT
  MAX(CASE WHEN continent = 'America' THEN name END) AS America,
  MAX(CASE WHEN continent = 'Asia' THEN name END) AS Asia,
  MAX(CASE WHEN continent = 'Europe' THEN name END) AS Europe,
  id
FROM StudentWithIdInContinent
GROUP BY id;",618
618,"WITH
  UniqueNumbers AS (
    SELECT num
    FROM MyNumbers
    GROUP BY 1
    HAVING COUNT(num) = 1
  )
SELECT MAX(num) AS num
FROM UniqueNumbers;",619
619,"SELECT *
FROM Cinema
WHERE
  MOD(id, 2) = 1
  AND description != 'boring'
ORDER BY rating DESC;",620
620,"class Solution {
 public:
  int leastInterval(vector<char>& tasks, int n) {
    if (n == 0)
      return tasks.size();

    vector<int> count(26);

    for (const char task : tasks)
      ++count[task - 'A'];

    const int maxFreq = ranges::max(count);
    // Put the most frequent task in the slot first.
    const int maxFreqTaskOccupy = (maxFreq - 1) * (n + 1);
    // Get the number of tasks with the same frequency as `maxFreq`, we'll
    // append them after `maxFreqTaskOccupy`.
    const int nMaxFreq = ranges::count(count, maxFreq);
    // max(
    //   the most frequent task is frequent enough to force some idle slots,
    //   the most frequent task is not frequent enough to force idle slots
    // )
    return max(maxFreqTaskOccupy + nMaxFreq, static_cast<int>(tasks.size()));
  }
};",621
621,"class MyCircularQueue {
 public:
  /** Initialize your data structure here. Set the size of the queue to be k. */
  MyCircularQueue(int k) : k(k), q(k), rear(k - 1) {}

  /** Insert an element into the circular queue. Return true if the operation is
   * successful. */
  bool enQueue(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Delete an element from the circular queue. Return true if the operation is
   * successful. */
  bool deQueue() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Get the front item from the queue. */
  int Front() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the queue. */
  int Rear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular queue is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular queue is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};",622
622,"class Solution {
 public:
  TreeNode* addOneRow(TreeNode* root, int v, int d) {
    if (d == 1) {
      TreeNode* newRoot = new TreeNode(v);
      newRoot->left = root;
      return newRoot;
    }

    int depth = 0;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
        if (depth == d - 1) {
          TreeNode* cachedLeft = node->left;
          TreeNode* cachedRight = node->right;
          node->left = new TreeNode(v);
          node->right = new TreeNode(v);
          node->left->left = cachedLeft;
          node->right->right = cachedRight;
        }
      }
      if (depth == d - 1)
        break;
    }

    return root;
  }
};",623
623,"class Solution {
 public:
  int maxDistance(vector<vector<int>>& arrays) {
    int ans = 0;
    int min = 10000;
    int max = -10000;

    for (const vector<int>& A : arrays) {
      ans = std::max({ans, A.back() - min, max - A.front()});
      min = std::min(min, A.front());
      max = std::max(max, A.back());
    }

    return ans;
  }
};",624
624,"class Solution {
 public:
  int smallestFactorization(int num) {
    if (num == 1)
      return 1;

    long ans = 0;
    long base = 1;

    for (int i = 9; i > 1; --i)
      while (num % i == 0) {
        num /= i;
        ans = base * i + ans;
        base *= 10;
      }

    return num == 1 && ans <= INT_MAX ? ans : 0;
  }
};",625
625,"SELECT
  ROW_NUMBER() OVER(ORDER BY IF(MOD(id, 2) = 0, id - 1, id + 1)) AS id,
  student
FROM Seat;",626
626,"UPDATE Salary
SET sex = IF(sex = 'm', 'f', 'm');",627
627,"class Solution {
 public:
  int maximumProduct(vector<int>& nums) {
    const int n = nums.size();
    ranges::sort(nums);
    return max(nums[n - 1] * nums[0] * nums[1],
               nums[n - 1] * nums[n - 2] * nums[n - 3]);
  }
};",628
628,"class Solution {
 public:
  int kInversePairs(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := the number of permutations of numbers 1..i with j inverse
    // pairs
    vector<vector<int>> dp(n + 1, vector<int>(k + 1));

    // If there's no inverse pair, the permutation is unique ""123..i"".
    for (int i = 0; i <= n; ++i)
      dp[i][0] = 1;

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j) {
        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % kMod;
        if (j - i >= 0)
          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + kMod) % kMod;
      }

    return dp[n][k];
  }
};",629
629,"class Solution {
 public:
  int scheduleCourse(vector<vector<int>>& courses) {
    int time = 0;
    priority_queue<int> maxHeap;

    ranges::sort(courses,
                 [](const auto& a, const auto& b) { return a[1] < b[1]; });

    for (const vector<int>& course : courses) {
      const int duration = course[0];
      const int lastDay = course[1];
      maxHeap.push(duration);
      time += duration;
      // If the current course cannot be taken, check if it can be swapped with
      // a previously taken course that has a larger duration to increase the
      // time available to take upcoming courses.
      if (time > lastDay)
        time -= maxHeap.top(), maxHeap.pop();
    }

    return maxHeap.size();
  }
};",630
630,"set(row: int, column: chr, val: int)",631
631,"struct T {
  int i;
  int j;
  int num;  // nums[i][j]
  T(int i, int j, int num) : i(i), j(j), num(num) {}
};

class Solution {
 public:
  vector<int> smallestRange(vector<vector<int>>& nums) {
    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    int mini = INT_MAX;
    int maxi = INT_MIN;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i][0];
      minHeap.emplace(i, 0, num);
      mini = min(mini, num);
      maxi = max(maxi, num);
    }

    int minRange = mini;
    int maxRange = maxi;

    while (minHeap.size() == nums.size()) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      if (j + 1 < nums[i].size()) {
        minHeap.emplace(i, j + 1, nums[i][j + 1]);
        maxi = max(maxi, nums[i][j + 1]);
        mini = minHeap.top().num;
        if (maxi - mini < maxRange - minRange) {
          minRange = mini;
          maxRange = maxi;
        }
      }
    }

    return {minRange, maxRange};
  }
};",632
632,"class Solution {
 public:
  bool judgeSquareSum(int c) {
    unsigned l = 0;
    unsigned r = sqrt(c);

    while (l <= r) {
      const unsigned sum = l * l + r * r;
      if (sum == c)
        return true;
      if (sum < c)
        ++l;
      else
        --r;
    }

    return false;
  }
};",633
633,"class Solution {
 public:
  int findDerangement(int n) {
    vector<int> mem(n + 1);
    return findDerangement(n, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int findDerangement(int i, vector<int>& mem) {
    if (i == 0)
      return 1;
    if (i == 1)
      return 0;
    if (mem[i] > 0)
      return mem[i];
    return mem[i] = (i - 1L) *
                    (findDerangement(i - 1, mem) +  //
                     findDerangement(i - 2, mem)) %
                    kMod;
  }
};",634
634,"put(id: int, timestamp: str)",635
635,"class Solution {
 public:
  vector<int> exclusiveTime(int n, vector<string>& logs) {
    vector<int> ans(n);
    stack<int> stack;  // [oldest_id, ..., latest_id]
    int prevTime;

    for (const string& log : logs) {
      // Get the seperators' indices.
      const int colon1 = log.find_first_of(':');
      const int colon2 = log.find_last_of(':');
      // Get the function_id, the label, and the timestamp.
      const int id = stoi(log.substr(0, colon1));  // {function_id}
      const char label = log[colon1 + 1];  // {""s"" (""start"") | ""e"" (""end"") }
      const int timestamp = stoi(log.substr(colon2 + 1));  // {timestamp}
      if (label == 's') {
        if (!stack.empty())
          ans[stack.top()] += timestamp - prevTime;
        stack.push(id);
        prevTime = timestamp;
      } else {
        ans[stack.top()] += timestamp - prevTime + 1, stack.pop();
        prevTime = timestamp + 1;
      }
    }

    return ans;
  }
};",636
636,"class Solution {
 public:
  vector<double> averageOfLevels(TreeNode* root) {
    vector<double> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      long sum = 0;
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        sum += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(sum / (double)size);
    }

    return ans;
  }
};",637
637,"class Solution {
 public:
  int shoppingOffers(vector<int>& price, vector<vector<int>>& special,
                     vector<int>& needs) {
    return dfs(price, special, needs, 0);
  }

 private:
  int dfs(const vector<int>& price, const vector<vector<int>>& special,
          vector<int>& needs, int s) {
    int ans = 0;
    for (int i = 0; i < price.size(); ++i)
      ans += price[i] * needs[i];

    for (int i = s; i < special.size(); ++i)
      if (isValid(special[i], needs)) {
        // Use the special[i].
        for (int j = 0; j < needs.size(); ++j)
          needs[j] -= special[i][j];
        ans = min(ans, special[i].back() + dfs(price, special, needs, i));
        // Unuse the special[i] (backtracking).
        for (int j = 0; j < needs.size(); ++j)
          needs[j] += special[i][j];
      }

    return ans;
  }

  // Returns true if this special offer is a valid one.
  bool isValid(const vector<int>& offer, const vector<int>& needs) {
    for (int i = 0; i < needs.size(); ++i)
      if (needs[i] < offer[i])
        return false;
    return true;
  }
};",638
638,"class Solution {
 public:
  int numDecodings(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i] := the number of ways to decode s[i..n)
    vector<long> dp(n + 1);
    dp.back() = 1;
    dp[n - 1] = count(s[n - 1]);

    for (int i = n - 2; i >= 0; --i) {
      dp[i] += count(s[i], s[i + 1]) * dp[i + 2];
      dp[i] += count(s[i]) * dp[i + 1];
      dp[i] %= kMod;
    }

    return dp[0];
  }

 private:
  int count(char c) {
    if (c == '*')
      return 9;
    return c != '0';
  }

  int count(char c1, char c2) {
    if (c1 == '*' && c2 == '*')  // c1c2: [11-19, 21-26]
      return 15;
    if (c1 == '*') {
      if ('0' <= c2 && c2 <= '6')  // c1: [1-2]
        return 2;
      else  // c1: [1]
        return 1;
    }
    if (c2 == '*') {
      if (c1 == '1')  // c2: [1-9]
        return 9;
      if (c1 == '2')  // c2: [1-6]
        return 6;
      return 0;
    }
    return c1 == '1' || (c1 == '2' && c2 <= '6');
  }
};",639
639,"class Solution {
 public:
  string solveEquation(string equation) {
    const string lhsEquation = equation.substr(0, equation.find('='));
    const string rhsEquation = equation.substr(equation.find('=') + 1);
    const auto& [lhsCoefficient, lhsConstant] = calculate(lhsEquation);
    const auto& [rhsCoefficient, rhsConstant] = calculate(rhsEquation);
    const int coefficient = lhsCoefficient - rhsCoefficient;
    const int constant = rhsConstant - lhsConstant;

    if (coefficient == 0 && constant == 0)
      return ""Infinite solutions"";
    if (coefficient == 0 && constant != 0)
      return ""No solution"";
    return ""x="" + to_string(constant / coefficient);
  }

 private:
  pair<int, int> calculate(const string& s) {
    int coefficient = 0;
    int constant = 0;
    int num = 0;
    int sign = 1;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c))
        num = num * 10 + (c - '0');
      else if (c == '+' || c == '-') {
        constant += sign * num;
        sign = c == '+' ? 1 : -1;
        num = 0;
      } else {
        if (i > 0 && num == 0 && s[i - 1] == '0')
          continue;
        coefficient += num == 0 ? sign : sign * num;
        num = 0;
      }
    }

    return {coefficient, constant + sign * num};
  }
};",640
640,"class MyCircularDeque {
 public:
  /** Initialize your data structure here. Set the size of the deque to be k. */
  MyCircularDeque(int k) : k(k), q(k), rear(k - 1) {}

  /** Adds an item at the front of Deque. Return true if the operation is
   * successful. */
  bool insertFront(int value) {
    if (isFull())
      return false;

    front = (--front + k) % k;
    q[front] = value;
    ++size;
    return true;
  }

  /** Adds an item at the rear of Deque. Return true if the operation is
   * successful. */
  bool insertLast(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Deletes an item from the front of Deque. Return true if the operation is
   * successful. */
  bool deleteFront() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Deletes an item from the rear of Deque. Return true if the operation is
   * successful. */
  bool deleteLast() {
    if (isEmpty())
      return false;

    rear = (--rear + k) % k;
    --size;
    return true;
  }

  /** Get the front item from the deque. */
  int getFront() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the deque. */
  int getRear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular deque is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular deque is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};",641
641,input(c: chr),642
642,"class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    double sum = accumulate(nums.begin(), nums.begin() + k, 0);
    double ans = sum;

    for (int i = k; i < nums.size(); ++i) {
      sum += nums[i] - nums[i - k];
      ans = max(ans, sum);
    }

    return ans / k;
  }
};",643
643,"class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    constexpr double kErr = 1e-5;
    double l = ranges::min(nums);
    double r = ranges::max(nums);

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (check(nums, k, m))
        l = m;
      else
        r = m;
    }

    return l;
  }

 private:
  // Returns true if there's a subarray, where its length >= k and its average
  // sum >= m.
  bool check(const vector<int>& nums, int k, double m) {
    double sum = 0;
    double prevSum = 0;
    double minPrevSum = 0;

    for (int i = 0; i < nums.size(); ++i) {
      // Need to substract m for each `num` so that we can check if the sum of
      // the subarray >= 0.
      sum += nums[i] - m;
      if (i >= k) {
        prevSum += nums[i - k] - m;
        minPrevSum = min(minPrevSum, prevSum);
      }
      if (i + 1 >= k && sum >= minPrevSum)
        return true;
    }

    return false;
  };
};",644
644,"class Solution {
 public:
  vector<int> findErrorNums(vector<int>& nums) {
    int duplicate;

    for (const int num : nums)
      if (nums[abs(num) - 1] < 0)
        duplicate = abs(num);
      else
        nums[abs(num) - 1] *= -1;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > 0)
        return {duplicate, i + 1};

    throw;
  }
};",645
645,"class Solution {
 public:
  int findLongestChain(vector<vector<int>>& pairs) {
    int ans = 0;
    int prevEnd = INT_MIN;

    ranges::sort(pairs,
                 [](const auto& a, const auto& b) { return a[1] < b[1]; });

    for (const vector<int>& pair : pairs)
      if (pair[0] > prevEnd) {
        ++ans;
        prevEnd = pair[1];
      }

    return ans;
  }
};",646
646,"class Solution {
 public:
  int countSubstrings(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i) {
      ans += extendPalindromes(s, i, i);
      ans += extendPalindromes(s, i, i + 1);
    }

    return ans;
  }

 private:
  int extendPalindromes(const string& s, int l, int r) {
    int count = 0;

    while (l >= 0 && r < s.length() && s[l] == s[r]) {
      ++count;
      --l;
      ++r;
    }

    return count;
  }
};",647
647,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string replaceWords(vector<string>& dictionary, string sentence) {
    for (const string& word : dictionary)
      insert(word);

    string ans;
    istringstream iss(sentence);

    for (string s; iss >> s;)
      ans += search(s) + ' ';
    ans.pop_back();

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  string search(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      if (node->word)
        return *node->word;
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return word;
      node = node->children[i];
    }
    return word;
  }
};",648
648,"class Solution {
 public:
  string predictPartyVictory(string senate) {
    const int n = senate.length();
    queue<int> qR;
    queue<int> qD;

    for (int i = 0; i < n; ++i)
      if (senate[i] == 'R')
        qR.push(i);
      else
        qD.push(i);

    while (!qR.empty() && !qD.empty()) {
      const int indexR = qR.front();
      qR.pop();
      const int indexD = qD.front();
      qD.pop();
      if (indexR < indexD)
        qR.push(indexR + n);
      else
        qD.push(indexD + n);
    }

    return qR.empty() ? ""Dire"" : ""Radiant"";
  }
};",649
649,"class Solution {
 public:
  int minSteps(int n) {
    if (n <= 1)
      return 0;

    // dp[i] := the minimum steps to get i 'A's
    vector<int> dp(n + 1);

    // Copy 'A', then paste 'A' i - 1 times.
    iota(dp.begin(), dp.end(), 0);

    for (int i = 2; i <= n; ++i)
      for (int j = i / 2; j > 2; --j)
        if (i % j == 0) {
          dp[i] = dp[j] + i / j;  // Paste dp[j] i / j times.
          break;
        }

    return dp[n];
  }
};",650
650,"class Solution {
 public:
  int maxA(int n) {
    int ans = n;

    for (int i = 1; i <= n - 3; ++i)
      ans = max(ans, maxA(i) * (n - 1 - i));

    return ans;
  }
};",651
651,"class Solution {
 public:
  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
    vector<TreeNode*> ans;
    unordered_map<string, int> count;
    encode(root, count, ans);
    return ans;
  }

 private:
  string encode(TreeNode* root, unordered_map<string, int>& count,
                vector<TreeNode*>& ans) {
    if (root == nullptr)
      return """";

    const string encoded = to_string(root->val) + ""#"" +
                           encode(root->left, count, ans) + ""#"" +
                           encode(root->right, count, ans);
    if (++count[encoded] == 2)
      ans.push_back(root);
    return encoded;
  }
};",652
652,"class BSTIterator {
 public:
  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {
    pushUntilNull(root);
  }

  int next() {
    TreeNode* root = stack.top();
    stack.pop();
    pushUntilNull(leftToRight ? root->right : root->left);
    return root->val;
  }

 private:
  stack<TreeNode*> stack;
  bool leftToRight;

  void pushUntilNull(TreeNode* root) {
    while (root != nullptr) {
      stack.push(root);
      root = leftToRight ? root->left : root->right;
    }
  }
};

class Solution {
 public:
  bool findTarget(TreeNode* root, int k) {
    if (root == nullptr)
      return false;

    BSTIterator left(root, true);
    BSTIterator right(root, false);

    for (int l = left.next(), r = right.next(); l < r;) {
      const int sum = l + r;
      if (sum == k)
        return true;
      if (sum < k)
        l = left.next();
      else
        r = right.next();
    }

    return false;
  }
};",653
653,"class Solution {
 public:
  TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
  }

 private:
  TreeNode* build(const vector<int>& nums, int i, int j) {
    if (i > j)
      return nullptr;

    const auto it = max_element(nums.begin() + i, nums.begin() + j + 1);
    const int maxNum = *it;
    const int maxIndex = it - nums.begin();

    TreeNode* root = new TreeNode(maxNum);
    root->left = build(nums, i, maxIndex - 1);
    root->right = build(nums, maxIndex + 1, j);
    return root;
  }
};",654
654,"class Solution {
 public:
  vector<vector<string>> printTree(TreeNode* root) {
    const int m = maxHeight(root);
    const int n = pow(2, m) - 1;
    vector<vector<string>> ans(m, vector<string>(n));
    dfs(root, 0, 0, ans[0].size() - 1, ans);
    return ans;
  }

 private:
  int maxHeight(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxHeight(root->left), maxHeight(root->right));
  }

  void dfs(TreeNode* root, int row, int left, int right,
           vector<vector<string>>& ans) {
    if (root == nullptr)
      return;

    const int mid = (left + right) / 2;
    ans[row][mid] = to_string(root->val);
    dfs(root->left, row + 1, left, mid - 1, ans);
    dfs(root->right, row + 1, mid + 1, right, ans);
  }
};",655
655,"class Solution {
 public:
  vector<int> cheapestJump(vector<int>& coins, int maxJump) {
    if (coins.back() == -1)
      return {};

    const int n = coins.size();
    vector<int> next(n, -1);
    vector<int> mem(n, INT_MAX);
    cheapestJump(coins, maxJump, 0, next);

    if (mem[0] == INT_MAX)
      return {};
    return constructPath(next, 0);
  }

 private:
  // Returns the minimum cost to jump from i to n - 1.
  int cheapestJump(const vector<int>& coins, int maxJump, int i,
                   vector<int>& next, vector<int>& mem) {
    if (i == coins.size() - 1)
      return mem[i] = coins[i];
    if (mem[i] < INT_MAX)
      return mem[i];
    if (coins[i] == -1)
      return INT_MAX;

    for (int j = i + 1; j <= i + maxJump && j < coins.size(); ++j) {
      const int res = cheapestJump(coins, maxJump, j, next, mem);
      if (res == INT_MAX)
        continue;
      const int cost = coins[i] + res;
      if (cost < mem[i]) {
        mem[i] = cost;
        next[i] = j;
      }
    }

    return mem[i];
  }

  vector<int> constructPath(const vector<int>& next, int i) {
    vector<int> ans;
    while (i != -1) {
      ans.push_back(i + 1);  // 1-indexed
      i = next[i];
    }
    return ans;
  }
};",656
656,"class Solution {
 public:
  bool judgeCircle(string moves) {
    int right = 0;
    int up = 0;

    for (const char move : moves) {
      switch (move) {
        case 'R':
          ++right;
          break;
        case 'L':
          --right;
          break;
        case 'U':
          ++up;
          break;
        case 'D':
          --up;
          break;
      }
    }

    return right == 0 && up == 0;
  }
};",657
657,"class Solution {
 public:
  vector<int> findClosestElements(vector<int>& arr, int k, int x) {
    int l = 0;
    int r = arr.size() - k;

    while (l < r) {
      const int m = (l + r) / 2;
      if (x - arr[m] <= arr[m + k] - x)
        r = m;
      else
        l = m + 1;
    }

    return {arr.begin() + l, arr.begin() + l + k};
  }
};",658
658,"class Solution {
 public:
  bool isPossible(vector<int>& nums) {
    unordered_map<int, int> count;
    vector<int> starts;  // the start indices of each subsequence
    vector<int> ends;    // the end indices of each subsequence

    for (const int num : nums)
      ++count[num];

    for (int i = 0; i < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      const int num = nums[i];
      const int currCount = count[num];
      const int prevCount = count.count(num - 1) ? count[num - 1] : 0;
      const int nextCount = count.count(num + 1) ? count[num + 1] : 0;
      for (int j = 0; j < currCount - prevCount; ++j)
        starts.push_back(num);
      for (int j = 0; j < currCount - nextCount; ++j)
        ends.push_back(num);
    }

    for (int i = 0; i < starts.size(); ++i)
      if (ends[i] - starts[i] < 2)
        return false;

    return true;
  }
};",659
659,"class Solution {
 public:
  int newInteger(int n) {
    string ans;
    while (n) {
      ans = to_string(n % 9) + ans;
      n /= 9;
    }
    return stoi(ans);
  }
};",660
660,"class Solution {
 public:
  vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
    const int m = M.size();
    const int n = M[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int ones = 0;
        int count = 0;
        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)
          for (int y = max(0, j - 1); y < min(n, j + 2); ++y) {
            ones += M[x][y];
            ++count;
          }
        ans[i][j] = ones / count;
      }

    return ans;
  }
};",661
661,"class Solution {
 public:
  int widthOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;
    queue<pair<TreeNode*, int>> q{{{root, 1}}};  // {node, index}

    while (!q.empty()) {
      const int offset = q.front().second * 2;
      ans = max(ans, q.back().second - q.front().second + 1);
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [node, index] = q.front();
        q.pop();
        if (node->left)
          q.emplace(node->left, index * 2 - offset);
        if (node->right)
          q.emplace(node->right, index * 2 + 1 - offset);
      }
    }

    return ans;
  }
};",662
662,"class Solution {
 public:
  bool checkEqualTree(TreeNode* root) {
    if (root == nullptr)
      return false;

    unordered_set<int> seen;
    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);
    return sum % 2 == 0 && seen.count(sum / 2);
  }

 private:
  int dfs(TreeNode* root, unordered_set<int>& seen) {
    if (root == nullptr)
      return 0;

    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);
    seen.insert(sum);
    return sum;
  }
};",663
663,"class Solution {
 public:
  int strangePrinter(string s) {
    const int n = s.length();
    vector<vector<int>> mem(n, vector<int>(n));
    return strangePrinter(s, 0, n - 1, mem);
  }

 private:
  // Returns the minimum number of turns to print s[i..j].
  int strangePrinter(const string& s, int i, int j, vector<vector<int>>& mem) {
    if (i > j)
      return 0;
    if (mem[i][j] > 0)
      return mem[i][j];

    // Print s[i].
    mem[i][j] = strangePrinter(s, i + 1, j, mem) + 1;

    for (int k = i + 1; k <= j; ++k)
      if (s[k] == s[i])
        mem[i][j] = min(mem[i][j], strangePrinter(s, i, k - 1, mem) +
                                       strangePrinter(s, k + 1, j, mem));

    return mem[i][j];
  }
};",664
664,"class Solution {
 public:
  bool checkPossibility(vector<int>& nums) {
    bool modified = false;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < nums[i - 1]) {
        if (modified)
          return false;
        if (i == 1 || nums[i] >= nums[i - 2])
          nums[i - 1] = nums[i];  // Decrease the previous value.
        else
          nums[i] = nums[i - 1];  // Increase the current value.
        modified = true;
      }

    return true;
  }
};",665
665,"class Solution {
 public:
  int pathSum(vector<int>& nums) {
    int ans = 0;
    vector<vector<int>> tree(4, vector<int>(8, -1));

    for (const int num : nums) {
      const int d = num / 100 - 1;
      const int p = (num % 100) / 10 - 1;
      const int v = num % 10;
      tree[d][p] = v;
    }

    dfs(tree, 0, 0, 0, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& tree, int i, int j, int path, int& ans) {
    if (tree[i][j] == -1)
      return;
    if (i == 3 || max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1) {
      ans += path + tree[i][j];
      return;
    }

    dfs(tree, i + 1, j * 2, path + tree[i][j], ans);
    dfs(tree, i + 1, j * 2 + 1, path + tree[i][j], ans);
  }
};",666
666,"class Solution {
 public:
  vector<int> constructArray(int n, int k) {
    vector<int> ans;

    for (int i = 0; i < n - k; ++i)
      ans.push_back(i + 1);

    for (int i = 0; i < k; ++i)
      if (i % 2 == 0)
        ans.push_back(n - i / 2);
      else
        ans.push_back(n - k + (i + 1) / 2);

    return ans;
  }
};",667
667,"class Solution {
 public:
  int findKthNumber(int m, int n, int k) {
    int l = 1;
    int r = m * n;

    auto numsNoGreaterThan = [&](int target) {
      int count = 0;
      // For each row i, count the number of numbers <= target.
      for (int i = 1; i <= m; ++i)
        count += min(target / i, n);
      return count;
    };

    while (l < r) {
      const int mid = (l + r) / 2;
      if (numsNoGreaterThan(mid) >= k)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }
};",668
668,"class Solution {
 public:
  TreeNode* trimBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return nullptr;
    if (root->val < L)
      return trimBST(root->right, L, R);
    if (root->val > R)
      return trimBST(root->left, L, R);
    root->left = trimBST(root->left, L, R);
    root->right = trimBST(root->right, L, R);
    return root;
  }
};",669
669,"class Solution {
 public:
  int maximumSwap(int num) {
    string s = to_string(num);
    vector<int> lastIndex(10, -1);  // {digit: last index}

    for (int i = 0; i < s.length(); ++i)
      lastIndex[s[i] - '0'] = i;

    for (int i = 0; i < s.length(); ++i)
      for (int d = 9; d > s[i] - '0'; --d)
        if (lastIndex[d] > i) {
          swap(s[i], s[lastIndex[d]]);
          return stoi(s);
        }

    return num;
  }
};",670
670,"class Solution {
 public:
  int findSecondMinimumValue(TreeNode* root) {
    if (root == nullptr)
      return -1;
    return findSecondMinimumValue(root, root->val);
  }

 private:
  int findSecondMinimumValue(TreeNode* root, int mini) {
    if (root == nullptr)
      return -1;
    if (root->val > mini)
      return root->val;

    const int leftMin = findSecondMinimumValue(root->left, mini);
    const int rightMin = findSecondMinimumValue(root->right, mini);

    if (leftMin == -1 || rightMin == -1)
      return max(leftMin, rightMin);
    return min(leftMin, rightMin);
  }
};",671
671,"class Solution {
 public:
  int flipLights(int n, int m) {
    n = min(n, 3);

    if (m == 0)
      return 1;
    if (m == 1)
      return vector{2, 3, 4}[n - 1];
    if (m == 2)
      return vector{2, 4, 7}[n - 1];

    return pow(2, n);
  }
};",672
672,"class Solution {
 public:
  int findNumberOfLIS(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    int maxLength = 0;
    // length[i] := the length of LIS's ending in nums[i]
    vector<int> length(n, 1);
    // count[i] := the number of LIS's ending in nums[i]
    vector<int> count(n, 1);

    // Calculate `length` and `count` arrays.
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (nums[j] < nums[i])
          if (length[i] < length[j] + 1) {
            length[i] = length[j] + 1;
            count[i] = count[j];
          } else if (length[i] == length[j] + 1) {
            count[i] += count[j];
          }

    // Get the number of LIS.
    for (int i = 0; i < n; ++i)
      if (length[i] > maxLength) {
        maxLength = length[i];
        ans = count[i];
      } else if (length[i] == maxLength) {
        ans += count[i];
      }

    return ans;
  }
};",673
673,"class Solution {
 public:
  int findLengthOfLCIS(vector<int>& nums) {
    int ans = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (r > 0 && nums[r] <= nums[r - 1])
        l = r;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",674
674,"struct T {
  int i;
  int j;
  int height;
  T(int i, int j, int height) : i(i), j(j), height(height) {}
};

class Solution {
 public:
  int cutOffTree(vector<vector<int>>& forest) {
    auto compare = [&](const T& a, const T& b) { return a.height > b.height; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < forest.size(); ++i)
      for (int j = 0; j < forest[0].size(); ++j)
        if (forest[i][j] > 1)
          minHeap.emplace(i, j, forest[i][j]);

    int ans = 0;
    int x = 0;
    int y = 0;

    while (!minHeap.empty()) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      // Walk from (x, y) to (i, j).
      const int steps = bfs(forest, x, y, i, j);
      if (steps < 0)
        return -1;
      ans += steps;
      x = i;
      y = j;
    }

    return ans;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  int bfs(const vector<vector<int>>& forest, int si, int sj, int ei, int ej) {
    const int m = forest.size();
    const int n = forest[0].size();
    int steps = 0;
    queue<pair<int, int>> q{{{si, sj}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[si][sj] = true;

    while (!q.empty()) {
      for (int s = q.size(); s > 0; --s) {
        const auto [i, j] = q.front();
        q.pop();
        if (i == ei && j == ej)
          return steps;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || forest[x][y] == 0)
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
      ++steps;
    }

    return -1;
  };
};",675
675,buildDict(dictionary: List[str]),676
676,"insert(key: str, val: int)",677
677,"class Solution {
 public:
  bool checkValidString(const string& s) {
    int low = 0;   // the lower bound of the number of valid '('s
    int high = 0;  // the upper bound of the number of valid '('s

    for (const char c : s) {
      switch (c) {
        case '(':
          ++low;
          ++high;
          break;
        case ')':
          low = max(0, --low);
          --high;
          break;
        case '*':
          low = max(0, --low);
          ++high;
          break;
      }
      if (high < 0)
        return false;
    }

    return low == 0;
  }
};",678
678,n = 4,679
679,"class Solution {
 public:
  bool validPalindrome(string s) {
    for (int l = 0, r = s.length() - 1; l < r; ++l, --r)
      if (s[l] != s[r])
        return validPalindrome(s, l + 1, r) ||  //
               validPalindrome(s, l, r - 1);
    return true;
  }

 private:
  bool validPalindrome(const string& s, int l, int r) {
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};",680
680,"class Solution {
 public:
  string nextClosestTime(string time) {
    const set<char> digitsSet{time[0], time[1], time[3], time[4]};
    string ans = time;

    ans[4] = nextClosest(digitsSet, ans[4], '9');
    if (time[4] < ans[4])
      return ans;

    ans[3] = nextClosest(digitsSet, ans[3], '5');
    if (time[3] < ans[3])
      return ans;

    ans[1] = nextClosest(digitsSet, ans[1], ans[0] == '2' ? '3' : '9');
    if (time[1] < ans[1])
      return ans;

    ans[0] = nextClosest(digitsSet, ans[0], '2');
    return ans;
  }

 private:
  char nextClosest(const set<char>& digitsSet, char digit, char limit) {
    auto it = digitsSet.upper_bound(digit);
    return it == digitsSet.end() || *it > limit ? *digitsSet.begin() : *it;
  }
};",681
681,"class Solution {
 public:
  int calPoints(vector<string>& operations) {
    vector<int> scores;

    for (const string& operation : operations)
      if (operation == ""+"")
        scores.push_back(scores.back() + scores[scores.size() - 2]);
      else if (operation == ""D"")
        scores.push_back(scores.back() * 2);
      else if (operation == ""C"")
        scores.pop_back();
      else
        scores.push_back(stoi(operation));

    return accumulate(scores.begin(), scores.end(), 0);
  }
};",682
682,"class Solution {
 public:
  int kEmptySlots(vector<int>& bulbs, int k) {
    const int n = bulbs.size();
    int ans = INT_MAX;
    // day[i] := the day when bulbs[i] is turned on
    vector<int> day(n);

    for (int i = 0; i < n; ++i)
      day[bulbs[i] - 1] = i + 1;

    // Find a subarray of day[l..r], where its length is k + 2.
    // For each l < i < r, day[i] > max(day[l], day[r]).
    int l = 0;
    int r = l + k + 1;
    for (int i = 1; r < n; ++i)
      if (i == r) {
        ans = min(ans, max(day[l], day[r]));
        l = i;
        r = i + k + 1;
      } else if (day[i] < max(day[l], day[r])) {
        l = i;
        r = i + k + 1;
      }

    return ans == INT_MAX ? -1 : ans;
  }
};",683
683,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    return true;
  }

 private:
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    UnionFind uf(edges.size() + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      if (!uf.unionByRank(u, v))
        return edge;
    }

    throw;
  }
};",684
684,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    return true;
  }

 private:
  vector<int> id;
  vector<int> rank;
  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
    vector<int> ids(edges.size() + 1);
    int nodeWithTwoParents = 0;

    for (const vector<int>& edge : edges) {
      const int v = edge[1];
      if (++ids[v] == 2) {
        nodeWithTwoParents = v;
        break;
      }
    }

    // If there is no edge with two ids, don't skip any edge.
    if (nodeWithTwoParents == 0)
      return findRedundantDirectedConnection(edges, -1);

    for (int i = edges.size() - 1; i >= 0; --i)
      if (edges[i][1] == nodeWithTwoParents)
        // Try to delete the edges[i].
        if (findRedundantDirectedConnection(edges, i).empty())
          return edges[i];

    throw;
  }

  vector<int> findRedundantDirectedConnection(const vector<vector<int>>& edges,
                                              int skippedEdgeIndex) {
    UnionFind uf(edges.size() + 1);

    for (int i = 0; i < edges.size(); ++i) {
      if (i == skippedEdgeIndex)
        continue;
      if (!uf.unionByRank(edges[i][0], edges[i][1]))
        return edges[i];
    }

    return {};
  }
};",685
685,"class Solution {
 public:
  int repeatedStringMatch(string a, string b) {
    const int n = ceil((double)b.length() / a.length());
    string s;

    for (int i = 0; i < n; ++i)
      s += a;

    if (s.find(b) != string::npos)
      return n;
    if ((s + a).find(b) != string::npos)
      return n + 1;
    return -1;
  }
};",686
686,"class Solution {
 public:
  int longestUnivaluePath(TreeNode* root) {
    int ans = 0;
    longestUnivaluePathDownFrom(root, ans);
    return ans;
  }

 private:
  int longestUnivaluePathDownFrom(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = longestUnivaluePathDownFrom(root->left, ans);
    const int r = longestUnivaluePathDownFrom(root->right, ans);
    const int arrowLeft =
        root->left && root->left->val == root->val ? l + 1 : 0;
    const int arrowRight =
        root->right && root->right->val == root->val ? r + 1 : 0;
    ans = max(ans, arrowLeft + arrowRight);
    return max(arrowLeft, arrowRight);
  }
};",687
687,"class Solution {
 public:
  double knightProbability(int n, int k, int row, int column) {
    constexpr int dirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},
                                {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};
    constexpr double kProb = 0.125;
    // dp[i][j] := the probability to stand on (i, j)
    vector<vector<double>> dp(n, vector<double>(n));
    dp[row][column] = 1.0;

    for (int move = 0; move < k; ++move) {
      vector<vector<double>> newDp(n, vector<double>(n));
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          if (dp[i][j] > 0.0) {
            for (const auto& [dx, dy] : dirs) {
              const int x = i + dx;
              const int y = j + dy;
              if (x < 0 || x >= n || y < 0 || y >= n)
                continue;
              newDp[x][y] += dp[i][j] * kProb;
            }
          }
      dp = std::move(newDp);
    }

    return accumulate(dp.begin(), dp.end(), 0.0,
                      [](double subtotal, const vector<double>& row) {
      return subtotal + accumulate(row.begin(), row.end(), 0.0);
    });
  }
};",688
688,"class Solution {
 public:
  vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
    const int n = nums.size() - k + 1;
    // sums[i] := sum(nums[i..i + k))
    vector<int> sums(n);
    // l[i] := the index in [0..i] that has the maximum sums[i]
    vector<int> l(n);
    // r[i] := the index in [i..n) that has the maximum sums[i]
    vector<int> r(n);

    int sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
      sum += nums[i];
      if (i >= k)
        sum -= nums[i - k];
      if (i >= k - 1)
        sums[i - k + 1] = sum;
    }

    int maxIndex = 0;
    for (int i = 0; i < n; ++i) {
      if (sums[i] > sums[maxIndex])
        maxIndex = i;
      l[i] = maxIndex;
    }

    maxIndex = n - 1;
    for (int i = n - 1; i >= 0; --i) {
      if (sums[i] >= sums[maxIndex])
        maxIndex = i;
      r[i] = maxIndex;
    }

    vector<int> ans{-1, -1, -1};

    for (int i = k; i < n - k; ++i)
      if (ans[0] == -1 || sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <
                              sums[l[i - k]] + sums[i] + sums[r[i + k]]) {
        ans[0] = l[i - k];
        ans[1] = i;
        ans[2] = r[i + k];
      }

    return ans;
  }
};",689
689,"class Solution {
 public:
  int getImportance(vector<Employee*> employees, int id) {
    unordered_map<int, Employee*> idToEmployee;

    for (Employee* employee : employees)
      idToEmployee[employee->id] = employee;

    return dfs(id, idToEmployee);
  }

 private:
  int dfs(int id, const unordered_map<int, Employee*>& idToEmployee) {
    int values = 0;

    for (const int subId : idToEmployee.at(id)->subordinates)
      values += dfs(subId, idToEmployee);

    return idToEmployee.at(id)->importance + values;
  }
};",690
690,"class Solution {
 public:
  int minStickers(vector<string>& stickers, string target) {
    const int n = target.size();
    const int maxMask = 1 << n;
    // dp[i] := the minimum number of stickers to spell out i, where i is the
    // bit mask of target
    vector<int> dp(maxMask, INT_MAX);
    dp[0] = 0;

    for (int mask = 0; mask < maxMask; ++mask) {
      if (dp[mask] == INT_MAX)
        continue;
      // Try to expand from `mask` by using each sticker.
      for (const string& sticker : stickers) {
        int superMask = mask;
        for (const char c : sticker)
          for (int i = 0; i < n; ++i)
            // Try to apply it on a missing letter.
            if (c == target[i] && (superMask >> i & 1) == 0) {
              superMask |= 1 << i;
              break;
            }
        dp[superMask] = min(dp[superMask], dp[mask] + 1);
      }
    }

    return dp.back() == INT_MAX ? -1 : dp.back();
  }
};",691
691,"class Solution {
 public:
  vector<string> topKFrequent(vector<string>& words, int k) {
    const int n = words.size();
    vector<string> ans;
    vector<vector<string>> bucket(n + 1);
    unordered_map<string, int> count;

    for (const string& word : words)
      ++count[word];

    for (const auto& [word, freq] : count)
      bucket[freq].push_back(word);

    for (int freq = n; freq > 0; --freq) {
      ranges::sort(bucket[freq]);
      for (const string& word : bucket[freq]) {
        ans.push_back(word);
        if (ans.size() == k)
          return ans;
      }
    }

    throw;
  }
};",692
692,"class Solution {
 public:
  bool hasAlternatingBits(int n) {
    //            n = 0b010101
    //       n >> 2 = 0b000101
    // n ^ (n >> 2) = 0b010000 = a
    //        a - 1 = 0b001111
    //  a & (a - 1) = 0
    const int a = n ^ (n >> 2);
    return (a & (a - 1)) == 0;
  }
};",693
693,"class Solution {
 public:
  int numDistinctIslands(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    set<vector<pair<int, int>>> islands;  // all the different islands
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        vector<pair<int, int>> island;
        dfs(grid, i, j, i, j, seen, island);
        if (!island.empty())
          islands.insert(island);
      }

    return islands.size();
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j, int i0, int j0,
           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 0 || seen[i][j])
      return;

    seen[i][j] = true;
    island.emplace_back(i - i0, j - j0);

    dfs(grid, i + 1, j, i0, j0, seen, island);
    dfs(grid, i - 1, j, i0, j0, seen, island);
    dfs(grid, i, j + 1, i0, j0, seen, island);
    dfs(grid, i, j - 1, i0, j0, seen, island);
  }
};",694
694,"class Solution {
 public:
  int maxAreaOfIsland(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] != 1)
      return 0;

    grid[i][j] = 2;

    return 1 +                                          //
           dfs(grid, i + 1, j) + dfs(grid, i - 1, j) +  //
           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);
  }
};",695
695,"class Solution {
 public:
  int countBinarySubstrings(string s) {
    int ans = 0;
    int prevEquals = 0;
    int currEquals = 1;

    for (int i = 0; i + 1 < s.length(); ++i)
      if (s[i] == s[i + 1])
        ++currEquals;
      else {
        ans += min(prevEquals, currEquals);
        prevEquals = currEquals;
        currEquals = 1;
      }

    return ans + min(prevEquals, currEquals);
  }
};",696
696,"class Solution {
 public:
  int findShortestSubArray(vector<int>& nums) {
    int ans = 0;
    int degree = 0;
    unordered_map<int, int> debut;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      if (!debut.count(num))
        debut[num] = i;
      if (++count[num] > degree) {
        degree = count[num];
        ans = i - debut[num] + 1;
      } else if (count[num] == degree) {
        ans = min(ans, i - debut[num] + 1);
      }
    }

    return ans;
  }
};",697
697,"class Solution {
 public:
  bool canPartitionKSubsets(vector<int>& nums, int k) {
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % k != 0)
      return false;

    const int target = sum / k;  // the target sum of each subset
    if (ranges::any_of(nums, [target](const int num) { return num > target; }))
      return false;

    ranges::sort(nums, greater<>());
    return dfs(nums, 0, k, /*currSum=*/0, target, /*used=*/0);
  }

 private:
  bool dfs(const vector<int>& nums, int s, int remainingGroups, int currSum,
           const int subsetTargetSum, int used) {
    if (remainingGroups == 0)
      return true;
    if (currSum > subsetTargetSum)
      return false;
    if (currSum == subsetTargetSum)  // Find a valid group, so fresh start.
      return dfs(nums, 0, remainingGroups - 1, 0, subsetTargetSum, used);

    for (int i = s; i < nums.size(); ++i) {
      if (used >> i & 1)
        continue;
      if (dfs(nums, i + 1, remainingGroups, currSum + nums[i], subsetTargetSum,
              used | 1 << i))
        return true;
    }

    return false;
  }
};",698
698,"class Solution {
 public:
  vector<int> fallingSquares(vector<vector<int>>& positions) {
    vector<int> ans;
    map<pair<int, int>, int> xsToHeight;  // {(xStart, xEnd), height}
    int maxHeight = INT_MIN;

    for (const vector<int>& p : positions) {
      const int left = p[0];
      const int sideLength = p[1];
      const int right = left + sideLength;
      // Find the first range that intersects with [left, right).
      auto it = xsToHeight.upper_bound({left, right});
      if (it != xsToHeight.begin() && (--it)->first.second <= left)
        ++it;
      int maxHeightInRange = 0;
      vector<tuple<int, int, int>> ranges;
      while (it != xsToHeight.end() && it->first.first < right) {
        const int l = it->first.first;
        const int r = it->first.second;
        const int h = it->second;
        if (l < left)
          ranges.emplace_back(l, left, h);
        if (right < r)
          ranges.emplace_back(right, r, h);
        maxHeightInRange = max(maxHeightInRange, h);
        it = xsToHeight.erase(it);
      }
      const int newHeight = maxHeightInRange + sideLength;
      xsToHeight[{left, right}] = newHeight;
      for (const auto& [l, r, h] : ranges)
        xsToHeight[{l, r}] = h;
      maxHeight = max(maxHeight, newHeight);
      ans.push_back(maxHeight);
    }

    return ans;
  }
};",699
699,"class Solution {
 public:
  TreeNode* searchBST(TreeNode* root, int val) {
    if (root == nullptr)
      return nullptr;
    if (root->val == val)
      return root;
    if (root->val > val)
      return searchBST(root->left, val);
    return searchBST(root->right, val);
  }
};",700
700,"class Solution {
 public:
  TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == nullptr)
      return new TreeNode(val);
    if (root->val > val)
      root->left = insertIntoBST(root->left, val);
    else
      root->right = insertIntoBST(root->right, val);
    return root;
  }
};",701
701,"/**
 * // This is the ArrayReader's API interface.
 * // You should not implement it, or speculate about its implementation
 * class ArrayReader {
 *  public:
 *   int get(int index);
 * };
 */

class Solution {
 public:
  int search(const ArrayReader& reader, int target) {
    int l = 0;
    int r = 10'000;

    while (l < r) {
      const int m = (l + r) / 2;
      if (reader.get(m) >= target)
        r = m;
      else
        l = m + 1;
    }

    return reader.get(l) == target ? l : -1;
  }
};",702
702,"class KthLargest {
 public:
  KthLargest(int k, vector<int>& nums) : k(k) {
    for (const int num : nums)
      heapify(num);
  }

  int add(int val) {
    heapify(val);
    return minHeap.top();
  }

 private:
  const int k;
  priority_queue<int, vector<int>, greater<>> minHeap;

  void heapify(int val) {
    minHeap.push(val);
    if (minHeap.size() > k)
      minHeap.pop();
  }
};",703
703,"class Solution {
 public:
  int search(vector<int>& nums, int target) {
    const auto it = ranges::lower_bound(nums, target);
    return (it == nums.cend() || *it != target) ? -1
                                                : distance(nums.begin(), it);
  }
};",704
704,"class MyHashSet {
 public:
  /** Initialize your data structure here. */
  MyHashSet() : set(1000001) {}

  void add(int key) {
    set[key] = true;
  }

  void remove(int key) {
    set[key] = false;
  }

  /** Returns true if this set contains the specified element */
  bool contains(int key) {
    return set[key];
  }

 private:
  vector<bool> set;
};",705
705,"class MyHashMap {
 public:
  MyHashMap() : lists(kSize) {}

  void put(int key, int value) {
    auto& pairs = lists[key % kSize];
    for (auto& [k, v] : pairs)
      if (k == key) {
        v = value;
        return;
      }
    pairs.emplace_back(key, value);
  }

  int get(int key) {
    const list<pair<int, int>>& pairs = lists[key % kSize];
    for (const auto& [k, v] : pairs)
      if (k == key)
        return v;
    return -1;
  }

  void remove(int key) {
    auto& pairs = lists[key % kSize];
    for (auto it = pairs.begin(); it != pairs.end(); ++it)
      if (it->first == key) {
        pairs.erase(it);
        return;
      }
  }

 private:
  static constexpr int kSize = 10000;
  // Each slot stores the (key, value) list.
  vector<list<pair<int, int>>> lists;
};",706
706,"class Solution {
 public:
  Node* insert(Node* head, int insertVal) {
    if (head == nullptr) {
      Node* newNode = new Node(insertVal);
      newNode->next = newNode;
      return newNode;
    }

    Node* prev = head;
    Node* curr = head->next;

    while (curr != head) {
      // Case 1: the minimum <= insertVal <= the maximum
      // Case 2: insertVal >= the maximum or insertVal <= the minimum
      if ((prev->val <= insertVal && insertVal <= curr->val) ||
          // `prev` is the maximum and `curr` is the minimum
          (prev->val > curr->val &&
           (insertVal >= prev->val || insertVal <= curr->val))) {
        // Insert the node between `prev` and `curr`.
        prev->next = new Node(insertVal, curr);
        return head;
      }
      prev = prev->next;
      curr = curr->next;
    }

    // All the values in the list are identical.
    prev->next = new Node(insertVal, curr);
    return head;
  }
};",708
707,"class Solution {
 public:
  string toLowerCase(string str) {
    const int diff = 'A' - 'a';

    for (char& c : str)
      if (c >= 'A' && c <= 'Z')
        c -= diff;

    return str;
  }
};",709
708,pick(),710
709,"class Solution {
 public:
  int numDistinctIslands2(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // all the islands with different shapes
    set<vector<pair<int, int>>> islands;
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        vector<pair<int, int>> island;
        dfs(grid, i, j, seen, island);
        if (!island.empty())
          islands.insert(normalize(island));
      }

    return islands.size();
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j,
           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 0 || seen[i][j])
      return;

    seen[i][j] = true;
    island.emplace_back(i, j);

    dfs(grid, i + 1, j, seen, island);
    dfs(grid, i - 1, j, seen, island);
    dfs(grid, i, j + 1, seen, island);
    dfs(grid, i, j - 1, seen, island);
  }

  vector<pair<int, int>> normalize(const vector<pair<int, int>>& island) {
    // points[i] := 8 different rotations/reflections of an island
    vector<vector<pair<int, int>>> points(8);

    for (const auto& [i, j] : island) {
      points[0].emplace_back(i, j);
      points[1].emplace_back(i, -j);
      points[2].emplace_back(-i, j);
      points[3].emplace_back(-i, -j);
      points[4].emplace_back(j, i);
      points[5].emplace_back(j, -i);
      points[6].emplace_back(-j, i);
      points[7].emplace_back(-j, -i);
    }

    for (vector<pair<int, int>>& p : points)
      ranges::sort(p);

    // Normalize each p by substracting p[1..7] with p[0].
    for (vector<pair<int, int>>& p : points) {
      for (int i = 1; i < island.size(); ++i)
        p[i] = {p[i].first - p[0].first, p[i].second - p[0].second};
      p[0] = {0, 0};
    }

    ranges::sort(points);
    return points[0];
  }
};",711
710,"class Solution {
 public:
  int minimumDeleteSum(string s1, string s2) {
    const int m = s1.length();
    const int n = s2.length();
    // dp[i][j] := the minimum cost to make s1[0..i) and s2[0..j) equal
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Delete s1[i - 1].
    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] + s1[i - 1];

    // Delete s2[j - 1].
    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] + s2[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s1[i - 1] == s2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);

    return dp[m][n];
  }
};",712
711,"class Solution {
 public:
  int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1)
      return 0;

    int ans = 0;
    int prod = 1;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      prod *= nums[r];
      while (prod >= k)
        prod /= nums[l++];
      ans += r - l + 1;
    }

    return ans;
  }
};",713
712,"class Solution {
 public:
  int maxProfit(vector<int>& prices, int fee) {
    int sell = 0;
    int hold = INT_MIN;

    for (const int price : prices) {
      sell = max(sell, hold + price);
      hold = max(hold, sell - price - fee);
    }

    return sell;
  }
};",714
713,"addRange(left: int, right: int)",715
714,push(x: int),716
715,"class Solution {
 public:
  bool isOneBitCharacter(vector<int>& bits) {
    const int n = bits.size();

    int i = 0;
    while (i < n - 1)
      if (bits[i] == 0)
        i += 1;
      else
        i += 2;

    return i == n - 1;
  }
};",717
716,"class Solution {
 public:
  int findLength(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    int ans = 0;
    // dp[i][j] := the maximum length of a subarray that appears in both
    // nums1[i..m) and nums2[j..n)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j)
        if (nums1[i] == nums2[j]) {
          dp[i][j] = dp[i + 1][j + 1] + 1;
          ans = max(ans, dp[i][j]);
        }

    return ans;
  }
};",718
717,"class Solution {
 public:
  int smallestDistancePair(vector<int>& nums, int k) {
    ranges::sort(nums);

    int l = 0;
    int r = nums.back() - nums.front();

    while (l < r) {
      const int m = (l + r) / 2;
      if (numPairDistancesNoGreaterThan(nums, m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int numPairDistancesNoGreaterThan(const vector<int>& nums, int m) {
    int count = 0;
    int j = 1;
    // For each index i, find the first index j s.t. nums[j] > nums[i] + m,
    // so numPairDistancesNoGreaterThan for the index i will be j - i - 1.
    for (int i = 0; i < nums.size(); ++i) {
      while (j < nums.size() && nums[j] <= nums[i] + m)
        ++j;
      count += j - i - 1;
    }
    return count;
  }
};",719
718,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string longestWord(vector<string>& words) {
    for (const string& word : words)
      insert(word);
    return longestWordFrom(root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  string longestWordFrom(shared_ptr<TrieNode> node) {
    string ans = node->word ? *node->word : """";

    for (shared_ptr<TrieNode> child : node->children)
      if (child && child->word) {
        string childWord = longestWordFrom(child);
        if (childWord.length() > ans.length())
          ans = childWord;
      }

    return ans;
  }
};",720
719,"class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(id.begin(), id.end(), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> sz;
};

class Solution {
 public:
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    vector<vector<string>> ans;
    unordered_map<string, int> emailToIndex;        // {email: index}
    unordered_map<int, set<string>> indexToEmails;  // {index: {emails}}
    UnionFind uf(accounts.size());

    for (int i = 0; i < accounts.size(); ++i) {
      const string name = accounts[i][0];
      for (int j = 1; j < accounts[i].size(); ++j) {
        const string email = accounts[i][j];
        const auto it = emailToIndex.find(email);
        if (it == emailToIndex.end()) {
          emailToIndex[email] = i;
        } else {
          uf.unionBySize(i, it->second);
        }
      }
    }

    for (const auto& [email, index] : emailToIndex)
      indexToEmails[uf.find(index)].insert(email);

    for (const auto& [index, emails] : indexToEmails) {
      const string name = accounts[index][0];
      vector<string> row{name};
      row.insert(row.end(), emails.begin(), emails.end());
      ans.push_back(row);
    }

    return ans;
  }
};",721
720,"class Solution {
 public:
  vector<string> removeComments(vector<string>& source) {
    vector<string> ans;
    bool commenting = false;
    string modified;

    for (const string& line : source) {
      for (int i = 0; i < line.length();) {
        if (i + 1 == line.length()) {
          if (!commenting)
            modified += line[i];
          ++i;
          break;
        }
        const string& twoChars = line.substr(i, 2);
        if (twoChars == ""/*"" && !commenting) {
          commenting = true;
          i += 2;
        } else if (twoChars == ""*/"" && commenting) {
          commenting = false;
          i += 2;
        } else if (twoChars == ""//"") {
          if (!commenting)
            break;
          else
            i += 2;
        } else {
          if (!commenting)
            modified += line[i];
          ++i;
        }
      }
      if (modified.length() > 0 && !commenting) {
        ans.push_back(modified);
        modified = """";
      }
    }

    return ans;
  }
};",722
721,"class Solution {
 public:
  vector<vector<int>> candyCrush(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();
    bool haveCrushes = true;

    while (haveCrushes) {
      haveCrushes = false;

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
          const int val = abs(board[i][j]);
          if (val == 0)
            continue;
          // Crush the vertical candies.
          if (j + 2 < n && abs(board[i][j + 1]) == val &&
              abs(board[i][j + 2]) == val) {
            haveCrushes = true;
            for (int k = j; k < j + 3; ++k)
              board[i][k] = -val;
          }
          // Crush the horizontal candies.
          if (i + 2 < m && abs(board[i + 1][j]) == val &&
              abs(board[i + 2][j]) == val) {
            haveCrushes = true;
            for (int k = i; k < i + 3; ++k)
              board[k][j] = -val;
          }
        }

      if (haveCrushes) {
        // For each column, drop the candies.
        for (int j = 0; j < n; ++j) {
          int nextIndex = m - 1;
          for (int i = m - 1; i >= 0; --i)
            if (board[i][j] > 0)
              board[nextIndex--][j] = board[i][j];
          // Set board[0..nextIndex][j] to 0s.
          for (int i = nextIndex; i >= 0; --i)
            board[i][j] = 0;
        }
      }
    }

    return board;
  }
};",723
722,"class Solution {
 public:
  int pivotIndex(vector<int>& nums) {
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    int prefix = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (prefix == sum - prefix - nums[i])
        return i;
      prefix += nums[i];
    }

    return -1;
  }
};",724
723,"class Solution {
 public:
  vector<ListNode*> splitListToParts(ListNode* root, int k) {
    vector<ListNode*> ans(k);
    const int length = getLength(root);
    const int subLength = length / k;
    int remainder = length % k;

    ListNode* prev = nullptr;
    ListNode* head = root;

    for (int i = 0; i < k; ++i, --remainder) {
      ans[i] = head;
      for (int j = 0; j < subLength + (remainder > 0); ++j) {
        prev = head;
        head = head->next;
      }
      if (prev != nullptr)
        prev->next = nullptr;
    }

    return ans;
  }

 private:
  int getLength(ListNode* root) {
    int length = 0;
    for (ListNode* curr = root; curr; curr = curr->next)
      ++length;
    return length;
  }
};",725
724,"class Solution {
 public:
  string countOfAtoms(string formula) {
    string ans;
    int i = 0;

    for (const auto& [elem, freq] : parse(formula, i)) {
      ans += elem;
      if (freq > 1)
        ans += to_string(freq);
    }

    return ans;
  }

 private:
  map<string, int> parse(const string& s, int& i) {
    map<string, int> count;

    while (i < s.length())
      if (s[i] == '(') {
        for (const auto& [elem, freq] : parse(s, ++i))
          count[elem] += freq;
      } else if (s[i] == ')') {
        const int num = getNum(s, ++i);
        for (auto&& [_, freq] : count)
          freq *= num;
        return count;  // Return back to the previous scope.
      } else {         // `s[i]` must be uppercased.
        const string& elem = getElem(s, i);
        const int num = getNum(s, i);
        count[elem] += num;
      }

    return count;
  }

  string getElem(const string& s, int& i) {
    const int elemStart = i++;  // `s[elemStart]` is uppercased.
    while (i < s.length() && islower(s[i]))
      ++i;
    return s.substr(elemStart, i - elemStart);
  }

  int getNum(const string& s, int& i) {
    const int numStart = i;
    while (i < s.length() && isdigit(s[i]))
      ++i;
    const string& numString = s.substr(numStart, i - numStart);
    return numString.empty() ? 1 : stoi(numString);
  }
};",726
725,"class Solution {
 public:
  string minWindow(string s1, string s2) {
    const int m = s2.length();
    const int n = s1.length();
    // dp[i][j] := the start index (1-indexed) of the minimum window of s2[0..i)
    // and s1[0..j).
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Fill in the placeholder values.
    for (int j = 0; j <= n; ++j)
      dp[0][j] = j + 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s2[i - 1] == s1[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = dp[i][j - 1];

    int bestLeft = 0;
    int minLength = INT_MAX;

    for (int j = 1; j <= n; ++j)
      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {
        bestLeft = dp[m][j] - 1;
        minLength = j - dp[m][j] + 1;
      }

    return minLength == INT_MAX ? """" : s1.substr(bestLeft, minLength);
  }
};",727
726,"class Solution {
 public:
  vector<int> selfDividingNumbers(int left, int right) {
    vector<int> ans;

    for (int num = left; num <= right; ++num)
      if (selfDividingNumbers(num))
        ans.push_back(num);

    return ans;
  }

 private:
  bool selfDividingNumbers(int num) {
    for (int n = num; n > 0; n /= 10)
      if (n % 10 == 0 || num % (n % 10) != 0)
        return false;
    return true;
  }
};",728
727,"class MyCalendar {
 public:
  bool book(int start, int end) {
    for (const auto& [s, e] : timeline)
      if (max(start, s) < min(end, e))
        return false;
    timeline.emplace_back(start, end);
    return true;
  }

 private:
  vector<pair<int, int>> timeline;
};",729
728,"class Solution {
 public:
  int countPalindromicSubsequences(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i][j] := the number of different non-empty palindromic subsequences in
    // s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          int lo = i + 1;
          int hi = j - 1;
          while (lo <= hi && s[lo] != s[i])
            ++lo;
          while (lo <= hi && s[hi] != s[i])
            --hi;
          if (lo > hi)
            dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
          else if (lo == hi)
            dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
          else
            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1];
        } else {
          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
        }
        dp[i][j] = (dp[i][j] + kMod) % kMod;
      }

    return dp[0][n - 1];
  }
};",730
729,"book(start: int, end: int)",731
730,"class MyCalendarThree {
 public:
  int book(int start, int end) {
    ++timeline[start];
    --timeline[end];

    int ans = 0;
    int activeEvents = 0;

    for (const auto& [_, count] : timeline) {
      activeEvents += count;
      ans = max(ans, activeEvents);
    }

    return ans;
  }

 private:
  map<int, int> timeline;
};",732
731,"class Solution {
 public:
  vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc,
                                int newColor) {
    dfs(image, sr, sc,
        vector<vector<bool>>(image.size(), vector<bool>(image[0].size())),
        image[sr][sc], newColor);
    return image;
  }

 private:
  void dfs(vector<vector<int>>& image, int i, int j,
           vector<vector<bool>>&& seen, int startColor, int newColor) {
    if (i < 0 || i == image.size() || j < 0 || j == image[0].size())
      return;
    if (image[i][j] != startColor || seen[i][j])
      return;

    image[i][j] = newColor;
    seen[i][j] = true;

    dfs(image, i + 1, j, move(seen), startColor, newColor);
    dfs(image, i - 1, j, move(seen), startColor, newColor);
    dfs(image, i, j + 1, move(seen), startColor, newColor);
    dfs(image, i, j - 1, move(seen), startColor, newColor);
  }
};",733
732,"class Solution {
 public:
  bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2,
                           vector<vector<string>>& similarPairs) {
    if (sentence1.size() != sentence2.size())
      return false;

    // map[key] := all the similar words of key
    unordered_map<string, unordered_set<string>> map;

    for (const vector<string>& pair : similarPairs) {
      map[pair[1]].insert(pair[0]);
      map[pair[0]].insert(pair[1]);
    }

    for (int i = 0; i < sentence1.size(); ++i) {
      if (sentence1[i] == sentence2[i])
        continue;
      if (!map.count(sentence1[i]))
        return false;
      if (!map[sentence1[i]].count(sentence2[i]))
        return false;
    }

    return true;
  }
};",734
733,"class Solution {
 public:
  vector<int> asteroidCollision(vector<int>& asteroids) {
    vector<int> stack;

    for (const int a : asteroids)
      if (a > 0) {
        stack.push_back(a);
      } else {  // a < 0
        // Destroy the previous positive one(s).
        while (!stack.empty() && stack.back() > 0 && stack.back() < -a)
          stack.pop_back();
        if (stack.empty() || stack.back() < 0)
          stack.push_back(a);
        else if (stack.back() == -a)
          stack.pop_back();  // Both asteroids explode.
        else                 // stack[-1] > the current asteroid.
          ;                  // Destroy the current asteroid, so do nothing.
      }

    return stack;
  }
};",735
734,"class Solution {
 public:
  int evaluate(string expression) {
    return evaluate(expression, unordered_map<string, int>());
  }

 private:
  int evaluate(const string& e, unordered_map<string, int> scope) {
    if (isdigit(e[0]) || e[0] == '-')
      return stoi(e);
    if (const auto it = scope.find(e); it != scope.cend())
      return it->second;

    const int spaceIndex = e.find_first_of(' ');
    const string nextExpression =
        e.substr(spaceIndex + 1, e.length() - spaceIndex - 2);  // -2: ""()""
    const vector<string> tokens = split(nextExpression);

    // Note that e[0] == '('.
    if (e[1] == 'm')  // 'mult'
      return evaluate(tokens[0], scope) * evaluate(tokens[1], scope);
    if (e[1] == 'a')  // 'add'
      return evaluate(tokens[0], scope) + evaluate(tokens[1], scope);

    // 'let'
    for (int i = 0; i + 1 < tokens.size(); i += 2)
      scope[tokens[i]] = evaluate(tokens[i + 1], scope);
    return evaluate(tokens.back(), scope);
  };

  vector<string> split(const string& e) {
    vector<string> tokens;
    string s;
    int opened = 0;

    for (const char c : e) {
      if (c == '(')
        ++opened;
      else if (c == ')')
        --opened;
      if (opened == 0 && c == ' ') {
        tokens.push_back(s);
        s = """";
      } else {
        s += c;
      }
    }

    if (!s.empty())
      tokens.push_back(s);
    return tokens;
  }
};",736
735,"class Solution {
 public:
  bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2,
                              vector<vector<string>>& pairs) {
    if (words1.size() != words2.size())
      return false;

    // graph[key] := all the similar words of key
    unordered_map<string, unordered_set<string>> graph;

    for (const vector<string>& pair : pairs) {
      graph[pair[1]].insert(pair[0]);
      graph[pair[0]].insert(pair[1]);
    }

    for (int i = 0; i < words1.size(); ++i) {
      if (words1[i] == words2[i])
        continue;
      if (!graph.count(words1[i]))
        return false;
      if (!dfs(graph, words1[i], words2[i], {}))
        return false;
    }

    return true;
  }

 private:
  bool dfs(const unordered_map<string, unordered_set<string>>& graph,
           const string& source, const string& target,
           unordered_set<string>&& seen) {
    if (graph.at(source).count(target))
      return true;

    seen.insert(source);

    for (const string& child : graph.at(source)) {
      if (seen.count(child))
        continue;
      if (dfs(graph, child, target, move(seen)))
        return true;
    }

    return false;
  }
};",737
736,"class Solution {
 public:
  int monotoneIncreasingDigits(int n) {
    string s = to_string(n);
    const int n = s.length();
    int k = n;  // s[k..n) -> '9'

    for (int i = n - 1; i > 0; --i)
      if (s[i] < s[i - 1]) {
        --s[i - 1];
        k = i;
      }

    for (int i = k; i < n; ++i)
      s[i] = '9';

    return stoi(s);
  }
};",738
737,"class Solution {
 public:
  vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> ans(temperatures.size());
    stack<int> stack;  // a decreasing stack

    for (int i = 0; i < temperatures.size(); ++i) {
      while (!stack.empty() && temperatures[stack.top()] < temperatures[i]) {
        const int index = stack.top();
        stack.pop();
        ans[index] = i - index;
      }
      stack.push(i);
    }

    return ans;
  }
};",739
738,"class Solution {
 public:
  int deleteAndEarn(vector<int>& nums) {
    // Reduce to 198. House Robber
    vector<int> bucket(10001);

    for (const int num : nums)
      bucket[num] += num;

    int prev1 = 0;
    int prev2 = 0;

    for (const int num : bucket) {
      const int dp = max(prev1, prev2 + num);
      prev2 = prev1;
      prev1 = dp;
    }

    return prev1;
  }
};",740
739,"class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    // The problem is identical as two people start picking cherries from
    // grid[0][0] simultaneously.
    const int n = grid.size();
    vector<vector<vector<int>>> mem(
        n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INT_MIN)));
    return max(0, cherryPickup(grid, 0, 0, 0, mem));
  }

 private:
  // Returns the maximum cherries we could pick from g[0][0] ->
  // g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1], where y2 = x1 + y1 - x2
  // (reducing states from 4 to 3).
  int cherryPickup(const vector<vector<int>>& grid, int x1, int y1, int x2,
                   vector<vector<vector<int>>>& mem) {
    const int n = grid.size();
    const int y2 = x1 + y1 - x2;
    if (x1 == n || y1 == n || x2 == n || y2 == n)
      return -1;
    if (x1 == n - 1 && y1 == n - 1)
      return grid[x1][y1];
    if (grid[x1][y1] == -1 || grid[x2][y2] == -1)
      return -1;
    int& res = mem[x1][y1][x2];
    if (mem[x1][y1][x2] > INT_MIN)
      return res;

    res = max({cherryPickup(grid, x1 + 1, y1, x2, mem),
               cherryPickup(grid, x1 + 1, y1, x2 + 1, mem),
               cherryPickup(grid, x1, y1 + 1, x2, mem),
               cherryPickup(grid, x1, y1 + 1, x2 + 1, mem)});
    if (res == -1)
      return res;

    res += grid[x1][y1];  // Pick some cherries.
    if (x1 != x2)         // Two people are on the different grids.
      res += grid[x2][y2];

    return res;
  }
};",741
740,"class Solution {
 public:
  int findClosestLeaf(TreeNode* root, int k) {
    int ans = -1;
    int minDist = 1000;
    // {node: distance to TreeNode(k)}
    unordered_map<TreeNode*, int> nodeToDist;

    getDists(root, k, nodeToDist);
    getClosestLeaf(root, 0, nodeToDist, minDist, ans);

    return ans;
  }

 private:
  void getDists(TreeNode* root, int k,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root->val == k) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != nodeToDist.cend()) {
      // The TreeNode(k) is in the left subtree.
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != nodeToDist.cend())
      // The TreeNode(k) is in the right subtree.
      nodeToDist[root] = it->second + 1;
  }

  void getClosestLeaf(TreeNode* root, int dist,
                      unordered_map<TreeNode*, int>& nodeToDist, int& minDist,
                      int& ans) {
    if (root == nullptr)
      return;
    if (nodeToDist.count(root))
      dist = nodeToDist[root];
    if (root->left == nullptr && root->right == nullptr) {
      if (dist < minDist) {
        minDist = dist;
        ans = root->val;
      }
      return;
    }

    getClosestLeaf(root->left, dist + 1, nodeToDist, minDist, ans);
    getClosestLeaf(root->right, dist + 1, nodeToDist, minDist, ans);
  }
};",742
741,"class Solution {
 public:
  int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& time : times) {
      const int u = time[0] - 1;
      const int v = time[1] - 1;
      const int w = time[2];
      graph[u].emplace_back(v, w);
    }

    return dijkstra(graph, k - 1);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {
    vector<int> dist(graph.size(), INT_MAX);
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
    }

    const int maxDist = ranges::max(dist);
    return maxDist == INT_MAX ? -1 : maxDist;
  }
};",743
742,"class Solution {
 public:
  char nextGreatestLetter(vector<char>& letters, char target) {
    int l = 0;
    int r = letters.size();

    while (l < r) {
      const int m = (l + r) / 2;
      if (letters[m] > target)
        r = m;
      else
        l = m + 1;
    }

    return letters[l % letters.size()];
  }
};",744
743,"class WordFilter {
 public:
  WordFilter(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      vector<string> prefixes;
      vector<string> suffixes;
      for (int j = 0; j <= word.length(); ++j) {
        const string prefix = word.substr(0, j);
        const string suffix = word.substr(j);
        prefixes.push_back(prefix);
        suffixes.push_back(suffix);
      }
      for (const string& prefix : prefixes)
        for (const string& suffix : suffixes)
          keyToIndex[prefix + '_' + suffix] = i;
    }
  }

  int f(string prefix, string suffix) {
    const string key = prefix + '_' + suffix;
    if (const auto it = keyToIndex.find(key); it != keyToIndex.cend())
      return it->second;
    return -1;
  }

 private:
  unordered_map<string, int> keyToIndex;
};",745
744,"class Solution {
 public:
  int minCostClimbingStairs(vector<int>& cost) {
    const int n = cost.size();

    for (int i = 2; i < n; ++i)
      cost[i] += min(cost[i - 1], cost[i - 2]);

    return min(cost[n - 1], cost[n - 2]);
  }
};",746
745,"class Solution {
 public:
  int dominantIndex(vector<int>& nums) {
    int ans;
    int max = 0;
    int secondMax = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > max) {
        secondMax = max;
        max = nums[i];
        ans = i;
      } else if (nums[i] > secondMax) {
        secondMax = nums[i];
      }

    return max >= 2 * secondMax ? ans : -1;
  }
};",747
746,"class Solution {
 public:
  string shortestCompletingWord(string licensePlate, vector<string>& words) {
    string ans(16, '.');
    vector<int> count(26);

    for (const char c : licensePlate)
      if (isalpha(c))
        ++count[tolower(c) - 'a'];

    for (const string& word : words)
      if (word.length() < ans.length() && isComplete(count, getCount(word)))
        ans = word;

    return ans;
  }

 private:
  // Returns true if c1 is a subset of c2.
  bool isComplete(const vector<int>& c1, const vector<int> c2) {
    for (int i = 0; i < 26; ++i)
      if (c1[i] > c2[i])
        return false;
    return true;
  }

  vector<int> getCount(const string& word) {
    vector<int> count(26);
    for (const char c : word)
      ++count[c - 'a'];
    return count;
  }
};",748
747,"struct Region {
  // Given m = the number of rows and n = the number of columns, (x, y) will be
  // hashed as x * n + y.
  unordered_set<int> infected;
  unordered_set<int> noninfected;
  int wallsRequired = 0;
};

class Solution {
 public:
  int containVirus(vector<vector<int>>& isInfected) {
    const int m = isInfected.size();
    const int n = isInfected[0].size();
    int ans = 0;

    while (true) {
      vector<Region> regions;
      vector<vector<bool>> seen(m, vector<bool>(n));

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (isInfected[i][j] == 1 && !seen[i][j]) {
            Region region;
            // Use DFS to find all the regions (1s).
            dfs(isInfected, i, j, region, seen);
            if (!region.noninfected.empty())
              regions.push_back(region);
          }

      if (regions.empty())
        break;  // No region causes further infection.

      // Regions that infect the most neighbors will be sorted to the back of
      // the array.
      ranges::sort(regions, [](const Region& a, const Region& b) {
        return a.noninfected.size() < b.noninfected.size();
      });

      // Build walls around the region that infects the most neighbors.
      Region mostInfectedRegion = regions.back();
      regions.pop_back();
      ans += mostInfectedRegion.wallsRequired;

      for (const int neighbor : mostInfectedRegion.infected) {
        const int i = neighbor / n;
        const int j = neighbor % n;
        // The isInfected is now contained and won't be infected anymore.
        isInfected[i][j] = 2;
      }

      // For remaining regions, infect their neighbors.
      for (const Region& region : regions)
        for (const int neighbor : region.noninfected) {
          const int i = neighbor / n;
          const int j = neighbor % n;
          isInfected[i][j] = 1;
        }
    }

    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& isInfected, int i, int j, Region& region,
           vector<vector<bool>>& seen) {
    if (i < 0 || i == isInfected.size() || j < 0 || j == isInfected[0].size())
      return;
    if (seen[i][j] || isInfected[i][j] == 2)
      return;
    if (isInfected[i][j] == 0) {
      region.noninfected.insert(i * isInfected[0].size() + j);
      ++region.wallsRequired;
      return;
    }

    // isInfected[i][j] == 1
    seen[i][j] = true;
    region.infected.insert(i * isInfected[0].size() + j);

    dfs(isInfected, i + 1, j, region, seen);
    dfs(isInfected, i - 1, j, region, seen);
    dfs(isInfected, i, j + 1, region, seen);
    dfs(isInfected, i, j - 1, region, seen);
  }
};",749
748,"class Solution {
 public:
  int countCornerRectangles(vector<vector<int>>& grid) {
    int ans = 0;

    for (int row1 = 0; row1 < grid.size() - 1; ++row1)
      for (int row2 = row1 + 1; row2 < grid.size(); ++row2) {
        int count = 0;
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[row1][j] && grid[row2][j])
            ++count;
        ans += count * (count - 1) / 2;
      }

    return ans;
  }
};",750
749,"class Solution {
 public:
  vector<string> ipToCIDR(string ip, int n) {
    vector<string> ans;
    long num = getNum(ip);

    while (n > 0) {
      const long lowbit = num & -num;
      const long count = lowbit == 0 ? maxLow(n) : firstFit(lowbit, n);
      ans.push_back(getCIDR(num, getPrefix(count)));
      n -= count;
      num += count;
    }

    return ans;
  }

 private:
  long getNum(const string& ip) {
    istringstream iss(ip);
    long num = 0;
    for (string token; getline(iss, token, '.');)
      num = num * 256 + stol(token);
    return num;
  }

  // Returns the maximum i s.t. 2^i < n.
  int maxLow(int n) {
    for (int i = 0; i < 32; ++i)
      if (1 << i + 1 > n)
        return 1 << i;
    throw;
  }

  long firstFit(long lowbit, long n) {
    while (lowbit > n)
      lowbit >>= 1;
    return lowbit;
  }

  string getCIDR(long num, long prefix) {
    const long d = num & 255;
    num >>= 8;
    const long c = num & 255;
    num >>= 8;
    const long b = num & 255;
    num >>= 8;
    const long a = num & 255;
    return to_string(a) + '.' + to_string(b) + '.' + to_string(c) + '.' +
           to_string(d) + '/' + to_string(prefix);
  }

  // e.g. count = 8 = 2^3 -> prefix = 32 - 3 = 29
  //      count = 1 = 2^0 -> prefix = 32 - 0 = 32
  int getPrefix(long count) {
    for (int i = 0; i < 32; ++i)
      if (count == 1 << i)
        return 32 - i;
    throw;
  }
};",751
750,"class Solution {
 public:
  int openLock(vector<string>& deadends, string target) {
    unordered_set<string> seen{deadends.begin(), deadends.end()};
    if (seen.count(""0000""))
      return -1;
    if (target == ""0000"")
      return 0;

    int ans = 0;
    queue<string> q{{""0000""}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
          const char cache = word[i];
          // Increase the i-th digit by 1.
          word[i] = word[i] == '9' ? '0' : word[i] + 1;
          if (word == target)
            return ans;
          if (!seen.count(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
          // Decrease the i-th digit by 1.
          word[i] = word[i] == '0' ? '9' : word[i] - 1;
          if (word == target)
            return ans;
          if (!seen.count(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
        }
      }
    }

    return -1;
  }
};",752
751,"class Solution {
 public:
  string crackSafe(int n, int k) {
    string ans(n, '0');
    dfs(pow(k, n), n, k, {ans}, ans);
    return ans;
  }

 private:
  bool dfs(int passwordSize, int n, int k, unordered_set<string>&& seen,
           string& path) {
    if (seen.size() == passwordSize)
      return true;

    string prefix = path.substr(path.length() - n + 1);

    for (char c = '0'; c < '0' + k; ++c) {
      prefix.push_back(c);
      if (!seen.count(prefix)) {
        seen.insert(prefix);
        path.push_back(c);
        if (dfs(passwordSize, n, k, move(seen), path))
          return true;
        path.pop_back();
        seen.erase(prefix);
      }
      prefix.pop_back();
    }

    return false;
  }
};",753
752,"class Solution {
 public:
  int reachNumber(int target) {
    const int newTarget = abs(target);
    int ans = 0;
    int pos = 0;

    while (pos < newTarget)
      pos += ++ans;
    while ((pos - newTarget) & 1)
      pos += ++ans;

    return ans;
  }
};",754
753,"class Solution {
 public:
  vector<int> pourWater(vector<int>& heights, int volume, int k) {
    int i = k;

    while (volume-- > 0) {
      while (i > 0 && heights[i] >= heights[i - 1])
        --i;
      while (i + 1 < heights.size() && heights[i] >= heights[i + 1])
        ++i;
      while (i > k && heights[i] == heights[i - 1])
        --i;
      ++heights[i];
    }

    return heights;
  }
};",755
754,"class Solution {
 public:
  bool pyramidTransition(string bottom, vector<string>& allowed) {
    unordered_map<string, vector<char>> prefixToBlocks;

    for (const string& a : allowed)
      prefixToBlocks[a.substr(0, 2)].push_back(a[2]);

    return dfs(bottom, """", 0, prefixToBlocks);
  }

 private:
  bool dfs(const string& row, const string& nextRow, int i,
           const unordered_map<string, vector<char>>& prefixToBlocks) {
    if (row.length() == 1)
      return true;
    if (nextRow.length() + 1 == row.length())
      return dfs(nextRow, """", 0, prefixToBlocks);

    const string& prefix = row.substr(i, 2);

    if (const auto it = prefixToBlocks.find(prefix);
        it != prefixToBlocks.cend())
      for (const char c : it->second)
        if (dfs(row, nextRow + c, i + 1, prefixToBlocks))
          return true;

    return false;
  }
};",756
755,"class Solution {
 public:
  int intersectionSizeTwo(vector<vector<int>>& intervals) {
    int ans = 0;
    int max = -1;
    int secondMax = -1;

    ranges::sort(intervals, [](const vector<int>& a, const vector<int>& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];
    });

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      // The maximum and the second maximum still satisfy.
      if (max >= a && secondMax >= a)
        continue;
      if (max >= a) {  // The maximum still satisfy.
        secondMax = max;
        max = b;  // Add b to the set S.
        ans += 1;
      } else {              // The maximum and the second maximum can't satisfy.
        max = b;            // Add b to the set S.
        secondMax = b - 1;  // Add b - 1 to the set S.
        ans += 2;
      }
    }

    return ans;
  }
};",757
756,"class Solution {
 public:
  string boldWords(vector<string>& words, string s) {
    const int n = s.length();
    string ans;
    // bold[i] := true if s[i] should be bolded
    vector<bool> bold(n);

    int boldEnd = -1;  // s[i:boldEnd] should be bolded
    for (int i = 0; i < n; ++i) {
      for (const string& word : words)
        if (s.substr(i).find(word) == 0)
          boldEnd = max(boldEnd, i + static_cast<int>(word.length()));
      bold[i] = boldEnd > i;
    }

    // Construct the string with the bold tags.
    int i = 0;
    while (i < n)
      if (bold[i]) {
        int j = i;
        while (j < n && bold[j])
          ++j;
        // `s[i..j)` should be bolded.
        ans += ""<b>"" + s.substr(i, j - i) + ""</b>"";
        i = j;
      } else {
        ans += s[i++];
      }

    return ans;
  }
};",758
757,"class Solution {
 public:
  vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {
    vector<Interval> ans;
    vector<Interval> intervals;

    for (const vector<Interval>& s : schedule)
      intervals.insert(intervals.end(), s.begin(), s.end());

    ranges::sort(intervals, [](const auto& a, const auto& b) {
      return a.start < b.start;
    });

    int prevEnd = intervals[0].end;

    for (const auto& [start, end] : intervals) {
      if (start > prevEnd)
        ans.emplace_back(prevEnd, start);
      prevEnd = max(prevEnd, end);
    }

    return ans;
  }
};",759
758,"class Solution {
 public:
  vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_map<int, stack<int>> numToIndices;

    for (int i = 0; i < nums2.size(); ++i)
      numToIndices[nums2[i]].push(i);

    for (const int num : nums1)
      ans.push_back(numToIndices[num].top()), numToIndices[num].pop();

    return ans;
  }
};",760
759,"class Solution {
 public:
  string makeLargestSpecial(string s) {
    vector<string> specials;
    int count = 0;

    for (int i = 0, j = 0; j < s.length(); ++j) {
      count += s[j] == '1' ? 1 : -1;
      if (count == 0) {  // Find a special string.
        const string& inner = s.substr(i + 1, j - i - 1);
        specials.push_back('1' + makeLargestSpecial(inner) + '0');
        i = j + 1;
      }
    }

    ranges::sort(specials, greater<>());
    return join(specials);
  }

 private:
  string join(const vector<string>& specials) {
    string joined;
    for (const string& special : specials)
      joined += special;
    return joined;
  }
};",761
760,"class Solution {
 public:
  int countPrimeSetBits(int L, int R) {
    // {2, 3, 5, 7, 11, 13, 17, 19}-th bits are 1s.
    // 0b10100010100010101100 = 665772
    constexpr int magic = 665772;
    int ans = 0;

    for (int n = L; n <= R; ++n)
      if (magic & 1 << __builtin_popcountll(n))
        ++ans;

    return ans;
  }
};",762
761,"class Solution {
 public:
  vector<int> partitionLabels(string s) {
    vector<int> ans;
    vector<int> rightmost(26);

    for (int i = 0; i < s.length(); ++i)
      rightmost[s[i] - 'a'] = i;

    int l = 0;  // the leftmost index of the current running string
    int r = 0;  // the rightmost index of the current running string

    for (int i = 0; i < s.length(); ++i) {
      r = max(r, rightmost[s[i] - 'a']);
      if (r == i) {
        ans.push_back(i - l + 1);
        l = i + 1;
      }
    }

    return ans;
  }
};",763
762,"class Solution {
 public:
  int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
    vector<vector<int>> grid(n, vector<int>(n, n));

    for (const vector<int>& mine : mines)
      grid[mine[0]][mine[1]] = 0;

    // Extend the four directions. If meet 0, need to start over from 0.
    for (int i = 0; i < n; ++i) {
      for (int j = 0, leftToRight = 0; j < n; ++j) {
        leftToRight = (grid[i][j] == 0 ? 0 : leftToRight + 1);
        grid[i][j] = min(grid[i][j], leftToRight);
      }
      for (int j = n - 1, rightToLeft = 0; j >= 0; --j) {
        rightToLeft = (grid[i][j] == 0 ? 0 : rightToLeft + 1);
        grid[i][j] = min(grid[i][j], rightToLeft);
      }
      for (int j = 0, upToDown = 0; j < n; ++j) {
        upToDown = (grid[j][i] == 0 ? 0 : upToDown + 1);
        grid[j][i] = min(grid[j][i], upToDown);
      }
      for (int j = n - 1, downToUp = 0; j >= 0; --j) {
        downToUp = (grid[j][i] == 0) ? 0 : downToUp + 1;
        grid[j][i] = min(grid[j][i], downToUp);
      }
    }

    int ans = 0;

    for (const vector<int>& row : grid)
      ans = max(ans, ranges::max(row));

    return ans;
  }
};",764
763,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int minSwapsCouples(vector<int>& row) {
    const int n = row.size() / 2;
    UnionFind uf(n);

    for (int i = 0; i < n; ++i) {
      const int a = row[2 * i];
      const int b = row[2 * i + 1];
      uf.unionByRank(a / 2, b / 2);
    }

    return n - uf.getCount();
  }
};",765
764,"class Solution {
 public:
  bool isToeplitzMatrix(vector<vector<int>>& matrix) {
    for (int i = 0; i + 1 < matrix.size(); ++i)
      for (int j = 0; j + 1 < matrix[0].size(); ++j)
        if (matrix[i][j] != matrix[i + 1][j + 1])
          return false;
    return true;
  }
};",766
765,"class Solution {
 public:
  string reorganizeString(string s) {
    unordered_map<char, int> count;
    int maxFreq = 0;

    for (const char c : s)
      maxFreq = max(maxFreq, ++count[c]);

    if (maxFreq > (s.length() + 1) / 2)
      return """";

    string ans;
    priority_queue<pair<int, char>> maxHeap;  // (freq, c)
    int prevFreq = 0;
    char prevChar = '@';

    for (const auto& [c, freq] : count)
      maxHeap.emplace(freq, c);

    while (!maxHeap.empty()) {
      // Get the letter with the maximum frequency.
      const auto [freq, c] = maxHeap.top();
      maxHeap.pop();
      ans += c;
      // Add the previous letter back s.t. any two adjacent characters are not
      // the same.
      if (prevFreq > 0)
        maxHeap.emplace(prevFreq, prevChar);
      prevFreq = freq - 1;
      prevChar = c;
    }

    return ans;
  }
};",767
766,"class Solution {
 public:
  int maxChunksToSorted(vector<int>& arr) {
    const int n = arr.size();
    int ans = 0;
    vector<int> maxL(n);  // l[i] := max(arr[0..i])
    vector<int> minR(n);  // r[i] := min(arr[i..n))

    for (int i = 0; i < n; ++i)
      maxL[i] = i == 0 ? arr[i] : max(arr[i], maxL[i - 1]);

    for (int i = n - 1; i >= 0; --i)
      minR[i] = i == n - 1 ? arr[i] : min(arr[i], minR[i + 1]);

    for (int i = 0; i + 1 < n; ++i)
      if (maxL[i] <= minR[i + 1])
        ++ans;

    return ans + 1;
  }
};",768
767,"class Solution {
 public:
  int maxChunksToSorted(vector<int>& arr) {
    int ans = 0;
    int maxi = INT_MIN;

    for (int i = 0; i < arr.size(); ++i) {
      maxi = max(maxi, arr[i]);
      if (maxi == i)
        ++ans;
    }

    return ans;
  }
};",769
768,"class Poly {
  friend Poly operator+(const Poly& lhs, const Poly& rhs) {
    Poly res(lhs);
    for (const auto& [term, coef] : rhs.terms)
      res.terms[term] += coef;
    return res;
  }

  friend Poly operator-(const Poly& lhs, const Poly& rhs) {
    Poly res(lhs);
    for (const auto& [term, coef] : rhs.terms)
      res.terms[term] -= coef;
    return res;
  }

  friend Poly operator*(const Poly& lhs, const Poly& rhs) {
    Poly res;
    for (const auto& [a, aCoef] : lhs.terms)
      for (const auto& [b, bCoef] : rhs.terms)
        res.terms[merge(a, b)] += aCoef * bCoef;
    return res;
  }

  // Friend ostream& operator<<(ostream& os, const Poly& poly) {
  //   os << ""{"";
  //   for (const auto& [term, coef] : poly.terms)
  //     os << term << "": "" << coef << "", "";
  //   os << ""}"";
  //   return os;
  // }

 public:
  vector<string> toList() {
    vector<string> res;
    vector<string> keys;
    for (const auto& [term, _] : terms)
      keys.push_back(term);
    ranges::sort(keys, [&](const string& a, const string& b) {
      // the minimum degree is the last
      if (a == ""1"")
        return false;
      if (b == ""1"")
        return true;
      const vector<string> as = split(a, '*');
      const vector<string> bs = split(b, '*');
      // the maximum degree is the first
      // Break ties by their lexicographic orders.
      return as.size() == bs.size() ? a < b : as.size() > bs.size();
    });
    auto concat = [&](const string& term) -> string {
      if (term == ""1"")
        return to_string(terms[term]);
      return to_string(terms[term]) + '*' + term;
    };
    for (const string& key : keys)
      if (terms[key])
        res.push_back(concat(key));
    return res;
  }

  Poly() = default;
  Poly(const string& term, int coef) {
    terms[term] = coef;
  }

 private:
  unordered_map<string, int> terms;

  // e.g. merge(""a*b"", ""a*c"") -> ""a*a*b*c""
  static string merge(const string& a, const string& b) {
    if (a == ""1"")
      return b;
    if (b == ""1"")
      return a;
    string res;
    vector<string> A = split(a, '*');
    vector<string> B = split(b, '*');
    int i = 0;  // A's index
    int j = 0;  // B's index
    while (i < A.size() && j < B.size())
      if (A[i] < B[j])
        res += '*' + A[i++];
      else
        res += '*' + B[j++];
    while (i < A.size())
      res += '*' + A[i++];
    while (j < B.size())
      res += '*' + B[j++];
    return res.substr(1);
  }

  static vector<string> split(const string& token, char c) {
    vector<string> vars;
    istringstream iss(token);
    for (string var; getline(iss, var, c);)
      vars.push_back(var);
    return vars;
  }
};

class Solution {
 public:
  vector<string> basicCalculatorIV(string expression, vector<string>& evalvars,
                                   vector<int>& evalints) {
    vector<string> tokens = getTokens(expression);
    unordered_map<string, int> evalMap;

    for (int i = 0; i < evalvars.size(); ++i)
      evalMap[evalvars[i]] = evalints[i];

    for (string& token : tokens)
      if (const auto it = evalMap.find(token); it != evalMap.cend())
        token = to_string(it->second);

    const vector<string>& postfix = infixToPostfix(tokens);
    return evaluate(postfix).toList();
  }

 private:
  vector<string> getTokens(const string& s) {
    vector<string> tokens;
    int i = 0;
    for (int j = 0; j < s.length(); ++j)
      if (s[j] == ' ') {
        if (i < j)
          tokens.push_back(s.substr(i, j - i));
        i = j + 1;
      } else if (string(""()+-*"").find(s[j]) != string::npos) {
        if (i < j)
          tokens.push_back(s.substr(i, j - i));
        tokens.push_back(s.substr(j, 1));
        i = j + 1;
      }
    if (i < s.length())
      tokens.push_back(s.substr(i));
    return tokens;
  }

  bool isOperator(const string& token) {
    return token == ""+"" || token == ""-"" || token == ""*"";
  }

  vector<string> infixToPostfix(const vector<string>& tokens) {
    vector<string> postfix;
    stack<string> ops;

    auto precedes = [](const string& prevOp, const string& currOp) -> bool {
      if (prevOp == ""("")
        return false;
      return prevOp == ""*"" || currOp == ""+"" || currOp == ""-"";
    };

    for (const string& token : tokens)
      if (token == ""("") {
        ops.push(token);
      } else if (token == "")"") {
        while (ops.top() != ""("")
          postfix.push_back(ops.top()), ops.pop();
        ops.pop();
      } else if (isOperator(token)) {
        while (!ops.empty() && precedes(ops.top(), token))
          postfix.push_back(ops.top()), ops.pop();
        ops.push(token);
      } else {  // isOperand(token)
        postfix.push_back(token);
      }

    while (!ops.empty())
      postfix.push_back(ops.top()), ops.pop();

    return postfix;
  }

  Poly evaluate(const vector<string>& postfix) {
    vector<Poly> polys;
    for (const string& token : postfix)
      if (isOperator(token)) {
        const Poly b = polys.back();
        polys.pop_back();
        const Poly a = polys.back();
        polys.pop_back();
        if (token == ""+"")
          polys.push_back(a + b);
        else if (token == ""-"")
          polys.push_back(a - b);
        else  // token == ""*""
          polys.push_back(a * b);
      } else if (token[0] == '-' ||
                 ranges::all_of(token, [](char c) { return isdigit(c); })) {
        polys.push_back(Poly(""1"", stoi(token)));
      } else {
        polys.push_back(Poly(token, 1));
      }
    return polys[0];
  }
};",770
769,"class Solution {
 public:
  int numJewelsInStones(string jewels, string stones) {
    int ans = 0;
    unordered_set<char> jewelsSet(jewels.begin(), jewels.end());

    for (const char stone : stones)
      if (jewelsSet.count(stone))
        ++ans;

    return ans;
  }
};",771
770,"class Solution {
 public:
  int calculate(string s) {
    stack<int> nums;
    stack<int> ops;
    bool hasPrevNum = false;

    auto calc = [&]() {
      const int b = nums.top();
      nums.pop();
      const int a = nums.top();
      nums.pop();
      const char op = ops.top();
      ops.pop();
      if (op == '+')
        nums.push(a + b);
      else if (op == '-')
        nums.push(a - b);
      else if (op == '*')
        nums.push(a * b);
      else  // op == '/'
        nums.push(a / b);
    };

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c)) {
        int num = c - '0';
        while (i + 1 < s.length() && isdigit(s[i + 1]))
          num = num * 10 + (s[i++ + 1] - '0');
        nums.push(num);
        hasPrevNum = true;
      } else if (c == '(') {
        ops.push('(');
        hasPrevNum = false;
      } else if (c == ')') {
        while (ops.top() != '(')
          calc();
        ops.pop();  // Pop '('.
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        if (!hasPrevNum)
          nums.push(0);
        while (!ops.empty() && precedes(ops.top(), c))
          calc();
        ops.push(c);
      }
    }

    while (!ops.empty())
      calc();

    return nums.top();
  }

 private:
  // Returns true if the previous character is a operator and the priority of
  // the previous operator >= the priority of the current character (operator).
  bool precedes(char prev, char curr) {
    if (prev == '(')
      return false;
    return prev == '*' || prev == '/' || curr == '+' || curr == '-';
  }
};",772
771,"class Solution {
 public:
  int slidingPuzzle(vector<vector<int>>& board) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    constexpr int m = 2;
    constexpr int n = 3;
    const string goal = ""123450"";
    int steps = 0;
    string start;

    // Hash the 2D vector into a string.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        start += '0' + board[i][j];

    if (start == goal)
      return 0;

    queue<string> q{{start}};
    unordered_set<string> seen{start};

    while (!q.empty()) {
      ++steps;
      for (int sz = q.size(); sz > 0; --sz) {
        string s = q.front();
        q.pop();
        const int zeroIndex = s.find('0');
        const int i = zeroIndex / n;
        const int j = zeroIndex % n;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const int swappedIndex = x * n + y;
          swap(s[zeroIndex], s[swappedIndex]);
          if (s == goal)
            return steps;
          if (!seen.count(s)) {
            q.push(s);
            seen.insert(s);
          }
          swap(s[zeroIndex], s[swappedIndex]);
        }
      }
    }

    return -1;
  }
};",773
772,"class Solution {
 public:
  double minmaxGasDist(vector<int>& stations, int k) {
    constexpr double kErr = 1e-6;
    double l = 0;
    double r = stations.back() - stations[0];

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (check(stations, k, m))
        r = m;
      else
        l = m;
    }

    return l;
  }

 private:
  // Returns true if can use <= k gas stations to ensure that each adjacent
  // distance between gas stations <= m.
  bool check(const vector<int>& stations, int k, double m) {
    for (int i = 1; i < stations.size(); ++i) {
      const int diff = stations[i] - stations[i - 1];
      if (diff > m) {
        k -= ceil(diff / m) - 1;
        if (k < 0)
          return false;
      }
    }
    return true;
  };
};",774
773,"class Solution {
 public:
  bool isIdealPermutation(vector<int>& nums) {
    int maxi = -1;  // the number that is most likely > nums[i + 2]

    for (int i = 0; i + 2 < nums.size(); ++i) {
      maxi = max(maxi, nums[i]);
      if (maxi > nums[i + 2])
        return false;
    }

    return true;
  }
};",775
774,"class Solution {
 public:
  vector<TreeNode*> splitBST(TreeNode* root, int target) {
    if (root == nullptr)
      return {nullptr, nullptr};
    if (root->val > target) {
      const vector<TreeNode*> res = splitBST(root->left, target);
      root->left = res[1];
      return {res[0], root};
    } else {  // root->val <= target
      const vector<TreeNode*> res = splitBST(root->right, target);
      root->right = res[0];
      return {root, res[1]};
    }
  }
};",776
775,"class Solution {
 public:
  bool canTransform(string start, string end) {
    if (removeX(start) != removeX(end))
      return false;

    int i = 0;  // start's index
    int j = 0;  // end's index

    while (i < start.length() && j < end.length()) {
      while (i < start.length() && start[i] == 'X')
        ++i;
      while (j < end.length() && end[j] == 'X')
        ++j;
      if (i == start.length() && j == end.length())
        return true;
      if (i == start.length() || j == end.length())
        return false;
      // L can only move to left.
      if (start[i] == 'L' && i < j)
        return false;
      // R can only move to right.
      if (start[i] == 'R' && i > j)
        return false;
      ++i;
      ++j;
    }

    return true;
  }

 private:
  string removeX(const string& s) {
    string t = s;
    t.erase(remove(t.begin(), t.end(), 'X'), t.end());
    return t;
  }
};",777
776,"class Solution {
 public:
  int swimInWater(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int n = grid.size();
    int ans = grid[0][0];
    using T = tuple<int, int, int>;  // (grid[i][j], i, j)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<bool>> seen(n, vector<bool>(n));

    minHeap.emplace(grid[0][0], 0, 0);
    seen[0][0] = true;

    while (!minHeap.empty()) {
      const auto [height, i, j] = minHeap.top();
      minHeap.pop();
      ans = max(ans, height);
      if (i == n - 1 && j == n - 1)
        break;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == n || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        minHeap.emplace(grid[x][y], x, y);
        seen[x][y] = true;
      }
    }

    return ans;
  }
};",778
777,"class Solution {
 public:
  int kthGrammar(int n, int k) {
    if (n == 1)
      return 0;
    if (k & 1)
      return kthGrammar(n - 1, (k + 1) / 2) != 0;  // the left node
    return kthGrammar(n - 1, k / 2) == 0;          // the right node
  }
};",779
778,"class Solution {
 public:
  bool reachingPoints(int sx, int sy, int tx, int ty) {
    while (sx < tx && sy < ty)
      if (tx > ty)
        tx %= ty;
      else
        ty %= tx;

    return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||
           sy == ty && sx <= tx && (tx - sx) % sy == 0;
  }
};",780
779,"class Solution {
 public:
  int numRabbits(vector<int>& answers) {
    int ans = 0;
    vector<int> count(1000);

    for (const int answer : answers) {
      if (count[answer] % (answer + 1) == 0)
        ans += answer + 1;
      ++count[answer];
    }

    return ans;
  }
};",781
780,"class Solution {
 public:
  int movesToChessboard(vector<vector<int>>& board) {
    const int n = board.size();
    int rowSum = 0;
    int colSum = 0;
    int rowSwaps = 0;
    int colSwaps = 0;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j] == 1)
          return -1;

    for (int i = 0; i < n; ++i) {
      rowSum += board[0][i];
      colSum += board[i][0];
    }

    if (rowSum != n / 2 && rowSum != (n + 1) / 2)
      return -1;
    if (colSum != n / 2 && colSum != (n + 1) / 2)
      return -1;

    for (int i = 0; i < n; ++i) {
      rowSwaps += board[i][0] == (i & 1);
      colSwaps += board[0][i] == (i & 1);
    }

    if (n % 2 == 1) {
      if (rowSwaps & 1)
        rowSwaps = n - rowSwaps;
      if (colSwaps & 1)
        colSwaps = n - colSwaps;
    } else {
      rowSwaps = min(rowSwaps, n - rowSwaps);
      colSwaps = min(colSwaps, n - colSwaps);
    }

    return (rowSwaps + colSwaps) / 2;
  }
};",782
781,"class Solution {
 public:
  int minDiffInBST(TreeNode* root) {
    int ans = INT_MAX;
    inorder(root, ans);
    return ans;
  }

 private:
  int pred = -1;

  void inorder(TreeNode* root, int& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, ans);
    if (pred >= 0)
      ans = min(ans, root->val - pred);
    pred = root->val;
    inorder(root->right, ans);
  }
};",783
782,"class Solution {
 public:
  vector<string> letterCasePermutation(string s) {
    vector<string> ans;
    dfs(s, 0, ans);
    return ans;
  }

 private:
  void dfs(string& s, int i, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(s);
      return;
    }
    if (isdigit(s[i])) {
      dfs(s, i + 1, ans);
      return;
    }

    s[i] = tolower(s[i]);
    dfs(s, i + 1, ans);
    s[i] = toupper(s[i]);
    dfs(s, i + 1, ans);
  }
};",784
783,"enum class Color { kWhite, kRed, kGreen };

class Solution {
 public:
  bool isBipartite(vector<vector<int>>& graph) {
    vector<Color> colors(graph.size(), Color::kWhite);

    for (int i = 0; i < graph.size(); ++i) {
      // This node has been colored, so do nothing.
      if (colors[i] != Color::kWhite)
        continue;
      // Always paint red for a white node.
      colors[i] = Color::kRed;
      // BFS.
      queue<int> q{{i}};
      while (!q.empty()) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u]) {
          if (colors[v] == colors[u])
            return false;
          if (colors[v] == Color::kWhite) {
            colors[v] = colors[u] == Color::kRed ? Color::kGreen : Color::kRed;
            q.push(v);
          }
        }
      }
    }

    return true;
  }
};",785
784,"class Solution {
 public:
  vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
    const int n = arr.size();
    double l = 0.0;
    double r = 1.0;

    while (l < r) {
      const double m = (l + r) / 2.0;
      int fractionsNoGreaterThanM = 0;
      int p = 0;
      int q = 1;

      // For each index i, find the first index j s.t. arr[i] / arr[j] <= m,
      // so fractionsNoGreaterThanM for index i will be n - j.
      for (int i = 0, j = 1; i < n; ++i) {
        while (j < n && arr[i] > m * arr[j])
          ++j;
        if (j == n)
          break;
        fractionsNoGreaterThanM += n - j;
        if (p * arr[j] < q * arr[i]) {
          p = arr[i];
          q = arr[j];
        }
      }

      if (fractionsNoGreaterThanM == k)
        return {p, q};
      if (fractionsNoGreaterThanM > k)
        r = m;
      else
        l = m;
    }

    throw;
  }
};",786
785,"class Solution {
 public:
  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,
                        int k) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& flight : flights) {
      const int u = flight[0];
      const int v = flight[1];
      const int w = flight[2];
      graph[u].emplace_back(v, w);
    }

    return dijkstra(graph, src, dst, k);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int k) {
    vector<vector<int>> dist(graph.size(), vector<int>(k + 2, INT_MAX));
    using T = tuple<int, int, int>;  // (d, u, stops)
    priority_queue<T, vector<T>, greater<>> minHeap;

    dist[src][k + 1] = 0;
    minHeap.emplace(dist[src][k + 1], src, k + 1);

    while (!minHeap.empty()) {
      const auto [d, u, stops] = minHeap.top();
      minHeap.pop();
      if (u == dst)
        return d;
      if (stops == 0)
        continue;
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v][stops - 1]) {
          dist[v][stops - 1] = d + w;
          minHeap.emplace(dist[v][stops - 1], v, stops - 1);
        }
    }

    return -1;
  }
};",787
786,"class Solution {
 public:
  int rotatedDigits(int n) {
    int ans = 0;

    for (int i = 1; i <= n; ++i)
      if (isGoodNumber(i))
        ++ans;

    return ans;
  }

 private:
  bool isGoodNumber(int i) {
    bool isRotated = false;

    for (const char c : to_string(i)) {
      if (c == '0' || c == '1' || c == '8')
        continue;
      if (c == '2' || c == '5' || c == '6' || c == '9')
        isRotated = true;
      else
        return false;
    }

    return isRotated;
  }
};",788
787,"class Solution {
 public:
  bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {
    const int d = abs(target[0]) + abs(target[1]);

    for (const vector<int>& ghost : ghosts)
      if (d >= abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]))
        return false;

    return true;
  }
};",789
788,"class Solution {
 public:
  int numTilings(int n) {
    constexpr int kMod = 1'000'000'007;
    vector<long> dp(1001);
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 5;

    for (int i = 4; i <= n; ++i)
      dp[i] = (2 * dp[i - 1] + dp[i - 3]) % kMod;

    return dp[n];
  }
};",790
789,"class Solution {
 public:
  string customSortString(string order, string s) {
    string ans;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const char c : order)
      while (count[c]-- > 0)
        ans += c;

    for (char c = 'a'; c <= 'z'; ++c)
      while (count[c]-- > 0)
        ans += c;

    return ans;
  }
};",791
790,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  int numMatchingSubseq(string s, vector<string>& words) {
    for (const string& word : words)
      insert(word);
    return dfs(s, 0, root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    ++node->count;
  }

  int dfs(const string& s, int i, shared_ptr<TrieNode> node) {
    int ans = node->count;
    if (i >= s.length())
      return ans;

    for (int j = 0; j < 26; ++j)
      if (node->children[j]) {
        const int index = s.find('a' + j, i);
        if (index != -1)
          ans += dfs(s, index + 1, node->children[j]);
      }

    return ans;
  }
};",792
791,"class Solution {
 public:
  int preimageSizeFZF(int k) {
    long l = 0;
    long r = 5L * k;

    while (l < r) {
      const long m = (l + r) / 2;
      if (trailingZeroes(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return trailingZeroes(l) == k ? 5 : 0;
  }

 private:
  // Same as 172. Factorial Trailing Zeroes
  int trailingZeroes(long n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};",793
792,"class Solution {
 public:
  bool validTicTacToe(vector<string>& board) {
    const int countX = sum(board, 'X');
    const int countO = sum(board, 'O');

    if (countX < countO || countX - countO > 1)
      return false;
    if (isWinned(board, 'X') && countX == countO ||
        isWinned(board, 'O') && countX != countO)
      return false;

    return true;
  }

 private:
  int sum(const vector<string>& board, char c) {
    int ans = 0;

    for (const string& row : board)
      ans += ranges::count(row, c);

    return ans;
  }

  bool isWinned(const vector<string>& board, char c) {
    vector<string> rotated = rotate(board);

    auto equalsToThree = [&c](const string& row) {
      return ranges::count(row, c) == 3;
    };

    return ranges::any_of(board, equalsToThree) ||
           ranges::any_of(rotated, equalsToThree) ||
           board[0][0] == c && board[1][1] == c && board[2][2] == c ||
           board[0][2] == c && board[1][1] == c && board[2][0] == c;
  }

  vector<string> rotate(const vector<string>& board) {
    vector<string> rotated(3);

    for (const string& row : board)
      for (int i = 0; i < 3; ++i)
        rotated[i].push_back(row[i]);

    return rotated;
  }
};",794
793,"class Solution {
 public:
  int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
    int ans = 0;
    int l = -1;
    int r = -1;

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > right)  // Handle the reset value.
        l = i;
      if (nums[i] >= left)  // Handle the reset and the needed value.
        r = i;
      ans += r - l;
    }

    return ans;
  }
};",795
794,"class Solution {
 public:
  bool rotateString(string s, string goal) {
    return s.length() == goal.length() && (s + s).find(goal) != string::npos;
  }
};",796
795,"class Solution {
 public:
  vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    vector<vector<int>> ans;
    dfs(graph, 0, {0}, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (u == graph.size() - 1) {
      ans.push_back(path);
      return;
    }

    for (const int v : graph[u]) {
      path.push_back(v);
      dfs(graph, v, move(path), ans);
      path.pop_back();
    }
  }
};",797
796,"class Solution {
 public:
  int bestRotation(vector<int>& nums) {
    const int n = nums.size();
    // rotate[i] := the number of points lost after rotating left i times
    vector<int> rotate(n);

    // Rotating i - nums[i] times makes nums[i] == its new index.
    // So, rotating i - nums[i] + 1 times will ""start"" to make nums[i] > its
    // index, which is the starting index to lose point.
    for (int i = 0; i < n; ++i)
      --rotate[(i - nums[i] + 1 + n) % n];

    // Each time of the rotation, make index 0 to index n - 1 to get 1 point.
    for (int i = 1; i < n; ++i)
      rotate[i] += rotate[i - 1] + 1;

    return distance(rotate.begin(), ranges::max_element(rotate));
  }
};",798
797,"class Solution {
 public:
  double champagneTower(int poured, int query_row, int query_glass) {
    vector<vector<double>> dp(query_row + 1, vector<double>(query_row + 1));
    dp[0][0] = poured;

    for (int i = 0; i < query_row; ++i)
      for (int j = 0; j <= i; ++j)
        if (dp[i][j] > 1) {
          dp[i + 1][j] += (dp[i][j] - 1) / 2.0;
          dp[i + 1][j + 1] += (dp[i][j] - 1) / 2.0;
        }

    return min(1.0, dp[query_row][query_glass]);
  }
};",799
798,"class Solution {
 public:
  string similarRGB(string color) {
    const vector<string> kShorthands = {""00"", ""11"", ""22"", ""33"", ""44"", ""55"",
                                        ""66"", ""77"", ""88"", ""99"", ""aa"", ""bb"",
                                        ""cc"", ""dd"", ""ee"", ""ff""};
    string ans = ""#"";

    for (int i = 1; i < color.length(); i += 2) {
      const int currValue = stoi(color.substr(i, 2), 0, 16);
      ans += findClosestShorthand(kShorthands, currValue);
    }

    return ans;
  }

 private:
  static constexpr int maxSimilarity = 255 * 255;

  string findClosestShorthand(const vector<string>& shorthands,
                              int targetValue) {
    string closest = shorthands[0];
    int minSimilarity = maxSimilarity;

    for (const string& shorthand : shorthands) {
      const int shorthandValue = stoi(shorthand, 0, 16);
      const int similarity = pow((targetValue - shorthandValue), 2);
      if (similarity < minSimilarity) {
        closest = shorthand;
        minSimilarity = similarity;
      }
    }

    return closest;
  }
};",800
799,"class Solution {
 public:
  int minSwap(vector<int>& nums1, vector<int>& nums2) {
    vector<int> keepAt(nums1.size(), INT_MAX);
    vector<int> swapAt(nums1.size(), INT_MAX);
    keepAt[0] = 0;
    swapAt[0] = 1;

    for (int i = 1; i < nums1.size(); ++i) {
      if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
        keepAt[i] = keepAt[i - 1];
        swapAt[i] = swapAt[i - 1] + 1;
      }
      if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
        keepAt[i] = min(keepAt[i], swapAt[i - 1]);
        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1);
      }
    }

    return min(keepAt.back(), swapAt.back());
  }
};",801
800,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
    vector<int> ans;
    vector<State> states(graph.size());

    for (int i = 0; i < graph.size(); ++i)
      if (!hasCycle(graph, i, states))
        ans.push_back(i);

    return ans;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u,
                vector<State>& states) {
    if (states[u] == State::kVisiting)
      return true;
    if (states[u] == State::kVisited)
      return false;

    states[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, states))
        return true;
    states[u] = State::kVisited;

    return false;
  }
};",802
801,"class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(id.begin(), id.end(), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int getStableSize() {
    // Bricks connected with 0 (top) are stable.
    return sz[find(0)];
  }

 private:
  vector<int> id;
  vector<int> sz;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
    m = grid.size();
    n = grid[0].size();

    UnionFind uf(m * n + 1);  // 0 := top (stable)

    // Mark cells to hit as 2.
    for (const vector<int>& hit : hits) {
      const int i = hit[0];
      const int j = hit[1];
      if (grid[i][j] == 1)
        grid[i][j] = 2;
    }

    // Union all the 1s.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          unionNeighbors(grid, uf, i, j);

    vector<int> ans(hits.size());
    int stableSize = uf.getStableSize();

    for (int i = hits.size() - 1; i >= 0; --i) {
      const int x = hits[i][0];
      const int y = hits[i][1];
      if (grid[x][y] == 2) {  // cells marked from 1 to 2
        grid[x][y] = 1;       // Unhit and restore it back to 1.
        unionNeighbors(grid, uf, x, y);
        const int newStableSize = uf.getStableSize();
        if (newStableSize > stableSize)
          ans[i] = newStableSize - stableSize - 1;  // 1 := the hit cell
        stableSize = newStableSize;
      }
    }

    return ans;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  int m;
  int n;

  void unionNeighbors(const vector<vector<int>>& grid, UnionFind& uf, int i,
                      int j) {
    const int hash = getHash(i, j);

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (grid[x][y] != 1)
        continue;
      uf.unionBySize(hash, getHash(x, y));
    }

    if (i == 0)
      uf.unionBySize(hash, 0);
  }

  int getHash(int i, int j) {
    return i * n + j + 1;
  }
};",803
802,"class Solution {
 public:
  int uniqueMorseRepresentations(vector<string>& words) {
    const vector<string> morse{
        "".-"",   ""-..."", ""-.-."", ""-.."",  ""."",   ""..-."", ""--."",  ""...."", "".."",
        "".---"", ""-.-"",  "".-.."", ""--"",   ""-."",  ""---"",  "".--."", ""--.-"", "".-."",
        ""..."",  ""-"",    ""..-"",  ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""};
    unordered_set<string> transformations;

    for (const string& word : words) {
      string transformation;
      for (const char c : word)
        transformation += morse[c - 'a'];
      transformations.insert(transformation);
    }

    return transformations.size();
  }
};",804
803,"class Solution {
 public:
  bool splitArraySameAverage(vector<int>& nums) {
    const int n = nums.size();
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    if (!isPossible(sum, n))
      return false;

    vector<unordered_set<int>> sums(n / 2 + 1);
    sums[0].insert(0);

    for (const int num : nums)
      for (int i = n / 2; i > 0; --i)
        for (const int val : sums[i - 1])
          sums[i].insert(num + val);

    for (int i = 1; i < n / 2 + 1; ++i)
      if (i * sum % n == 0 && sums[i].count(i * sum / n))
        return true;

    return false;
  }

 private:
  bool isPossible(int sum, int n) {
    for (int i = 1; i < n / 2 + 1; ++i)
      if (i * sum % n == 0)
        return true;
    return false;
  }
};",805
804,"class Solution {
 public:
  vector<int> numberOfLines(vector<int>& widths, string s) {
    int numLines = 1;
    int runningWidth = 0;

    for (const char c : s) {
      const int width = widths[c - 'a'];
      if (runningWidth + width <= 100) {
        runningWidth += width;
      } else {
        ++numLines;
        runningWidth = width;
      }
    }

    return {numLines, runningWidth};
  }
};",806
805,"class Solution {
 public:
  int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    vector<int> rowMax(n);
    vector<int> colMax(n);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        rowMax[i] = max(rowMax[i], grid[i][j]);
        colMax[j] = max(colMax[j], grid[i][j]);
      }

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        ans += min(rowMax[i], colMax[j]) - grid[i][j];

    return ans;
  }
};",807
806,"class Solution {
 public:
  double soupServings(int n) {
    return n >= 4800 ? 1.0 : dfs((n + 24) / 25, (n + 24) / 25);
  }

 private:
  vector<vector<double>> mem =
      vector<vector<double>>(4800 / 25, vector<double>(4800 / 25));

  double dfs(int a, int b) {
    if (a <= 0 && b <= 0)
      return 0.5;
    if (a <= 0)
      return 1.0;
    if (b <= 0)
      return 0.0;
    if (mem[a][b] > 0)
      return mem[a][b];
    return mem[a][b] = 0.25 * (dfs(a - 4, b) + dfs(a - 3, b - 1) +
                               dfs(a - 2, b - 2) + dfs(a - 1, b - 3));
  }
};",808
807,"class Solution {
 public:
  int expressiveWords(string s, vector<string>& words) {
    int ans = 0;

    for (const string& word : words)
      if (isStretchy(s, word))
        ++ans;

    return ans;
  }

 private:
  bool isStretchy(const string& s, const string& word) {
    const int n = s.length();
    const int m = word.length();

    int j = 0;
    for (int i = 0; i < n; ++i)
      if (j < m && s[i] == word[j])
        ++j;
      else if (i > 1 && s[i] == s[i - 1] && s[i - 1] == s[i - 2])
        continue;
      else if (0 < i && i + 1 < n && s[i - 1] == s[i] && s[i] == s[i + 1])
        continue;
      else
        return false;

    return j == m;
  }
};",809
808,"class Solution {
 public:
  bool xorGame(vector<int>& nums) {
    const int xors = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());
    return xors == 0 || nums.size() % 2 == 0;
  }
};",810
809,"class Solution {
 public:
  vector<string> subdomainVisits(vector<string>& cpdomains) {
    vector<string> ans;
    unordered_map<string, int> count;

    for (const string& cpdomain : cpdomains) {
      const int space = cpdomain.find(' ');
      const int num = stoi(cpdomain.substr(0, space));
      const string& domain = cpdomain.substr(space + 1);
      count[domain] += num;
      for (int i = 0; i < domain.length(); ++i)
        if (domain[i] == '.')
          count[domain.substr(i + 1)] += num;
    }

    for (const auto& [subdomain, freq] : count)
      ans.push_back(to_string(freq) + ' ' + subdomain);

    return ans;
  }
};",811
810,"class Solution {
 public:
  double largestTriangleArea(vector<vector<int>>& points) {
    double ans = 0;

    for (const vector<int>& A : points)
      for (const vector<int>& B : points)
        for (const vector<int>& C : points)
          ans = max(ans, 0.5 * abs((B[0] - A[0]) * (C[1] - A[1]) -
                                   (C[0] - A[0]) * (B[1] - A[1])));

    return ans;
  }
};",812
811,"class Solution {
 public:
  double largestSumOfAverages(vector<int>& nums, int k) {
    const int n = nums.size();
    vector<vector<double>> mem(n + 1, vector<double>(k + 1));
    vector<double> prefix(n + 1);
    partial_sum(nums.begin(), nums.end(), prefix.begin() + 1);
    return largestSumOfAverages(nums, n, k, prefix, mem);
  }

 private:
  // Returns the maximum score to partition the first i numbers into k groups.
  double largestSumOfAverages(const vector<int>& nums, int i, int k,
                              const vector<double>& prefix,
                              vector<vector<double>>& mem) {
    if (k == 1)
      return prefix[i] / i;
    if (mem[i][k] > 0)
      return mem[i][k];

    // Try all the possible partitions.
    for (int j = k - 1; j < i; ++j)
      mem[i][k] =
          max(mem[i][k], largestSumOfAverages(nums, j, k - 1, prefix, mem) +
                             (prefix[i] - prefix[j]) / (i - j));

    return mem[i][k];
  }
};",813
812,"class Solution {
 public:
  TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;
    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);
    if (root->left == nullptr && root->right == nullptr && root->val == 0)
      return nullptr;
    return root;
  }
};",814
813,"class Solution {
 public:
  int numBusesToDestination(vector<vector<int>>& routes, int source,
                            int target) {
    if (source == target)
      return 0;

    unordered_map<int, vector<int>> graph;  // {route: [buses]}
    unordered_set<int> usedBuses;

    for (int i = 0; i < routes.size(); ++i)
      for (const int route : routes[i])
        graph[route].push_back(i);

    int ans = 0;
    queue<int> q{{source}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int route = q.front();
        q.pop();
        for (const int bus : graph[route])
          if (usedBuses.insert(bus).second)
            for (const int nextRoute : routes[bus]) {
              if (nextRoute == target)
                return ans;
              q.push(nextRoute);
            }
      }
    }

    return -1;
  }
};",815
814,"class Solution {
 public:
  vector<string> ambiguousCoordinates(string s) {
    vector<string> ans;
    s = s.substr(1, s.length() - 2);

    for (int i = 1; i < s.length(); ++i)
      for (const string& x : splits(s.substr(0, i)))
        for (const string& y : splits(s.substr(i)))
          ans.push_back('(' + x + "", "" + y + ')');

    return ans;
  }

 private:
  vector<string> splits(const string& s) {
    if (s.empty() || s.length() > 1 && s.front() == '0' && s.back() == '0')
      return {};
    if (s.back() == '0')
      return {s};
    if (s.front() == '0')
      return {""0."" + s.substr(1)};

    vector<string> candidates{s};
    for (int i = 1; i < s.length(); ++i)
      candidates.push_back(s.substr(0, i) + '.' + s.substr(i));
    return candidates;
  }
};",816
815,"class Solution {
 public:
  int numComponents(ListNode* head, vector<int>& nums) {
    int ans = 0;
    unordered_set<int> setNums{nums.begin(), nums.end()};

    for (; head; head = head->next)
      if (setNums.count(head->val) &&
          (!head->next || !setNums.count(head->next->val)))
        ++ans;

    return ans;
  }
};",817
816,"class Solution {
 public:
  int racecar(int target) {
    vector<int> mem(target + 1, -1);
    return racecar(target, mem);
  }

 private:
  int racecar(int i, vector<int>& mem) {
    if (mem[i] >= 0)
      return mem[i];

    int res = INT_MAX;
    int x = 1;             // xA := (2^x - 1) unit distance
    int j = (1 << x) - 1;  // j = 2^x - 1, k = 2^y - 1

    // (xA + 1R) + (yA + 1R) + racecar(i - (j - k))
    for (; j < i; j = (1 << ++x) - 1)
      for (int y = 0, k = 0; k < j; k = (1 << ++y) - 1)
        res = min(res, (x + 1) + (y + 1) + racecar(i - (j - k), mem));

    // xA || (xA + 1R) + racecar(j - i)
    return mem[i] = min(res, i == j ? x : x + 1 + racecar(j - i, mem));
  }
};",818
817,"class Solution {
 public:
  string mostCommonWord(string paragraph, vector<string>& banned) {
    string ans;
    int maxCount = 0;
    unordered_map<string, int> count;
    unordered_set<string> bannedSet{banned.begin(), banned.end()};

    // Make the paragraph lowercased and remove all the punctuations.
    for (char& c : paragraph)
      c = isalpha(c) ? tolower(c) : ' ';

    istringstream iss(paragraph);

    for (string word; iss >> word;)
      if (!bannedSet.count(word))
        ++count[word];

    for (const auto& [word, freq] : count)
      if (freq > maxCount) {
        maxCount = freq;
        ans = word;
      }

    return ans;
  }
};",819
818,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int depth = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  int minimumLengthEncoding(vector<string>& words) {
    int ans = 0;
    shared_ptr<TrieNode> root = make_shared<TrieNode>();
    vector<shared_ptr<TrieNode>> heads;

    for (const string& word : unordered_set<string>(words.begin(), words.end()))
      heads.push_back(insert(root, word));

    for (shared_ptr<TrieNode> head : heads)
      if (ranges::all_of(head->children,
                         [](const auto& child) { return child == nullptr; }))
        ans += head->depth + 1;

    return ans;
  }

 private:
  shared_ptr<TrieNode> insert(shared_ptr<TrieNode> root, const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : string(word.rbegin(), word.rend())) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->depth = word.length();
    return node;
  }
};",820
819,"class Solution {
 public:
  vector<int> shortestToChar(string s, char c) {
    const int n = s.length();
    vector<int> ans(n);
    int prev = -n;

    for (int i = 0; i < n; ++i) {
      if (s[i] == c)
        prev = i;
      ans[i] = i - prev;
    }

    for (int i = prev - 1; i >= 0; --i) {
      if (s[i] == c)
        prev = i;
      ans[i] = min(ans[i], prev - i);
    }

    return ans;
  }
};",821
820,"class Solution {
 public:
  int flipgame(vector<int>& fronts, vector<int>& backs) {
    constexpr int kMax = 2001;
    int ans = kMax;
    unordered_set<int> same;

    for (int i = 0; i < fronts.size(); ++i)
      if (fronts[i] == backs[i])
        same.insert(fronts[i]);

    for (const int front : fronts)
      if (!same.count(front))
        ans = min(ans, front);

    for (const int back : backs)
      if (!same.count(back))
        ans = min(ans, back);

    return ans == kMax ? 0 : ans;
  }
};",822
821,"class Solution {
 public:
  int numFactoredBinaryTrees(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    // dp[i] := the number of binary trees with arr[i] as the root
    vector<long> dp(n, 1);
    unordered_map<int, int> numToIndex;

    ranges::sort(arr);

    for (int i = 0; i < n; ++i)
      numToIndex[arr[i]] = i;

    for (int i = 0; i < n; ++i)  // arr[i] is the root
      for (int j = 0; j < i; ++j)
        if (arr[i] % arr[j] == 0) {  // arr[j] is the left subtree
          const int right = arr[i] / arr[j];
          if (const auto it = numToIndex.find(right); it != numToIndex.cend()) {
            dp[i] += dp[j] * dp[it->second];
            dp[i] %= kMod;
          }
        }

    return accumulate(dp.begin(), dp.end(), 0L) % kMod;
  }
};",823
822,"class Solution {
 public:
  string toGoatLatin(string sentence) {
    string ans;
    istringstream iss(sentence);

    int i = 1;
    for (string word; iss >> word;) {
      if (i > 1)
        ans += ' ';
      if (isVowel(word[0]))
        ans += word;
      else
        ans += word.substr(1) + word[0];
      ans += ""ma"" + string(i++, 'a');
    }

    return ans;
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }
};",824
823,"class Solution {
 public:
  int numFriendRequests(vector<int>& ages) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int age : ages)
      ++count[age];

    for (const auto& [ageA, countA] : count)
      for (const auto& [ageB, countB] : count)
        if (request(ageA, ageB))
          if (ageA == ageB)
            ans += countA * (countB - 1);
          else
            ans += countA * countB;

    return ans;
  }

 private:
  bool request(int ageA, int ageB) {
    return !(ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100);
  }
};",825
824,"class Solution {
 public:
  int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit,
                          vector<int>& worker) {
    int ans = 0;
    vector<pair<int, int>> jobs;

    for (int i = 0; i < difficulty.size(); ++i)
      jobs.emplace_back(difficulty[i], profit[i]);

    ranges::sort(jobs);
    ranges::sort(worker);

    int i = 0;
    int maxProfit = 0;

    for (const int w : worker) {
      for (; i < jobs.size() && w >= jobs[i].first; ++i)
        maxProfit = max(maxProfit, jobs[i].second);
      ans += maxProfit;
    }

    return ans;
  }
};",826
825,"class Solution {
 public:
  int largestIsland(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int maxSize = 0;
    // sizes[i] := the size of the i-th connected component (starting from 2)
    vector<int> sizes{0, 0};

    // For each 1 in the grid, paint all the connected 1s with the next
    // available color (2, 3, and so on). Also, remember the size of the island
    // we just painted with that color.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          sizes.push_back(paint(grid, i, j, sizes.size()));  // Paint 2, 3, ...

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          const unordered_set<int> neighborIds{
              getId(grid, i + 1, j), getId(grid, i - 1, j),
              getId(grid, i, j + 1), getId(grid, i, j - 1)};
          maxSize = max(maxSize, 1 + getSize(neighborIds, sizes));
        }

    return maxSize == 0 ? m * n : maxSize;
  }

 private:
  int paint(vector<vector<int>>& grid, int i, int j, int id) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] != 1)
      return 0;
    grid[i][j] = id;  // grid[i][j] is part of the id-th connected component.
    return 1 + paint(grid, i + 1, j, id) + paint(grid, i - 1, j, id) +
           paint(grid, i, j + 1, id) + paint(grid, i, j - 1, id);
  }

  // Gets the id of grid[i][j] and returns 0 if it's out-of-bounds.
  int getId(const vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;  // Invalid
    return grid[i][j];
  }

  int getSize(const unordered_set<int>& neighborIds, const vector<int>& sizes) {
    int size = 0;
    for (const int neighborId : neighborIds)
      size += sizes[neighborId];
    return size;
  }
};",827
826,"class Solution {
 public:
  int uniqueLetterString(string s) {
    int ans = 0;
    // the number of unique letters in all the substrings ending in the index so
    // far
    int dp = 0;
    vector<int> lastCount(26);
    vector<int> lastSeen(26, -1);

    for (int i = 0; i < s.length(); ++i) {
      const int c = s[i] - 'A';
      const int newCount = i - lastSeen[c];
      // Substract the duplicates.
      dp -= lastCount[c];
      // Add count of s[lastSeen[c] + 1..i], s[lastSeen[c] + 2..i], ..., s[i].
      dp += newCount;
      lastCount[c] = newCount;
      lastSeen[c] = i;
      ans += dp;
    }

    return ans;
  }
};",828
827,"class Solution {
 public:
  int consecutiveNumbersSum(int n) {
    int ans = 0;
    for (int i = 1, triangleNum = i; triangleNum <= n; ++i, triangleNum += i)
      if ((n - triangleNum) % i == 0)
        ++ans;
    return ans;
  }
};",829
828,"class Solution {
 public:
  vector<vector<int>> largeGroupPositions(string s) {
    const int n = s.length();
    vector<vector<int>> ans;

    for (int i = 0, j = 0; i < n; i = j) {
      while (j < n && s[j] == s[i])
        ++j;
      if (j - i >= 3)
        ans.push_back({i, j - 1});
    }

    return ans;
  }
};",830
829,"class Solution {
 public:
  string maskPII(string s) {
    const int atIndex = s.find('@');
    if (atIndex != string::npos) {
      ranges::transform(s, s.begin(), ::tolower);
      return s.substr(0, 1) + ""*****"" + s.substr(atIndex - 1);
    }

    string ans;
    for (const char c : s)
      if (isdigit(c))
        ans += c;

    if (ans.length() == 10)
      return ""***-***-"" + ans.substr(ans.length() - 4);
    return '+' + string(ans.length() - 10, '*') + ""-***-***-"" +
           ans.substr(ans.length() - 4);
  }
};",831
830,"class Solution {
 public:
  vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
    const int n = A.size();

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < (n + 1) / 2; ++j) {
        const int temp = A[i][j];
        A[i][j] = A[i][n - j - 1] ^ 1;
        A[i][n - j - 1] = temp ^ 1;
      }

    return A;
  }
};",832
831,"class Solution {
 public:
  string findReplaceString(string s, vector<int>& indices,
                           vector<string>& sources, vector<string>& targets) {
    vector<pair<int, int>> sortedIndices;

    for (int i = 0; i < indices.size(); ++i)
      sortedIndices.emplace_back(indices[i], i);

    ranges::sort(sortedIndices, greater<>());

    for (const auto& [index, i] : sortedIndices) {
      const string& source = sources[i];
      const string& target = targets[i];
      if (s.substr(index, source.length()) == source)
        s = s.substr(0, index) + target + s.substr(index + source.length());
    }

    return s;
  }
};",833
832,"class Solution {
 public:
  vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
    vector<int> ans(n);
    vector<int> count(n, 1);
    vector<unordered_set<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].insert(v);
      tree[v].insert(u);
    }

    postorder(tree, 0, -1, count, ans);
    preorder(tree, 0, -1, count, ans);
    return ans;
  }

 private:
  void postorder(const vector<unordered_set<int>>& tree, int node, int parent,
                 vector<int>& count, vector<int>& ans) {
    for (const int child : tree[node]) {
      if (child == parent)
        continue;
      postorder(tree, child, node, count, ans);
      count[node] += count[child];
      ans[node] += ans[child] + count[child];
    }
  }

  void preorder(const vector<unordered_set<int>>& tree, int node, int parent,
                vector<int>& count, vector<int>& ans) {
    for (const int child : tree[node]) {
      if (child == parent)
        continue;
      // count[child] nodes are 1 step closer from child than parent.
      // (n - count[child]) nodes are 1 step farther from child than parent.
      ans[child] = ans[node] - count[child] + (tree.size() - count[child]);
      preorder(tree, child, node, count, ans);
    }
  }
};",834
833,"class Solution {
 public:
  int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {
    const int n = A.size();
    const int magic = 100;
    int ans = 0;
    vector<pair<int, int>> onesA;
    vector<pair<int, int>> onesB;
    unordered_map<int, int> map;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        if (A[i][j] == 1)
          onesA.emplace_back(i, j);
        if (B[i][j] == 1)
          onesB.emplace_back(i, j);
      }

    for (const pair<int, int>& a : onesA)
      for (const pair<int, int>& b : onesB)
        ++map[(a.first - b.first) * magic + (a.second - b.second)];

    for (const auto& [_, value] : map)
      ans = max(ans, value);

    return ans;
  }
};",835
834,"class Solution {
 public:
  bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
    return rec1[0] < rec2[2] && rec2[0] < rec1[2] &&  //
           rec1[1] < rec2[3] && rec2[1] < rec1[3];
  }
};",836
835,"class Solution {
 public:
  double new21Game(int n, int k, int maxPts) {
    // When the game ends, the point is in [k..k - 1 maxPts].
    //   P = 1, if n >= k - 1 + maxPts
    //   P = 0, if n < k (note that the constraints already have k <= n)
    if (k == 0 || n >= k - 1 + maxPts)
      return 1.0;

    double ans = 0.0;
    vector<double> dp(n + 1);  // dp[i] := the probability to have i points
    dp[0] = 1.0;
    double windowSum = dp[0];  // P(i - 1) + P(i - 2) + ... + P(i - maxPts)

    for (int i = 1; i <= n; ++i) {
      // The probability to get i points is
      // P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts
      dp[i] = windowSum / maxPts;
      if (i < k)
        windowSum += dp[i];
      else  // The game ends.
        ans += dp[i];
      if (i - maxPts >= 0)
        windowSum -= dp[i - maxPts];
    }

    return ans;
  }
};",837
836,"class Solution {
 public:
  string pushDominoes(string dominoes) {
    int L = -1;
    int R = -1;

    for (int i = 0; i <= dominoes.length(); ++i)
      if (i == dominoes.length() || dominoes[i] == 'R') {
        if (L < R)
          while (R < i)
            dominoes[R++] = 'R';
        R = i;
      } else if (dominoes[i] == 'L') {
        if (R < L || L == -1 && R == -1) {
          if (L == -1 && R == -1)
            ++L;
          while (L < i)
            dominoes[L++] = 'L';
        } else {
          int l = R + 1;
          int r = i - 1;
          while (l < r) {
            dominoes[l++] = 'R';
            dominoes[r--] = 'L';
          }
        }
        L = i;
      }

    return dominoes;
  }
};",838
837,"class Solution {
 public:
  int numSimilarGroups(vector<string>& strs) {
    int ans = 0;
    vector<bool> seen(strs.size());

    for (int i = 0; i < strs.size(); ++i)
      if (!seen[i]) {
        dfs(strs, i, seen);
        ++ans;
      }

    return ans;
  }

 private:
  void dfs(const vector<string>& strs, int i, vector<bool>& seen) {
    seen[i] = true;
    for (int j = 0; j < strs.size(); ++j)
      if (!seen[j] && isSimilar(strs[i], strs[j]))
        dfs(strs, j, seen);
  }

  bool isSimilar(const string& X, const string& Y) {
    int diff = 0;
    for (int i = 0; i < X.length(); ++i)
      if (X[i] != Y[i] && ++diff > 2)
        return false;
    return true;
  }
};",839
838,"class Solution {
 public:
  int numMagicSquaresInside(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i + 2 < grid.size(); ++i)
      for (int j = 0; j + 2 < grid[0].size(); ++j)
        if (grid[i][j] % 2 == 0 && grid[i + 1][j + 1] == 5)
          ans += isMagic(grid, i, j);

    return ans;
  }

 private:
  int isMagic(const vector<vector<int>>& grid, int i, int j) {
    string s;

    for (const int num : {0, 1, 2, 5, 8, 7, 6, 3})
      s += to_string(grid[i + num / 3][j + num % 3]);

    return string(""4381672943816729"").find(s) != string::npos ||
           string(""9276183492761834"").find(s) != string::npos;
  }
};",840
839,"class Solution {
 public:
  bool canVisitAllRooms(vector<vector<int>>& rooms) {
    vector<bool> seen(rooms.size());
    dfs(rooms, 0, seen);
    return ranges::all_of(seen, [](int s) { return s == true; });
  }

 private:
  void dfs(const vector<vector<int>>& rooms, int node, vector<bool>& seen) {
    seen[node] = true;
    for (const int child : rooms[node])
      if (!seen[child])
        dfs(rooms, child, seen);
  }
};",841
840,"class Solution {
 public:
  vector<int> splitIntoFibonacci(string num) {
    vector<int> ans;
    dfs(num, 0, ans);
    return ans;
  }

 private:
  bool dfs(const string& num, int s, vector<int>& ans) {
    if (s == num.length() && ans.size() >= 3)
      return true;

    for (int i = s; i < num.length(); ++i) {
      if (num[s] == '0' && i > s)
        break;
      const long val = stol(num.substr(s, i + 1 - s));
      if (val > INT_MAX)
        break;
      if (ans.size() >= 2 &&
          val > ans[ans.size() - 2] + static_cast<long>(ans.back()))
        break;
      if (ans.size() <= 1 ||
          val == ans[ans.size() - 2] + static_cast<long>(ans.back())) {
        ans.push_back(val);
        if (dfs(num, i + 1, ans))
          return true;
        ans.pop_back();
      }
    }

    return false;
  }
};",842
841,"/**
 * // This is the Master's API interface.
 * // You should not implement it, or speculate about its implementation
 * class Master {
 *  public:
 *   int guess(string word);
 * };
 */
class Solution {
 public:
  void findSecretWord(vector<string>& wordlist, Master& master) {
    srand(time(nullptr));

    for (int i = 0; i < 10; ++i) {
      const string& guessedWord = wordlist[rand() % wordlist.size()];
      const int matches = master.guess(guessedWord);
      if (matches == 6)
        break;
      vector<string> updated;
      for (const string& word : wordlist)
        if (getMatches(guessedWord, word) == matches)
          updated.push_back(word);
      wordlist = move(updated);
    }
  }

 private:
  int getMatches(const string& s1, const string& s2) {
    int matches = 0;
    for (int i = 0; i < s1.length(); ++i)
      if (s1[i] == s2[i])
        ++matches;
    return matches;
  }
};",843
842,"class Solution {
 public:
  bool backspaceCompare(string s, string t) {
    return backspace(s) == backspace(t);
  }

 private:
  string backspace(const string& s) {
    string stack;
    for (const char c : s)
      if (c != '#')
        stack.push_back(c);
      else if (!stack.empty())
        stack.pop_back();
    return stack;
  }
};",844
843,"class Solution {
 public:
  int longestMountain(vector<int>& arr) {
    int ans = 0;

    for (int i = 0; i + 1 < arr.size();) {
      while (i + 1 < arr.size() && arr[i] == arr[i + 1])
        ++i;

      int increasing = 0;
      int decreasing = 0;

      while (i + 1 < arr.size() && arr[i] < arr[i + 1]) {
        ++increasing;
        ++i;
      }

      while (i + 1 < arr.size() && arr[i] > arr[i + 1]) {
        ++decreasing;
        ++i;
      }

      if (increasing > 0 && decreasing > 0)
        ans = max(ans, increasing + decreasing + 1);
    }

    return ans;
  }
};",845
844,"class Solution {
 public:
  bool isNStraightHand(vector<int>& hand, int groupSize) {
    map<int, int> count;

    for (const int card : hand)
      ++count[card];

    for (const auto& [start, _] : count) {
      const int value = count[start];
      if (value > 0)
        for (int i = start; i < start + groupSize; ++i) {
          count[i] -= value;
          if (count[i] < 0)
            return false;
        }
    }

    return true;
  }
};",846
845,"class Solution {
 public:
  int shortestPathLength(vector<vector<int>>& graph) {
    const int n = graph.size();
    const int goal = (1 << n) - 1;

    int ans = 0;
    queue<pair<int, int>> q;  // (u, state)
    vector<vector<bool>> seen(n, vector<bool>(1 << n));

    for (int i = 0; i < n; ++i)
      q.emplace(i, 1 << i);

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [u, state] = q.front();
        q.pop();
        if (state == goal)
          return ans;
        if (seen[u][state])
          continue;
        seen[u][state] = true;
        for (const int v : graph[u])
          q.emplace(v, state | (1 << v));
      }
      ++ans;
    }

    return -1;
  }
};",847
846,"class Solution {
 public:
  string shiftingLetters(string s, vector<int>& shifts) {
    string ans;

    for (int i = shifts.size() - 2; i >= 0; --i)
      shifts[i] = (shifts[i] + shifts[i + 1]) % 26;

    for (int i = 0; i < s.length(); ++i)
      ans += (s[i] - 'a' + shifts[i]) % 26 + 'a';

    return ans;
  }
};",848
847,"class Solution {
 public:
  int maxDistToClosest(vector<int>& seats) {
    const int n = seats.size();
    int ans = 0;
    int j = -1;

    for (int i = 0; i < n; ++i)
      if (seats[i] == 1) {
        ans = j == -1 ? i : max(ans, (i - j) / 2);
        j = i;
      }

    return max(ans, n - j - 1);
  }
};",849
848,"struct Event {
  int x;
  int y1;
  int y2;
  char type;
  Event(int x, int y1, int y2, char type) : x(x), y1(y1), y2(y2), type(type) {}
};

class Solution {
 public:
  int rectangleArea(vector<vector<int>>& rectangles) {
    constexpr int kMod = 1'000'000'007;

    vector<Event> events;

    for (const vector<int>& r : rectangles) {
      events.emplace_back(r[0], r[1], r[3], 's');
      events.emplace_back(r[2], r[1], r[3], 'e');
    }

    ranges::sort(events,
                 [](const auto& a, const auto& b) { return a.x < b.x; });

    long ans = 0;
    int prevX = 0;
    vector<pair<int, int>> yPairs;

    for (const auto& [currX, y1, y2, type] : events) {
      if (currX > prevX) {
        const int width = currX - prevX;
        ans = (ans + width * getHeight(yPairs)) % kMod;
        prevX = currX;
      }
      if (type == 's') {
        yPairs.emplace_back(y1, y2);
        ranges::sort(yPairs);
      } else {  // type == 'e'
        const auto it =
            find(yPairs.begin(), yPairs.end(), pair<int, int>(y1, y2));
        yPairs.erase(it);
      }
    }

    return ans % kMod;
  }

 private:
  long getHeight(const vector<pair<int, int>>& yPairs) {
    int height = 0;
    int prevY = 0;

    for (const auto& [y1, y2] : yPairs) {
      prevY = max(prevY, y1);
      if (y2 > prevY) {
        height += y2 - prevY;
        prevY = y2;
      }
    }

    return height;
  }
};",850
849,"class Solution {
 public:
  vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
    const int n = quiet.size();
    vector<int> ans(n, -1);
    vector<vector<int>> graph(n);

    for (const vector<int>& r : richer) {
      const int u = r[1];
      const int v = r[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      dfs(graph, i, quiet, ans);

    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, const vector<int>& quiet,
          vector<int>& ans) {
    if (ans[u] != -1)
      return ans[u];

    ans[u] = u;

    for (const int v : graph[u]) {
      const int res = dfs(graph, v, quiet, ans);
      if (quiet[res] < quiet[ans[u]])
        ans[u] = res;
    }

    return ans[u];
  }
};",851
850,"class Solution {
 public:
  int peakIndexInMountainArray(vector<int>& arr) {
    int l = 0;
    int r = arr.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] >= arr[m + 1])
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",852
851,"struct Car {
  int pos;
  double time;  // the time to reach the target
};

class Solution {
 public:
  int carFleet(int target, vector<int>& position, vector<int>& speed) {
    int ans = 0;
    vector<Car> cars(position.size());

    for (int i = 0; i < position.size(); ++i)
      cars[i] = {position[i], (double)(target - position[i]) / speed[i]};

    ranges::sort(cars,
                 [](const auto& a, const auto& b) { return a.pos > b.pos; });

    double maxTime = 0;  // the time of the slowest car to reach the target

    for (const Car& car : cars)
      // A car needs more time to reach the target, so it becomes the slowest.
      if (car.time > maxTime) {
        maxTime = car.time;
        ++ans;
      }

    return ans;
  }
};",853
852,"class Solution {
 public:
  int kSimilarity(string s1, string s2) {
    int ans = 0;
    queue<string> q{{s1}};
    unordered_set<string> seen{{s1}};

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        string curr = q.front();
        q.pop();
        if (curr == s2)
          return ans;
        for (const string& child : getChildren(curr, s2)) {
          if (seen.count(child))
            continue;
          q.push(child);
          seen.insert(child);
        }
      }
      ++ans;
    }

    return -1;
  }

 private:
  vector<string> getChildren(string& curr, const string& target) {
    vector<string> children;
    int i = 0;  // the first index s.t. curr[i] != target[i]
    while (curr[i] == target[i])
      ++i;

    for (int j = i + 1; j < curr.length(); ++j)
      if (curr[j] == target[i]) {
        swap(curr[i], curr[j]);
        children.push_back(curr);
        swap(curr[i], curr[j]);
      }

    return children;
  }
};",854
853,seat(),855
854,"class Solution {
 public:
  int scoreOfParentheses(string s) {
    int ans = 0;
    int layer = 0;

    for (int i = 0; i + 1 < s.length(); ++i) {
      const char a = s[i];
      const char b = s[i + 1];
      if (a == '(' && b == ')')
        ans += 1 << layer;
      layer += a == '(' ? 1 : -1;
    }

    return ans;
  }
};",856
855,"class Solution {
 public:
  double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {
    double ans = DBL_MAX;
    int qualitySum = 0;
    // (wagePerQuality, quality) sorted by wagePerQuality
    vector<pair<double, int>> workers;
    priority_queue<int> maxHeap;

    for (int i = 0; i < quality.size(); ++i)
      workers.emplace_back((double)wage[i] / quality[i], quality[i]);

    ranges::sort(workers);

    for (const auto& [wagePerQuality, q] : workers) {
      maxHeap.push(q);
      qualitySum += q;
      if (maxHeap.size() > k)
        qualitySum -= maxHeap.top(), maxHeap.pop();
      if (maxHeap.size() == k)
        ans = min(ans, qualitySum * wagePerQuality);
    }

    return ans;
  }
};",857
856,"class Solution {
 public:
  int mirrorReflection(int p, int q) {
    while (p % 2 == 0 && q % 2 == 0) {
      p /= 2;
      q /= 2;
    }

    if (p % 2 == 0)
      return 2;
    if (q % 2 == 0)
      return 0;
    return 1;
  }
};",858
857,"class Solution {
 public:
  bool buddyStrings(string s, string goal) {
    if (s.length() != goal.length())
      return false;
    if (s == goal && hasDuplicateLetters(s))
      return true;

    vector<int> diffIndices;

    for (int i = 0; i < s.length(); ++i)
      if (s[i] != goal[i])
        diffIndices.push_back(i);

    return diffIndices.size() == 2 &&
           s[diffIndices[0]] == goal[diffIndices[1]] &&
           s[diffIndices[1]] == goal[diffIndices[0]];
  }

 private:
  bool hasDuplicateLetters(const string& s) {
    vector<int> count(26);
    for (const char c : s)
      ++count[c - 'a'];
    return ranges::any_of(count, [](int freq) { return freq > 1; });
  }
};",859
858,"class Solution {
 public:
  bool lemonadeChange(vector<int>& bills) {
    int count5 = 0;
    int count10 = 0;

    for (const int bill : bills) {
      if (bill == 5) {
        ++count5;
      } else if (bill == 10) {
        --count5;
        ++count10;
      } else {  // bill == 20
        if (count10 > 0) {
          --count10;
          --count5;
        } else {
          count5 -= 3;
        }
      }
      if (count5 < 0)
        return false;
    }

    return true;
  }
};",860
859,"class Solution {
 public:
  int matrixScore(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;

    // Flip the rows with a leading 0.
    for (auto& row : grid)
      if (row[0] == 0)
        flip(row);

    // Flip the columns with 1s < 0s.
    for (int j = 0; j < n; ++j)
      if (onesColCount(grid, j) * 2 < m)
        flipCol(grid, j);

    // Add a binary number for each row.
    for (const vector<int>& row : grid)
      ans += binary(row);

    return ans;
  }

 private:
  void flip(vector<int>& row) {
    for (int i = 0; i < row.size(); ++i)
      row[i] ^= 1;
  }

  int onesColCount(const vector<vector<int>>& grid, int j) {
    int ones = 0;
    for (int i = 0; i < grid.size(); ++i)
      ones += grid[i][j];
    return ones;
  }

  void flipCol(vector<vector<int>>& grid, int j) {
    for (int i = 0; i < grid.size(); ++i)
      grid[i][j] ^= 1;
  }

  int binary(const vector<int>& row) {
    int res = row[0];
    for (int j = 1; j < row.size(); ++j)
      res = res * 2 + row[j];
    return res;
  }
};",861
860,"class Solution {
 public:
  int shortestSubarray(vector<int>& nums, int k) {
    const int n = nums.size();
    int ans = n + 1;
    deque<int> dq;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    for (int i = 0; i < n + 1; ++i) {
      while (!dq.empty() && prefix[i] - prefix[dq.front()] >= k)
        ans = min(ans, i - dq.front()), dq.pop_front();
      while (!dq.empty() && prefix[i] <= prefix[dq.back()])
        dq.pop_back();
      dq.push_back(i);
    }

    return ans <= n ? ans : -1;
  }
};",862
861,"class Solution {
 public:
  vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
    vector<int> ans;
    unordered_map<TreeNode*, int> nodeToDist;  // {node: distance to target}

    getDists(root, target, nodeToDist);
    dfs(root, k, 0, nodeToDist, ans);
    return ans;
  }

 private:
  void getDists(TreeNode* root, TreeNode* target,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root == target) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, target, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != nodeToDist.cend()) {
      // The target is in the left subtree.
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, target, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != nodeToDist.cend())
      // The target is in the right subtree.
      nodeToDist[root] = it->second + 1;
  }

  void dfs(TreeNode* root, int k, int dist,
           unordered_map<TreeNode*, int>& nodeToDist, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (const auto it = nodeToDist.find(root); it != nodeToDist.cend())
      dist = it->second;
    if (dist == k)
      ans.push_back(root->val);

    dfs(root->left, k, dist + 1, nodeToDist, ans);
    dfs(root->right, k, dist + 1, nodeToDist, ans);
  }
};",863
862,"struct T {
  int i;
  int j;
  int keys;  // the keys in the bitmask
  T(int i, int j, int keys) : i(i), j(j), keys(keys) {}
};

class Solution {
 public:
  int shortestPathAllKeys(vector<string>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].length();
    const int keysCount = getKeysCount(grid);
    const int kKeys = (1 << keysCount) - 1;
    const vector<int> start = getStart(grid);
    int ans = 0;
    queue<T> q{{{start[0], start[1], 0}}};
    vector<vector<vector<bool>>> seen(
        m, vector<vector<bool>>(n, vector<bool>(kKeys)));
    seen[start[0]][start[1]][0] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j, keys] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const char c = grid[x][y];
          if (c == '#')
            continue;
          const int newKeys = 'a' <= c && c <= 'f' ? keys | 1 << c - 'a' : keys;
          if (newKeys == kKeys)
            return ans;
          if (seen[x][y][newKeys])
            continue;
          if ('A' <= c && c <= 'F' && ((newKeys >> c - 'A') & 1) == 0)
            continue;
          q.emplace(x, y, newKeys);
          seen[x][y][newKeys] = true;
        }
      }
    }

    return -1;
  }

 private:
  int getKeysCount(const vector<string>& grid) {
    int count = 0;
    for (const string& s : grid)
      count += ranges::count_if(s, [](char c) { return 'a' <= c && c <= 'f'; });
    return count;
  }

  vector<int> getStart(const vector<string>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].length(); ++j)
        if (grid[i][j] == '@')
          return {i, j};
    throw;
  }
};",864
863,"struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* subtreeWithAllDeepest(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};

    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};",865
864,"class Solution {
 public:
  int primePalindrome(int n) {
    if (n <= 2)
      return 2;
    if (n == 3)
      return 3;
    if (n <= 5)
      return 5;
    if (n <= 7)
      return 7;
    if (n <= 11)
      return 11;

    int nLength = to_string(n).length();

    while (true) {
      for (const int num : getPalindromes(nLength))
        if (num >= n && isPrime(num))
          return num;
      ++nLength;
    }

    throw;
  }

 private:
  vector<int> getPalindromes(int n) {
    vector<int> palindromes;
    const int length = n / 2;

    for (int i = pow(10, length - 1); i < pow(10, length); ++i) {
      const string s = to_string(i);
      string reversedS = s;
      reverse(reversedS.begin(), reversedS.end());
      for (int j = 0; j < 10; ++j)
        palindromes.push_back(stoi(s + to_string(j) + reversedS));
    }

    return palindromes;
  }

  bool isPrime(int num) {
    for (int i = 2; i < sqrt(num) + 1; ++i)
      if (num % i == 0)
        return false;
    return true;
  }
};",866
865,"class Solution {
 public:
  vector<vector<int>> transpose(vector<vector<int>>& A) {
    vector<vector<int>> ans(A[0].size(), vector<int>(A.size()));

    for (int i = 0; i < A.size(); ++i)
      for (int j = 0; j < A[0].size(); ++j)
        ans[j][i] = A[i][j];

    return ans;
  }
};",867
866,"class Solution {
 public:
  int binaryGap(int n) {
    int ans = 0;

    // d := the distance between any two 1s
    for (int d = -32; n; n /= 2, ++d)
      if (n % 2 == 1) {
        ans = max(ans, d);
        d = 0;
      }

    return ans;
  }
};",868
867,"class Solution {
 public:
  bool reorderedPowerOf2(int n) {
    int count = counter(n);

    for (int i = 0; i < 30; ++i)
      if (counter(1 << i) == count)
        return true;

    return false;
  }

 private:
  int counter(int n) {
    int count = 0;

    for (; n > 0; n /= 10)
      count += pow(10, n % 10);

    return count;
  }
};",869
868,"class Solution {
 public:
  vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
    multiset<int> set{nums1.begin(), nums1.end()};

    for (int i = 0; i < nums2.size(); ++i) {
      const auto p =
          *set.rbegin() <= nums2[i] ? set.begin() : set.upper_bound(nums2[i]);
      nums1[i] = *p;
      set.erase(p);
    }

    return nums1;
  }
};",870
869,"class Solution {
 public:
  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
    // dp[i] := the farthest position we can reach with i refuels
    vector<long> dp(stations.size() + 1);
    dp[0] = startFuel;

    for (int i = 0; i < stations.size(); ++i)
      for (int j = i + 1; j > 0; --j)
        if (dp[j - 1] >= stations[i][0])
          dp[j] = max(dp[j], dp[j - 1] + stations[i][1]);

    for (int i = 0; i < dp.size(); ++i)
      if (dp[i] >= target)
        return i;

    return -1;
  }
};",871
870,"class Solution {
 public:
  bool leafSimilar(TreeNode* root1, TreeNode* root2) {
    vector<int> leaves1;
    vector<int> leaves2;
    dfs(root1, leaves1);
    dfs(root2, leaves2);
    return leaves1 == leaves2;
  }

  void dfs(TreeNode* root, vector<int>& leaves) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      leaves.push_back(root->val);
      return;
    }

    dfs(root->left, leaves);
    dfs(root->right, leaves);
  }
};",872
871,"class Solution {
 public:
  int lenLongestFibSubseq(vector<int>& arr) {
    const int n = arr.size();
    int ans = 0;
    vector<vector<int>> dp(n, vector<int>(n, 2));
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < n; ++i)
      numToIndex[arr[i]] = i;

    for (int j = 0; j < n; ++j)
      for (int k = j + 1; k < n; ++k) {
        const int ai = arr[k] - arr[j];
        if (ai < arr[j] && numToIndex.count(ai)) {
          const int i = numToIndex[ai];
          dp[j][k] = dp[i][j] + 1;
          ans = max(ans, dp[j][k]);
        }
      }

    return ans;
  }
};",873
872,"class Solution {
 public:
  int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int ans = 0;
    int d = 0;  // 0 := north, 1 := east, 2 := south, 3 := west
    int x = 0;  // the start x
    int y = 0;  // the start y
    unordered_set<pair<int, int>, PairHash> obstaclesSet;

    for (const vector<int>& o : obstacles)
      obstaclesSet.insert({o[0], o[1]});

    for (const int c : commands) {
      if (c == -1) {
        d = (d + 1) % 4;
      } else if (c == -2) {
        d = (d + 3) % 4;
      } else {
        for (int step = 0; step < c; ++step) {
          if (obstaclesSet.count({x + dirs[d], y + dirs[d + 1]}))
            break;
          x += dirs[d];
          y += dirs[d + 1];
        }
      }
      ans = max(ans, x * x + y * y);
    }

    return ans;
  }

 private:
  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",874
873,"class Solution {
 public:
  int minEatingSpeed(vector<int>& piles, int h) {
    int l = 1;
    int r = ranges::max(piles);

    while (l < r) {
      const int m = (l + r) / 2;
      if (eatHours(piles, m) <= h)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns the hours to eat all the piles with speed m.
  int eatHours(const vector<int>& piles, int m) {
    return accumulate(piles.begin(), piles.end(), 0,
                      [&](int subtotal, int pile) {
      return subtotal + (pile - 1) / m + 1;  // ceil(pile / m)
    });
  }
};",875
874,"class Solution {
 public:
  ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
    }

    return slow;
  }
};",876
875,"class Solution {
 public:
  bool stoneGame(vector<int>& piles) {
    const int n = piles.size();
    // dp[i][j] := the maximum stones you can get more than your opponent in
    // piles[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = piles[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] > 0;
  }
};",877
876,"class Solution {
 public:
  int nthMagicalNumber(long n, long a, long b) {
    constexpr int kMod = 1'000'000'007;
    const long lcm = a * b / __gcd(a, b);
    long l = min(a, b);
    long r = min(a, b) * n;

    while (l < r) {
      const long m = (l + r) / 2;
      if (m / a + m / b - m / lcm >= n)
        r = m;
      else
        l = m + 1;
    }

    return l % kMod;
  }
};",878
877,"class Solution {
 public:
  int profitableSchemes(int n, int minProfit, vector<int>& group,
                        vector<int>& profit) {
    constexpr int kMod = 1'000'000'007;
    // dp[k][i][j] := the number of schemes, where the first k crimes are
    // committed by <= i members, generating >= j profits
    vector<vector<vector<int>>> dp(
        group.size() + 1,
        vector<vector<int>>(n + 1, vector<int>(minProfit + 1)));

    // No crimes, no profits, and any number of members.
    for (int i = 0; i <= n; ++i)
      dp[0][i][0] = 1;

    for (int k = 1; k <= group.size(); ++k) {
      const int g = group[k - 1];
      const int p = profit[k - 1];
      for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= minProfit; ++j)
          if (i < g) {
            dp[k][i][j] = dp[k - 1][i][j];
          } else {
            dp[k][i][j] = dp[k - 1][i][j] + dp[k - 1][i - g][max(0, j - p)];
            dp[k][i][j] %= kMod;
          }
    }

    return dp[group.size()][n][minProfit];
  }
};",879
878,"class Solution {
 public:
  string decodeAtIndex(string s, int k) {
    long size = 0;  // the length of the decoded `s`

    for (const char c : s)
      if (isdigit(c))
        size *= c - '0';
      else
        ++size;

    for (int i = s.length() - 1; i >= 0; --i) {
      k %= size;
      if (k == 0 && isalpha(s[i]))
        return string(1, s[i]);
      if (isdigit(s[i]))
        size /= s[i] - '0';
      else
        --size;
    }

    throw;
  }
};",880
879,"class Solution {
 public:
  int numRescueBoats(vector<int>& people, int limit) {
    int ans = 0;

    ranges::sort(people);

    for (int i = 0, j = people.size() - 1; i <= j; ++ans) {
      const int remain = limit - people[j--];
      if (people[i] <= remain)
        ++i;
    }

    return ans;
  }
};",881
880,"class Solution {
 public:
  int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
    vector<vector<pair<int, int>>> graph(n);
    vector<int> dist(graph.size(), maxMoves + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int cnt = edge[2];
      graph[u].emplace_back(v, cnt);
      graph[v].emplace_back(u, cnt);
    }

    const int reachableNodes = dijkstra(graph, 0, maxMoves, dist);
    int reachableSubnodes = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int cnt = edge[2];
      // the number of reachable nodes of `edge` from `u`
      const int a = dist[u] > maxMoves ? 0 : min(maxMoves - dist[u], cnt);
      // the number of reachable nodes of `edge` from `v`
      const int b = dist[v] > maxMoves ? 0 : min(maxMoves - dist[v], cnt);
      reachableSubnodes += min(a + b, cnt);
    }

    return reachableNodes + reachableSubnodes;
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src,
               int maxMoves, vector<int>& dist) {
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      // Already took `maxMoves` to reach `u`, so can't explore anymore.
      if (d >= maxMoves)
        break;
      for (const auto& [v, w] : graph[u])
        if (d + w + 1 < dist[v]) {
          dist[v] = d + w + 1;
          minHeap.emplace(dist[v], v);
        }
    }

    return ranges::count_if(dist, [&](int d) { return d <= maxMoves; });
  }
};",882
881,"class Solution {
 public:
  int projectionArea(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i) {
      int maxOfRow = 0;
      int maxOfCol = 0;
      for (int j = 0; j < grid.size(); ++j) {
        maxOfRow = max(maxOfRow, grid[i][j]);
        maxOfCol = max(maxOfCol, grid[j][i]);
        if (grid[i][j])
          ++ans;
      }
      ans += maxOfRow + maxOfCol;
    }

    return ans;
  }
};",883
882,"class Solution {
 public:
  vector<string> uncommonFromSentences(string A, string B) {
    vector<string> ans;
    unordered_map<string, int> count;
    istringstream iss(A + ' ' + B);

    while (iss >> A)
      ++count[A];

    for (const auto& [word, freq] : count)
      if (freq == 1)
        ans.push_back(word);

    return ans;
  }
};",884
883,"class Solution {
 public:
  vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart,
                                      int cStart) {
    const vector<int> dx{1, 0, -1, 0};
    const vector<int> dy{0, 1, 0, -1};
    vector<vector<int>> ans{{rStart, cStart}};

    for (int i = 0; ans.size() < rows * cols; ++i)
      for (int step = 0; step < i / 2 + 1; ++step) {
        rStart += dy[i % 4];
        cStart += dx[i % 4];
        if (0 <= rStart && rStart < rows && 0 <= cStart && cStart < cols)
          ans.push_back({rStart, cStart});
      }

    return ans;
  }
};",885
884,"enum Color { kWhite, kRed, kGreen };

class Solution {
 public:
  bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
    vector<vector<int>> graph(n + 1);
    vector<Color> colors(n + 1, Color::kWhite);

    for (const vector<int>& d : dislikes) {
      const int u = d[0];
      const int v = d[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // Reduce to 785. Is Graph Bipartite?
    for (int i = 1; i <= n; ++i)
      if (colors[i] == Color::kWhite &&
          !isValidColor(graph, i, colors, Color::kRed))
        return false;

    return true;
  }

 private:
  bool isValidColor(const vector<vector<int>>& graph, int u,
                    vector<Color>& colors, Color color) {
    // Always paint red for a white node.
    if (colors[u] != Color::kWhite)
      return colors[u] == color;

    colors[u] = color;  // Always paint the node with `color`.

    // All the children should have valid colors.
    for (const int v : graph[u])
      if (!isValidColor(graph, v, colors,
                        color == Color::kRed ? Color::kGreen : Color::kRed))
        return false;

    return true;
  }
};",886
885,"class Solution {
 public:
  int superEggDrop(int k, int n) {
    vector<vector<int>> mem(k + 1, vector<int>(n + 1, INT_MAX));
    return drop(k, n, mem);
  }

 private:
  // Returns the minimum number of moves to know f with k eggs and n floors.
  int drop(int k, int n, vector<vector<int>>& mem) {
    if (k == 0)  // no eggs -> done
      return 0;
    if (k == 1)  // one egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0)  // no floor -> done
      return 0;
    if (n == 1)  // one floor -> drop from that floor
      return 1;
    if (mem[k][n] != INT_MAX)
      return mem[k][n];

    for (int i = 1; i <= n; ++i) {
      const int broken = drop(k - 1, i - 1, mem);
      const int unbroken = drop(k, n - i, mem);
      mem[k][n] = min(mem[k][n], 1 + max(broken, unbroken));
    }

    return mem[k][n];
  }
};",887
886,"class Solution {
 public:
  vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
    const int diff = (accumulate(aliceSizes.begin(), aliceSizes.end(), 0) -
                      accumulate(bobSizes.begin(), bobSizes.end(), 0)) /
                     2;
    const unordered_set<int> bobSizesSet{bobSizes.begin(), bobSizes.end()};

    for (const int aliceSize : aliceSizes) {
      const int target = aliceSize - diff;
      if (bobSizesSet.count(target))
        return {aliceSize, target};
    }

    throw;
  }
};",888
887,"class Solution {
 public:
  TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {
    unordered_map<int, int> postToIndex;

    for (int i = 0; i < post.size(); ++i)
      postToIndex[post[i]] = i;

    return build(pre, 0, pre.size() - 1, post, 0, post.size() - 1, postToIndex);
  }

 private:
  TreeNode* build(const vector<int>& pre, int preStart, int preEnd,
                  const vector<int>& post, int postStart, int postEnd,
                  const unordered_map<int, int>& postToIndex) {
    if (preStart > preEnd)
      return nullptr;
    if (preStart == preEnd)
      return new TreeNode(pre[preStart]);

    const int rootVal = pre[preStart];
    const int leftRootVal = pre[preStart + 1];
    const int leftRootPostIndex = postToIndex.at(leftRootVal);
    const int leftSize = leftRootPostIndex - postStart + 1;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(pre, preStart + 1, preStart + leftSize, post, postStart,
                       leftRootPostIndex, postToIndex);
    root->right = build(pre, preStart + leftSize + 1, preEnd, post,
                        leftRootPostIndex + 1, postEnd - 1, postToIndex);
    return root;
  }
};",889
888,"class Solution {
 public:
  vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
    vector<string> ans;

    for (const string& word : words)
      if (isIsomorphic(word, pattern))
        ans.push_back(word);

    return ans;
  }

 private:
  bool isIsomorphic(const string& w, const string& p) {
    vector<int> map_w(128);
    vector<int> map_p(128);

    for (int i = 0; i < w.length(); ++i) {
      if (map_w[w[i]] != map_p[p[i]])
        return false;
      map_w[w[i]] = i + 1;
      map_p[p[i]] = i + 1;
    }

    return true;
  }
};",890
889,"class Solution {
 public:
  int sumSubseqWidths(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    long ans = 0;
    long exp = 1;

    ranges::sort(nums);

    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {
      ans += (nums[i] - nums[n - 1 - i]) * exp;
      ans %= kMod;
    }

    return ans;
  }
};",891
890,"class Solution {
 public:
  int surfaceArea(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid.size(); ++j) {
        if (grid[i][j])
          ans += grid[i][j] * 4 + 2;
        if (i > 0)
          ans -= min(grid[i][j], grid[i - 1][j]) * 2;
        if (j > 0)
          ans -= min(grid[i][j], grid[i][j - 1]) * 2;
      }

    return ans;
  }
};",892
891,"class Solution {
 public:
  int numSpecialEquivGroups(vector<string>& words) {
    unordered_set<string> set;

    for (const string& word : words) {
      string even;
      string odd;
      for (int i = 0; i < word.length(); ++i)
        if (i % 2 == 0)
          even += word[i];
        else
          odd += word[i];
      ranges::sort(even);
      ranges::sort(odd);
      set.insert(even + odd);
    }

    return set.size();
  }
};",893
892,"class Solution {
 public:
  vector<TreeNode*> allPossibleFBT(int n) {
    if (n % 2 == 0)
      return {};
    if (n == 1)
      return {new TreeNode(0)};
    if (const auto it = mem.find(n); it != mem.cend())
      return it->second;

    vector<TreeNode*> ans;

    for (int leftCount = 0; leftCount < n; ++leftCount) {
      const int rightCount = n - 1 - leftCount;
      for (TreeNode* left : allPossibleFBT(leftCount))
        for (TreeNode* right : allPossibleFBT(rightCount)) {
          ans.push_back(new TreeNode(0));
          ans.back()->left = left;
          ans.back()->right = right;
        }
    }

    return mem[n] = ans;
  }

 private:
  unordered_map<int, vector<TreeNode*>> mem;
};",894
893,push(val: int),895
894,"class Solution {
 public:
  bool isMonotonic(vector<int>& nums) {
    bool increasing = true;
    bool decreasing = true;

    for (int i = 1; i < nums.size(); ++i) {
      increasing &= nums[i] >= nums[i - 1];
      decreasing &= nums[i] <= nums[i - 1];
    }

    return increasing || decreasing;
  }
};",896
895,"class Solution {
 public:
  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {
    if (root == nullptr)
      return tail;

    TreeNode* ans = increasingBST(root->left, root);
    root->left = nullptr;
    root->right = increasingBST(root->right, tail);
    return ans;
  }
};",897
896,"class Solution {
 public:
  int subarrayBitwiseORs(vector<int>& arr) {
    vector<int> s;
    int l = 0;

    for (const int a : arr) {
      const int r = s.size();
      s.push_back(a);
      // s[l..r) are values generated in the previous iteration
      for (int i = l; i < r; ++i)
        if (s.back() != (s[i] | a))
          s.push_back(s[i] | a);
      l = r;
    }

    return unordered_set<int>(s.begin(), s.end()).size();
  }
};",898
897,"class Solution {
 public:
  string orderlyQueue(string s, int k) {
    if (k > 1) {
      ranges::sort(s);
      return s;
    }

    string ans = s;

    for (int i = 1; i < s.length(); ++i)
      ans = min(ans, s.substr(i) + s.substr(0, i));

    return ans;
  }
};",899
898,next(n: int),900
899,"class StockSpanner {
 public:
  int next(int price) {
    int span = 1;
    while (!stack.empty() && stack.top().first <= price)
      span += stack.top().second, stack.pop();
    stack.emplace(price, span);
    return span;
  }

 private:
  stack<pair<int, int>> stack;  // (price, span)
};",901
900,"class Solution {
 public:
  int atMostNGivenDigitSet(vector<string>& digits, int n) {
    int ans = 0;
    const string num = to_string(n);

    for (int i = 1; i < num.length(); ++i)
      ans += pow(digits.size(), i);

    for (int i = 0; i < num.length(); ++i) {
      bool dHasSameNum = false;
      for (const string& digit : digits) {
        if (digit[0] < num[i])
          ans += pow(digits.size(), num.length() - i - 1);
        else if (digit[0] == num[i])
          dHasSameNum = true;
      }
      if (!dHasSameNum)
        return ans;
    }

    return ans + 1;
  }
};",902
901,"class Solution {
 public:
  int numPermsDISequence(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i][j] := the number of valid permutations with i + 1 digits, where
    // s[i] is j-th Digit of remaining digits
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    // When there's only one digit, the number of permutations is 1.
    for (int j = 0; j <= n; ++j)
      dp[0][j] = 1;

    for (int i = 1; i <= n; ++i)
      if (s[i - 1] == 'I') {  // s[i - 1] == 'I'
        // Calculate the postfix sum to prevent duplicate calculation.
        int postfixsum = 0;
        for (int j = n - i; j >= 0; --j) {
          postfixsum = (postfixsum + dp[i - 1][j + 1]) % kMod;
          dp[i][j] = postfixsum;
        }
      } else {  // s[i - 1] == 'D'
        // Calculate the prefix sum to prevent duplicate calculation.
        int prefix = 0;
        for (int j = 0; j <= n - i; ++j) {
          prefix = (prefix + dp[i - 1][j]) % kMod;
          dp[i][j] = prefix;
        }
      }

    return dp[n][0];
  }
};",903
902,"class Solution {
 public:
  int totalFruit(vector<int>& fruits) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < fruits.size(); ++r) {
      ++count[fruits[r]];
      while (count.size() > 2) {
        if (--count[fruits[l]] == 0)
          count.erase(fruits[l]);
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",904
903,"class Solution {
 public:
  vector<int> sortArrayByParity(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      if (nums[l] % 2 == 1 && nums[r] % 2 == 0)
        swap(nums[l], nums[r]);
      if (nums[l] % 2 == 0)
        ++l;
      if (nums[r] % 2 == 1)
        --r;
    }

    return nums;
  }
};",905
904,"class Solution {
 public:
  int superpalindromesInRange(string left, string right) {
    int ans = 0;
    const long l = stoll(left);
    const long r = stoll(right);

    for (long i = sqrt(l); i * i <= r;) {
      const long palindrome = nextPalindrome(i);
      const long squared = palindrome * palindrome;
      if (squared <= r && isPalindrome(squared))
        ++ans;
      i = palindrome + 1;
    }

    return ans;
  }

 private:
  long nextPalindrome(int num) {
    const string s = to_string(num);
    const int n = s.length();
    string half = s.substr(0, (n + 1) / 2);
    string reversedHalf = reversed(half.substr(0, n / 2));
    const long candidate = stoll(half + reversedHalf);
    if (candidate >= num)
      return candidate;
    half = to_string(stoll(half) + 1);
    reversedHalf = reversed(half.substr(0, n / 2));
    return stoll(half + reversedHalf);
  }

  string reversed(const string& s) {
    return {s.rbegin(), s.rend()};
  }

  bool isPalindrome(long num) {
    const string s = to_string(num);
    int l = 0;
    int r = s.length() - 1;
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};",906
905,"class Solution {
 public:
  int sumSubarrayMins(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    long ans = 0;
    // prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]
    vector<int> prevMin(n, -1);
    // nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]
    vector<int> nextMin(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && arr[stack.top()] > arr[i]) {
        const int index = stack.top();
        stack.pop();
        nextMin[index] = i;
      }
      if (!stack.empty())
        prevMin[i] = stack.top();
      stack.push(i);
    }

    for (int i = 0; i < n; ++i) {
      ans += static_cast<long>(arr[i]) * (i - prevMin[i]) * (nextMin[i] - i);
      ans %= kMod;
    }

    return ans;
  }
};",907
906,"class Solution {
 public:
  int smallestRangeI(vector<int>& nums, int k) {
    const int max = ranges::max(nums);
    const int min = ranges::min(nums);
    return std::max(0, max - min - 2 * k);
  }
};",908
907,"class Solution {
 public:
  int snakesAndLadders(vector<vector<int>>& board) {
    const int n = board.size();
    int ans = 0;
    queue<int> q{{1}};
    vector<bool> seen(1 + n * n);
    vector<int> A(1 + n * n);  // 2D -> 1D

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        A[(n - 1 - i) * n + (n - i & 1 ? j + 1 : n - j)] = board[i][j];

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int curr = q.front();
        q.pop();
        for (int next = curr + 1; next <= min(curr + 6, n * n); ++next) {
          const int dest = A[next] > 0 ? A[next] : next;
          if (dest == n * n)
            return ans;
          if (seen[dest])
            continue;
          q.push(dest);
          seen[dest] = true;
        }
      }
    }

    return -1;
  }
};",909
908,"class Solution {
 public:
  int smallestRangeII(vector<int>& nums, int k) {
    ranges::sort(nums);

    int ans = nums.back() - nums.front();
    const int left = nums.front() + k;
    const int right = nums.back() - k;

    for (int i = 0; i + 1 < nums.size(); ++i) {
      const int mini = min(left, nums[i + 1] - k);
      const int maxi = max(right, nums[i] + k);
      ans = min(ans, maxi - mini);
    }

    return ans;
  }
};",910
909,q(t: int),911
910,"class Solution {
 public:
  vector<int> sortArray(vector<int>& nums) {
    mergeSort(nums, 0, nums.size() - 1);
    return nums;
  }

 private:
  void mergeSort(vector<int>& A, int l, int r) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(A, l, m);
    mergeSort(A, m + 1, r);
    merge(A, l, m, r);
  }

  void merge(vector<int>& A, int l, int m, int r) {
    vector<int> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (A[i] < A[j])
        sorted[k++] = A[i++];
      else
        sorted[k++] = A[j++];

    // Put the possible remaining left part into the sorted array.
    while (i <= m)
      sorted[k++] = A[i++];

    // Put the possible remaining right part into the sorted array.
    while (j <= r)
      sorted[k++] = A[j++];

    copy(sorted.begin(), sorted.end(), A.begin() + l);
  }
};",912
911,"enum class State { kDraw, kMouseWin, kCatWin };

class Solution {
 public:
  int catMouseGame(vector<vector<int>>& graph) {
    const int n = graph.size();
    // result of (cat, mouse, move)
    // move := 0 (mouse) / 1 (cat)
    vector<vector<vector<State>>> states(
        n, vector<vector<State>>(n, vector<State>(2)));
    vector<vector<vector<int>>> outDegree(
        n, vector<vector<int>>(n, vector<int>(2)));
    queue<tuple<int, int, int, State>> q;  // (cat, mouse, move, state)

    for (int cat = 0; cat < n; ++cat)
      for (int mouse = 0; mouse < n; ++mouse) {
        outDegree[cat][mouse][0] = graph[mouse].size();
        outDegree[cat][mouse][1] =
            graph[cat].size() - ranges::count(graph[cat], 0);
      }

    // Start from the states s.t. the winner can be determined.
    for (int cat = 1; cat < n; ++cat)
      for (int move = 0; move < 2; ++move) {
        // Mouse is in the hole.
        states[cat][0][move] = State::kMouseWin;
        q.emplace(cat, 0, move, State::kMouseWin);
        // Cat catches mouse.
        states[cat][cat][move] = State::kCatWin;
        q.emplace(cat, cat, move, State::kCatWin);
      }

    while (!q.empty()) {
      const auto [cat, mouse, move, state] = q.front();
      q.pop();
      if (cat == 2 && mouse == 1 && move == 0)
        return static_cast<int>(state);
      const int prevMove = move ^ 1;
      for (const int prev : graph[prevMove ? cat : mouse]) {
        const int prevCat = prevMove ? prev : cat;
        if (prevCat == 0)  // invalid
          continue;
        const int prevMouse = prevMove ? mouse : prev;
        // The state has been determined.
        if (states[prevCat][prevMouse][prevMove] != State::kDraw)
          continue;
        if (prevMove == 0 && state == State::kMouseWin ||
            prevMove == 1 && state == State::kCatWin ||
            --outDegree[prevCat][prevMouse][prevMove] == 0) {
          states[prevCat][prevMouse][prevMove] = state;
          q.emplace(prevCat, prevMouse, prevMove, state);
        }
      }
    }

    return static_cast<int>(states[2][1][0]);
  }
};",913
912,"class Solution {
 public:
  bool hasGroupsSizeX(vector<int>& deck) {
    unordered_map<int, int> count;
    int gcd = 0;

    for (const int d : deck)
      ++count[d];

    for (const auto& [_, value] : count)
      gcd = __gcd(gcd, value);

    return gcd >= 2;
  }
};",914
913,"class Solution {
 public:
  int partitionDisjoint(vector<int>& nums) {
    const int n = nums.size();
    vector<int> min(n);
    min[n - 1] = nums[n - 1];
    int max = INT_MIN;

    for (int i = n - 2; i >= 0; --i)
      min[i] = std::min(min[i + 1], nums[i]);

    for (int i = 0; i < n; ++i) {
      max = std::max(max, nums[i]);
      if (max <= min[i + 1])
        return i + 1;
    }

    throw;
  }
};",915
914,"class Solution {
 public:
  vector<string> wordSubsets(vector<string>& A, vector<string>& B) {
    vector<string> ans;
    vector<int> countB(26);

    for (const string& b : B) {
      vector<int> temp = counter(b);
      for (int i = 0; i < 26; ++i)
        countB[i] = max(countB[i], temp[i]);
    }

    for (const string& a : A)
      if (isUniversal(counter(a), countB))
        ans.push_back(a);

    return ans;
  }

 private:
  vector<int> counter(const string& s) {
    vector<int> count(26);
    for (char c : s)
      ++count[c - 'a'];
    return count;
  }

  bool isUniversal(vector<int> countA, vector<int>& countB) {
    for (int i = 0; i < 26; ++i)
      if (countA[i] < countB[i])
        return false;
    return true;
  }
};",916
915,"class Solution {
 public:
  string reverseOnlyLetters(string s) {
    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {
      while (i < j && !isalpha(s[i]))
        ++i;
      while (i < j && !isalpha(s[j]))
        --j;
      swap(s[i], s[j]);
    }
    return s;
  }
};",917
916,"class Solution {
 public:
  int maxSubarraySumCircular(vector<int>& nums) {
    int totalSum = 0;
    int currMaxSum = 0;
    int currMinSum = 0;
    int maxSum = INT_MIN;
    int minSum = INT_MAX;

    for (const int num : nums) {
      totalSum += num;
      currMaxSum = max(currMaxSum + num, num);
      currMinSum = min(currMinSum + num, num);
      maxSum = max(maxSum, currMaxSum);
      minSum = min(minSum, currMinSum);
    }

    return maxSum < 0 ? maxSum : max(maxSum, totalSum - minSum);
  }
};",918
917,insert(v: int),919
918,"class Solution {
 public:
  int numMusicPlaylists(int n, int goal, int k) {
    vector<vector<long>> mem(goal + 1, vector<long>(n + 1, -1));
    return numMusicPlaylists(n, k, goal, n, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of playlists with i songs and j different songs.
  long numMusicPlaylists(int n, int k, int i, int j,
                         vector<vector<long>>& mem) {
    if (i == 0)
      return j == 0;
    if (j == 0)
      return 0;
    if (mem[i][j] >= 0)
      return mem[i][j];

    // The last song is new.
    mem[i][j] = numMusicPlaylists(n, k, i - 1, j - 1, mem) * (n - (j - 1));
    // The last song is old.
    mem[i][j] += numMusicPlaylists(n, k, i - 1, j, mem) * max(0, j - k);
    return mem[i][j] %= kMod;
  }
};",920
919,"class Solution {
 public:
  int minAddToMakeValid(string s) {
    int l = 0;
    int r = 0;

    for (const char c : s)
      if (c == '(') {
        ++l;
      } else {
        if (l == 0)
          ++r;
        else
          --l;
      }

    return l + r;
  }
};",921
920,"class Solution {
 public:
  vector<int> sortArrayByParityII(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0, j = 1; i < n; i += 2, j += 2) {
      while (i < n && nums[i] % 2 == 0)
        i += 2;
      while (j < n && nums[j] % 2 == 1)
        j += 2;
      if (i < n)
        swap(nums[i], nums[j]);
    }

    return nums;
  }
};",922
921,"class Solution {
 public:
  int threeSumMulti(vector<int>& arr, int target) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    unordered_map<int, int> count;

    for (const int a : arr)
      ++count[a];

    for (const auto& [i, x] : count)
      for (const auto& [j, y] : count) {
        const int k = target - i - j;
        const auto it = count.find(k);
        if (it == count.cend())
          continue;
        if (i == j && j == k)
          ans = (ans + static_cast<long>(x) * (x - 1) * (x - 2) / 6) % kMod;
        else if (i == j && j != k)
          ans = (ans + static_cast<long>(x) * (x - 1) / 2 * it->second) % kMod;
        else if (i < j && j < k)
          ans = (ans + static_cast<long>(x) * y * it->second) % kMod;
      }

    return ans;
  }
};",923
922,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    const int n = graph.size();
    UnionFind uf(n);
    vector<int> ufSize(n);
    vector<int> malwareCount(n);

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
        if (graph[i][j] == 1)
          uf.unionByRank(i, j);

    for (int i = 0; i < n; ++i)
      ++ufSize[uf.find(i)];

    for (const int i : initial)
      ++malwareCount[uf.find(i)];

    ranges::sort(initial);

    int ans = initial[0];
    int maxUfSize = 0;

    // Find the maximum union's malware if it only contains 1 malware.
    for (const int i : initial) {
      const int id = uf.find(i);
      if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {
        maxUfSize = ufSize[id];
        ans = i;
      }
    }

    return ans;
  }
};",924
923,"class Solution {
 public:
  bool isLongPressedName(string name, string typed) {
    int i = 0;

    for (int j = 0; j < typed.length(); ++j)
      if (i < name.length() && name[i] == typed[j])
        ++i;
      else if (j == 0 || typed[j] != typed[j - 1])
        return false;

    return i == name.length();
  }
};",925
924,"class Solution {
 public:
  int minFlipsMonoIncr(string s) {
    // the number of characters to be flilpped to make the substring so far
    // monotone increasing
    int dp = 0;
    int count1 = 0;

    for (const char c : s)
      if (c == '0')
        // 1. Flip '0'.
        // 2. Keep '0' and flip all the previous 1s.
        dp = min(dp + 1, count1);
      else
        ++count1;

    return dp;
  }
};",926
925,"class Solution {
 public:
  vector<int> threeEqualParts(vector<int>& arr) {
    const int ones = ranges::count_if(arr, [](int a) { return a == 1; });

    if (ones == 0)
      return {0, static_cast<int>(arr.size()) - 1};
    if (ones % 3 != 0)
      return {-1, -1};

    int k = ones / 3;
    int i;
    int j;
    int first;
    int second;
    int third;

    for (i = 0; i < arr.size(); ++i)
      if (arr[i] == 1) {
        first = i;
        break;
      }

    int gapOnes = k;

    for (j = i + 1; j < arr.size(); ++j)
      if (arr[j] == 1 && --gapOnes == 0) {
        second = j;
        break;
      }

    gapOnes = k;

    for (i = j + 1; i < arr.size(); ++i)
      if (arr[i] == 1 && --gapOnes == 0) {
        third = i;
        break;
      }

    while (third < arr.size() && arr[first] == arr[second] &&
           arr[second] == arr[third]) {
      ++first;
      ++second;
      ++third;
    }

    if (third == arr.size())
      return {first - 1, second};
    return {-1, -1};
  }
};",927
926,"class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int ans = 0;
    int minCount = graph.size();

    ranges::sort(initial);

    for (const int i : initial) {
      const int count = bfs(graph, i, initial);
      if (count < minCount) {
        minCount = count;
        ans = i;
      }
    }

    return ans;
  }

 private:
  int bfs(const vector<vector<int>>& graph, int removed, vector<int>& initial) {
    queue<int> q;
    vector<bool> seen(graph.size());
    seen[removed] = true;

    int count = 0;

    for (const int i : initial)
      if (i != removed) {
        q.push(i);
        seen[i] = true;
      }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      ++count;
      for (int i = 0; i < graph.size(); ++i) {
        if (seen[i])
          continue;
        if (i != u && graph[i][u]) {
          q.push(i);
          seen[i] = true;
        }
      }
    }

    return count;
  }
};",928
927,"class Solution {
 public:
  int numUniqueEmails(vector<string>& emails) {
    unordered_set<string> normalized;

    for (const string& email : emails) {
      string local;
      for (const char c : email) {
        if (c == '+' || c == '@')
          break;
        if (c == '.')
          continue;
        local += c;
      }
      string atDomain = email.substr(email.find('@'));
      normalized.insert(local + atDomain);
    }

    return normalized.size();
  }
};",929
928,"class Solution {
 public:
  int numSubarraysWithSum(vector<int>& nums, int goal) {
    int ans = 0;
    int prefix = 0;
    // {prefix: number of occurrence}
    unordered_map<int, int> count{{0, 1}};

    for (const int num : nums) {
      prefix += num;
      if (const auto it = count.find(prefix - goal); it != count.cend())
        ans += it->second;
      ++count[prefix];
    }

    return ans;
  }
};",930
929,"class Solution {
 public:
  int minFallingPathSum(vector<vector<int>>& A) {
    const int n = A.size();

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        int mini = INT_MAX;
        for (int k = max(0, j - 1); k < min(n, j + 2); ++k)
          mini = min(mini, A[i - 1][k]);
        A[i][j] += mini;
      }

    return ranges::min(A[n - 1]);
  }
};",931
930,"class Solution {
 public:
  vector<int> beautifulArray(int n) {
    vector<int> A(n);
    iota(A.begin(), A.end(), 1);
    divide(A, 0, n - 1, 1);
    return A;
  }

 private:
  void divide(vector<int>& A, int l, int r, int mask) {
    if (l >= r)
      return;
    const int m = partition(A, l, r, mask);
    divide(A, l, m, mask << 1);
    divide(A, m + 1, r, mask << 1);
  }

  int partition(vector<int>& A, int l, int r, int mask) {
    int nextSwapped = l;
    for (int i = l; i <= r; ++i)
      if (A[i] & mask)
        swap(A[i], A[nextSwapped++]);
    return nextSwapped - 1;
  }
};",932
931,ping(),933
932,"class Solution {
 public:
  int shortestBridge(vector<vector<int>>& grid) {
    markGridTwo(grid);

    for (int color = 2;; ++color)
      for (int i = 0; i < grid.size(); ++i)
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[i][j] == color)
            if (expand(grid, i + 1, j, color) ||  //
                expand(grid, i - 1, j, color) ||  //
                expand(grid, i, j + 1, color) ||  //
                expand(grid, i, j - 1, color))
              return color - 2;
  }

 private:
  // Marks one group to 2s by DFS.
  void markGridTwo(vector<vector<int>>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 1) {
          markGridTwo(grid, i, j);
          return;
        }
  }

  void markGridTwo(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] != 1)
      return;
    grid[i][j] = 2;
    markGridTwo(grid, i + 1, j);
    markGridTwo(grid, i - 1, j);
    markGridTwo(grid, i, j + 1);
    markGridTwo(grid, i, j - 1);
  }

  // Returns true if we touch 1s' group through expanding.
  bool expand(vector<vector<int>>& grid, int i, int j, int color) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return false;
    if (grid[i][j] == 0)
      grid[i][j] = color + 1;
    return grid[i][j] == 1;
  }
};",934
933,"class Solution {
 public:
  int knightDialer(int n) {
    constexpr int dirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},
                                {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};
    constexpr int kMod = 1'000'000'007;

    // dp[i][j] := the number of ways to stand on (i, j)
    vector<vector<int>> dp(4, vector<int>(3, 1));
    dp[3][0] = dp[3][2] = 0;

    for (int k = 0; k < n - 1; ++k) {
      vector<vector<int>> newDp(4, vector<int>(3));
      for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 3; ++j) {
          if (isNotNumericCell(i, j))
            continue;
          for (const auto& [dx, dy] : dirs) {
            const int x = i + dx;
            const int y = j + dy;
            if (x < 0 || x >= 4 || y < 0 || y >= 3)
              continue;
            if (isNotNumericCell(x, y))
              continue;
            newDp[i][j] = (newDp[i][j] + dp[x][y]) % kMod;
          }
        }
      dp = move(newDp);
    }

    int ans = 0;

    for (const vector<int>& row : dp)
      for (const int a : row)
        ans = (ans + a) % kMod;

    return ans;
  }

 private:
  bool isNotNumericCell(int i, int j) {
    return i == 3 && (j == 0 || j == 2);
  }
};",935
934,"class Solution {
 public:
  vector<int> movesToStamp(string stamp, string target) {
    vector<int> ans;
    // stamped[i] := true if we already stamped target by stamping on index i
    vector<bool> stamped(target.length());
    int stampedCount = 0;  // Our goal is to make stampedCount = |target|.

    while (stampedCount < target.length()) {
      bool isStamped = false;
      // Try to stamp target[i..i + |stamp|) for each index.
      for (int i = 0; i <= target.length() - stamp.length(); ++i) {
        if (stamped[i])
          continue;
        const int stampified = stampify(stamp, target, i);
        if (stampified == 0)
          continue;
        stampedCount += stampified;
        isStamped = true;
        stamped[i] = true;
        ans.push_back(i);
      }
      // After trying to stamp on each index, we can't find a valid stamp.
      if (!isStamped)
        return {};
    }

    reverse(ans.begin(), ans.end());
    return ans;
  }

 private:
  // Stamps target[i..i + |stamp|) and returns the number of newly stamped
  // characters.
  // e.g. stampify(""abc"", ""ababc"", 2) returns 3 because target becomes ""ab***"".
  int stampify(const string& stamp, string& target, int s) {
    int stampified = stamp.length();

    for (int i = 0; i < stamp.length(); ++i)
      if (target[s + i] == '*')  // It's already been stamped.
        --stampified;
      else if (target[s + i] != stamp[i])
        return 0;  // We can't stamp on the index i.

    if (stampified > 0)
      fill(target.begin() + s, target.begin() + s + stamp.length(), '*');

    return stampified;
  }
};",936
935,"class Solution {
 public:
  vector<string> reorderLogFiles(vector<string>& logs) {
    vector<string> ans;
    vector<string> digitLogs;
    vector<pair<string, string>> letterLogs;

    for (const string& log : logs) {
      const int i = log.find_first_of(' ');
      if (isdigit(log[i + 1]))
        digitLogs.push_back(log);
      else
        letterLogs.emplace_back(log.substr(0, i), log.substr(i + 1));
    }

    ranges::sort(letterLogs, [](const pair<string, string>& a,
                                const pair<string, string>& b) {
      return a.second == b.second ? a.first < b.first : a.second < b.second;
    });

    for (const auto& [identifier, letters] : letterLogs)
      ans.push_back(identifier + ' ' + letters);

    for (const string& digitLog : digitLogs)
      ans.push_back(digitLog);

    return ans;
  }
};",937
936,"class Solution {
 public:
  int rangeSumBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return 0;
    if (root->val < L)
      return rangeSumBST(root->right, L, R);
    if (root->val > R)
      return rangeSumBST(root->left, L, R);
    return root->val + rangeSumBST(root->left, L, R) +
           rangeSumBST(root->right, L, R);
  }
};",938
937,"class Solution {
 public:
  int minAreaRect(vector<vector<int>>& points) {
    int ans = INT_MAX;
    unordered_map<int, unordered_set<int>> xToYs;

    for (const vector<int>& p : points)
      xToYs[p[0]].insert(p[1]);

    for (int i = 1; i < points.size(); ++i)
      for (int j = 0; j < i; ++j) {
        const vector<int>& p = points[i];
        const vector<int>& q = points[j];
        if (p[0] == q[0] || p[1] == q[1])
          continue;
        if (xToYs[p[0]].count(q[1]) && xToYs[q[0]].count(p[1]))
          ans = min(ans, abs(p[0] - q[0]) * abs(p[1] - q[1]));
      }

    return ans == INT_MAX ? 0 : ans;
  }
};",939
938,"class Solution {
 public:
  int distinctSubseqII(string s) {
    constexpr int kMod = 1'000'000'007;
    // endsIn[i] := the number of subsequence that end in ('a' + i)
    vector<long> endsIn(26);

    for (const char c : s)
      endsIn[c - 'a'] = accumulate(endsIn.begin(), endsIn.end(), 1L) % kMod;

    return accumulate(endsIn.begin(), endsIn.end(), 0L) % kMod;
  }
};",940
939,"class Solution {
 public:
  bool validMountainArray(vector<int>& arr) {
    if (arr.size() < 3)
      return false;

    int l = 0;
    int r = arr.size() - 1;

    while (l + 1 < arr.size() && arr[l] < arr[l + 1])
      ++l;
    while (r > 0 && arr[r] < arr[r - 1])
      --r;

    return l > 0 && r < arr.size() - 1 && l == r;
  }
};",941
940,"class Solution {
 public:
  vector<int> diStringMatch(string s) {
    vector<int> ans;
    int min = 0;
    int max = s.length();

    for (const char c : s)
      ans.push_back(c == 'I' ? min++ : max--);
    ans.push_back(min);

    return ans;
  }
};",942
941,"class Solution {
 public:
  string shortestSuperstring(vector<string>& A) {
    const int n = A.size();
    // cost[i][j] := the cost to append A[j] after A[i]
    vector<vector<int>> cost(n, vector<int>(n));

    // Returns the cost to append b after a.
    auto getCost = [](const string& a, const string& b) {
      int cost = b.length();
      const int minLength = min(a.length(), b.length());
      for (int k = 1; k <= minLength; ++k)
        if (a.substr(a.length() - k) == b.substr(0, k))
          cost = b.length() - k;
      return cost;
    };

    // Pre-calculate cost array to save time.
    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        cost[i][j] = getCost(A[i], A[j]);
        cost[j][i] = getCost(A[j], A[i]);
      }

    vector<int> bestPath;
    int minLength = n * 20;  // given by problem

    dfs(A, cost, {}, bestPath, 0, 0, 0, minLength);

    string ans = A[bestPath[0]];

    for (int k = 1; k < n; ++k) {
      const int i = bestPath[k - 1];
      const int j = bestPath[k];
      ans += A[j].substr(A[j].length() - cost[i][j]);
    }

    return ans;
  }

 private:
  // used: i-th bit means A[i] is used or not
  void dfs(const vector<string>& A, const vector<vector<int>>& cost,
           vector<int>&& path, vector<int>& bestPath, int used, int depth,
           int currLength, int& minLength) {
    if (currLength >= minLength)
      return;
    if (depth == A.size()) {
      minLength = currLength;
      bestPath = path;
      return;
    }

    for (int i = 0; i < A.size(); ++i) {
      if (1 << i & used)
        continue;
      path.push_back(i);
      const int newLength =
          depth == 0 ? A[i].length() : currLength + cost[path[depth - 1]][i];
      dfs(A, cost, move(path), bestPath, used | 1 << i, depth + 1, newLength,
          minLength);
      path.pop_back();
    }
  }
};",943
942,"class Solution {
 public:
  int minDeletionSize(vector<string>& strs) {
    int ans = 0;

    for (int j = 0; j < strs[0].length(); ++j)
      for (int i = 0; i + 1 < strs.size(); ++i)
        if (strs[i][j] > strs[i + 1][j]) {
          ++ans;
          break;
        }

    return ans;
  }
};",944
943,"class Solution {
 public:
  int minIncrementForUnique(vector<int>& nums) {
    int ans = 0;
    int minAvailable = 0;

    ranges::sort(nums);

    for (const int num : nums) {
      ans += max(minAvailable - num, 0);
      minAvailable = max(minAvailable, num) + 1;
    }

    return ans;
  }
};",945
944,"class Solution {
 public:
  bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    stack<int> stack;
    int i = 0;  // popped's index

    for (const int x : pushed) {
      stack.push(x);
      while (!stack.empty() && stack.top() == popped[i]) {
        stack.pop();
        ++i;
      }
    }

    return stack.empty();
  }
};",946
945,"class Solution {
 public:
  int removeStones(vector<vector<int>>& stones) {
    int numOfIslands = 0;
    vector<vector<int>> graph(stones.size());
    unordered_set<int> seen;

    for (int i = 0; i < stones.size(); ++i)
      for (int j = i + 1; j < stones.size(); ++j)
        if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
          graph[i].push_back(j);
          graph[j].push_back(i);
        }

    for (int i = 0; i < stones.size(); ++i)
      if (seen.insert(i).second) {
        dfs(graph, i, seen);
        ++numOfIslands;
      }

    return stones.size() - numOfIslands;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u])
      if (seen.insert(v).second)
        dfs(graph, v, seen);
  }
};",947
946,"class Solution {
 public:
  int bagOfTokensScore(vector<int>& tokens, int power) {
    int ans = 0;
    int score = 0;
    int i = 0;                  // the index of the smallest token
    int j = tokens.size() - 1;  // the index of the largest token

    ranges::sort(tokens);

    while (i <= j && (power >= tokens[i] || score)) {
      while (i <= j && power >= tokens[i]) {
        // Play the smallest face up.
        power -= tokens[i++];
        ++score;
      }
      ans = max(ans, score);
      if (i <= j && score) {
        // Play the largest face down.
        power += tokens[j--];
        --score;
      }
    }

    return ans;
  }
};",948
947,"class Solution {
 public:
  string largestTimeFromDigits(vector<int>& arr) {
    string ans;

    for (int i = 0; i < 4; ++i)
      for (int j = 0; j < 4; ++j)
        for (int k = 0; k < 4; ++k) {
          if (i == j || i == k || j == k)
            continue;
          const string hours = to_string(arr[i]) + to_string(arr[j]);
          const string minutes =
              to_string(arr[k]) + to_string(arr[6 - i - j - k]);
          if (hours < ""24"" && minutes < ""60"")
            ans = max(ans, hours + ':' + minutes);
        }

    return ans;
  }
};",949
948,"class Solution {
 public:
  vector<int> deckRevealedIncreasing(vector<int>& deck) {
    ranges::sort(deck, greater<int>());

    deque<int> dq{deck[0]};

    for (int i = 1; i < deck.size(); ++i) {
      dq.push_front(dq.back());
      dq.pop_back();
      dq.push_front(deck[i]);
    }

    return {dq.begin(), dq.end()};
  }
};",950
949,"class Solution {
 public:
  bool flipEquiv(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr)
      return root2 == nullptr;
    if (root2 == nullptr)
      return root1 == nullptr;
    if (root1->val != root2->val)
      return false;
    return flipEquiv(root1->left, root2->left) &&
               flipEquiv(root1->right, root2->right) ||
           flipEquiv(root1->left, root2->right) &&
               flipEquiv(root1->right, root2->left);
  }
};",951
950,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int largestComponentSize(vector<int>& nums) {
    const int n = ranges::max(nums);
    int ans = 0;
    UnionFind uf(n + 1);
    unordered_map<int, int> count;

    for (const int num : nums)
      for (int x = 2; x <= sqrt(num); ++x)
        if (num % x == 0) {
          uf.unionByRank(num, x);
          uf.unionByRank(num, num / x);
        }

    for (const int num : nums)
      ans = max(ans, ++count[uf.find(num)]);

    return ans;
  }
};",952
951,"class Solution {
 public:
  bool isAlienSorted(vector<string>& words, const string& order) {
    vector<char> map(26);  // e.g. order = ""bca"" -> map = ['c', 'a', 'b']

    for (int i = 0; i < 26; ++i)
      map[order[i] - 'a'] = i + 'a';

    for (string& word : words)
      for (char& c : word)
        c = map[c - 'a'];

    return is_sorted(words.begin(), words.end());
  }
};",953
952,"class Solution {
 public:
  bool canReorderDoubled(vector<int>& arr) {
    unordered_map<int, int> count;

    for (const int a : arr)
      ++count[a];

    ranges::sort(arr, [](const int a, const int b) { return abs(a) < abs(b); });

    for (const int a : arr) {
      if (count[a] == 0)
        continue;
      if (count[2 * a] == 0)
        return false;
      --count[a];
      --count[2 * a];
    }

    return true;
  }
};",954
953,"class Solution {
 public:
  int minDeletionSize(vector<string>& strs) {
    const int n = strs.size();
    int ans = 0;
    // sorted[i] := true if strs[i] < strs[i + 1]
    vector<bool> sorted(n - 1);

    for (int j = 0; j < strs[0].length(); ++j) {
      int i;
      for (i = 0; i + 1 < n; ++i)
        if (!sorted[i] && strs[i][j] > strs[i + 1][j]) {
          ++ans;
          break;
        }
      // Already compared each pair, so update the sorted array if needed.
      if (i + 1 == n)
        for (i = 0; i + 1 < n; ++i)
          sorted[i] = sorted[i] || strs[i][j] < strs[i + 1][j];
    }

    return ans;
  }
};",955
954,"class Solution {
 public:
  int tallestBillboard(vector<int>& rods) {
    const int n = rods.size();
    const int sum = accumulate(rods.begin(), rods.end(), 0);
    // dp[i][j] := the maximum min-height of using rods[0..i) to pile two piles
    // that have height difference j
    vector<vector<int>> dp(n + 1, vector<int>(sum + 1, -1));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const int h = rods[i - 1];
      for (int j = 0; j <= sum - h; ++j) {
        if (dp[i - 1][j] < 0)
          continue;
        // Don't use rods[i - 1].
        dp[i][j] = max(dp[i][j], dp[i - 1][j]);
        // Put on the taller pile.
        dp[i][j + h] = max(dp[i][j + h], dp[i - 1][j]);
        // Put on the shorter pile.
        dp[i][abs(j - h)] = max(dp[i][abs(j - h)], dp[i - 1][j] + min(j, h));
      }
    }

    return dp[n][0];
  }
};",956
955,"class Solution {
 public:
  vector<int> prisonAfterNDays(vector<int>& cells, int n) {
    vector<int> firstDayCells;
    vector<int> nextDayCells(cells.size());

    for (int day = 0; n-- > 0; cells = nextDayCells, ++day) {
      for (int i = 1; i + 1 < cells.size(); ++i)
        nextDayCells[i] = cells[i - 1] == cells[i + 1];
      if (day == 0)
        firstDayCells = nextDayCells;
      else if (nextDayCells == firstDayCells)
        n %= day;
    }

    return cells;
  }
};",957
956,"class Solution {
 public:
  bool isCompleteTree(TreeNode* root) {
    if (root == nullptr)
      return true;

    queue<TreeNode*> q{{root}};

    while (q.front() != nullptr) {
      TreeNode* node = q.front();
      q.pop();
      q.push(node->left);
      q.push(node->right);
    }

    while (!q.empty() && q.front() == nullptr)
      q.pop();

    return q.empty();
  }
};",958
957,"class Solution {
 public:
  int regionsBySlashes(vector<string>& grid) {
    const int n = grid.size();
    // G := upscaled grid
    vector<vector<int>> g(n * 3, vector<int>(n * 3));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '/') {
          g[i * 3][j * 3 + 2] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3] = 1;
        } else if (grid[i][j] == '\\') {
          g[i * 3][j * 3] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3 + 2] = 1;
        }

    int ans = 0;

    for (int i = 0; i < n * 3; ++i)
      for (int j = 0; j < n * 3; ++j)
        if (g[i][j] == 0) {
          dfs(g, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return;
    if (g[i][j] != 0)
      return;

    g[i][j] = 2;  // Mark 2 as visited.
    dfs(g, i + 1, j);
    dfs(g, i - 1, j);
    dfs(g, i, j + 1);
    dfs(g, i, j - 1);
  }
};",959
958,"class Solution {
 public:
  int minDeletionSize(vector<string>& strs) {
    const int k = strs[0].length();
    // dp[i] the length of LIS ending in strs[*][i]
    vector<int> dp(k, 1);

    for (int i = 1; i < k; ++i)
      for (int j = 0; j < i; ++j)
        if (ranges::all_of(strs, [&](const string& s) { return s[j] <= s[i]; }))
          dp[i] = max(dp[i], dp[j] + 1);

    return k - ranges::max(dp);
  }
};",960
959,"class Solution {
 public:
  int repeatedNTimes(vector<int>& nums) {
    for (int i = 0; i + 2 < nums.size(); ++i)
      if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2])
        return nums[i];
    return nums.back();
  }
};",961
960,"class Solution {
 public:
  int maxWidthRamp(vector<int>& nums) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i < nums.size(); ++i)
      if (stack.empty() || nums[i] < nums[stack.top()])
        stack.push(i);

    for (int i = nums.size() - 1; i > ans; --i)
      while (!stack.empty() && nums[i] >= nums[stack.top()])
        ans = max(ans, i - stack.top()), stack.pop();

    return ans;
  }
};",962
961,"class Solution {
 public:
  double minAreaFreeRect(vector<vector<int>>& points) {
    long ans = LONG_MAX;
    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.
    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;

    for (const vector<int>& A : points)
      for (const vector<int>& B : points) {
        const int center = hash(A, B);
        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);
      }

    // For all pair points ""that share the same center"".
    for (const auto& [_, points] : centerToPoints)
      for (const auto& [ax, ay, bx, by] : points)
        for (const auto& [cx, cy, dx, dy] : points)
          // AC is perpendicular to AD.
          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.
          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {
            const long squaredArea =
                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);
            if (squaredArea > 0)
              ans = min(ans, squaredArea);
          }

    return ans == LONG_MAX ? 0 : sqrt(ans);
  }

 private:
  int hash(const vector<int>& p, const vector<int>& q) {
    return ((long)(p[0] + q[0]) << 16) + (p[1] + q[1]);
  }

  long dist(int px, int py, int qx, int qy) {
    return (px - qx) * (px - qx) + (py - qy) * (py - qy);
  }
};",963
962,"class Solution {
 public:
  int leastOpsExpressTarget(int x, int target) {
    return dfs(x, target, {});
  }

 private:
  int dfs(int x, int target, unordered_map<int, int>&& mem) {
    if (const auto it = mem.find(target); it != mem.cend())
      return it->second;
    if (x > target)
      return min(2 * target - 1, 2 * (x - target));
    if (x == target)
      return 0;

    long prod = x;
    int n = 0;
    while (prod < target) {
      prod *= x;
      ++n;
    }
    if (prod == target)
      return mem[target] = n;

    int ans = dfs(x, target - prod / x, move(mem)) + n;
    if (prod < 2 * target)
      ans = min(ans, dfs(x, prod - target, move(mem)) + n + 1);
    return mem[target] = ans;
  }
};",964
963,"class Solution {
 public:
  bool isUnivalTree(TreeNode* root) {
    if (root == nullptr)
      return true;
    if (root->left != nullptr && root->left->val != root->val)
      return false;
    if (root->right != nullptr && root->right->val != root->val)
      return false;
    return isUnivalTree(root->left) && isUnivalTree(root->right);
  }
};",965
964,"class Solution {
 public:
  vector<string> spellchecker(vector<string>& wordlist,
                              vector<string>& queries) {
    vector<string> ans;
    unordered_map<string, string> dict;

    for (const string& word : wordlist) {
      dict.insert({word, word});
      dict.insert({lowerKey(word), word});
      dict.insert({vowelKey(word), word});
    }

    for (const string& query : queries)
      if (const auto it = dict.find(query); it != dict.cend())
        ans.push_back(it->second);
      else if (const auto it = dict.find(lowerKey(query)); it != dict.cend())
        ans.push_back(it->second);
      else if (const auto it = dict.find(vowelKey(query)); it != dict.cend())
        ans.push_back(it->second);
      else
        ans.push_back("""");

    return ans;
  }

 private:
  string lowerKey(const string& word) {
    string s{""$""};
    for (const char c : word)
      s += tolower(c);
    return s;
  }

  string vowelKey(const string& word) {
    string s;
    for (const char c : word)
      s += isVowel(c) ? '*' : tolower(c);
    return s;
  }

  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }
};",966
965,"class Solution {
 public:
  vector<int> numsSameConsecDiff(int n, int k) {
    if (n == 1)
      return {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    vector<int> ans;

    if (k == 0) {
      for (char c = '1'; c <= '9'; ++c)
        ans.push_back(stoi(string(n, c)));
      return ans;
    }

    for (int num = 1; num <= 9; ++num)
      dfs(n - 1, k, num, ans);

    return ans;
  }

 private:
  void dfs(int n, int k, int num, vector<int>& ans) {
    if (n == 0) {
      ans.push_back(num);
      return;
    }

    const int lastDigit = num % 10;

    for (const int nextDigit : {lastDigit - k, lastDigit + k})
      if (0 <= nextDigit && nextDigit <= 9)
        dfs(n - 1, k, num * 10 + nextDigit, ans);
  }
};",967
966,"class Solution {
 public:
  int minCameraCover(TreeNode* root) {
    vector<int> ans = dfs(root);
    return min(ans[1], ans[2]);
  }

 private:
  // 0 := all the nodes below the root are covered except the root
  // 1 := all the nodes below and including the root are covered with no camera
  // 2 := all nodes below and including the root are covered with a camera
  vector<int> dfs(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 1000};

    vector<int> l = dfs(root->left);
    vector<int> r = dfs(root->right);

    const int s0 = l[1] + r[1];
    const int s1 = min(l[2] + min(r[1], r[2]),  //
                       r[2] + min(l[1], l[2]));
    const int s2 = min({l[0], l[1], l[2]}) +  //
                   min({r[0], r[1], r[2]}) + 1;
    return {s0, s1, s2};
  }
};",968
967,"class Solution {
 public:
  vector<int> pancakeSort(vector<int>& arr) {
    vector<int> ans;

    for (int target = arr.size(); target >= 1; --target) {
      int index = find(arr, target);
      reverse(arr.begin(), arr.begin() + index + 1);
      reverse(arr.begin(), arr.begin() + target);
      ans.push_back(index + 1);
      ans.push_back(target);
    }

    return ans;
  }

 private:
  int find(vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i)
      if (arr[i] == target)
        return i;
    throw;
  }
};",969
968,"class Solution {
 public:
  vector<int> powerfulIntegers(int x, int y, int bound) {
    unordered_set<int> ans;

    for (int i = 1; i < bound; i *= x) {
      for (int j = 1; i + j <= bound; j *= y) {
        ans.insert(i + j);
        if (y == 1)
          break;
      }
      if (x == 1)
        break;
    }

    return {ans.begin(), ans.end()};
  }
};",970
969,"class Solution {
 public:
  vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
    vector<int> ans;
    dfs(root, 0, voyage, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int&& i, const vector<int>& voyage,
           vector<int>& ans) {
    if (root == nullptr)
      return;
    if (root->val != voyage[i++]) {
      ans.clear();
      ans.push_back(-1);
      return;
    }

    if (i < voyage.size() && root->left && root->left->val != voyage[i]) {
      // Flip the root.
      ans.push_back(root->val);
      dfs(root->right, move(i), voyage, ans);
      dfs(root->left, move(i), voyage, ans);
    } else {
      dfs(root->left, move(i), voyage, ans);
      dfs(root->right, move(i), voyage, ans);
    }
  }
};",971
970,"class Solution {
 public:
  bool isRationalEqual(string s, string t) {
    return abs(valueOf(s) - valueOf(t)) < 1e-9;
  }

 private:
  const static vector<double> ratios{1.0, 1.0 / 9, 1.0 / 99, 1.0 / 999,
                                     1.0 / 9999};

  double valueOf(const string& s) {
    if (s.find('(') == string::npos)
      return stod(s);

    // Get the indices..
    const int leftParenIndex = s.find_first_of('(');
    const int rightParenIndex = s.find_first_of(')');
    const int dotIndex = s.find_first_of('.');

    // integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>
    const double integerAndNonRepeating = stod(s.substr(0, leftParenIndex));
    const int nonRepeatingLength = leftParenIndex - dotIndex - 1;

    // repeating := <RepeatingPart>
    const int repeating = stoi(s.substr(leftParenIndex + 1, rightParenIndex));
    const int repeatingLength = rightParenIndex - leftParenIndex - 1;
    return integerAndNonRepeating +
           repeating * pow(0.1, nonRepeatingLength) * ratios[repeatingLength];
  }
};",972
971,"class Solution {
 public:
  vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
    vector<vector<int>> ans;
    auto compare = [&](const vector<int>& a, const vector<int>& b) {
      return squareDist(a) < squareDist(b);
    };
    priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> maxHeap(
        compare);

    for (const vector<int>& point : points) {
      maxHeap.push(point);
      if (maxHeap.size() > k)
        maxHeap.pop();
    }

    while (!maxHeap.empty())
      ans.push_back(maxHeap.top()), maxHeap.pop();

    return ans;
  };

 private:
  int squareDist(const vector<int>& p) {
    return p[0] * p[0] + p[1] * p[1];
  }
};",973
972,"class Solution {
 public:
  int subarraysDivByK(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    vector<int> count(k);
    count[0] = 1;

    for (const int num : nums) {
      prefix = (prefix + num % k + k) % k;
      ans += count[prefix];
      ++count[prefix];
    }

    return ans;
  }
};",974
973,"class Solution {
 public:
  int oddEvenJumps(vector<int>& arr) {
    const int n = arr.size();
    map<int, int> map;  // {num: min index}
    // inc[i] := true if can reach arr[n - 1] from i using increasing jumps
    vector<bool> inc(n);
    // dec[i] := true if can reach arr[n - 1] from i using decreasing jumps
    vector<bool> dec(n);

    map[arr[n - 1]] = n - 1;
    inc.back() = true;
    dec.back() = true;

    for (int i = n - 2; i >= 0; --i) {
      const auto lo = map.lower_bound(arr[i]);  // the minimum value >= arr[i]
      const auto hi = map.upper_bound(arr[i]);  // the minimum value > arr[i]
      if (lo != map.cend())
        inc[i] = dec[lo->second];
      if (hi != map.cbegin())
        dec[i] = inc[prev(hi)->second];
      map[arr[i]] = i;
    }

    return ranges::count(inc, true);
  }
};",975
974,"class Solution {
 public:
  int largestPerimeter(vector<int>& nums) {
    ranges::sort(nums);

    for (int i = nums.size() - 1; i > 1; --i)
      if (nums[i - 2] + nums[i - 1] > nums[i])
        return nums[i - 2] + nums[i - 1] + nums[i];

    return 0;
  }
};",976
975,"class Solution {
 public:
  vector<int> sortedSquares(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    int i = n - 1;

    for (int l = 0, r = n - 1; l <= r;)
      if (abs(nums[l]) > abs(nums[r]))
        ans[i--] = nums[l] * nums[l++];
      else
        ans[i--] = nums[r] * nums[r--];

    return ans;
  }
};",977
976,"class Solution {
 public:
  int maxTurbulenceSize(vector<int>& arr) {
    int ans = 1;
    int increasing = 1;
    int decreasing = 1;

    for (int i = 1; i < arr.size(); ++i) {
      if (arr[i] > arr[i - 1]) {
        increasing = decreasing + 1;
        decreasing = 1;
      } else if (arr[i] < arr[i - 1]) {
        decreasing = increasing + 1;
        increasing = 1;
      } else {
        increasing = 1;
        decreasing = 1;
      }
      ans = max({ans, increasing, decreasing});
    }

    return ans;
  }
};",978
977,"class Solution {
 public:
  int distributeCoins(TreeNode* root) {
    int ans = 0;
    dfs(root, ans);
    return ans;
  }

 private:
  // Returns the number of coins I can give (positive) / take (negative).
  int dfs(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = dfs(root->left, ans);
    const int r = dfs(root->right, ans);
    ans += abs(l) + abs(r);
    return (root->val - 1) + l + r;
  }
};",979
978,"class Solution {
 public:
  int uniquePathsIII(vector<vector<int>>& grid) {
    int ans = 0;
    int empty = 1;
    int sx;
    int sy;
    int ex;
    int ey;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 0) {
          ++empty;
        } else if (grid[i][j] == 1) {
          sx = i;
          sy = j;
        } else if (grid[i][j] == 2) {
          ex = i;
          ey = j;
        }

    dfs(grid, empty, sx, sy, ex, ey, ans);

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& grid, int empty, int i, int j, int ex, int ey,
           int& ans) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] < 0)
      return;
    if (i == ex && j == ey) {
      if (empty == 0)
        ++ans;
      return;
    }

    grid[i][j] = -2;
    dfs(grid, empty - 1, i + 1, j, ex, ey, ans);
    dfs(grid, empty - 1, i - 1, j, ex, ey, ans);
    dfs(grid, empty - 1, i, j + 1, ex, ey, ans);
    dfs(grid, empty - 1, i, j - 1, ex, ey, ans);
    grid[i][j] = 0;
  }
};",980
979,"set(key: str, value: str, timestamp: int)",981
980,"class Solution {
 public:
  int countTriplets(vector<int>& nums) {
    constexpr int kMax = 1 << 16;
    int ans = 0;
    vector<int> count(kMax);  // {nums[i] & nums[j]: times}

    for (const int a : nums)
      for (const int b : nums)
        ++count[a & b];

    for (const int num : nums)
      for (int i = 0; i < kMax; ++i)
        if ((num & i) == 0)
          ans += count[i];

    return ans;
  }
};",982
981,"class Solution {
 public:
  int mincostTickets(vector<int>& days, vector<int>& costs) {
    int ans = 0;
    queue<pair<int, int>> last7;
    queue<pair<int, int>> last30;

    for (int day : days) {
      while (!last7.empty() && last7.front().first + 7 <= day)
        last7.pop();
      while (!last30.empty() && last30.front().first + 30 <= day)
        last30.pop();
      last7.emplace(day, ans + costs[1]);
      last30.emplace(day, ans + costs[2]);
      ans = min({ans + costs[0], last7.front().second, last30.front().second});
    }

    return ans;
  }
};",983
982,"class Solution {
 public:
  string strWithout3a3b(int A, int B, char a = 'a', char b = 'b') {
    if (A < B)
      return strWithout3a3b(B, A, b, a);
    if (B == 0)
      return string(min(A, 2), a);

    const int useA = min(A, 2);
    const int useB = (A - useA >= B) ? 1 : 0;
    return string(useA, a) + string(useB, b) +
           strWithout3a3b(A - useA, B - useB, a, b);
  }
};",984
983,"class Solution {
 public:
  vector<int> sumEvenAfterQueries(vector<int>& nums,
                                  vector<vector<int>>& queries) {
    vector<int> ans;
    int sum =
        accumulate(nums.begin(), nums.end(), 0, [](int subtotal, int num) {
          return subtotal + (num % 2 == 0 ? num : 0);
        });

    for (const vector<int>& query : queries) {
      const int val = query[0];
      const int index = query[1];
      if (nums[index] % 2 == 0)
        sum -= nums[index];
      nums[index] += val;
      if (nums[index] % 2 == 0)
        sum += nums[index];
      ans.push_back(sum);
    }

    return ans;
  }
};",985
984,"class Solution {
 public:
  vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList,
                                           vector<vector<int>>& secondList) {
    vector<vector<int>> ans;
    short i = 0;
    short j = 0;

    while (i < firstList.size() && j < secondList.size()) {
      // lo := the start of the intersection
      // hi := the end of the intersection
      const int lo = max(firstList[i][0], secondList[j][0]);
      const int hi = min(firstList[i][1], secondList[j][1]);
      if (lo <= hi)
        ans.push_back({lo, hi});
      firstList[i][1] < secondList[j][1] ? ++i : ++j;
    }

    return ans;
  }
};",986
985,"class Solution {
 public:
  vector<vector<int>> verticalTraversal(TreeNode* root) {
    vector<vector<int>> ans;
    map<int, multiset<pair<int, int>>> xToSortedPairs;  // {x: {(-y, val)}}

    dfs(root, 0, 0, xToSortedPairs);

    for (const auto& [_, pairs] : xToSortedPairs) {
      vector<int> vals;
      for (const pair<int, int>& pair : pairs)
        vals.push_back(pair.second);
      ans.push_back(vals);
    }

    return ans;
  }

 private:
  void dfs(TreeNode* root, int x, int y,
           map<int, multiset<pair<int, int>>>& xToSortedPairs) {
    if (root == nullptr)
      return;
    xToSortedPairs[x].emplace(y, root->val);
    dfs(root->left, x - 1, y + 1, xToSortedPairs);
    dfs(root->right, x + 1, y + 1, xToSortedPairs);
  }
};",987
986,"class Solution {
 public:
  string smallestFromLeaf(TreeNode* root) {
    string ans;
    dfs(root, """", ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, string&& path, string& ans) {
    if (root == nullptr)
      return;

    path.push_back(root->val + 'a');

    if (root->left == nullptr && root->right == nullptr) {
      reverse(path.begin(), path.end());
      if (ans == """" || ans > path)
        ans = path;
      reverse(path.begin(), path.end());  // Roll back.
    }

    dfs(root->left, move(path), ans);
    dfs(root->right, move(path), ans);
    path.pop_back();
  }
};",988
987,"class Solution {
 public:
  vector<int> addToArrayForm(vector<int>& num, int k) {
    for (int i = num.size() - 1; i >= 0; --i) {
      num[i] += k;
      k = num[i] / 10;
      num[i] %= 10;
    }

    while (k > 0) {
      num.insert(num.begin(), k % 10);
      k /= 10;
    }

    return num;
  }
};",989
988,"class UnionFind {
 public:
  UnionFind(int n) : id(n) {
    iota(id.begin(), id.end(), 0);
  }

  void union_(int u, int v) {
    id[find(u)] = find(v);
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
};

class Solution {
 public:
  bool equationsPossible(vector<string>& equations) {
    UnionFind uf(26);

    for (const string& e : equations)
      if (e[1] == '=') {
        const int x = e[0] - 'a';
        const int y = e[3] - 'a';
        uf.union_(x, y);
      }

    for (const string& e : equations)
      if (e[1] == '!') {
        const int x = e[0] - 'a';
        const int y = e[3] - 'a';
        if (uf.find(x) == uf.find(y))
          return false;
      }

    return true;
  }
};",990
989,"class Solution {
 public:
  int brokenCalc(int X, int Y) {
    int ops = 0;

    while (X < Y) {
      if (Y % 2 == 0)
        Y /= 2;
      else
        Y += 1;
      ++ops;
    }

    return ops + X - Y;
  }
};",991
990,"class Solution {
 public:
  int subarraysWithKDistinct(vector<int>& nums, int k) {
    return subarrayWithAtMostKDistinct(nums, k) -
           subarrayWithAtMostKDistinct(nums, k - 1);
  }

 private:
  int subarrayWithAtMostKDistinct(const vector<int>& nums, int k) {
    int ans = 0;
    vector<int> count(nums.size() + 1);

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (++count[nums[r]] == 1)
        --k;
      while (k == -1)
        if (--count[nums[l++]] == 0)
          ++k;
      ans += r - l + 1;  // nums[l..r], nums[l + 1..r], ..., nums[r]
    }

    return ans;
  }
};",992
991,"class Solution {
 public:
  bool isCousins(TreeNode* root, int x, int y) {
    if (root == nullptr)
      return false;

    queue<TreeNode*> queue{{root}};

    while (!queue.empty()) {
      bool isFindX = false;
      bool isFindY = false;
      for (int i = queue.size(); i > 0; --i) {
        root = queue.front(), queue.pop();
        if (root->val == x)
          isFindX = true;
        else if (root->val == y)
          isFindY = true;
        else if (root->left && root->right) {
          if (root->left->val == x && root->right->val == y)
            return false;
          if (root->left->val == y && root->right->val == x)
            return false;
        }
        if (root->left)
          queue.push(root->left);
        if (root->right)
          queue.push(root->right);
      }
      if (isFindX && isFindY)
        return true;
      else if (isFindX || isFindY)
        return false;
    }

    return false;
  }
};",993
992,"class Solution {
 public:
  int orangesRotting(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();

    auto isNeighborRotten = [&](int i, int j, const vector<vector<int>>& grid) {
      for (const auto& [dx, dy] : dirs) {
        const int r = i + dx;
        const int c = j + dy;
        if (r < 0 || r == m || c < 0 || c == n)
          continue;
        if (grid[r][c] == 2)
          return true;
      }
      return false;
    };

    int ans = 0;

    while (true) {
      vector<vector<int>> nextGrid(m, vector<int>(n));
      // Calculate `nextGrid` based on `grid`.
      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (grid[i][j] == 1) {  // fresh
            // Any of the 4-directionally oranges is rotten
            if (isNeighborRotten(i, j, grid))
              nextGrid[i][j] = 2;
            else
              nextGrid[i][j] = 1;
          } else if (grid[i][j] == 2) {  // rotten
            nextGrid[i][j] = 2;          // Keep rotten.
          }
      if (nextGrid == grid)
        break;
      grid = nextGrid;
      ++ans;
    }

    return any_of(grid.begin(), grid.end(),
                  [&](vector<int>& row) {
      return ranges::any_of(row, [&](int orange) { return orange == 1; });
    })
               ? -1
               : ans;
  }
};",994
993,"class Solution {
 public:
  int minKBitFlips(vector<int>& nums, int k) {
    int ans = 0;
    int flippedTime = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (i >= k && nums[i - k] == 2)
        --flippedTime;
      if (flippedTime % 2 == nums[i]) {
        if (i + k > nums.size())
          return -1;
        ++ans;
        ++flippedTime;
        nums[i] = 2;
      }
    }

    return ans;
  }
};",995
994,"class Solution {
 public:
  int numSquarefulPerms(vector<int>& nums) {
    int ans = 0;
    ranges::sort(nums);
    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           int& ans) {
    if (path.size() > 1 && !isSquare(path.back() + path[path.size() - 2]))
      return;
    if (path.size() == nums.size()) {
      ++ans;
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }

  bool isSquare(int num) {
    const int root = sqrt(num);
    return root * root == num;
  }
};",996
995,"class Solution {
 public:
  int findJudge(int n, vector<vector<int>>& trust) {
    vector<int> count(n + 1);

    for (vector<int>& t : trust) {
      --count[t[0]];
      ++count[t[1]];
    }

    for (int i = 1; i < n + 1; ++i)
      if (count[i] == n - 1)
        return i;

    return -1;
  }
};",997
996,"class Solution {
 public:
  TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
    if (root == nullptr)
      return new TreeNode(val);
    if (root->val < val)
      return new TreeNode(val, root, nullptr);
    root->right = insertIntoMaxTree(root->right, val);
    return root;
  }
};",998
997,"class Solution {
 public:
  int numRookCaptures(vector<vector<char>>& board) {
    int ans = 0;
    int i0 = 0;
    int j0 = 0;

    for (int i = 0; i < 8; ++i)
      for (int j = 0; j < 8; ++j)
        if (board[i][j] == 'R') {
          i0 = i;
          j0 = j;
        }

    for (const vector<int>& d :
         vector<vector<int>>({{1, 0}, {0, 1}, {-1, 0}, {0, -1}}))
      for (int i = i0 + d[0], j = j0 + d[1]; 0 <= i && i < 8 && 0 <= j && j < 8;
           i += d[0], j += d[1]) {
        if (board[i][j] == 'p')
          ++ans;
        if (board[i][j] != '.')
          break;
      }

    return ans;
  }
};",999
998,"class Solution {
 public:
  int mergeStones(vector<int>& stones, int K) {
    const int n = stones.size();
    vector<vector<vector<int>>> mem(
        n, vector<vector<int>>(n, vector<int>(K + 1, kMax)));
    vector<int> prefix(n + 1);
    partial_sum(stones.begin(), stones.end(), prefix.begin() + 1);
    const int cost = mergeStones(stones, 0, n - 1, 1, K, prefix, mem);
    return cost == kMax ? -1 : cost;
  }

 private:
  static constexpr int kMax = 1'000'000'000;

  // Returns the minimum cost to merge stones[i..j] into k piles.
  int mergeStones(const vector<int>& stones, int i, int j, int k, int K,
                  const vector<int>& prefix, vector<vector<vector<int>>>& mem) {
    if ((j - i + 1 - k) % (K - 1))
      return kMax;
    if (i == j)
      return k == 1 ? 0 : kMax;
    if (mem[i][j][k] != kMax)
      return mem[i][j][k];
    if (k == 1)
      return mem[i][j][k] = mergeStones(stones, i, j, K, K, prefix, mem) +
                            prefix[j + 1] - prefix[i];

    for (int m = i; m < j; m += K - 1)
      mem[i][j][k] =
          min(mem[i][j][k],
              mergeStones(stones, i, m, 1, K, prefix, mem) +
                  mergeStones(stones, m + 1, j, k - 1, K, prefix, mem));

    return mem[i][j][k];
  }
};",1000
999,"class Solution {
 public:
  vector<int> gridIllumination(int n, vector<vector<int>>& lamps,
                               vector<vector<int>>& queries) {
    vector<int> ans;
    unordered_map<int, int> rows;
    unordered_map<int, int> cols;
    unordered_map<int, int> diag1;
    unordered_map<int, int> diag2;
    unordered_set<pair<int, int>, PairHash> lampsSet;

    for (vector<int>& lamp : lamps) {
      int i = lamp[0];
      int j = lamp[1];
      if (lampsSet.insert({i, j}).second) {
        ++rows[i];
        ++cols[j];
        ++diag1[i + j];
        ++diag2[i - j];
      }
    }

    for (const vector<int>& query : queries) {
      int i = query[0];
      int j = query[1];
      if (rows[i] || cols[j] || diag1[i + j] || diag2[i - j]) {
        ans.push_back(1);
        for (int y = max(0, i - 1); y < min(n, i + 2); ++y)
          for (int x = max(0, j - 1); x < min(n, j + 2); ++x)
            if (lampsSet.erase({y, x})) {
              --rows[y];
              --cols[x];
              --diag1[y + x];
              --diag2[y - x];
            }
      } else {
        ans.push_back(0);
      }
    }

    return ans;
  }

 private:
  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",1001
1000,"class Solution {
 public:
  vector<string> commonChars(vector<string>& A) {
    vector<string> ans;
    vector<int> commonCount(26, INT_MAX);

    for (const string& a : A) {
      vector<int> count(26);
      for (char c : a)
        ++count[c - 'a'];
      for (int i = 0; i < 26; ++i)
        commonCount[i] = min(commonCount[i], count[i]);
    }

    for (char c = 'a'; c <= 'z'; ++c)
      for (int i = 0; i < commonCount[c - 'a']; ++i)
        ans.push_back(string(1, c));

    return ans;
  }
};",1002
1001,"class Solution {
 public:
  bool isValid(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == 'c') {
        if (stack.size() < 2)
          return false;
        if (stack.top() != 'b')
          return false;
        stack.pop();
        if (stack.top() != 'a')
          return false;
        stack.pop();
      } else {
        stack.push(c);
      }

    return stack.empty();
  }
};",1003
1002,"class Solution {
 public:
  int longestOnes(vector<int>& nums, int k) {
    int ans = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        --k;
      while (k < 0)
        if (nums[l++] == 0)
          ++k;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",1004
1003,"class Solution {
 public:
  int largestSumAfterKNegations(vector<int>& nums, int k) {
    ranges::sort(nums);

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > 0 || k == 0)
        break;
      nums[i] = -nums[i];
      --k;
    }

    return accumulate(nums.begin(), nums.end(), 0) -
           (k % 2) * ranges::min(nums) * 2;
  }
};",1005
1004,"class Solution {
 public:
  int clumsy(int n) {
    if (n == 1)
      return 1;
    if (n == 2)
      return 2;
    if (n == 3)
      return 6;
    if (n == 4)
      return 7;
    if (n % 4 == 1)
      return n + 2;
    if (n % 4 == 2)
      return n + 2;
    if (n % 4 == 3)
      return n - 1;
    return n + 1;
  }
};",1006
1005,"class Solution {
 public:
  int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {
    const int n = tops.size();
    vector<int> countTops(7);
    vector<int> countBottoms(7);
    vector<int> countBoth(7);

    for (int i = 0; i < n; ++i) {
      ++countTops[tops[i]];
      ++countBottoms[bottoms[i]];
      if (tops[i] == bottoms[i])
        ++countBoth[tops[i]];
    }

    for (int i = 1; i <= 6; ++i)
      if (countTops[i] + countBottoms[i] - countBoth[i] == n)
        return n - max(countTops[i], countBottoms[i]);

    return -1;
  }
};",1007
1006,"class Solution {
 public:
  TreeNode* bstFromPreorder(vector<int>& preorder) {
    TreeNode* root = new TreeNode(preorder[0]);
    stack<TreeNode*> stack{{root}};

    for (int i = 1; i < preorder.size(); ++i) {
      TreeNode* parent = stack.top();
      TreeNode* child = new TreeNode(preorder[i]);
      // Adjust the parent.
      while (!stack.empty() && stack.top()->val < child->val)
        parent = stack.top(), stack.pop();
      // Create parent-child link according to BST property.
      if (parent->val > child->val)
        parent->left = child;
      else
        parent->right = child;
      stack.push(child);
    }

    return root;
  }
};",1008
1007,"class Solution {
 public:
  int bitwiseComplement(int n) {
    int mask = 1;
    while (mask < n)
      mask = (mask << 1) + 1;
    return mask ^ n;
  }
};",1009
1008,"class Solution {
 public:
  int numPairsDivisibleBy60(vector<int>& time) {
    int ans = 0;
    vector<int> count(60);

    for (int t : time) {
      t %= 60;
      ans += count[(60 - t) % 60];
      ++count[t];
    }

    return ans;
  }
};",1010
1009,"class Solution {
 public:
  int shipWithinDays(vector<int>& weights, int days) {
    int l = ranges::max(weights);
    int r = accumulate(weights.begin(), weights.end(), 0);

    while (l < r) {
      const int m = (l + r) / 2;
      if (shipDays(weights, m) <= days)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int shipDays(const vector<int>& weights, int shipCapacity) {
    int days = 1;
    int capacity = 0;
    for (const int weight : weights)
      if (capacity + weight > shipCapacity) {
        ++days;
        capacity = weight;
      } else {
        capacity += weight;
      }
    return days;
  };
};",1011
1010,"class Solution {
 public:
  int numDupDigitsAtMostN(int n) {
    return n - countSpecialNumbers(n);
  }

 private:
  // Same as 2376. Count Special Integers
  int countSpecialNumbers(int n) {
    const int digitSize = log10(n) + 1;
    vector<vector<vector<int>>> mem(
        digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));
    return count(to_string(n), 0, 0, true, mem) - 1;  // - 0;
  }

 private:
  // Returns the number of special integers, considering the i-th digit, where
  // `used` is the bitmask of the used digits, and `isTight` indicates if the
  // current digit is tightly bound.
  int count(const string& s, int i, int used, bool isTight,
            vector<vector<vector<int>>>& mem) {
    if (i == s.length())
      return 1;
    if (mem[i][used][isTight] != -1)
      return mem[i][used][isTight];

    int res = 0;

    const int maxDigit = isTight ? s[i] - '0' : 9;
    for (int d = 0; d <= maxDigit; ++d) {
      // `d` is used.
      if (used >> d & 1)
        continue;
      // Use `d` now.
      const bool nextIsTight = isTight && (d == maxDigit);
      if (used == 0 && d == 0)  // Don't count leading 0s as used.
        res += count(s, i + 1, used, nextIsTight, mem);
      else
        res += count(s, i + 1, used | 1 << d, nextIsTight, mem);
    }

    return mem[i][used][isTight] = res;
  }
};",1012
1011,"class Solution {
 public:
  bool canThreePartsEqualSum(vector<int>& arr) {
    const int sum = accumulate(arr.begin(), arr.end(), 0);
    if (sum % 3 != 0)
      return false;

    const int average = sum / 3;
    int partCount = 0;
    int partSum = 0;

    for (const int a : arr) {
      partSum += a;
      if (partSum == average) {
        ++partCount;
        partSum = 0;
      }
    }

    // edge case: arr = [0, 0, 0, 0] -> partCount = 4.
    return partCount >= 3;
  }
};",1013
1012,"class Solution {
 public:
  int maxScoreSightseeingPair(vector<int>& values) {
    int ans = 0;
    int bestPrev = 0;

    for (const int value : values) {
      ans = max(ans, value + bestPrev);
      bestPrev = max(bestPrev, value) - 1;
    }

    return ans;
  }
};",1014
1013,"class Solution {
 public:
  int smallestRepunitDivByK(int k) {
    if (k % 10 != 1 && k % 10 != 3 && k % 10 != 7 && k % 10 != 9)
      return -1;

    unordered_set<int> seen;
    int n = 0;

    for (int length = 1; length <= k; ++length) {
      n = (n * 10 + 1) % k;
      if (n == 0)
        return length;
      if (seen.count(n))
        return -1;
      seen.insert(n);
    }

    return -1;
  }
};",1015
1014,"class Solution {
 public:
  bool queryString(string s, int n) {
    if (n > 1511)
      return false;

    for (int i = n; i > n / 2; --i) {
      string binary = bitset<32>(i).to_string();
      binary = binary.substr(binary.find(""1""));
      if (s.find(binary) == string::npos)
        return false;
    }

    return true;
  }
};",1016
1015,"class Solution {
 public:
  string baseNeg2(int n) {
    string ans;

    while (n != 0) {
      ans += to_string(n & 1);
      n = -(n >> 1);
    }

    return ans.empty() ? ""0"" : string{ans.rbegin(), ans.rend()};
  }
};",1017
1016,"class Solution {
 public:
  vector<bool> prefixesDivBy5(vector<int>& nums) {
    vector<bool> ans;
    int curr = 0;

    for (const int num : nums) {
      curr = (curr * 2 + num) % 5;
      ans.push_back(curr % 5 == 0);
    }

    return ans;
  }
};",1018
1017,"class Solution {
 public:
  vector<int> nextLargerNodes(ListNode* head) {
    vector<int> ans;
    stack<int> stack;

    for (; head; head = head->next) {
      while (!stack.empty() && head->val > ans[stack.top()]) {
        int index = stack.top();
        stack.pop();
        ans[index] = head->val;
      }
      stack.push(ans.size());
      ans.push_back(head->val);
    }

    for (; !stack.empty(); stack.pop())
      ans[stack.top()] = 0;

    return ans;
  }
};",1019
1018,"class Solution {
 public:
  int numEnclaves(vector<vector<int>>& A) {
    const int m = A.size();
    const int n = A[0].size();

    // Remove the lands connected to the edge.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (A[i][j] == 1)
            dfs(A, i, j);

    return accumulate(A.begin(), A.end(), 0, [](int s, vector<int>& row) {
      return s + accumulate(row.begin(), row.end(), 0);
    });
  }

 private:
  void dfs(vector<vector<int>>& A, int i, int j) {
    if (i < 0 || i == A.size() || j < 0 || j == A[0].size())
      return;
    if (A[i][j] == 0)
      return;

    A[i][j] = 0;
    dfs(A, i + 1, j);
    dfs(A, i - 1, j);
    dfs(A, i, j + 1);
    dfs(A, i, j - 1);
  };
};",1020
1019,"class Solution {
 public:
  string removeOuterParentheses(string s) {
    string ans;
    int opened = 0;

    for (const char c : s)
      if (c == '(') {
        if (++opened > 1)
          ans += c;
      } else if (--opened > 0) {  // c == ')'
        ans += c;
      }

    return ans;
  }
};",1021
1020,"class Solution {
 public:
  int sumRootToLeaf(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int val, int& ans) {
    if (root == nullptr)
      return;
    val = val * 2 + root->val;
    if (root->left == nullptr && root->right == nullptr)
      ans += val;
    dfs(root->left, val, ans);
    dfs(root->right, val, ans);
  }
};",1022
1021,"class Solution {
 public:
  vector<bool> camelMatch(vector<string>& queries, string pattern) {
    vector<bool> ans;
    for (const string& query : queries)
      ans.push_back(isMatch(query, pattern));
    return ans;
  }

 private:
  bool isMatch(const string& query, const string& pattern) {
    int j = 0;
    for (const char c : query)
      if (j < pattern.length() && c == pattern[j])
        ++j;
      else if (isupper(c))
        return false;
    return j == pattern.length();
  }
};",1023
1022,"class Solution {
 public:
  int videoStitching(vector<vector<int>>& clips, int time) {
    int ans = 0;
    int end = 0;
    int farthest = 0;

    sort(std::clips.begin(), std::end(clips));

    int i = 0;
    while (farthest < time) {
      while (i < clips.size() && clips[i][0] <= end)
        farthest = max(farthest, clips[i++][1]);
      if (end == farthest)
        return -1;
      ++ans;
      end = farthest;
    }

    return ans;
  }
};",1024
1023,"class Solution {
 public:
  bool divisorGame(int n) {
    return n % 2 == 0;
  }
};",1025
1024,"class Solution {
 public:
  int maxAncestorDiff(TreeNode* root) {
    return maxAncestorDiff(root, root->val, root->val);
  }

 private:
  // Returns |the maximum - the minimum| of the tree.
  int maxAncestorDiff(TreeNode* root, int mini, int maxi) {
    if (root == nullptr)
      return 0;
    mini = min(mini, root->val);
    maxi = max(maxi, root->val);
    const int l = maxAncestorDiff(root->left, mini, maxi);
    const int r = maxAncestorDiff(root->right, mini, maxi);
    return max({maxi - mini, l, r});
  }
};",1026
1025,"class Solution {
 public:
  int longestArithSeqLength(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][k] := the length of the longest arithmetic subsequence of
    // nums[0..i] with k = diff + 500
    vector<vector<int>> dp(n, vector<int>(1001));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const int k = nums[i] - nums[j] + 500;
        dp[i][k] = max(2, dp[j][k] + 1);
        ans = max(ans, dp[i][k]);
      }

    return ans;
  }
};",1027
1026,"class Solution {
 public:
  TreeNode* recoverFromPreorder(string traversal) {
    int i = 0;
    return recoverFromPreorder(traversal, 0, i);
  }

 private:
  TreeNode* recoverFromPreorder(const string& traversal, int depth, int& i) {
    int nDashes = 0;
    while (i + nDashes < traversal.length() && traversal[i + nDashes] == '-')
      ++nDashes;
    if (nDashes != depth)
      return nullptr;

    i += depth;
    const int start = i;
    while (i < traversal.length() && isdigit(traversal[i]))
      ++i;

    return new TreeNode(stoi(traversal.substr(start, i - start)),
                        recoverFromPreorder(traversal, depth + 1, i),
                        recoverFromPreorder(traversal, depth + 1, i));
  }
};",1028
1027,"class Solution {
 public:
  int twoCitySchedCost(vector<vector<int>>& costs) {
    const int n = costs.size() / 2;
    int ans = 0;

    // How much money can we save if we fly a person to A instead of B?
    // To save money, we should
    //   1. Fly the person with the maximum saving to A.
    //   2. Fly the person with the minimum saving to B.
    ranges::sort(costs, [](const vector<int>& a, const vector<int>& b) {
      // Sort `costs` in descending order by the money saved if we fly a person
      // to A instead of B.
      return a[1] - a[0] > b[1] - b[0];
    });

    for (int i = 0; i < n; ++i)
      ans += costs[i][0] + costs[i + n][1];

    return ans;
  }
};",1029
1028,"class Solution {
 public:
  vector<vector<int>> allCellsDistOrder(int rows, int cols, int rCenter,
                                        int cCenter) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    vector<vector<int>> ans;
    vector<vector<int>> seen(rows, vector<int>(cols));
    queue<pair<int, int>> q{{{rCenter, cCenter}}};
    seen[rCenter][cCenter] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      ans.push_back({i, j});
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == rows || y < 0 || y == cols)
          continue;
        if (seen[x][y])
          continue;
        seen[x][y] = true;
        q.emplace(x, y);
      }
    }

    return ans;
  }
};",1030
1029,"class Solution {
 public:
  int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {
    return max(helper(nums, firstLen, secondLen),
               helper(nums, secondLen, firstLen));
  }

 private:
  int helper(vector<int>& A, int l, int r) {
    const int n = A.size();
    vector<int> left(n);
    int sum = 0;

    for (int i = 0; i < n; ++i) {
      sum += A[i];
      if (i >= l)
        sum -= A[i - l];
      if (i >= l - 1)
        left[i] = i > 0 ? max(left[i - 1], sum) : sum;
    }

    vector<int> right(n);
    sum = 0;

    for (int i = n - 1; i >= 0; --i) {
      sum += A[i];
      if (i <= n - r - 1)
        sum -= A[i + r];
      if (i <= n - r)
        right[i] = i < n - 1 ? max(right[i + 1], sum) : sum;
    }

    int ans = 0;

    for (int i = 0; i < n - 1; ++i)
      ans = max(ans, left[i] + right[i + 1]);

    return ans;
  }
};",1031
1030,query(letter: chr),1032
1031,"class Solution {
 public:
  vector<int> numMovesStones(int a, int b, int c) {
    vector<int> nums = {a, b, c};

    ranges::sort(nums);

    if (nums[2] - nums[0] == 2)
      return {0, 0};
    return {min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 ? 1 : 2,
            nums[2] - nums[0] - 2};
  }
};",1033
1032,"class Solution {
 public:
  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,
                                  int color) {
    dfs(grid, r0, c0, grid[r0][c0]);

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] < 0)
          grid[i][j] = color;

    return grid;
  }

 private:
  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] != startColor)
      return;

    grid[i][j] = -startColor;
    dfs(grid, i + 1, j, startColor);
    dfs(grid, i - 1, j, startColor);
    dfs(grid, i, j + 1, startColor);
    dfs(grid, i, j - 1, startColor);

    // If this cell is already on the boarder, it must be painted later.
    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)
      return;

    if (abs(grid[i + 1][j]) == startColor &&  //
        abs(grid[i - 1][j]) == startColor &&  //
        abs(grid[i][j + 1]) == startColor &&  //
        abs(grid[i][j - 1]) == startColor)
      grid[i][j] = startColor;
  }
};",1034
1033,"class Solution {
 public:
  int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        dp[i][j] = nums1[i - 1] == nums2[j - 1]
                       ? dp[i - 1][j - 1] + 1
                       : max(dp[i - 1][j], dp[i][j - 1]);

    return dp[m][n];
  }
};",1035
1034,"class Solution {
 public:
  bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source,
                        vector<int>& target) {
    unordered_set<long> blockedSet;
    for (const vector<int>& b : blocked)
      blockedSet.insert(hash(b[0], b[1]));

    return dfs(blockedSet, source[0], source[1], hash(target[0], target[1]),
               {}) &&
           dfs(blockedSet, target[0], target[1], hash(source[0], source[1]),
               {});
  }

 private:
  bool dfs(unordered_set<long>& blockedSet, int i, int j, long target,
           unordered_set<long>&& visited) {
    if (i < 0 || i >= 1e6 || j < 0 || j >= 1e6 ||
        blockedSet.count(hash(i, j)) || visited.count(hash(i, j)))
      return false;

    visited.insert(hash(i, j));
    if (visited.size() > (1 + 199) * 199 / 2 || hash(i, j) == target)
      return true;
    return dfs(blockedSet, i + 1, j, target, move(visited)) ||
           dfs(blockedSet, i - 1, j, target, move(visited)) ||
           dfs(blockedSet, i, j + 1, target, move(visited)) ||
           dfs(blockedSet, i, j - 1, target, move(visited));
  }

  long hash(int i, int j) {
    return (static_cast<long>(i) << 16) + j;
  }
};",1036
1035,"class Solution {
 public:
  bool isBoomerang(vector<vector<int>>& points) {
    return (points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=
           (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]);
  }
};",1037
1036,"class Solution {
 public:
  TreeNode* bstToGst(TreeNode* root) {
    int prefix = 0;

    function<void(TreeNode*)> reversedInorder = [&](TreeNode* root) {
      if (root == nullptr)
        return;

      reversedInorder(root->right);

      root->val += prefix;
      prefix = root->val;

      reversedInorder(root->left);
    };

    reversedInorder(root);
    return root;
  }
};",1038
1037,"class Solution {
 public:
  int minScoreTriangulation(vector<int>& values) {
    const int n = values.size();
    vector<vector<int>> dp(n, vector<int>(n));

    for (int j = 2; j < n; ++j)
      for (int i = j - 2; i >= 0; --i) {
        dp[i][j] = INT_MAX;
        for (int k = i + 1; k < j; ++k)
          dp[i][j] =
              min(dp[i][j],
                  dp[i][k] + values[i] * values[k] * values[j] + dp[k][j]);
      }

    return dp[0][n - 1];
  }
};",1039
1038,"class Solution {
 public:
  vector<int> numMovesStonesII(vector<int>& stones) {
    const int n = stones.size();
    int minMoves = n;

    ranges::sort(stones);

    for (int l = 0, r = 0; r < n; ++r) {
      while (stones[r] - stones[l] + 1 > n)
        ++l;
      int alreadyStored = r - l + 1;
      if (alreadyStored == n - 1 && stones[r] - stones[l] + 1 == n - 1)
        minMoves = min(minMoves, 2);
      else
        minMoves = min(minMoves, n - alreadyStored);
    }

    return {minMoves, max(stones[n - 1] - stones[1] - n + 2,
                          stones[n - 2] - stones[0] - n + 2)};
  }
};",1040
1039,"class Solution {
 public:
  bool isRobotBounded(string instructions) {
    int x = 0;
    int y = 0;
    int d = 0;
    vector<vector<int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    for (char instruction : instructions) {
      if (instruction == 'G') {
        x += directions[d][0];
        y += directions[d][1];
      } else if (instruction == 'L')
        d = (d + 3) % 4;
      else
        d = (d + 1) % 4;
    }

    return x == 0 && y == 0 || d > 0;
  }
};",1041
1040,"class Solution {
 public:
  vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {
    vector<int> ans(n);  // ans[i] := 1, 2, 3, or 4
    vector<vector<int>> graph(n);

    for (const vector<int>& p : paths) {
      const int u = p[0] - 1;
      const int v = p[1] - 1;
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i) {
      vector<bool> used(5);
      for (const int v : graph[i])
        used[ans[v]] = true;
      for (int type = 1; type < 5; ++type)
        if (!used[type]) {
          ans[i] = type;
          break;
        }
    }

    return ans;
  }
};",1042
1041,"class Solution {
 public:
  int maxSumAfterPartitioning(vector<int>& arr, int k) {
    const int n = arr.size();
    vector<int> dp(n + 1);

    for (int i = 1; i <= n; ++i) {
      int maxi = INT_MIN;
      for (int j = 1; j <= min(i, k); ++j) {
        maxi = max(maxi, arr[i - j]);
        dp[i] = max(dp[i], dp[i - j] + maxi * j);
      }
    }

    return dp[n];
  }
};",1043
1042,"class Solution {
 public:
  string longestDupSubstring(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    vector<int> pows(n, 1);
    int bestStart = -1;
    int l = 1;
    int r = n;

    for (int i = 1; i < n; ++i)
      pows[i] = (pows[i - 1] * 26L) % kMod;

    while (l < r) {
      const int m = (l + r) / 2;
      const int start = getStart(s, m, pows, kMod);
      if (start == -1) {
        r = m;
      } else {
        bestStart = start;
        l = m + 1;
      }
    }

    if (bestStart == -1)
      return """";
    if (getStart(s, l, pows, kMod) == -1)
      return s.substr(bestStart, l - 1);
    return s.substr(bestStart, l);
  }

 private:
  // k := the length of the substring to be hashed
  int getStart(const string& s, int k, const vector<int>& pows,
               const int& kMod) {
    unordered_map<int, vector<int>> hashToStarts;
    long h = 0;

    // Compute the hash value of s[:k].
    for (int i = 0; i < k; ++i)
      h = ((h * 26) % kMod + val(s[i])) % kMod;
    hashToStarts[h].push_back(0);

    // Compute the rolling hash by Rabin Karp.
    for (int i = k; i < s.length(); ++i) {
      const int startIndex = i - k + 1;
      h = ((h - static_cast<long>(pows[k - 1]) * val(s[i - k])) % kMod + kMod) %
          kMod;
      h = (h * 26 + val(s[i])) % kMod;
      if (const auto it = hashToStarts.find(h); it != hashToStarts.cend()) {
        const string currSub = s.substr(startIndex, k);
        for (const int start : it->second)
          if (s.substr(start, k) == currSub)
            return startIndex;
      }
      hashToStarts[h].push_back(startIndex);
    }

    return -1;
  }

  constexpr int val(char c) {
    return c - 'a';
  }
};",1044
1043,"SELECT customer_id
FROM Customer
GROUP BY 1
HAVING COUNT(DISTINCT product_key) = (
    SELECT COUNT(*) FROM Product
  );",1045
1044,"class Solution {
 public:
  int lastStoneWeight(vector<int>& stones) {
    priority_queue<int> pq{stones.begin(), stones.end()};

    while (pq.size() >= 2) {
      const int n1 = pq.top();
      pq.pop();
      const int n2 = pq.top();
      pq.pop();
      if (n1 != n2)
        pq.push(n1 - n2);
    }

    return pq.empty() ? 0 : pq.top();
  }
};",1046
1045,"class Solution {
 public:
  string removeDuplicates(const string& S) {
    string ans;

    for (const char c : S)
      if (!ans.empty() && ans.back() == c)
        ans.pop_back();
      else
        ans.push_back(c);

    return ans;
  }
};",1047
1046,"class Solution {
 public:
  int longestStrChain(vector<string>& words) {
    const unordered_set<string> wordsSet{words.begin(), words.end()};
    unordered_map<string, int> mem;
    return accumulate(words.begin(), words.end(), 0,
                      [&](int acc, const string& word) {
      return max(acc, longestStrChain(word, wordsSet, mem));
    });
  }

 private:
  // Returns the longest string chain, where s is the last word.
  int longestStrChain(const string& s, const unordered_set<string>& wordsSet,
                      unordered_map<string, int>& mem) {
    if (const auto it = mem.find(s); it != mem.cend())
      return it->second;

    int res = 1;

    for (int i = 0; i < s.length(); ++i) {
      const string pred = s.substr(0, i) + s.substr(i + 1);
      if (wordsSet.count(pred))
        res = max(res, longestStrChain(pred, wordsSet, mem) + 1);
    }

    return mem[s] = res;
  }
};",1048
1047,"class Solution {
 public:
  int lastStoneWeightII(vector<int>& stones) {
    const int sum = accumulate(stones.begin(), stones.end(), 0);
    vector<bool> dp(sum + 1);
    dp[0] = true;
    int s = 0;

    for (int stone : stones)
      for (int w = sum / 2; w > 0; --w) {
        if (w >= stone)
          dp[w] = dp[w] || dp[w - stone];
        if (dp[w])
          s = max(s, w);
      }

    return sum - 2 * s;
  }
};",1049
1048,"SELECT actor_id, director_id
FROM ActorDirector
GROUP BY 1, 2
HAVING COUNT(*) >= 3;",1050
1049,"class Solution {
 public:
  int heightChecker(vector<int>& heights) {
    int ans = 0;
    int currentHeight = 1;
    vector<int> count(101);

    for (int height : heights)
      ++count[height];

    for (int height : heights) {
      while (count[currentHeight] == 0)
        ++currentHeight;
      if (height != currentHeight)
        ++ans;
      --count[currentHeight];
    }

    return ans;
  }
};",1051
1050,"class Solution {
 public:
  int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {
    int satisfied = 0;
    int madeSatisfied = 0;
    int windowSatisfied = 0;

    for (int i = 0; i < customers.size(); ++i) {
      if (grumpy[i] == 0)
        satisfied += customers[i];
      else
        windowSatisfied += customers[i];
      if (i >= X && grumpy[i - X] == 1)
        windowSatisfied -= customers[i - X];
      madeSatisfied = max(madeSatisfied, windowSatisfied);
    }

    return satisfied + madeSatisfied;
  }
};",1052
1051,"class Solution {
 public:
  vector<int> prevPermOpt1(vector<int>& arr) {
    const int n = arr.size();
    int l = n - 2;
    int r = n - 1;

    while (l >= 0 && arr[l] <= arr[l + 1])
      l--;
    if (l < 0)
      return arr;
    while (arr[r] >= arr[l] || arr[r] == arr[r - 1])
      r--;
    swap(arr[l], arr[r]);

    return arr;
  }
};",1053
1052,"class Solution {
 public:
  vector<int> rearrangeBarcodes(vector<int>& barcodes) {
    vector<int> ans(barcodes.size());
    vector<int> count(10001);
    int i = 0;  // ans' index

    for (const int b : barcodes)
      ++count[b];

    const auto maxIt = ranges::max_element(count);
    const int maxNum = maxIt - count.begin();

    auto fillAns = [&](int num) {
      while (count[num]-- > 0) {
        ans[i] = num;
        i = i + 2 < barcodes.size() ? i + 2 : 1;
      }
    };

    fillAns(maxNum);
    for (int num = 1; num < 10001; ++num)
      fillAns(num);

    return ans;
  }
};",1054
1053,"class Solution {
 public:
  int shortestWay(string source, string target) {
    int ans = 0;

    for (int i = 0; i < target.length();) {
      const int prevIndex = i;
      for (int j = 0; j < source.length(); ++j)
        if (i < target.length() && source[j] == target[i])
          ++i;
      // All chars in source didn't match target[i]
      if (i == prevIndex)
        return -1;
      ++ans;
    }

    return ans;
  }
};",1055
1054,"class Solution {
 public:
  bool confusingNumber(int n) {
    const string s = to_string(n);
    const vector<char> rotated{'0', '1', 'x', 'x', 'x',
                               'x', '9', 'x', '8', '6'};
    string rotatedNum;

    for (int i = s.length() - 1; i >= 0; --i) {
      if (rotated[s[i] - '0'] == 'x')
        return false;
      rotatedNum += rotated[s[i] - '0'];
    }

    return rotatedNum != s;
  }
};",1056
1055,"class Solution {
 public:
  vector<int> assignBikes(vector<vector<int>>& workers,
                          vector<vector<int>>& bikes) {
    const int n = workers.size();
    const int m = bikes.size();
    vector<int> ans(n, -1);
    vector<bool> usedBikes(m);
    // buckets[k] := (i, j), where k = dist(workers[i], bikes[j])
    vector<vector<pair<int, int>>> buckets(2001);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < m; ++j)
        buckets[dist(workers[i], bikes[j])].emplace_back(i, j);

    for (int k = 0; k < 2001; ++k)
      for (const auto& [i, j] : buckets[k])
        if (ans[i] == -1 && !usedBikes[j]) {
          ans[i] = j;
          usedBikes[j] = true;
        }

    return ans;
  }

 private:
  int dist(const vector<int>& p1, const vector<int>& p2) {
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);
  }
};",1057
1056,"class Solution {
 public:
  string minimizeError(vector<string>& prices, int target) {
    // A[i] := (costCeil - costFloor, costCeil, costFloor)
    // The lower the costCeil - costFloor is, the cheaper to ceil it.
    vector<tuple<double, double, double>> A;
    int sumFloored = 0;
    int sumCeiled = 0;

    for (const string& p : prices) {
      const double price = stod(p);
      const int floored = floor(price);
      const int ceiled = ceil(price);
      sumFloored += floored;
      sumCeiled += ceiled;
      const double costFloor = price - static_cast<double>(floored);
      const double costCeil = static_cast<double>(ceiled) - price;
      A.emplace_back(costCeil - costFloor, costCeil, costFloor);
    }

    if (sumFloored > target || sumCeiled < target)
      return ""-1"";

    ranges::sort(A);

    double sumError = 0.0;
    const int nCeiled = target - sumFloored;
    for (int i = 0; i < nCeiled; ++i)
      sumError += get<1>(A[i]);
    for (int i = nCeiled; i < A.size(); ++i)
      sumError += get<2>(A[i]);

    stringstream ss;
    ss << std::fixed << std::setprecision(3) << sumError;
    return ss.str();
  }
};",1058
1057,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool leadsToDestination(int n, vector<vector<int>>& edges, int source,
                          int destination) {
    vector<vector<int>> graph(n);
    vector<State> states(n);

    for (const vector<int>& edge : edges)
      graph[e[0]].push_back(e[1]);

    return acyclic(graph, source, destination, states);
  }

 private:
  bool acyclic(const vector<vector<int>>& graph, int u, int dest,
               vector<State>& states) {
    if (graph[u].empty())
      return u == dest;
    if (states[u] == State::kVisiting)
      return false;
    if (states[u] == State::kVisited)
      return true;

    states[u] = State::kVisiting;
    for (const int v : graph[u])
      if (!acyclic(graph, v, dest, states))
        return false;
    states[u] = State::kVisited;

    return true;
  }
};",1059
1058,"class Solution {
 public:
  int missingElement(vector<int>& nums, int k) {
    int l = 0;
    int r = nums.size();

    // the number of missing numbers in [nums[0], nums[i]]
    auto nMissing = [&](int i) { return nums[i] - nums[0] - i; };

    // Find the first index l s.t. nMissing(l) >= k
    while (l < r) {
      const int m = (l + r) / 2;
      if (nMissing(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return nums[l - 1] + (k - nMissing(l - 1));
  }
};",1060
1059,"class UnionFind {
 public:
  UnionFind(int n) : id(n) {
    iota(id.begin(), id.end(), 0);
  }

  void union_(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i > j)
      id[i] = j;
    else
      id[j] = i;
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
};

class Solution {
 public:
  string smallestEquivalentString(string s1, string s2, string baseStr) {
    string ans;
    UnionFind uf(26);

    for (int i = 0; i < s1.length(); ++i)
      uf.union_(s1[i] - 'a', s2[i] - 'a');

    for (const char c : baseStr)
      ans += 'a' + uf.find(c - 'a');

    return ans;
  }
};",1061
1060,"class Solution {
 public:
  int longestRepeatingSubstring(string s) {
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    for (int i = 1; i <= n; ++i)
      for (int j = i + 1; j <= n; ++j)
        if (s[i - 1] == s[j - 1]) {
          dp[i][j] = 1 + dp[i - 1][j - 1];
          ans = max(ans, dp[i][j]);
        }

    return ans;
  }
};",1062
1061,"class Solution {
 public:
  int validSubarrays(vector<int>& nums) {
    // For each `num` in `nums`, each element x in the stack can be the leftmost
    // element s.t. [x, num] forms a valid subarray, so the size of the stack is
    // the number of valid subarrays ending in the current number.
    //
    // e.g. nums = [1, 3, 2]
    // num = 1, stack = [1] -> valid subarray is [1]
    // num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]
    // num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]
    int ans = 0;
    stack<int> stack;

    for (const int num : nums) {
      while (!stack.empty() && stack.top() > num)
        stack.pop();
      stack.push(num);
      ans += stack.size();
    }

    return ans;
  }
};",1063
1062,"class Solution {
 public:
  int fixedPoint(vector<int>& arr) {
    int l = 0;
    int r = arr.size() - 1;

    // Since arr[i] is strictly increasing, arr[i] - i will also be increasing.
    // Therefore, binary search `arr` for the first arr[i] - i = 0.
    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] - m >= 0)
        r = m;
      else
        l = m + 1;
    }

    return arr[l] == l ? l : -1;
  }
};",1064
1063,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<vector<int>> indexPairs(string text, vector<string>& words) {
    vector<vector<int>> ans;
    shared_ptr<TrieNode> root = make_shared<TrieNode>();

    for (const string& word : words) {
      shared_ptr<TrieNode> node = root;
      for (const char c : word) {
        const int i = c - 'a';
        if (node->children[i] == nullptr)
          node->children[i] = make_shared<TrieNode>();
        node = node->children[i];
      }
      node->isWord = true;
    }

    for (int i = 0; i < text.length(); ++i) {
      shared_ptr<TrieNode> node = root;
      for (int j = i; j < text.length(); j++) {
        const int index = text[j] - 'a';
        if (node->children[index] == nullptr)
          break;
        node = node->children[index];
        if (node->isWord)
          ans.push_back({i, j});
      }
    }

    return ans;
  }
};",1065
1064,"class Solution {
 public:
  int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
    vector<int> mem(1 << bikes.size(), INT_MAX);
    return assignBikes(workers, bikes, 0, 0, mem);
  }

 private:
  // Returns the minimum Manhattan distances to assign bikes to
  // workers[workerIndex..n), where `used` is the bitmask of the used bikes.
  int assignBikes(const vector<vector<int>>& workers,
                  const vector<vector<int>>& bikes, int workerIndex, int used,
                  vector<int>& mem) {
    if (workerIndex == workers.size())
      return 0;
    if (mem[used] != INT_MAX)
      return mem[used];

    for (int bikeIndex = 0; bikeIndex < bikes.size(); ++bikeIndex)
      if ((used & 1 << bikeIndex) == 0)
        mem[used] =
            min(mem[used], dist(workers[workerIndex], bikes[bikeIndex]) +
                               assignBikes(workers, bikes, workerIndex + 1,
                                           used | 1 << bikeIndex, mem));

    return mem[used];
  }

  int dist(const vector<int>& p1, const vector<int>& p2) {
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);
  }
};",1066
1065,"class Solution {
 public:
  int digitsCount(int d, int low, int high) {
    return countDigit(high, d) - countDigit(low - 1, d);
  }

 private:
  int countDigit(int n, int d) {
    int count = 0;

    for (int pow10 = 1; pow10 <= n; pow10 *= 10) {
      const int divisor = pow10 * 10;
      const int quotient = n / divisor;
      const int remainder = n % divisor;
      if (quotient > 0)
        count += quotient * pow10;
      if (d == 0)
        count -= pow10;
      if (remainder >= d * pow10)
        count += min(remainder - d * pow10 + 1, pow10);
    }

    return count;
  }
};",1067
1066,"SELECT
  Product.product_name,
  Sales.year,
  Sales.price
FROM Sales
INNER JOIN Product
  USING (product_id);",1068
1067,"SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales
GROUP BY 1;",1069
1068,"WITH
  ProductToYear AS (
    SELECT product_id, MIN(year) AS year
    FROM Sales
    GROUP BY 1
  )
SELECT
  Sales.product_id,
  ProductToYear.year AS first_year,
  Sales.quantity,
  Sales.price
FROM Sales
INNER JOIN ProductToYear
  USING (product_id, year);",1070
1069,"class Solution {
 public:
  string gcdOfStrings(string str1, string str2) {
    if (str1.length() < str2.length())
      return gcdOfStrings(str2, str1);
    if (str1.find(str2) == string::npos)
      return """";
    if (str2.empty())
      return str1;
    return gcdOfStrings(str2, mod(str1, str2));
  }

 private:
  string mod(string& s1, const string& s2) {
    while (s1.find(s2) == 0)
      s1 = s1.substr(s2.length());
    return s1;
  }
};",1071
1070,"class Solution {
 public:
  int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;
    vector<int> flip(n);
    unordered_set<int> seen;

    for (int i = 0; i < m; ++i) {
      if (seen.count(i))
        continue;
      int count = 0;
      for (int j = 0; j < n; ++j)
        flip[j] = 1 ^ matrix[i][j];
      for (int k = 0; k < m; ++k)
        if (matrix[k] == matrix[i] || matrix[k] == flip) {
          seen.insert(k);
          ++count;
        }
      ans = max(ans, count);
    }

    return ans;
  }
};",1072
1071,"class Solution {
 public:
  vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
    deque<int> ans;
    int carry = 0;
    int i = arr1.size() - 1;
    int j = arr2.size() - 1;

    while (carry || i >= 0 || j >= 0) {
      if (i >= 0)
        carry += arr1[i--];
      if (j >= 0)
        carry += arr2[j--];
      ans.push_front(carry & 1);
      carry = -(carry >> 1);
    }

    while (ans.size() > 1 && ans.front() == 0)
      ans.pop_front();

    return {ans.begin(), ans.end()};
  }
};",1073
1072,"class Solution {
 public:
  int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;

    // Transfer each row in the matrix to the prefix sum.
    for (auto& row : matrix)
      for (int i = 1; i < n; ++i)
        row[i] += row[i - 1];

    for (int baseCol = 0; baseCol < n; ++baseCol)
      for (int j = baseCol; j < n; ++j) {
        unordered_map<int, int> prefixCount{{0, 1}};
        int sum = 0;
        for (int i = 0; i < m; ++i) {
          if (baseCol > 0)
            sum -= matrix[i][baseCol - 1];
          sum += matrix[i][j];
          if (const auto it = prefixCount.find(sum - target);
              it != prefixCount.cend())
            ans += it->second;
          ++prefixCount[sum];
        }
      }

    return ans;
  }
};",1074
1073,"SELECT
  Project.project_id,
  ROUND(AVG(Employee.experience_years), 2) AS average_years
FROM Project
INNER JOIN Employee
  USING (employee_id)
GROUP BY 1;",1075
1074,"WITH
  RankedProjects AS (
    SELECT project_id, RANK() OVER(ORDER BY COUNT(*) DESC) AS `rank`
    FROM Project
    GROUP BY 1
  )
SELECT project_id
FROM RankedProjects
WHERE `rank` = 1;",1076
1075,"WITH
  RankedProjectToEmployee AS (
    SELECT
      Project.project_id,
      Project.employee_id,
      RANK() OVER(
        PARTITION BY Project.project_id
        ORDER BY Employee.experience_years DESC
      ) AS `rank`
    FROM Project
    INNER JOIN Employee
      USING (employee_id)
  )
SELECT project_id, employee_id
FROM RankedProjectToEmployee
WHERE `rank` = 1;",1077
1076,"class Solution {
 public:
  vector<string> findOcurrences(string text, string first, string second) {
    vector<string> ans;
    stringstream ss(text);

    for (string prev2, prev, word; ss >> word;) {
      if (prev2 == first && prev == second)
        ans.push_back(word);
      prev2 = prev;
      prev = word;
    }

    return ans;
  }
};",1078
1077,"class Solution {
 public:
  int numTilePossibilities(string tiles) {
    vector<int> count(26);

    for (const char t : tiles)
      ++count[t - 'A'];

    return dfs(count);
  }

 private:
  int dfs(vector<int>& count) {
    int possibleSequences = 0;

    for (int& c : count) {
      if (c == 0)
        continue;
      // Put c in the current position. We only care about the number of
      // possible sequences of letters but don't care about the actual
      // combination.
      --c;
      possibleSequences += 1 + dfs(count);
      ++c;
    }

    return possibleSequences;
  }
};",1079
1078,"class Solution {
 public:
  TreeNode* sufficientSubset(TreeNode* root, int limit) {
    if (root == nullptr)
      return nullptr;
    if (root->left == nullptr && root->right == nullptr)
      return root->val < limit ? nullptr : root;
    root->left = sufficientSubset(root->left, limit - root->val);
    root->right = sufficientSubset(root->right, limit - root->val);
    return root->left == nullptr && root->right == nullptr ? nullptr : root;
  }
};",1080
1079,"class Solution {
 public:
  string smallestSubsequence(string text) {
    string ans;
    vector<int> count(128);
    vector<bool> used(128);

    for (const char c : text)
      ++count[c];

    for (const char c : text) {
      --count[c];
      if (used[c])
        continue;
      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {
        used[ans.back()] = false;
        ans.pop_back();
      }
      used[c] = true;
      ans.push_back(c);
    }

    return ans;
  }
};",1081
1080,"WITH
  SellerToPrice AS (
    SELECT seller_id, SUM(price) AS price
    FROM Sales
    GROUP BY 1
  )
SELECT seller_id
FROM SellerToPrice
WHERE price = (
    SELECT MAX(price)
    FROM SellerToPrice
  );",1082
1081,"SELECT Sales.buyer_id
FROM Sales
INNER JOIN Product
  USING (product_id)
GROUP BY 1
HAVING
  SUM(Product.product_name = 'S8') > 0
  AND SUM(Product.product_name = 'iPhone') = 0;",1083
1082,"SELECT
  Product.product_id,
  Product.product_name
FROM Product
INNER JOIN Sales
  USING (product_id)
GROUP BY 1, 2
HAVING SUM(
    Sales.sale_date < '2019-01-01'
    OR Sales.sale_date > '2019-03-31'
  ) = 0;",1084
1083,"class Solution {
 public:
  int sumOfDigits(vector<int>& nums) {
    int min = ranges::min(nums);
    int sum = 0;

    while (min > 0) {
      sum += min % 10;
      min /= 10;
    }

    return sum & 1 ^ 1;
  }
};",1085
1084,"class Solution {
 public:
  vector<vector<int>> highFive(vector<vector<int>>& items) {
    vector<vector<int>> ans;
    map<int, priority_queue<int, vector<int>, greater<int>>> idToScores;

    for (const vector<int>& item : items) {
      const int id = item[0];
      const int score = item[1];
      auto& scores = idToScores[id];
      scores.push(score);
      if (scores.size() > 5)
        scores.pop();
    }

    for (auto& [id, scores] : idToScores) {
      int sum = 0;
      while (!scores.empty())
        sum += scores.top(), scores.pop();
      ans.push_back({id, sum / 5});
    }

    return ans;
  }
};",1086
1085,"class Solution {
 public:
  vector<string> expand(string s) {
    vector<string> ans;
    string path;
    dfs(s, 0, path, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int i, string& path, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(path);
      return;
    }
    if (s[i] == '{') {
      const int nextRightBraceIndex = s.find_first_of('}', i);
      for (const char c :
           split(s.substr(i + 1, nextRightBraceIndex - i - 1), ',')) {
        path.push_back(c);
        dfs(s, nextRightBraceIndex + 1, path, ans);
        path.pop_back();
      }
    } else {  // s[i] != '{'
      path.push_back(s[i]);
      dfs(s, i + 1, path, ans);
      path.pop_back();
    }
  }

  vector<char> split(const string& s, char delimiter) {
    vector<char> splitted;
    for (const char c : s)
      if (c != delimiter)
        splitted.push_back(c);
    return splitted;
  }
};",1087
1086,"class Solution {
 public:
  int confusingNumberII(int n) {
    return dfs(n, 0, 0, 1);
  }

 private:
  vector<pair<int, int>> digitToRotated{{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};

  int dfs(int n, long num, long rotatedNum, long unit) {
    int ans = num != rotatedNum;
    // Add one more digit
    for (const auto& [digit, rotated] : digitToRotated) {
      if (digit == 0 && num == 0)
        continue;
      const long nextNum = num * 10 + digit;
      if (nextNum > n)
        break;
      ans += dfs(n, nextNum, rotated * unit + rotatedNum, unit * 10);
    }
    return ans;
  }
};",1088
1087,"class Solution {
 public:
  void duplicateZeros(vector<int>& arr) {
    int zeros = ranges::count_if(arr, [](int a) { return a == 0; });

    for (int i = arr.size() - 1, j = arr.size() + zeros - 1; i < j; --i, --j) {
      if (j < arr.size())
        arr[j] = arr[i];
      if (arr[i] == 0)
        if (--j < arr.size())
          arr[j] = arr[i];
    }
  }
};",1089
1088,"class Solution {
 public:
  int largestValsFromLabels(vector<int>& values, vector<int>& labels,
                            int num_wanted, int use_limit) {
    const int n = values.size();
    int ans = 0;
    vector<pair<int, int>> items;
    unordered_map<int, int> labelsUsed;

    for (int i = 0; i < n; ++i)
      items.emplace_back(values[i], labels[i]);

    ranges::sort(
        items, [](const auto& a, const auto& b) { return a.first > b.first; });

    for (const auto& [value, label] : items) {
      if (labelsUsed[label] < use_limit) {
        ans += value;
        ++labelsUsed[label];
        if (--num_wanted == 0)
          break;
      }
    }

    return ans;
  }
};",1090
1089,"class Solution {
 public:
  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    const int n = grid.size();
    if (grid[0][0] == 0 && n == 1)
      return 1;
    if (grid[0][0] == 1 || grid.back().back() == 1)
      return -1;

    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};

    int ans = 0;
    queue<pair<int, int>> q{{{0, 0}}};
    vector<vector<bool>> seen(n, vector<bool>(n));
    seen[0][0] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == n || y < 0 || y == n)
            continue;
          if (grid[x][y] != 0 || seen[x][y])
            continue;
          if (x == n - 1 && y == n - 1)
            return ans + 1;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return -1;
  }
};",1091
1090,"class Solution {
 public:
  string shortestCommonSupersequence(string str1, string str2) {
    string ans;
    int i = 0;  // str1's index
    int j = 0;  // str2's index

    for (const char c : lcs(str1, str2)) {
      // Append the letters that are not part of the LCS.
      while (str1[i] != c)
        ans += str1[i++];
      while (str2[j] != c)
        ans += str2[j++];
      // Append the letter of the LCS and match it with str1 and str2.
      ans += c;
      ++i;
      ++j;
    }

    // Append the remaining letters.
    return ans + str1.substr(i) + str2.substr(j);
  }

 private:
  string lcs(const string& A, const string& B) {
    const int m = A.length();
    const int n = B.length();
    // dp[i][j] := the length of LCS(A[0..i), B[0..j))
    vector<vector<string>> dp(m + 1, vector<string>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (A[i - 1] == B[j - 1])
          dp[i][j] = dp[i - 1][j - 1] + A[i - 1];
        else
          dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length()
                         ? dp[i - 1][j]
                         : dp[i][j - 1];

    return dp[m][n];
  }
};",1092
1091,"class Solution {
 public:
  vector<double> sampleStats(vector<int>& count) {
    const int n = accumulate(count.begin(), count.end(), 0);
    const double mode = ranges::max_element(count) - count.begin();
    return {
        getMinimum(count),
        getMaximum(count),
        getMean(count, n),
        (getLeftMedian(count, n) + getRightMedian(count, n)) / 2.0,
        mode,
    };
  }

 private:
  double getMinimum(const vector<int>& count) {
    for (int i = 0; i < count.size(); ++i)
      if (count[i])
        return i;
    return -1;
  }

  double getMaximum(const vector<int>& count) {
    for (int i = count.size() - 1; i >= 0; --i)
      if (count[i])
        return i;
    return -1;
  }

  double getMean(const vector<int>& count, double n) {
    double mean = 0;
    for (long i = 0; i < count.size(); ++i)
      mean += (i * count[i]) / n;
    return mean;
  }

  double getLeftMedian(const vector<int>& count, double n) {
    int numCount = 0;
    for (int i = 0; i < count.size(); ++i) {
      numCount += count[i];
      if (numCount >= n / 2)
        return i;
    }
    return -1;
  }

  double getRightMedian(const vector<int>& count, double n) {
    int numCount = 0;
    for (int i = count.size() - 1; i >= 0; --i) {
      numCount += count[i];
      if (numCount >= n / 2)
        return i;
    }
    return -1;
  }
};",1093
1092,"class Solution {
 public:
  bool carPooling(vector<vector<int>>& trips, int capacity) {
    int currentPassengers = 0;
    map<int, int> line;

    for (const vector<int>& trip : trips) {
      const int nPassengers = trip[0];
      const int start = trip[1];
      const int end = trip[2];
      line[start] += nPassengers;
      line[end] -= nPassengers;
    }

    for (const auto [_, passengerChange] : line) {
      currentPassengers += passengerChange;
      if (currentPassengers > capacity)
        return false;
    }

    return true;
  }
};",1094
1093,"/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *  public:
 *   int get(int index);
 *   int length();
 * };
 */

class Solution {
 public:
  int findInMountainArray(int target, MountainArray& mountainArr) {
    const int n = mountainArr.length();
    const int peakIndex = peakIndexInMountainArray(mountainArr, 0, n - 1);

    const int leftIndex = searchLeft(mountainArr, target, 0, peakIndex);
    if (mountainArr.get(leftIndex) == target)
      return leftIndex;

    const int rightIndex =
        searchRight(mountainArr, target, peakIndex + 1, n - 1);
    if (mountainArr.get(rightIndex) == target)
      return rightIndex;

    return -1;
  }

 private:
  // 852. Peak Index in a Mountain Array
  int peakIndexInMountainArray(MountainArray& A, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) < A.get(m + 1))
        l = m + 1;
      else
        r = m;
    }
    return l;
  }

  int searchLeft(MountainArray& A, int target, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) < target)
        l = m + 1;
      else
        r = m;
    }
    return l;
  }

  int searchRight(MountainArray& A, int target, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) > target)
        l = m + 1;
      else
        r = m;
    }
    return l;
  }
};",1095
1094,"class Solution {
 public:
  vector<string> braceExpansionII(string expression) {
    return dfs(expression, 0, expression.length() - 1);
  }

 private:
  vector<string> dfs(const string& expression, int s, int e) {
    set<string> ans;
    vector<vector<string>> groups{{}};
    int layer = 0;
    int left = 0;

    for (int i = s; i <= e; ++i)
      if (expression[i] == '{' && ++layer == 1)
        left = i + 1;
      else if (expression[i] == '}' && --layer == 0)
        merge(groups, dfs(expression, left, i - 1));
      else if (expression[i] == ',' && layer == 0)
        groups.push_back({});
      else if (layer == 0)
        merge(groups, {string(1, expression[i])});

    for (const vector<string>& group : groups)
      for (const string& word : group)
        ans.insert(word);

    return {ans.begin(), ans.end()};
  }

  void merge(vector<vector<string>>& groups, const vector<string> group) {
    if (groups.back().empty()) {
      groups[groups.size() - 1] = group;
      return;
    }

    vector<string> mergedGroup;

    for (auto& word1 : groups.back())
      for (auto& word2 : group)
        mergedGroup.push_back(word1 + word2);

    groups[groups.size() - 1] = mergedGroup;
  }
};",1096
1095,"WITH
  PlayerToInstallDate AS (
    SELECT player_id, MIN(event_date) AS install_dt
    FROM Activity
    GROUP BY 1
  )
SELECT PlayerToInstallDate.install_dt,
  COUNT(*) AS installs,
  ROUND(
    SUM(IF(Activity.event_date, 1, 0)) / COUNT(PlayerToInstallDate.install_dt),
    2
  ) AS Day1_retention
FROM PlayerToInstallDate
LEFT JOIN Activity
  ON (
    PlayerToInstallDate.player_id = Activity.player_id
    AND DATEDIFF(Activity.event_date, PlayerToInstallDate.install_dt) = 1
  )
GROUP BY 1;",1097
1096,"SELECT
  Books.book_id,
  ANY_VALUE(Books.name) AS name
FROM Books
LEFT JOIN Orders
  ON (
    Books.book_id = Orders.book_id
    AND Orders.dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'
  )
WHERE DATEDIFF('2019-06-23', Books.available_from) > 30
GROUP BY 1
HAVING IFNULL(SUM(Orders.quantity), 0) < 10;",1098
1097,"class Solution {
 public:
  int twoSumLessThanK(vector<int>& nums, int k) {
    if (nums.size() < 2)
      return -1;

    int ans = -1;  // Note the constraint that nums[i] > 0.
    int l = 0;
    int r = nums.size() - 1;

    ranges::sort(nums);

    while (l < r)
      if (nums[l] + nums[r] < k) {
        ans = max(ans, nums[l] + nums[r]);
        ++l;
      } else {
        --r;
      }

    return ans;
  }
};",1099
1098,"class Solution {
 public:
  int numKLenSubstrNoRepeats(string s, int k) {
    int ans = 0;
    int unique = 0;
    vector<int> count(26);

    for (int i = 0; i < s.length(); ++i) {
      if (++count[s[i] - 'a'] == 1)
        ++unique;
      if (i >= k && --count[s[i - k] - 'a'] == 0)
        --unique;
      if (unique == k)
        ++ans;
    }

    return ans;
  }
};",1100
1099,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int earliestAcq(vector<vector<int>>& logs, int n) {
    UnionFind uf(n);

    // Sort `logs` by timestamp.
    sort(
        logs.begin(), logs.end(),
        [](const vector<int>& a, const vector<int>& b) { return a[0] < b[0]; });

    for (const vector<int>& log : logs) {
      const int timestamp = log[0];
      const int x = log[1];
      const int y = log[2];
      uf.unionByRank(x, y);
      if (uf.getCount() == 1)
        return timestamp;
    }

    return -1;
  }
};",1101
1100,"struct T {
  int i;
  int j;
  int val;
  T(int i, int j, int val) : i(i), j(j), val(val) {}
};

class Solution {
 public:
  int maximumMinimumPath(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = grid[0][0];
    vector<vector<bool>> seen(m, vector<bool>(n));
    auto compare = [](const T& a, const T& b) { return a.val < b.val; };
    priority_queue<T, vector<T>, decltype(compare)> maxHeap(compare);

    maxHeap.emplace(0, 0, grid[0][0]);

    while (!maxHeap.empty()) {
      const auto [i, j, val] = maxHeap.top();
      maxHeap.pop();
      ans = min(ans, val);
      if (i == m - 1 && j == n - 1)
        return ans;
      seen[i][j] = true;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        maxHeap.emplace(x, y, grid[x][y]);
      }
    }

    throw;
  }
};",1102
1101,"class Solution {
 public:
  vector<int> distributeCandies(int candies, long n) {
    vector<int> ans(n);
    int rows = (-n + sqrt(n * n + 8 * n * n * candies)) / (2 * n * n);
    int accumN = rows * (rows - 1) * n / 2;

    for (int i = 0; i < n; ++i)
      ans[i] = accumN + rows * (i + 1);

    int givenCandies = (n * n * rows * rows + n * rows) / 2;
    candies -= givenCandies;

    for (int i = 0, lastGiven = rows * n + 1; candies > 0; ++i, ++lastGiven) {
      int actualGiven = min(lastGiven, candies);
      candies -= actualGiven;
      ans[i] += actualGiven;
    }

    return ans;
  }
};",1103
1102,"class Solution {
 public:
  vector<int> pathInZigZagTree(int label) {
    deque<int> ans;
    int level;

    for (int l = 0; l < 21; ++l)
      if (pow(2, l) > label) {
        level = l - 1;
        break;
      }

    if (level & 1)
      label = boundarySum(level) - label;

    for (int l = level; l >= 0; --l) {
      ans.push_front(l & 1 ? boundarySum(l) - label : label);
      label /= 2;
    }

    return {ans.begin(), ans.end()};
  }

 private:
  int boundarySum(int level) {
    return pow(2, level) + pow(2, level + 1) - 1;
  }
};",1104
1103,"class Solution {
 public:
  int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
    // dp[i] := the minimum height to place the first i books
    vector<int> dp(books.size() + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 0; i < books.size(); ++i) {
      int sumThickness = 0;
      int maxHeight = 0;
      // Place books[j..i] on a new shelf.
      for (int j = i; j >= 0; --j) {
        const int thickness = books[j][0];
        const int height = books[j][1];
        sumThickness += thickness;
        if (sumThickness > shelfWidth)
          break;
        maxHeight = max(maxHeight, height);
        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight);
      }
    }

    return dp.back();
  }
};",1105
1104,"class Solution {
 public:
  bool parseBoolExpr(string expression) {
    int i = 0;
    return parse(expression, i);
  }

 private:
  bool parse(const string& exp, int& i) {
    if (exp[i] == 't') {
      ++i;
      return true;
    }
    if (exp[i] == 'f') {
      ++i;
      return false;
    }
    if (exp[i] == '!') {
      i += 2;
      bool ans = !parse(exp, i);
      ++i;
      return ans;
    }

    bool isAnd = exp[i] == '&';
    bool ans = isAnd;
    i += 2;
    while (exp[i] != ')') {
      bool parsed = parse(exp, i);
      if (isAnd)
        ans &= parsed;
      else
        ans |= parsed;
      if (exp[i] == ',')
        ++i;
    }
    ++i;
    return ans;
  }
};",1106
1105,"WITH
  UserToLoginDate AS (
    SELECT
      user_id,
      MIN(activity_date) AS login_date
    FROM Traffic
    WHERE activity = 'login'
    GROUP BY 1
  )
SELECT
  login_date,
  COUNT(*) AS user_count
FROM UserToLoginDate
WHERE DATEDIFF('2019-06-30', login_date) <= 90
GROUP BY 1;",1107
1106,"class Solution {
 public:
  string defangIPaddr(string address) {
    return regex_replace(address, regex(""[.]""), ""[.]"");
  }
};",1108
1107,"class Solution {
 public:
  vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
    vector<int> ans(n);

    for (vector<int>& booking : bookings) {
      ans[booking[0] - 1] += booking[2];
      if (booking[1] < n)
        ans[booking[1]] -= booking[2];
    }

    for (int i = 1; i < n; ++i)
      ans[i] += ans[i - 1];

    return ans;
  }
};",1109
1108,"class Solution {
 public:
  vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
    vector<TreeNode*> ans;
    dfs(root, {to_delete.begin(), to_delete.end()}, true, ans);
    return ans;
  }

 private:
  TreeNode* dfs(TreeNode*& root, const unordered_set<int>&& toDeleteSet,
                bool isRoot, vector<TreeNode*>& ans) {
    if (root == nullptr)
      return nullptr;

    const bool deleted = toDeleteSet.count(root->val);
    if (isRoot && !deleted)
      ans.push_back(root);

    // If root is deleted, both children have the possibility to be a new root
    root->left = dfs(root->left, move(toDeleteSet), deleted, ans);
    root->right = dfs(root->right, move(toDeleteSet), deleted, ans);
    return deleted ? nullptr : root;
  }
};",1110
1109,"class Solution {
 public:
  vector<int> maxDepthAfterSplit(string seq) {
    vector<int> ans;
    int depth = 1;

    // Put all odd-depth parentheses in one group and even-depth parentheses in
    // the other group.
    for (const char c : seq)
      if (c == '(')
        ans.push_back(++depth % 2);
      else
        ans.push_back(depth-- % 2);

    return ans;
  }
};",1111
1110,"WITH
  RankedEnrollments AS (
    SELECT
      student_id,
      course_id,
      grade,
      RANK() OVER(
        PARTITION BY student_id
        ORDER BY grade DESC, course_id
      ) AS `rank`
    FROM Enrollments
  )
SELECT
  student_id,
  course_id,
  grade
FROM RankedEnrollments
WHERE `rank` = 1;",1112
1111,"SELECT
  extra AS report_reason,
  COUNT(DISTINCT post_id) AS report_count
FROM Actions
WHERE
  ACTION = 'report'
  AND DATEDIFF('2019-07-05', action_date) = 1
GROUP BY 1;",1113
1112,"class Foo {
 public:
  Foo() {
    firstDone.lock();
    secondDone.lock();
  }

  void first(function<void()> printFirst) {
    printFirst();
    firstDone.unlock();
  }

  void second(function<void()> printSecond) {
    firstDone.lock();
    printSecond();
    secondDone.unlock();
  }

  void third(function<void()> printThird) {
    secondDone.lock();
    printThird();
  }

 private:
  mutex firstDone;
  mutex secondDone;
};",1114
1113,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class FooBar {
 public:
  FooBar(int n) : n(n) {
    sem_init(&fooSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&barSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~FooBar() {
    sem_destroy(&fooSemaphore);
    sem_destroy(&barSemaphore);
  }

  void foo(function<void()> printFoo) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&fooSemaphore);
      printFoo();
      sem_post(&barSemaphore);
    }
  }

  void bar(function<void()> printBar) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&barSemaphore);
      printBar();
      sem_post(&fooSemaphore);
    }
  }

 private:
  const int n;
  sem_t fooSemaphore;
  sem_t barSemaphore;
};",1115
1114,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class ZeroEvenOdd {
 public:
  ZeroEvenOdd(int n) : n(n) {
    sem_init(&zeroSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&evenSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&oddSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~ZeroEvenOdd() {
    sem_destroy(&zeroSemaphore);
    sem_destroy(&evenSemaphore);
    sem_destroy(&oddSemaphore);
  }

  // printNumber(x) outputs ""x"", where x is an integer.
  void zero(function<void(int)> printNumber) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&zeroSemaphore);
      printNumber(0);
      sem_post(&(i % 2 == 0 ? oddSemaphore : evenSemaphore));
    }
  }

  void even(function<void(int)> printNumber) {
    for (int i = 2; i <= n; i += 2) {
      sem_wait(&evenSemaphore);
      printNumber(i);
      sem_post(&zeroSemaphore);
    }
  }

  void odd(function<void(int)> printNumber) {
    for (int i = 1; i <= n; i += 2) {
      sem_wait(&oddSemaphore);
      printNumber(i);
      sem_post(&zeroSemaphore);
    }
  }

 private:
  const int n;
  sem_t zeroSemaphore;
  sem_t evenSemaphore;
  sem_t oddSemaphore;
};",1116
1115,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class H2O {
 public:
  H2O() {
    sem_init(&hSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&oSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~H2O() {
    sem_destroy(&hSemaphore);
    sem_destroy(&oSemaphore);
  }

  void hydrogen(function<void()> releaseHydrogen) {
    sem_wait(&hSemaphore);
    ++h;
    // releaseHydrogen() outputs ""H"". Do not change or remove this line.
    releaseHydrogen();
    if (h % 2 == 0)
      sem_post(&oSemaphore);
    else
      sem_post(&hSemaphore);
  }

  void oxygen(function<void()> releaseOxygen) {
    sem_wait(&oSemaphore);
    // releaseOxygen() outputs ""O"". Do not change or remove this line.
    releaseOxygen();
    sem_post(&hSemaphore);
  }

 private:
  sem_t hSemaphore;
  sem_t oSemaphore;
  int h = 0;
};",1117
1116,"class Solution {
 public:
  int numberOfDays(int year, int month) {
    const vector<int> days = {0,  31, 28, 31, 30, 31, 30,
                              31, 31, 30, 31, 30, 31};
    return month == 2 && isLeapYear(year) ? 29 : days[month];
  }

 private:
  bool isLeapYear(int year) {
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
  };
};",1118
1117,"class Solution {
 public:
  string removeVowels(string s) {
    s.erase(remove_if(s.begin(), s.end(), [&](char c) { return isVowel(c); }),
            s.end());
    return s;
  }

  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiou"";
    return kVowels.find(c) != string_view::npos;
  }
};",1119
1118,"struct T {
  int sum;
  int count;
  double maxAverage;
};

class Solution {
 public:
  double maximumAverageSubtree(TreeNode* root) {
    return maximumAverage(root).maxAverage;
  }

 private:
  T maximumAverage(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 0.0};

    const T left = maximumAverage(root->left);
    const T right = maximumAverage(root->right);

    const int sum = root->val + left.sum + right.sum;
    const int count = 1 + left.count + right.count;
    const double maxAverage =
        max({sum / (double)count, left.maxAverage, right.maxAverage});
    return {sum, count, maxAverage};
  }
};",1120
1119,"class Solution {
 public:
  bool canDivideIntoSubsequences(vector<int>& nums, int k) {
    // Find the number with the maxFreq, we need at least maxFreq * k elements
    // e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to
    // Split nums into two subsequences say k = 3, the minimum length of nums is
    // 2 x 3 = 6, which is impossible if nums.size() = 5
    const int n = nums.size();
    int freq = 1;
    int maxFreq = 1;

    for (int i = 1; i < n; ++i) {
      freq = nums[i - 1] < nums[i] ? 1 : ++freq;
      maxFreq = max(maxFreq, freq);
    }

    return n >= maxFreq * k;
  }
};",1121
1120,"class Solution {
 public:
  vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
    vector<int> ans;
    vector<int> count(1001);

    for (int a : arr1)
      ++count[a];

    for (int a : arr2)
      while (count[a]-- > 0)
        ans.push_back(a);

    for (int num = 0; num < 1001; ++num)
      while (count[num]-- > 0)
        ans.push_back(num);

    return ans;
  }
};",1122
1121,"struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* lcaDeepestLeaves(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};
    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};",1123
1122,"class Solution {
 public:
  int longestWPI(vector<int>& hours) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> map;

    for (int i = 0; i < hours.size(); ++i) {
      prefix += hours[i] > 8 ? 1 : -1;
      if (prefix > 0) {
        ans = i + 1;
      } else {
        if (!map.count(prefix))
          map[prefix] = i;
        if (const auto it = map.find(prefix - 1); it != map.cend())
          ans = max(ans, i - it->second);
      }
    }

    return ans;
  }
};",1124
1123,"class Solution {
 public:
  vector<int> smallestSufficientTeam(vector<string>& req_skills,
                                     vector<vector<string>>& people) {
    const int n = req_skills.size();
    const int nSkills = 1 << n;
    unordered_map<string, int> skillToId;
    // dp[i] := the minimum people's indices to cover skillset of mask i
    unordered_map<int, vector<int>> dp;
    dp.reserve(nSkills);  // Avoid rehash.
    dp[0] = {};

    for (int i = 0; i < n; ++i)
      skillToId[req_skills[i]] = i;

    auto getSkill = [&](const vector<string>& person) {
      int mask = 0;
      for (const string& skill : person)
        if (const auto it = skillToId.find(skill); it != skillToId.cend())
          mask |= 1 << it->second;
      return mask;
    };

    for (int i = 0; i < people.size(); ++i) {
      const int currSkill = getSkill(people[i]);
      for (const auto& [mask, indices] : dp) {
        const int newSkillSet = mask | currSkill;
        if (newSkillSet == mask)  // Adding people[i] doesn't increase skill set
          continue;
        if (!dp.count(newSkillSet) ||
            dp[newSkillSet].size() > indices.size() + 1) {
          dp[newSkillSet] = indices;
          dp[newSkillSet].push_back(i);
        }
      }
    }

    return dp[nSkills - 1];
  }
};",1125
1124,"WITH
  AvgEvents AS (
    SELECT
      business_id,
      AVG(occurences) OVER(PARTITION BY event_type) AS event_avg_occurences,
      occurences
    FROM Events
  )
SELECT business_id
FROM AvgEvents
GROUP BY 1
HAVING SUM(IF(occurences > event_avg_occurences, 1, 0)) > 1;",1126
1125,"WITH
  UserToAmount AS (
    SELECT
      user_id,
      spend_date,
      CASE
        WHEN COUNT(DISTINCT platform) = 2 THEN 'both'
        ELSE platform
      END AS platform,
      SUM(amount) AS amount
    FROM Spending
    GROUP BY 1, 2
  ),
  DateAndPlatforms AS (
    SELECT DISTINCT(spend_date), 'desktop' AS platform
    FROM Spending
    UNION ALL
    SELECT DISTINCT(spend_date), 'mobile' AS platform
    FROM Spending
    UNION ALL
    SELECT DISTINCT(spend_date), 'both' AS platform
    FROM Spending
  )
SELECT
  DateAndPlatforms.spend_date,
  DateAndPlatforms.platform,
  IFNULL(SUM(UserToAmount.amount), 0) AS total_amount,
  COUNT(DISTINCT UserToAmount.user_id) AS total_users
FROM DateAndPlatforms
LEFT JOIN UserToAmount
  USING (spend_date, platform)
GROUP BY 1, 2;",1127
1126,"class Solution {
 public:
  int numEquivDominoPairs(vector<vector<int>>& dominoes) {
    int ans = 0;
    unordered_map<int, int> count;

    for (vector<int>& domino : dominoes) {
      int key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1]);
      ans += count[key];
      ++count[key];
    }

    return ans;
  }
};",1128
1127,"enum class Color { kInit, kRed, kBlue };

class Solution {
 public:
  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges,
                                       vector<vector<int>>& blueEdges) {
    vector<int> ans(n, -1);
    vector<vector<pair<int, Color>>> graph(n);  // graph[u] := [(v, edgeColor)]
    queue<pair<int, Color>> q{{{0, Color::kInit}}};  // [(u, prevColor)]

    for (const vector<int>& edge : redEdges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, Color::kRed);
    }

    for (const vector<int>& edge : blueEdges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, Color::kBlue);
    }

    for (int step = 0; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [u, prevColor] = q.front();
        q.pop();
        ans[u] = ans[u] == -1 ? step : ans[u];
        for (auto& [v, edgeColor] : graph[u]) {
          if (v == -1 || edgeColor == prevColor)
            continue;
          q.emplace(v, edgeColor);
          v = -1;  // Mark (u, v) as used.
        }
      }

    return ans;
  }
};",1129
1128,"class Solution {
 public:
  int mctFromLeafValues(vector<int>& arr) {
    const int n = arr.size();
    // dp[i][j] := the minimum cost of arr[i..j]
    vector<vector<int>> dp(n, vector<int>(n));
    // maxVal[i][j] := the maximum value of arr[i..j]
    vector<vector<int>> maxVal(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      maxVal[i][i] = arr[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j]);
      }

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = INT_MAX;
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +
                                       maxVal[i][k] * maxVal[k + 1][j]);
      }

    return dp[0].back();
  }
};",1130
1129,"class Solution {
 public:
  int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {
    const int n = arr1.size();
    vector<int> a(n);
    vector<int> b(n);
    vector<int> c(n);
    vector<int> d(n);

    for (int i = 0; i < n; ++i) {
      a[i] = arr1[i] + arr2[i] + i;
      b[i] = arr1[i] + arr2[i] - i;
      c[i] = arr1[i] - arr2[i] + i;
      d[i] = arr1[i] - arr2[i] - i;
    }

    return max(max(diff(a), diff(b)), max(diff(c), diff(d)));
  }

 private:
  int diff(vector<int>& nums) {
    const int min = ranges::min(nums);
    const int max = ranges::max(nums);
    return max - min;
  }
};",1131
1130,"WITH
  DailyPercents AS (
    SELECT (
        COUNT(DISTINCT Removals.post_id) / COUNT(DISTINCT Actions.post_id)
      ) * 100 AS percent
    FROM Actions
    LEFT JOIN Removals
      USING (post_id)
    WHERE Actions.extra = 'spam'
    GROUP BY Actions.action_date
  )
SELECT ROUND(AVG(percent), 2) AS average_daily_percent
FROM DailyPercents;",1132
1131,"class Solution {
 public:
  int largestUniqueNumber(vector<int>& nums) {
    constexpr int kMax = 1000;
    vector<short> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int num = kMax; num >= 0; --num)
      if (count[num] == 1)
        return num;

    return -1;
  }
};",1133
1132,"class Solution {
 public:
  bool isArmstrong(int n) {
    const string s = to_string(n);
    const int k = s.length();
    for (const char c : s)
      n -= pow(c - '0', k);
    return n == 0;
  }
};",1134
1133,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minimumCost(int n, vector<vector<int>>& connections) {
    int ans = 0;
    UnionFind uf(n + 1);

    // Sort by cost.
    sort(
        connections.begin(), connections.end(),
        [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });

    for (const vector<int>& c : connections) {
      const int u = c[0];
      const int v = c[1];
      const int cost = c[2];
      if (uf.find(u) == uf.find(v))
        continue;
      uf.unionByRank(u, v);
      ans += cost;
    }

    const int root = uf.find(1);
    for (int i = 1; i <= n; ++i)
      if (uf.find(i) != root)
        return -1;

    return ans;
  }
};",1135
1134,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  int minimumSemesters(int n, vector<vector<int>>& relations) {
    vector<vector<int>> graph(n);
    vector<State> states(n);
    vector<int> depth(n, 1);

    for (const vector<int>& relation : relations) {
      const int u = relation[0] - 1;
      const int v = relation[1] - 1;
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      if (hasCycle(graph, i, states, depth))
        return -1;

    return ranges::max(depth);
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& states,
                vector<int>& depth) {
    if (states[u] == State::kVisiting)
      return true;
    if (states[u] == State::kVisited)
      return false;

    states[u] = State::kVisiting;
    for (const int v : graph[u]) {
      if (hasCycle(graph, v, states, depth))
        return true;
      depth[u] = max(depth[u], 1 + depth[v]);
    }
    states[u] = State::kVisited;

    return false;
  }
};",1136
1135,"class Solution {
 public:
  int tribonacci(int n) {
    if (n < 2)
      return n;

    vector<int> dp{0, 1, 1};

    for (int i = 3; i <= n; ++i) {
      const int next = dp[0] + dp[1] + dp[2];
      dp[0] = dp[1];
      dp[1] = dp[2];
      dp[2] = next;
    }

    return dp[2];
  }
};",1137
1136,"class Solution {
 public:
  string alphabetBoardPath(string target) {
    string ans;
    int x = 0;
    int y = 0;

    for (char c : target) {
      int newX = (c - 'a') % 5;
      int newY = (c - 'a') / 5;
      ans += string(max(0, y - newY), 'U') + string(max(0, newX - x), 'R') +
             string(max(0, x - newX), 'L') + string(max(0, newY - y), 'D') +
             '!';
      x = newX;
      y = newY;
    }

    return ans;
  }
};",1138
1137,"class Solution {
 public:
  int largest1BorderedSquare(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    // leftOnes[i][j] := consecutive 1s in the left of grid[i][j]
    vector<vector<int>> leftOnes(m, vector<int>(n));
    // topOnes[i][j] := consecutive 1s in the top of grid[i][j]
    vector<vector<int>> topOnes(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          leftOnes[i][j] = j == 0 ? 1 : 1 + leftOnes[i][j - 1];
          topOnes[i][j] = i == 0 ? 1 : 1 + topOnes[i - 1][j];
        }

    for (int sz = min(m, n); sz > 0; --sz)
      for (int i = 0; i + sz - 1 < m; ++i)
        for (int j = 0; j + sz - 1 < n; ++j) {
          const int x = i + sz - 1;
          const int y = j + sz - 1;
          // If grid[i..x][j..y] has all 1s on its border.
          if (min(leftOnes[i][y], leftOnes[x][y]) >= sz &&
              min(topOnes[x][j], topOnes[x][y]) >= sz)
            return sz * sz;
        }

    return 0;
  }
};",1139
1138,"class Solution {
 public:
  int stoneGameII(vector<int>& piles) {
    const int n = piles.size();
    vector<vector<int>> mem(n, vector<int>(n));
    vector<int> suffix = piles;  // suffix[i] := sum(piles[i..n))
    for (int i = n - 2; i >= 0; --i)
      suffix[i] += suffix[i + 1];
    return stoneGameII(suffix, 0, 1, mem);
  }

 private:
  // Returns the maximum number of stones Alice can get from piles[i..n) with M.
  int stoneGameII(const vector<int>& suffix, int i, int M,
                  vector<vector<int>>& mem) {
    if (i + 2 * M >= mem.size())
      return suffix[i];
    if (mem[i][M] > 0)
      return mem[i][M];

    int opponent = suffix[i];

    for (int X = 1; X <= 2 * M; ++X)
      opponent = min(opponent, stoneGameII(suffix, i + X, max(M, X), mem));

    return mem[i][M] = suffix[i] - opponent;
  }
};",1140
1139,"SELECT
  activity_date AS day,
  COUNT(DISTINCT user_id) AS active_users
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND  '2019-07-27'
GROUP BY 1;",1141
1140,"SELECT
  IFNULL(
    ROUND(
      COUNT(DISTINCT session_id) / COUNT(DISTINCT user_id),
      2
    ),
    0.00
  ) AS average_sessions_per_user
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND  '2019-07-27';",1142
1141,"class Solution {
 public:
  int longestCommonSubsequence(string text1, string text2) {
    const int m = text1.length();
    const int n = text2.length();
    // dp[i][j] := the length of LCS(text1[0..i), text2[0..j))
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        dp[i + 1][j + 1] = text1[i] == text2[j]
                               ? 1 + dp[i][j]
                               : max(dp[i][j + 1], dp[i + 1][j]);

    return dp[m][n];
  }
};",1143
1142,"class Solution {
 public:
  int movesToMakeZigzag(vector<int>& nums) {
    vector<int> decreasing(2);

    for (int i = 0; i < nums.size(); ++i) {
      int l = i > 0 ? nums[i - 1] : 1001;
      int r = i + 1 < nums.size() ? nums[i + 1] : 1001;
      decreasing[i % 2] += max(0, nums[i] - min(l, r) + 1);
    }

    return min(decreasing[0], decreasing[1]);
  }
};",1144
1143,"class Solution {
 public:
  bool btreeGameWinningMove(TreeNode* root, int n, int x) {
    count(root, x);
    return max({leftCount, rightCount, n - leftCount - rightCount - 1}) > n / 2;
  }

 private:
  int leftCount;   // the number of nodes of n's left
  int rightCount;  // the number of nodes of n's right

  int count(TreeNode* root, int x) {
    if (root == nullptr)
      return 0;
    const int l = count(root->left, x);
    const int r = count(root->right, x);
    if (root->val == x) {
      leftCount = l;
      rightCount = r;
    }
    return 1 + l + r;
  }
};",1145
1144,"set(index: int, val: int)",1146
1145,"class Solution {
 public:
  int longestDecomposition(string text) {
    int count = 0;
    int l = 0;

    for (int r = 1; 2 * r <= text.length(); ++r)
      if (equal(text.begin() + l, text.begin() + r, text.end() - r)) {
        count += 2;
        l = r;
      }

    return count + (2 * l < text.length());
  }
};",1147
1146,"SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY 1;",1148
1147,"SELECT DISTINCT viewer_id AS id
FROM Views
GROUP BY viewer_id, view_date
HAVING COUNT(DISTINCT article_id) > 1
ORDER BY 1;",1149
1148,"class Solution {
 public:
  bool isMajorityElement(vector<int>& nums, int target) {
    const int n = nums.size();
    const int i = ranges::lower_bound(nums, target) - nums.begin();
    return i + n / 2 < n && nums[i + n / 2] == target;
  }
};",1150
1149,"class Solution {
 public:
  int minSwaps(vector<int>& data) {
    const int k = ranges::count(data, 1);
    int ones = 0;     // the number of ones in the window
    int maxOnes = 0;  // the maximum number of ones in the window

    for (int i = 0; i < data.size(); ++i) {
      if (i >= k && data[i - k])
        --ones;
      if (data[i])
        ++ones;
      maxOnes = max(maxOnes, ones);
    }

    return k - maxOnes;
  }
};",1151
1150,"class Solution:
  def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
    userToSites = collections.defaultdict(list)

    # Sort websites of each user by timestamp.
    for user, _, site in sorted(zip(username, timestamp, website), key=lambda x: (x[1])):
      userToSites[user].append(site)

    # For each of three websites, count its frequency.
    patternCount = collections.Counter()

    for user, sites in userToSites.items():
      patternCount.update(Counter(set(itertools.combinations(sites, 3))))

    return max(sorted(patternCount), key=patternCount.get)",1152
1151,"class Solution {
 public:
  bool canConvert(string str1, string str2) {
    if (str1 == str2)
      return true;

    vector<int> mappings(128);

    for (int i = 0; i < str1.length(); ++i) {
      const int a = str1[i];
      const int b = str2[i];
      if (mappings[a] != 0 && mappings[a] != b)
        return false;
      mappings[a] = b;
    }

    // No letter in the str1 maps to > 1 letter in the str2 and there is at
    // lest one temporary letter can break any loops.
    return unordered_set<char>(str2.begin(), str2.end()).size() < 26;
  }
};",1153
1152,"class Solution {
 public:
  int dayOfYear(string date) {
    int year = stoi(date.substr(0, 4));
    int month = stoi(date.substr(5, 2));
    int day = stoi(date.substr(8));
    vector<int> days = {
        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    return accumulate(days.begin(), days.begin() + month - 1, 0) + day;
  }

 private:
  bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
  }
};",1154
1153,"class Solution {
 public:
  int numRollsToTarget(int n, int k, int target) {
    constexpr int kMod = 1'000'000'007;
    vector<int> dp(target + 1);
    dp[0] = 1;

    while (n-- > 0) {  // n dices
      vector<int> newDp(target + 1);
      for (int i = 1; i <= k; ++i)           // numbers 1, 2, ..., f
        for (int t = i; t <= target; ++t) {  // all the possible targets
          newDp[t] += dp[t - i];
          newDp[t] %= kMod;
        }
      dp = move(newDp);
    }

    return dp[target];
  }
};",1155
1154,"class Solution {
 public:
  int maxRepOpt1(string text) {
    int ans = 0;
    vector<int> count(26);
    vector<pair<char, int>> groups{{text[0], 1}};

    for (char c : text)
      ++count[c - 'a'];

    for (int i = 1; i < text.length(); ++i)
      if (text[i] == text[i - 1])
        ++groups[groups.size() - 1].second;
      else
        groups.emplace_back(text[i], 1);

    for (const auto& [c, length] : groups)
      ans = max(ans, min(length + 1, count[c - 'a']));

    for (int i = 1; i + 1 < groups.size(); ++i)
      if (groups[i - 1].first == groups[i + 1].first && groups[i].second == 1)
        ans = max(ans, min(groups[i - 1].second + groups[i + 1].second + 1,
                           count[groups[i - 1].first - 'a']));

    return ans;
  }
};",1156
1155,"query(left: int, right: int, threshold: int)",1157
1156,"SELECT
  Users.user_id AS buyer_id,
  Users.join_date,
  COUNT(Orders.order_id) AS orders_in_2019
FROM Users
LEFT JOIN Orders
  ON (Users.user_id = Orders.buyer_id AND YEAR(order_date) = '2019')
GROUP BY 1;",1158
1157,"WITH
  RankedOrders AS (
    SELECT
      Orders.seller_id,
      RANK() OVER(
        PARTITION BY Orders.seller_id
        ORDER BY Orders.order_date
      ) AS `rank`,
      Items.item_brand
    FROM Orders
    INNER JOIN Items
      USING (item_id)
  )
SELECT
  user_id AS seller_id,
  CASE
    WHEN Users.favorite_brand = RankedOrders.item_brand THEN 'yes'
    ELSE 'no'
  END AS 2nd_item_fav_brand
FROM Users
LEFT JOIN RankedOrders
  ON (Users.user_id = RankedOrders.seller_id AND RankedOrders.`rank` = 2);",1159
1158,"class Solution {
 public:
  int countCharacters(vector<string>& words, string chars) {
    int ans = 0;
    vector<int> count(26);

    for (const char c : chars)
      ++count[c - 'a'];

    for (const string& word : words) {
      vector<int> tempCount(count);
      for (const char c : word)
        if (--tempCount[c - 'a'] < 0) {
          ans -= word.length();
          break;
        }
      ans += word.length();
    }

    return ans;
  }
};",1160
1159,"class Solution {
 public:
  int maxLevelSum(TreeNode* root) {
    int ans = 1;
    int maxLevelSum = INT_MIN;
    queue<TreeNode*> q{{root}};

    for (int level = 1; !q.empty(); ++level) {
      int levelSum = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        levelSum += node->val;
        if (node->left != nullptr)
          q.push(node->left);
        if (node->right != nullptr)
          q.push(node->right);
      }
      if (maxLevelSum < levelSum) {
        maxLevelSum = levelSum;
        ans = level;
      }
    }

    return ans;
  }
};",1161
1160,"class Solution {
 public:
  int maxDistance(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    queue<pair<int, int>> q;
    int water = 0;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0)
          ++water;
        else
          q.emplace(i, j);

    if (water == 0 || water == m * n)
      return -1;

    int ans = 0;

    for (int d = 0; !q.empty(); ++d)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        ans = d;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] > 0)
            continue;
          q.emplace(x, y);
          grid[x][y] = 2;  // Mark as visited.
        }
      }

    return ans;
  }
};",1162
1161,"class Solution {
 public:
  string lastSubstring(string s) {
    int i = 0;
    int j = 1;
    int k = 0;  // the number of the same letters of s[i..n) and s[j..n)

    while (j + k < s.length()) {
      if (s[i + k] == s[j + k]) {
        ++k;
      } else if (s[i + k] > s[j + k]) {
        // s[i..i + k] == s[j..j + k] and s[i + k] > s[j + k] means that we
        // should start from s[j + k] to find a possible larger substring.
        j += k + 1;
        k = 0;
      } else {
        // s[i..i + k] == s[j..j + k] and s[i + k] < s[j + k] means that either
        // starting from s[i + k + 1] or s[j] has a larger substring.
        i = max(i + k + 1, j);
        j = i + 1;
        k = 0;
      }
    }

    return s.substr(i);
  }
};",1163
1162,"WITH
  RankedProducts AS (
    SELECT
      product_id,
      new_price,
      RANK() OVER(
        PARTITION BY product_id
        ORDER BY change_date DESC
      ) AS `rank`
    FROM Products
    WHERE change_date <= '2019-08-16'
  ),
  ProductToLatestPrice AS (
    SELECT product_id, new_price
    FROM RankedProducts
    WHERE `rank` = 1
  )
SELECT
  Products.product_id,
  IFNULL(ProductToLatestPrice.new_price, 10) AS price
FROM Products
LEFT JOIN ProductToLatestPrice
  USING (product_id)
GROUP BY 1;",1164
1163,"class Solution {
 public:
  int calculateTime(string keyboard, string word) {
    int ans = 0;
    int prevIndex = 0;
    vector<int> letterToIndex(26);

    for (int i = 0; i < keyboard.length(); ++i)
      letterToIndex[keyboard[i] - 'a'] = i;

    for (const char c : word) {
      const int currIndex = letterToIndex[c - 'a'];
      ans += abs(currIndex - prevIndex);
      prevIndex = currIndex;
    }

    return ans;
  }
};",1165
1164,"createPath(path: str, value: int)",1166
1165,"class Solution {
 public:
  int connectSticks(vector<int>& sticks) {
    int ans = 0;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int stick : sticks)
      minHeap.push(stick);

    while (minHeap.size() > 1) {
      const int x = minHeap.top();
      minHeap.pop();
      const int y = minHeap.top();
      minHeap.pop();
      ans += x + y;
      minHeap.push(x + y);
    }

    return ans;
  }
};",1167
1166,"class Solution {
 public:
  int minCostToSupplyWater(int n, vector<int>& wells,
                           vector<vector<int>>& pipes) {
    int ans = 0;
    using P = pair<int, int>;
    vector<vector<P>> graph(n + 1);
    priority_queue<P, vector<P>, greater<>> minHeap;  // (d, u)

    for (const vector<int>& pipe : pipes) {
      const int u = pipe[0];
      const int v = pipe[1];
      const int w = pipe[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    // Connect virtual 0 with nodes 1 to n.
    for (int i = 0; i < n; ++i) {
      graph[0].emplace_back(i + 1, wells[i]);
      minHeap.emplace(wells[i], i + 1);
    }

    unordered_set<int> mst{{0}};

    while (mst.size() < n + 1) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (mst.count(u))
        continue;
      // Add the new vertex.
      mst.insert(u);
      ans += d;
      // Expand if possible.
      for (const auto [v, w] : graph[u])
        if (!mst.count(v))
          minHeap.emplace(w, v);
    }

    return ans;
  }
};",1168
1167,"struct Trans {
  string name;
  int time;
  int amount;
  string city;
};

class Solution {
 public:
  vector<string> invalidTransactions(vector<string>& transactions) {
    vector<string> ans;
    unordered_map<string, vector<Trans>> nameToTranses;

    for (const string& t : transactions) {
      const Trans trans = getTrans(t);
      nameToTranses[trans.name].push_back(trans);
    }

    for (const string& t : transactions) {
      const Trans currTrans = getTrans(t);
      if (currTrans.amount > 1000) {
        ans.push_back(t);
      } else if (const auto it = nameToTranses.find(currTrans.name);
                 it != nameToTranses.cend()) {
        // Iterate through all the transactions with the same name, check if
        // they're within 60 minutes in a different city.
        for (Trans trans : it->second)
          if (abs(trans.time - currTrans.time) <= 60 &&
              trans.city != currTrans.city) {
            ans.push_back(t);
            break;
          }
      }
    }

    return ans;
  }

 private:
  Trans getTrans(const string& t) {
    istringstream iss(t);
    vector<string> s(4, """");
    for (int i = 0; getline(iss, s[i++], ',');)
      ;
    return {s[0], stoi(s[1]), stoi(s[2]), s[3]};
  }
};",1169
1168,"class Solution {
 public:
  vector<int> numSmallerByFrequency(vector<string>& queries,
                                    vector<string>& words) {
    vector<int> ans;
    vector<int> wordsFreq;

    for (const string& word : words)
      wordsFreq.push_back(f(word));
    ranges::sort(wordsFreq);

    for (const string& query : queries) {
      const int freq = f(query);
      ans.push_back(wordsFreq.end() - ranges::upper_bound(wordsFreq, freq));
    }

    return ans;
  }

 private:
  int f(const string& word) {
    int count = 0;
    char currentChar = 'z' + 1;

    for (const char c : word)
      if (c < currentChar) {
        currentChar = c;
        count = 1;
      } else if (c == currentChar) {
        ++count;
      }

    return count;
  }
};",1170
1169,"class Solution {
 public:
  ListNode* removeZeroSumSublists(ListNode* head) {
    ListNode dummy(0, head);
    int prefix = 0;
    unordered_map<int, ListNode*> prefixToNode;
    prefixToNode[0] = &dummy;

    for (; head; head = head->next) {
      prefix += head->val;
      prefixToNode[prefix] = head;
    }

    prefix = 0;

    for (head = &dummy; head; head = head->next) {
      prefix += head->val;
      head->next = prefixToNode[prefix]->next;
    }

    return dummy.next;
  }
};",1171
1170,push(val: int),1172
1171,"SELECT
  ROUND(
    100 * AVG(order_date = customer_pref_delivery_date),
    2
  ) AS immediate_percentage
FROM Delivery;",1173
1172,"WITH
  CustomerToIsImmediate AS(
    SELECT
      DISTINCT customer_id,
      FIRST_VALUE(order_date = customer_pref_delivery_date) OVER(
        PARTITION BY customer_id
        ORDER BY order_date
      ) is_immediate
    FROM Delivery
  )
SELECT ROUND(AVG(is_immediate) * 100, 2) immediate_percentage
FROM CustomerToIsImmediate;",1174
1173,"class Solution {
 public:
  int numPrimeArrangements(int n) {
    constexpr int kMod = 1'000'000'007;
    const int count = countPrimes(n);
    return (factorial(count, kMod) * factorial(n - count, kMod)) % kMod;
  }

 private:
  int countPrimes(int n) {
    vector<bool> prime(n + 1, true);
    prime[0] = false;
    prime[1] = false;

    for (int i = 0; i <= sqrt(n); ++i)
      if (prime[i])
        for (int j = i * i; j <= n; j += i)
          prime[j] = false;

    return ranges::count(prime, true);
  }

  long factorial(int n, const int kMod) {
    long fact = 1;
    for (int i = 1; i <= n; ++i)
      fact = fact * i % kMod;
    return fact;
  }
};",1175
1174,"class Solution {
 public:
  int dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) {
    int ans = 0;
    int sum = 0;

    for (int i = 0; i < calories.size(); ++i) {
      sum += calories[i];
      if (i < k - 1)
        continue;
      if (i >= k)
        sum -= calories[i - k];
      if (sum < lower)
        --ans;
      else if (sum > upper)
        ++ans;
    }

    return ans;
  }
};",1176
1175,"class Solution {
 public:
  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {
    vector<bool> ans;
    vector<int> dp(s.length() + 1);

    for (int i = 1; i <= s.length(); ++i)
      dp[i] = dp[i - 1] ^ 1 << s[i - 1] - 'a';

    for (const vector<int>& query : queries) {
      const int odds = __builtin_popcount(dp[query[1] + 1] ^ dp[query[0]]);
      ans.push_back(odds / 2 <= query[2]);
    }

    return ans;
  }
};",1177
1176,"class Solution {
 public:
  vector<int> findNumOfValidWords(vector<string>& words,
                                  vector<string>& puzzles) {
    vector<int> ans;
    unordered_map<int, int> binaryCount;

    for (const string& word : words) {
      int mask = 0;
      for (char c : word)
        mask |= 1 << c - 'a';
      ++binaryCount[mask];
    }

    for (const string& puzzle : puzzles) {
      int valid = 0;
      const int n = puzzle.length() - 1;
      for (int i = 0; i < (1 << n); ++i) {
        int mask = 1 << puzzle[0] - 'a';
        for (int j = 0; j < n; ++j)
          if (i & 1 << j)
            mask |= 1 << puzzle[j + 1] - 'a';
        if (const auto it = binaryCount.find(mask); it != binaryCount.cend())
          valid += it->second;
      }
      ans.push_back(valid);
    }

    return ans;
  }
};",1178
1177,"SELECT
  id,
  SUM(IF(month = 'Jan', revenue, NULL)) AS Jan_Revenue,
  SUM(IF(month = 'Feb', revenue, NULL)) AS Feb_Revenue,
  SUM(IF(month = 'Mar', revenue, NULL)) AS Mar_Revenue,
  SUM(IF(month = 'Apr', revenue, NULL)) AS Apr_Revenue,
  SUM(IF(month = 'May', revenue, NULL)) AS May_Revenue,
  SUM(IF(month = 'Jun', revenue, NULL)) AS Jun_Revenue,
  SUM(IF(month = 'Jul', revenue, NULL)) AS Jul_Revenue,
  SUM(IF(month = 'Aug', revenue, NULL)) AS Aug_Revenue,
  SUM(IF(month = 'Sep', revenue, NULL)) AS Sep_Revenue,
  SUM(IF(month = 'Oct', revenue, NULL)) AS Oct_Revenue,
  SUM(IF(month = 'Nov', revenue, NULL)) AS Nov_Revenue,
  SUM(IF(month = 'Dec', revenue, NULL)) AS Dec_Revenue
FROM Department
GROUP BY 1;",1179
1178,"class Solution {
 public:
  int countLetters(string s) {
    int ans = 0;
    int dp = 0;         // the length of the running letter
    char letter = '@';  // the running letter

    for (const char c : s) {
      if (c == letter) {
        ++dp;
      } else {
        dp = 1;
        letter = c;
      }
      // Add the number of substrings ending in the current letter.
      ans += dp;
    }

    return ans;
  }
};",1180
1179,"class Solution {
 public:
  vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {
    set<string> ans;
    unordered_map<string, set<string>> firstWordToLasts;
    unordered_map<string, set<string>> lastWordToFirsts;

    for (const string& phrase : phrases) {
      const int firstSpaceIndex = phrase.find(' ');
      const int lastSpaceIndex = phrase.rfind(' ');
      // the index after the firstWord
      const int i =
          firstSpaceIndex == string::npos ? phrase.length() : firstSpaceIndex;
      // the index of the lastWord
      const int j = lastSpaceIndex == string::npos ? 0 : lastSpaceIndex + 1;
      const string firstWord = phrase.substr(0, i);
      const string lastWord = phrase.substr(j);

      // Concatenate `phrase` with `last` having the same `firstWord`.
      if (const auto it = firstWordToLasts.find(lastWord);
          it != firstWordToLasts.cend())
        for (const string& last : it->second)
          ans.insert(phrase + last);

      // Concatenate `first` having the same `lastWord` with `phrase`.
      if (const auto it = lastWordToFirsts.find(firstWord);
          it != lastWordToFirsts.cend())
        for (const string& first : it->second)
          ans.insert(first + phrase);

      // e.g. ""a b c"" -> {""a"": "" b c""}
      //          ""a"" -> {""a"": """"}
      firstWordToLasts[firstWord].insert(phrase.substr(i));

      // e.g. ""a b c"" -> {""c"": ""a b ""}
      //          ""a"" -> {""a"": """"}
      lastWordToFirsts[lastWord].insert(phrase.substr(0, j));
    }

    return {ans.begin(), ans.end()};
  }
};",1181
1180,"class Solution {
 public:
  vector<int> shortestDistanceColor(vector<int>& colors,
                                    vector<vector<int>>& queries) {
    constexpr int kNumColor = 3;
    const int n = colors.size();
    vector<int> ans;
    // left[i][c] := the closest index of color c in index i to the left
    vector<vector<int>> left(n, vector<int>(kNumColor + 1));
    // right[i][c] := the closest index of color c in index i to the right
    vector<vector<int>> right(n, vector<int>(kNumColor + 1));

    vector<int> colorToClosestIndex{0, -1, -1, -1};  // 0-indexed, -1 := N/A
    for (int i = 0; i < n; ++i) {
      colorToClosestIndex[colors[i]] = i;
      for (int c = 1; c <= kNumColor; ++c)
        left[i][c] = colorToClosestIndex[c];
    }

    colorToClosestIndex = {0, -1, -1, -1};  // Reset.
    for (int i = n - 1; i >= 0; --i) {
      colorToClosestIndex[colors[i]] = i;
      for (int c = 1; c <= kNumColor; ++c)
        right[i][c] = colorToClosestIndex[c];
    }

    for (const vector<int>& query : queries) {
      const int i = query[0];
      const int c = query[1];
      const int leftDist = left[i][c] == -1 ? INT_MAX : i - left[i][c];
      const int rightDist = right[i][c] == -1 ? INT_MAX : right[i][c] - i;
      const int minDist = min(leftDist, rightDist);
      ans.push_back(minDist == INT_MAX ? -1 : minDist);
    }

    return ans;
  }
};",1182
1181,"class Solution {
 public:
  int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {
    int ans = 0;
    vector<vector<int>> submatrix(sideLength, vector<int>(sideLength));
    priority_queue<int> maxHeap;

    for (int i = 0; i < width; ++i)
      for (int j = 0; j < height; ++j)
        ++submatrix[i % sideLength][j % sideLength];

    for (const vector<int>& row : submatrix)
      for (const int a : row)
        maxHeap.push(a);

    for (int i = 0; i < maxOnes; ++i)
      ans += maxHeap.top(), maxHeap.pop();

    return ans;
  }
};",1183
1182,"class Solution {
 public:
  int distanceBetweenBusStops(vector<int>& distance, int start,
                              int destination) {
    int clockwise = 0;
    int counterclockwise = 0;

    if (start > destination)
      swap(start, destination);

    for (int i = 0; i < distance.size(); ++i) {
      if (i >= start && i < destination)
        clockwise += distance[i];
      else
        counterclockwise += distance[i];
    }

    return min(clockwise, counterclockwise);
  }
};",1184
1183,"class Solution {
 public:
  string dayOfTheWeek(int day, int month, int year) {
    vector<string> week = {""Sunday"",   ""Monday"", ""Tuesday"", ""Wednesday"",
                           ""Thursday"", ""Friday"", ""Saturday""};
    vector<int> days = {
        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int count = 0;

    for (int i = 1971; i < year; ++i)
      count += i % 4 == 0 ? 366 : 365;
    for (int i = 0; i < month - 1; ++i)
      count += days[i];
    count += day;

    return week[(count + 4) % 7];
  }

 private:
  bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
  }
};",1185
1184,"class Solution {
 public:
  // Similar to 53. Maximum Subarray
  int maximumSum(vector<int>& arr) {
    // dp[0][i] := the maximum sum subarray ending in i (no deletion)
    // dp[1][i] := the maximum sum subarray ending in i (at most 1 deletion)
    vector<vector<int>> dp(2, vector<int>(arr.size()));

    dp[0][0] = arr[0];
    dp[1][0] = arr[0];
    for (int i = 1; i < arr.size(); ++i) {
      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i]);
      dp[1][i] =
          max({arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1] /*delete arr[i]*/});
    }

    return ranges::max(dp[1]);
  }
};",1186
1185,"class Solution {
 public:
  int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {
    // dp[i] := the minimum steps to reach i at previous round
    unordered_map<int, int> dp{{-1, 0}};

    ranges::sort(arr2);

    for (const int a : arr1) {
      unordered_map<int, int> nextDp;
      for (const auto& [val, steps] : dp) {
        // It's possible to use the value in the arr1.
        if (a > val)
          nextDp[a] = min(nextDp.count(a) ? nextDp[a] : INT_MAX, steps);
        // Also try the value in the arr2.
        if (const auto it = ranges::upper_bound(arr2, val); it != arr2.cend())
          nextDp[*it] =
              min(nextDp.count(*it) ? nextDp[*it] : INT_MAX, steps + 1);
      }
      if (nextDp.empty())
        return -1;
      dp = move(nextDp);
    }

    int ans = INT_MAX;
    for (const auto& [_, steps] : dp)
      ans = min(ans, steps);
    return ans;
  }
};",1187
1186,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class BoundedBlockingQueue {
 public:
  BoundedBlockingQueue(int capacity) {
    sem_init(&enqueueSemaphore, /*pshared=*/0, /*value=*/capacity);
    sem_init(&dequeueSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~BoundedBlockingQueue() {
    sem_destroy(&enqueueSemaphore);
    sem_destroy(&dequeueSemaphore);
  }

  void enqueue(int element) {
    sem_wait(&enqueueSemaphore);
    q.push(element);
    sem_post(&dequeueSemaphore);
  }

  int dequeue() {
    sem_wait(&dequeueSemaphore);
    const int element = q.front();
    q.pop();
    sem_post(&enqueueSemaphore);
    return element;
  }

  int size() {
    return q.size();
  }

 private:
  queue<int> q;
  sem_t enqueueSemaphore;
  sem_t dequeueSemaphore;
};",1188
1187,"class Solution {
 public:
  int maxNumberOfBalloons(string text) {
    int ans = INT_MAX;
    vector<int> count(26);

    for (char c : text)
      ++count[c - 'a'];

    for (char c : string(""ban""))
      ans = min(ans, count[c - 'a']);

    for (char c : string(""lo""))
      ans = min(ans, count[c - 'a'] / 2);

    return ans;
  }
};",1189
1188,"class Solution {
 public:
  string reverseParentheses(string s) {
    stack<int> stack;
    string ans;

    for (const char c : s)
      if (c == '(') {
        stack.push(ans.length());
      } else if (c == ')') {
        // Reverse the corresponding substring between ().
        const int j = stack.top();
        stack.pop();
        reverse(ans.begin() + j, ans.end());
      } else {
        ans += c;
      }

    return ans;
  }
};",1190
1189,"class Solution {
 public:
  int kConcatenationMaxSum(vector<int>& arr, int k) {
    constexpr int kMod = 1'000'000'007;
    const int sz = arr.size() * (k == 1 ? 1 : 2);
    const int sum = accumulate(arr.begin(), arr.end(), 0);
    // The concatenated array will be [arr1, arr2, ..., arrk].
    // If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.
    // Equivalently, maxSubarraySum is from arr1 and arrk.
    return (sum > 0 && k > 2 ? kadane(arr, sz) + sum * static_cast<long>(k - 2)
                             : kadane(arr, sz)) %
           kMod;
  }

 private:
  int kadane(const vector<int>& A, int sz) {
    int ans = 0;
    int sum = 0;
    for (int i = 0; i < sz; ++i) {
      const int a = A[i % A.size()];
      sum = max(a, sum + a);
      ans = max(ans, sum);
    }
    return ans;
  }
};",1191
1190,"class Solution {
 public:
  vector<vector<int>> criticalConnections(int n,
                                          vector<vector<int>>& connections) {
    vector<vector<int>> ans;
    vector<vector<int>> graph(n);

    for (const vector<int>& connection : connections) {
      const int u = connection[0];
      const int v = connection[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // rank[i] := the minimum node that node i can reach with forward edges
    // Initialize with NO_RANK = -2 to indicate not visited..
    getRank(graph, 0, 0, vector<int>(n, NO_RANK), ans);
    return ans;
  }

 private:
  static constexpr int NO_RANK = -2;

  // Gets the minimum rank that u can reach with forward edges.
  int getRank(const vector<vector<int>>& graph, int u, int currRank,
              vector<int>&& rank, vector<vector<int>>& ans) {
    if (rank[u] != NO_RANK)  // The rank is already determined.
      return rank[u];

    rank[u] = currRank;
    int minRank = currRank;

    for (const int v : graph[u]) {
      // visited || parent (that's why NO_RANK = -2 instead of -1)
      if (rank[u] == rank.size() || rank[v] == currRank - 1)
        continue;
      const int nextRank = getRank(graph, v, currRank + 1, move(rank), ans);
      // (u, v) is the only way for u go to v.
      if (nextRank == currRank + 1)
        ans.push_back({u, v});
      minRank = min(minRank, nextRank);
    }

    rank[u] = rank.size();  // Mark as visited.
    return minRank;
  }
};",1192
1191,"SELECT
  DATE_FORMAT(trans_date, '%Y-%m') AS month,
  country,
  COUNT(*) AS trans_count,
  SUM(state = 'approved') AS approved_count,
  SUM(amount) AS trans_total_amount,
  SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY 1, 2;",1193
1192,"WITH
  PlayerToScore AS (
    (
      SELECT
        Players.player_id,
        Players.group_id,
        Matches.first_score AS score
      FROM Players
      LEFT JOIN Matches
        ON (Players.player_id = Matches.first_player)
    )
    UNION ALL
    (
      SELECT
        Players.player_id,
        Players.group_id,
        Matches.second_score AS score
      FROM Players
      LEFT JOIN Matches
        ON (Players.player_id = Matches.second_player)
    )
  ),
  RankedPlayers AS (
    SELECT
      player_id,
      group_id,
      RANK() OVER(
        PARTITION BY group_id
        ORDER BY SUM(score) DESC,
          player_id
      ) AS `rank`
    FROM PlayerToScore
    GROUP BY 1
  )
SELECT group_id, player_id
FROM RankedPlayers
WHERE `rank` = 1;",1194
1193,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class FizzBuzz {
 public:
  FizzBuzz(int n) : n(n) {
    sem_init(&fizzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&buzzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&fizzbuzzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&numberSemaphore, /*pshared=*/0, /*value=*/1);
  }

  ~FizzBuzz() {
    sem_destroy(&fizzSemaphore);
    sem_destroy(&buzzSemaphore);
    sem_destroy(&fizzbuzzSemaphore);
    sem_destroy(&numberSemaphore);
  }

  // printFizz() outputs ""fizz"".
  void fizz(function<void()> printFizz) {
    for (int i = 1; i <= n; ++i)
      if (i % 3 == 0 && i % 15 != 0) {
        sem_wait(&fizzSemaphore);
        printFizz();
        sem_post(&numberSemaphore);
      }
  }

  // printBuzz() outputs ""buzz"".
  void buzz(function<void()> printBuzz) {
    for (int i = 1; i <= n; ++i)
      if (i % 5 == 0 && i % 15 != 0) {
        sem_wait(&buzzSemaphore);
        printBuzz();
        sem_post(&numberSemaphore);
      }
  }

  // printFizzBuzz() outputs ""fizzbuzz"".
  void fizzbuzz(function<void()> printFizzBuzz) {
    for (int i = 1; i <= n; ++i)
      if (i % 15 == 0) {
        sem_wait(&fizzbuzzSemaphore);
        printFizzBuzz();
        sem_post(&numberSemaphore);
      }
  }

  // printNumber(x) outputs ""x"", where x is an integer.
  void number(function<void(int)> printNumber) {
    for (int i = 1; i <= n; ++i) {
      sem_wait(&numberSemaphore);
      if (i % 15 == 0)
        sem_post(&fizzbuzzSemaphore);
      else if (i % 3 == 0)
        sem_post(&fizzSemaphore);
      else if (i % 5 == 0)
        sem_post(&buzzSemaphore);
      else {
        printNumber(i);
        sem_post(&numberSemaphore);
      }
    }
  }

 private:
  const int n;
  sem_t fizzSemaphore;
  sem_t buzzSemaphore;
  sem_t fizzbuzzSemaphore;
  sem_t numberSemaphore;
};",1195
1194,"class Solution {
 public:
  int maxNumberOfApples(vector<int>& weight) {
    int sum = 0;

    ranges::sort(weight);

    for (int i = 0; i < weight.size(); ++i) {
      sum += weight[i];
      if (sum > 5000)
        return i;
    }

    return weight.size();
  }
};",1196
1195,"class Solution {
 public:
  int minKnightMoves(int x, int y) {
    return dp(abs(x), abs(y));
  }

 private:
  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };

  unordered_map<pair<int, int>, int, PairHash> mem;

  int dp(int x, int y) {
    if (x + y == 0)  // (0, 0)
      return 0;
    if (x + y == 2)  // (0, 2), (1, 1), (2, 0)
      return 2;
    if (const auto it = mem.find({x, y}); it != mem.cend())
      return it->second;

    return mem[{x, y}] = 1 + min(dp(abs(x - 2), abs(y - 1)),  //
                                 dp(abs(x - 1), abs(y - 2)));
  }
};",1197
1196,"class Solution {
 public:
  int smallestCommonElement(vector<vector<int>>& mat) {
    constexpr int kMax = 10000;
    vector<int> count(kMax + 1);

    for (const vector<int>& row : mat)
      for (const int a : row)
        if (++count[a] == mat.size())
          return a;

    return -1;
  }
};",1198
1197,"class Solution {
 public:
  int minBuildTime(vector<int>& blocks, int split) {
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int block : blocks)
      minHeap.push(block);

    while (minHeap.size() > 1) {
      minHeap.pop();                // the minimum
      const int x = minHeap.top();  // the second minimum
      minHeap.pop();
      minHeap.push(x + split);
    }

    return minHeap.top();
  }
};",1199
1198,"class Solution {
 public:
  vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
    vector<vector<int>> ans;
    int min = INT_MAX;

    ranges::sort(arr);

    for (int i = 0; i + 1 < arr.size(); ++i) {
      int diff = arr[i + 1] - arr[i];
      if (diff < min) {
        min = diff;
        ans.clear();
      }
      if (diff == min)
        ans.push_back({arr[i], arr[i + 1]});
    }

    return ans;
  }
};",1200
1199,"class Solution {
 public:
  int nthUglyNumber(int n, long a, long b, long c) {
    const long ab = a * b / __gcd(a, b);
    const long ac = a * c / __gcd(a, c);
    const long bc = b * c / __gcd(b, c);
    const long abc = a * bc / __gcd(a, bc);
    int l = 1;
    int r = 2'000'000'000;

    while (l < r) {
      const int m = l + (r - l) / 2;
      if (m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc >= n)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",1201
1200,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
    string ans;
    UnionFind uf(s.length());
    unordered_map<int, priority_queue<char, vector<char>, greater<>>> map;

    for (const vector<int>& pair : pairs)
      uf.unionByRank(pair[0], pair[1]);

    for (int i = 0; i < s.length(); ++i)
      map[uf.find(i)].push(s[i]);

    for (int i = 0; i < s.length(); ++i)
      ans += map[uf.find(i)].top(), map[uf.find(i)].pop();

    return ans;
  }
};",1202
1201,"class Solution {
 public:
  vector<int> sortItems(int n, int m, vector<int>& group,
                        vector<vector<int>>& beforeItems) {
    vector<vector<int>> graph(n + m);
    vector<int> inDegrees(n + m);

    // Build the graph by remapping the k-th group to k + n imaginary node.
    for (int i = 0; i < group.size(); ++i) {
      if (group[i] == -1)
        continue;
      graph[group[i] + n].push_back(i);
      ++inDegrees[i];
    }

    for (int i = 0; i < beforeItems.size(); ++i)
      for (const int b : beforeItems[i]) {
        const int u = group[b] == -1 ? b : group[b] + n;
        const int v = group[i] == -1 ? i : group[i] + n;
        if (u == v) {  // u and v are already in the same group.
          graph[b].push_back(i);
          ++inDegrees[i];
        } else {
          graph[u].push_back(v);
          ++inDegrees[v];
        }
      }

    // Perform topological sorting.
    vector<int> ans;

    for (int i = 0; i < n + m; ++i)
      if (inDegrees[i] == 0)  // inDegrees[i] == -1 means visited.
        dfs(graph, i, inDegrees, n, ans);

    return ans.size() == n ? ans : vector<int>();
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>& inDegrees,
           int n, vector<int>& ans) {
    if (u < n)
      ans.push_back(u);

    inDegrees[u] = -1;  // Mark as visited.

    for (const int v : graph[u])
      if (--inDegrees[v] == 0)
        dfs(graph, v, inDegrees, n, ans);
  }
};",1203
1202,"WITH
  AccumulatedQueue AS (
    SELECT
      person_name,
      SUM(weight) OVER(ORDER BY turn) AS accumulated_weight
    FROM Queue
  )
SELECT person_name
FROM AccumulatedQueue
WHERE accumulated_weight <= 1000
ORDER BY accumulated_weight DESC
LIMIT 1;",1204
1203,"WITH
  ApprovedTransactionsAndChargebacks AS (
    SELECT
      id,
      country,
      state,
      amount,
      DATE_FORMAT(trans_date, '%Y-%m') AS `month`
    FROM Transactions
    WHERE state = 'approved'
    UNION ALL
    SELECT
      trans_id AS id,
      country,
      'chargeback' AS state,
      amount,
      DATE_FORMAT(Chargebacks.trans_date, '%Y-%m') AS `month`
    FROM Chargebacks
    LEFT JOIN Transactions
      ON (Chargebacks.trans_id = Transactions.id)
  )
SELECT
  `month`,
  country,
  SUM(state = 'approved') AS approved_count,
  SUM(IF(state = 'approved', amount, 0)) AS approved_amount,
  SUM(state = 'chargeback') AS chargeback_count,
  SUM(IF(state = 'chargeback', amount, 0)) AS chargeback_amount
FROM ApprovedTransactionsAndChargebacks
GROUP BY 1, 2;",1205
1204,search(target: int),1206
1205,"class Solution {
 public:
  bool uniqueOccurrences(vector<int>& arr) {
    unordered_map<int, int> count;
    unordered_set<int> occurrences;

    for (const int a : arr)
      ++count[a];

    for (const auto& [_, value] : count)
      if (!occurrences.insert(value).second)
        return false;

    return true;
  }
};",1207
1206,"class Solution {
 public:
  int equalSubstring(string s, string t, int maxCost) {
    int j = 0;
    for (int i = 0; i < s.length(); ++i) {
      maxCost -= abs(s[i] - t[i]);
      if (maxCost < 0)
        maxCost += abs(s[j] - t[j++]);
    }

    return s.length() - j;
  }
};",1208
1207,"class Solution {
 public:
  string removeDuplicates(const string& s, int k) {
    string ans;
    vector<pair<char, int>> stack;

    for (const char c : s)
      if (stack.empty() || stack.back().first != c)
        stack.emplace_back(c, 1);
      else if (++stack.back().second == k)  // stack[-1] == c
        stack.pop_back();

    for (const auto& [c, count] : stack)
      ans.append(count, c);

    return ans;
  }
};",1209
1208,"enum class Pos { kHorizontal, kVertical };

class Solution {
 public:
  int minimumMoves(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    // the state of (x, y, pos)
    // pos := 0 (horizontal) / 1 (vertical)
    queue<tuple<int, int, Pos>> q{{{0, 0, Pos::kHorizontal}}};
    vector<vector<vector<bool>>> seen(n,
                                      vector<vector<bool>>(n, vector<bool>(2)));
    seen[0][0][static_cast<int>(Pos::kHorizontal)] = true;

    auto canMoveRight = [&](int x, int y, Pos pos) -> bool {
      if (pos == Pos::kHorizontal)
        return y + 2 < n && !grid[x][y + 2];
      return y + 1 < n && !grid[x][y + 1] && !grid[x + 1][y + 1];
    };

    auto canMoveDown = [&](int x, int y, Pos pos) -> bool {
      if (pos == Pos::kVertical)
        return x + 2 < n && !grid[x + 2][y];
      return x + 1 < n && !grid[x + 1][y] && !grid[x + 1][y + 1];
    };

    auto canRotateClockwise = [&](int x, int y, Pos pos) -> bool {
      return pos == Pos::kHorizontal && x + 1 < n && !grid[x + 1][y + 1] &&
             !grid[x + 1][y];
    };

    auto canRotateCounterclockwise = [&](int x, int y, Pos pos) -> bool {
      return pos == Pos::kVertical && y + 1 < n && !grid[x + 1][y + 1] &&
             !grid[x][y + 1];
    };

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [x, y, pos] = q.front();
        q.pop();
        if (x == n - 1 && y == n - 2 && pos == Pos::kHorizontal)
          return ans;
        if (canMoveRight(x, y, pos) && !seen[x][y + 1][static_cast<int>(pos)]) {
          q.emplace(x, y + 1, pos);
          seen[x][y + 1][static_cast<int>(pos)] = true;
        }
        if (canMoveDown(x, y, pos) && !seen[x + 1][y][static_cast<int>(pos)]) {
          q.emplace(x + 1, y, pos);
          seen[x + 1][y][static_cast<int>(pos)] = true;
        }
        const Pos newPos =
            pos == Pos::kHorizontal ? Pos::kVertical : Pos::kHorizontal;
        if ((canRotateClockwise(x, y, pos) ||
             canRotateCounterclockwise(x, y, pos)) &&
            !seen[x][y][static_cast<int>(newPos)]) {
          q.emplace(x, y, newPos);
          seen[x][y][static_cast<int>(newPos)] = true;
        }
      }
      ++ans;
    }

    return -1;
  }
};",1210
1209,"SELECT
  query_name,
  ROUND(AVG(rating / position), 2) AS quality,
  ROUND(AVG(rating < 3) * 100, 2) AS poor_query_percentage
FROM Queries
GROUP BY 1;",1211
1210,"WITH
  TwoWayMatches AS (
    SELECT
      host_team AS team_id,
      host_goals AS goals,
      guest_goals AS opponent_goals
    FROM Matches
    UNION ALL
    SELECT
      guest_team,
      guest_goals,
      host_goals
    FROM Matches
  )
SELECT
  Teams.team_id,
  Teams.team_name,
  SUM(
    CASE
      WHEN goals > opponent_goals THEN 3
      WHEN goals = opponent_goals THEN 1
      ELSE 0
    END
 ) AS num_points
FROM Teams
LEFT JOIN TwoWayMatches
  USING (team_id)
GROUP BY 1
ORDER BY num_points DESC, team_id;",1212
1211,"class Solution {
 public:
  vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2,
                                 vector<int>& arr3) {
    vector<int> ans;
    int i = 0;
    int j = 0;
    int k = 0;

    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {
      const int mini = min({arr1[i], arr2[j], arr3[k]});
      if (arr1[i] == mini && arr2[j] == mini && arr3[k] == mini) {
        ans.push_back(mini);
        ++i;
        ++j;
        ++k;
      } else if (arr1[i] == mini) {
        ++i;
      } else if (arr2[j] == mini) {
        ++j;
      } else {
        ++k;
      }
    }

    return ans;
  }
};",1213
1212,"class BSTIterator {
 public:
  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {
    pushUntilNull(root);
  }

  bool hasNext() {
    return !stack.empty();
  }

  int next() {
    TreeNode* root = stack.top();
    stack.pop();
    pushUntilNull(leftToRight ? root->right : root->left);
    return root->val;
  }

 private:
  stack<TreeNode*> stack;
  bool leftToRight;

  void pushUntilNull(TreeNode* root) {
    while (root != nullptr) {
      stack.push(root);
      root = leftToRight ? root->left : root->right;
    }
  }
};

class Solution {
 public:
  bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {
    BSTIterator bst1(root1, true);
    BSTIterator bst2(root2, false);

    for (int l = bst1.next(), r = bst2.next(); true;) {
      const int sum = l + r;
      if (sum == target)
        return true;
      if (sum < target) {
        if (!bst1.hasNext())
          return false;
        l = bst1.next();
      } else {
        if (!bst2.hasNext())
          return false;
        r = bst2.next();
      }
    }
  }
};",1214
1213,"class Solution {
 public:
  vector<int> countSteppingNumbers(int low, int high) {
    vector<int> ans;
    if (low == 0)
      ans.push_back(0);

    queue<long> q;

    for (int i = 1; i <= 9; ++i)
      q.push(i);

    while (!q.empty()) {
      const long curr = q.front();
      q.pop();
      if (curr > high)
        continue;
      if (curr >= low)
        ans.push_back(curr);
      const int lastDigit = curr % 10;
      if (lastDigit > 0)
        q.push(curr * 10 + lastDigit - 1);
      if (lastDigit < 9)
        q.push(curr * 10 + lastDigit + 1);
    }

    return ans;
  }
};",1215
1214,"class Solution {
 public:
  bool isValidPalindrome(string s, int k) {
    return s.length() - longestPalindromeSubseq(s) <= k;
  }

 private:
  // Same as 516. Longest Palindromic Subsequence
  int longestPalindromeSubseq(const string& s) {
    const int n = s.length();
    // dp[i][j] := the length of LPS(s[i..j])
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j])
          dp[i][j] = 2 + dp[i + 1][j - 1];
        else
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
};",1216
1215,"class Solution {
 public:
  int minCostToMoveChips(vector<int>& chips) {
    vector<int> count(2);

    for (int chip : chips)
      ++count[chip % 2];

    return min(count[0], count[1]);
  }
};",1217
1216,"class Solution {
 public:
  int longestSubsequence(vector<int>& arr, int difference) {
    int ans = 0;
    unordered_map<int, int> lengthAt;

    for (const int a : arr) {
      if (const auto it = lengthAt.find(a - difference); it != lengthAt.cend())
        lengthAt[a] = it->second + 1;
      else
        lengthAt[a] = 1;
      ans = max(ans, lengthAt[a]);
    }

    return ans;
  }
};",1218
1217,"class Solution {
 public:
  int getMaximumGold(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || j < 0 || i == grid.size() || j == grid[0].size())
      return 0;
    if (grid[i][j] == 0)
      return 0;

    const int gold = grid[i][j];
    grid[i][j] = 0;  // Mark as visited.
    const int maxPath = max({dfs(grid, i + 1, j), dfs(grid, i - 1, j),
                             dfs(grid, i, j + 1), dfs(grid, i, j - 1)});
    grid[i][j] = gold;
    return gold + maxPath;
  }
};",1219
1218,"class Solution:
  def countVowelPermutation(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}

    for _ in range(n - 1):
      newDp = {'a': dp['e'] + dp['i'] + dp['u'],
               'e': dp['a'] + dp['i'],
               'i': dp['e'] + dp['o'],
               'o': dp['i'],
               'u': dp['i'] + dp['o']}
      dp = newDp

    return sum(dp.values()) % kMod",1220
1219,"class Solution {
 public:
  int balancedStringSplit(string s) {
    int ans = 0;
    int count = 0;

    for (const char c : s) {
      count += c == 'L' ? 1 : -1;
      if (count == 0)
        ++ans;
    }

    return ans;
  }
};",1221
1220,"class Solution {
 public:
  vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens,
                                          vector<int>& king) {
    vector<vector<int>> ans;
    unordered_set<int> queensSet;

    for (vector<int>& queen : queens)
      queensSet.insert(hash(queen[0], queen[1]));

    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};
    for (vector<int> d : directions)
      for (int i = king[0] + d[0], j = king[1] + d[1];
           0 <= i && i < 8 && 0 <= j && j < 8; i += d[0], j += d[1])
        if (queensSet.count(hash(i, j))) {
          ans.push_back({i, j});
          break;
        }

    return ans;
  }

 private:
  int hash(int i, int j) {
    return i * 8 + j;
  }
};",1222
1221,"class Solution:
  def dieSimulator(self, n: int, rollMax: List[int]) -> int:
    kMaxRolls = 15
    kMod = 1_000_000_007

    dp = [[[0] * (kMaxRolls + 1) for j in range(6)] for i in range(n + 1)]

    for num in range(6):
      dp[1][num][1] = 1

    for i in range(2, n + 1):
      for currNum in range(6):
        for prevNum in range(6):
          for k in range(1, 15 + 1):
            if prevNum != currNum:
              dp[i][currNum][1] = (
                  dp[i][currNum][1] + dp[i - 1][prevNum][k]) % kMod
            elif k < rollMax[currNum]:
              dp[i][currNum][k + 1] = dp[i - 1][currNum][k]

    ans = 0

    for num in range(6):
      for k in range(1, 15 + 1):
        ans += dp[n][num][k]

    return ans % kMod",1223
1222,"class Solution {
 public:
  int maxEqualFreq(vector<int>& nums) {
    int ans = 0;
    int maxFreq = 0;
    unordered_map<int, int> count;
    unordered_map<int, int> freq;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      --freq[count[num]];
      ++count[num];
      ++freq[count[num]];
      maxFreq = max(maxFreq, count[num]);
      if (maxFreq == 1 || maxFreq * freq[maxFreq] == i ||
          (maxFreq - 1) * (freq[maxFreq - 1] + 1) == i)
        ans = i + 1;
    }

    return ans;
  }
};",1224
1223,"WITH
  RankedDatesPerState AS (
    SELECT
      'failed' AS state,
      fail_date AS `date`,
      RANK() OVER(ORDER BY fail_date) AS rank_per_state
    FROM Failed
    WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31'
    UNION ALL
    SELECT
      'succeeded' AS state,
      success_date AS `date`,
      RANK() OVER(ORDER BY success_date) AS rank_per_state
    FROM Succeeded
    WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31'
  ),
  RankedDates AS (
    SELECT
      state,
      `date`,
      rank_per_state,
      RANK() OVER(ORDER BY `date`) AS `rank`
    FROM RankedDatesPerState
  )
SELECT
  state AS period_state,
  MIN(`date`) AS start_date,
  MAX(`date`) AS end_date
FROM RankedDates
GROUP BY state, (`rank` - rank_per_state)
ORDER BY start_date",1225
1224,"class DiningPhilosophers {
  std::mutex mutex;

 public:
  void wantsToEat(int philosopher, function<void()> pickLeftFork,
                  function<void()> pickRightFork, function<void()> eat,
                  function<void()> putLeftFork, function<void()> putRightFork) {
    mutex.lock();
    pickLeftFork();
    pickRightFork();
    eat();
    putLeftFork();
    putRightFork();
    mutex.unlock();
  }
};",1226
1225,"class Solution {
 public:
  double nthPersonGetsNthSeat(int n) {
    return n == 1 ? 1 : 0.5;
  }
};",1227
1226,"class Solution {
 public:
  int missingNumber(vector<int>& arr) {
    const int n = arr.size();
    const int delta = (arr.back() - arr.front()) / n;
    int l = 0;
    int r = n - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] == arr[0] + m * delta)
        l = m + 1;
      else
        r = m;
    }

    return arr[0] + l * delta;
  }
};",1228
1227,"class Solution {
 public:
  vector<int> minAvailableDuration(vector<vector<int>>& slots1,
                                   vector<vector<int>>& slots2, int duration) {
    ranges::sort(slots1);
    ranges::sort(slots2);

    int i = 0;  // slots1's index
    int j = 0;  // slots2's index

    while (i < slots1.size() && j < slots2.size()) {
      const int start = max(slots1[i][0], slots2[j][0]);
      const int end = min(slots1[i][1], slots2[j][1]);
      if (start + duration <= end)
        return {start, start + duration};
      if (slots1[i][1] < slots2[j][1])
        ++i;
      else
        ++j;
    }

    return {};
  }
};",1229
1228,"class Solution {
 public:
  double probabilityOfHeads(vector<double>& prob, int target) {
    // dp[i][j] := the probability of tossing the first i coins with j heads
    vector<vector<double>> dp(prob.size() + 1, vector<double>(target + 1));
    dp[0][0] = 1.0;

    for (int i = 1; i <= prob.size(); ++i)
      for (int j = 0; j <= target; ++j)
        dp[i][j] = (j > 0 ? dp[i - 1][j - 1] * prob[i - 1] : 0) +
                   dp[i - 1][j] * (1 - prob[i - 1]);

    return dp[prob.size()][target];
  }
};",1230
1229,"class Solution {
 public:
  int maximizeSweetness(vector<int>& sweetness, int k) {
    int l = sweetness.size() / (k + 1);
    int r = accumulate(sweetness.begin(), sweetness.end(), 0) / (k + 1);

    while (l < r) {
      const int m = (l + r) / 2;
      if (canEat(sweetness, k, m))
        l = m + 1;
      else
        r = m;
    }

    return canEat(sweetness, k, l) ? l : l - 1;
  }

 private:
  // Returns true if can eat m sweetness (the minimum sweetness of each piece).
  bool canEat(const vector<int>& sweetness, int k, int m) {
    int pieces = 0;
    int sum = 0;  // the running sum

    for (const int s : sweetness) {
      sum += s;
      if (sum >= m) {
        if (++pieces > k)
          return true;
        sum = 0;
      }
    }

    return false;
  };
};",1231
1230,"class Solution {
 public:
  bool checkStraightLine(vector<vector<int>>& coordinates) {
    int x0 = coordinates[0][0];
    int y0 = coordinates[0][1];
    int x1 = coordinates[1][0];
    int y1 = coordinates[1][1];
    int dx = x1 - x0;
    int dy = y1 - y0;

    for (int i = 2; i < coordinates.size(); ++i) {
      int x = coordinates[i][0];
      int y = coordinates[i][1];
      if ((x - x0) * dy != (y - y0) * dx)
        return false;
    }

    return true;
  }
};",1232
1231,"class Solution {
 public:
  vector<string> removeSubfolders(vector<string>& folder) {
    vector<string> ans;
    string prev;

    ranges::sort(folder);

    for (const string& f : folder) {
      if (!prev.empty() && f.find(prev) == 0 && f[prev.length()] == '/')
        continue;
      ans.push_back(f);
      prev = f;
    }

    return ans;
  }
};",1233
1232,"class Solution {
 public:
  int balancedString(string s) {
    const int n = s.length();
    const int k = n / 4;
    int ans = n;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (int i = 0, j = 0; i < n; ++i) {
      --count[s[i]];
      while (j < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k &&
             count['R'] <= k) {
        ans = min(ans, i - j + 1);
        ++count[s[j]];
        ++j;
      }
    }

    return ans;
  }
};",1234
1233,"struct Job {
  int startTime;
  int endTime;
  int profit;
  Job(int startTime, int endTime, int profit)
      : startTime(startTime), endTime(endTime), profit(profit) {}
};

class Solution {
 public:
  int jobScheduling(vector<int>& startTime, vector<int>& endTime,
                    vector<int>& profit) {
    const int n = startTime.size();
    vector<int> mem(n + 1);
    vector<Job> jobs;

    for (int i = 0; i < n; ++i)
      jobs.emplace_back(startTime[i], endTime[i], profit[i]);

    ranges::sort(jobs, [](const Job& a, const Job& b) {
      return a.startTime < b.startTime;
    });

    // Will use binary search to find the first available start time.
    for (int i = 0; i < n; ++i)
      startTime[i] = jobs[i].startTime;

    return jobScheduling(jobs, startTime, 0, mem);
  }

 private:
  // Returns the maximum profit to schedule jobs[i..n).
  int jobScheduling(const vector<Job>& jobs, const vector<int>& startTime,
                    int i, vector<int>& mem) {
    if (i == jobs.size())
      return 0;
    if (mem[i] > 0)
      return mem[i];

    const int j = firstGreaterEqual(startTime, i + 1, jobs[i].endTime);
    const int pick = jobs[i].profit + jobScheduling(jobs, startTime, j, mem);
    const int skip = jobScheduling(jobs, startTime, i + 1, mem);
    return mem[i] = max(pick, skip);
  }

  int firstGreaterEqual(const vector<int>& A, int startFrom, int target) {
    return lower_bound(A.begin() + startFrom, A.end(), target) - A.begin();
  }
};",1235
1234,"/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);

    while (!q.empty()) {
      const string currUrl = q.front();
      q.pop();
      for (const string& url : htmlParser.getUrls(currUrl)) {
        if (seen.count(url))
          continue;
        if (url.find(hostname) != string::npos) {
          q.push(url);
          seen.insert(url);
        }
      }
    }

    return {seen.begin(), seen.end()};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};",1236
1235,"class Solution {
 public:
  vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {
    vector<vector<int>> ans;
    int x = 1;
    int y = 1000;

    while (x <= 1000 && y >= 1) {
      int f = customfunction.f(x, y);
      if (f < z)
        ++x;
      else if (f > z)
        --y;
      else
        ans.push_back({x++, y--});
    }

    return ans;
  }
};",1237
1236,"class Solution {
 public:
  vector<int> circularPermutation(int n, int start) {
    vector<int> ans;

    for (int i = 0; i < 1 << n; ++i)
      ans.push_back(start ^ i ^ i >> 1);

    return ans;
  }
};",1238
1237,"class Solution {
 public:
  int maxLength(vector<string>& arr) {
    vector<int> masks;

    for (const string& s : arr) {
      const int mask = getMask(s);
      if (mask != -1)
        masks.push_back(mask);
    }

    return dfs(masks, 0, /*used=*/0);
  }

 private:
  int dfs(const vector<int>& masks, int s, int used) {
    int res = __builtin_popcount(used);
    for (int i = s; i < masks.size(); ++i)
      if ((used & masks[i]) == 0)
        res = max(res, dfs(masks, i + 1, used | masks[i]));
    return res;
  }

  int getMask(const string& s) {
    int mask = 0;
    for (const char c : s) {
      const int i = c - 'a';
      if ((mask & (1 << i)) != 0)
        return -1;
      mask |= 1 << i;
    }
    return mask;
  }
};",1239
1238,"class Solution {
 public:
  int tilingRectangle(int n, int m) {
    unordered_map<long, int> mem;
    return tilingRectangle(n, m, 0, /*heights=*/vector<int>(m), mem);
  }

 private:
  static constexpr int kBase = 13;

  int tilingRectangle(int n, int m, long hashedHeights, vector<int>&& heights,
                      unordered_map<long, int>& mem) {
    if (const auto it = mem.find(hashedHeights); it != mem.cend())
      return it->second;

    const auto it = ranges::min_element(heights);
    const int minHeight = *it;
    if (minHeight == n)  // All filled.
      return 0;

    int ans = m * n;
    const int start = it - heights.begin();
    // Try to put square of different size that doesn't exceed the width/height.
    for (int sz = 1; sz <= min(m - start, n - minHeight); ++sz) {
      // heights[start..start + sz) must has the same height.
      if (heights[start + sz - 1] != minHeight)
        break;
      // Put a square of size `sz` to cover heights[start..start + sz).
      for (int i = start; i < start + sz; ++i)
        heights[i] += sz;
      ans = min(ans, tilingRectangle(n, m, hash(heights), move(heights), mem));
      for (int i = start; i < start + sz; ++i)
        heights[i] -= sz;
    }

    return mem[hashedHeights] = 1 + ans;
  }

  long hash(const vector<int>& heights) {
    long hashed = 0;
    for (int i = heights.size() - 1; i >= 0; --i)
      hashed = hashed * kBase + heights[i];
    return hashed;
  }
};",1240
1239,"WITH
  Posts AS (
    SELECT DISTINCT sub_id AS post_id
    FROM Submissions
    WHERE parent_id IS NULL
  )
SELECT
  Posts.post_id,
  COUNT(DISTINCT Comments.sub_id) AS number_of_comments
FROM Posts
LEFT JOIN Submissions AS Comments
  ON (Posts.post_id = Comments.parent_id)
GROUP BY 1;",1241
1240,"/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);
    const int nThreads = std::thread::hardware_concurrency();
    vector<thread> threads;
    std::mutex mtx;
    std::condition_variable cv;

    auto t = [&]() {
      while (true) {
        unique_lock<mutex> lock(mtx);
        cv.wait_for(lock, 30ms, [&]() { return q.size(); });
        if (q.empty())
          return;
        auto cur = q.front();
        q.pop();
        lock.unlock();
        const vector<string> urls = htmlParser.getUrls(cur);
        lock.lock();
        for (const string& url : urls) {
          if (seen.count(url))
            continue;
          if (url.find(hostname) != string::npos) {
            q.push(url);
            seen.insert(url);
          }
        }
        lock.unlock();
        cv.notify_all();
      }
    };

    for (int i = 0; i < nThreads; ++i)
      threads.emplace_back(t);

    for (std::thread& t : threads)
      t.join();

    return {seen.begin(), seen.end()};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};",1242
1241,"class Solution {
 public:
  vector<int> transformArray(vector<int>& arr) {
    if (arr.size() < 3)
      return arr;

    vector<int> ans(arr.size());

    while (ans != arr) {
      ans = arr;
      for (int i = 1; i < arr.size() - 1; ++i) {
        if (ans[i - 1] > ans[i] && ans[i] < ans[i + 1])
          ++arr[i];
        else if (ans[i - 1] < ans[i] && ans[i] > ans[i + 1])
          --arr[i];
      }
    }

    return ans;
  }
};",1243
1242,"addScore(playerId: int, score: int)",1244
1243,"class Solution {
 public:
  int treeDiameter(vector<vector<int>>& edges) {
    const int n = edges.size();
    int ans = 0;
    vector<vector<int>> tree(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    maxDepth(tree, 0, -1, ans);
    return ans;
  }

 private:
  int maxDepth(const vector<vector<int>>& tree, int u, int parent, int& ans) {
    int maxDepth1 = 0;   // the maximum depth
    int maxDepth2 = -1;  // the second maximum depth

    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      const int depth = maxDepth(tree, v, u, ans);
      if (depth > maxDepth1) {
        maxDepth2 = maxDepth1;
        maxDepth1 = depth;
      } else if (depth > maxDepth2) {
        maxDepth2 = depth;
      }
    }

    ans = max(ans, maxDepth1 + maxDepth2);
    return 1 + maxDepth1;
  }
};",1245
1244,"class Solution {
 public:
  int minimumMoves(vector<int>& arr) {
    const int n = arr.size();
    // dp[i][j] := the minimum number of moves to remove all numbers from
    // arr[i..j]
    vector<vector<int>> dp(n, vector<int>(n, n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int i = 0; i + 1 < n; ++i)
      dp[i][i + 1] = arr[i] == arr[i + 1] ? 1 : 2;

    for (int d = 2; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        // Remove arr[i] and arr[j] within the move of removing
        // arr[i + 1..j - 1]
        if (arr[i] == arr[j])
          dp[i][j] = dp[i + 1][j - 1];
        // Try all the possible partitions.
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
      }

    return dp[0][n - 1];
  }
};",1246
1245,"class Solution {
 public:
  int minimumSwap(string s1, string s2) {
    // (""xx"", ""yy"") = (2 ""xy""s) -> 1 swap
    // (""yy"", ""xx"") = (2 ""yx""s) -> 1 swap
    // (""xy"", ""yx"") = (1 ""xy"" and 1 ""yx"") -> 2 swaps
    int xy = 0;  // the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'
    int yx = 0;  // the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'

    for (int i = 0; i < s1.length(); ++i) {
      if (s1[i] == s2[i])
        continue;
      if (s1[i] == 'x')
        ++xy;
      else
        ++yx;
    }

    if ((xy + yx) % 2 == 1)
      return -1;
    return xy / 2 + yx / 2 + (xy % 2 == 1 ? 2 : 0);
  }
};",1247
1246,"class Solution {
 public:
  int numberOfSubarrays(vector<int>& nums, int k) {
    return numberOfSubarraysAtMost(nums, k) -
           numberOfSubarraysAtMost(nums, k - 1);
  }

 private:
  int numberOfSubarraysAtMost(vector<int>& nums, int k) {
    int ans = 0;

    for (int l = 0, r = 0; r <= nums.size();)
      if (k >= 0) {
        ans += r - l;
        if (r == nums.size())
          break;
        if (nums[r] & 1)
          --k;
        ++r;
      } else {
        if (nums[l] & 1)
          ++k;
        ++l;
      }

    return ans;
  }
};",1248
1247,"class Solution {
 public:
  string minRemoveToMakeValid(string s) {
    stack<int> stack;  // unpaired '(' indices

    for (int i = 0; i < s.length(); ++i)
      if (s[i] == '(') {
        stack.push(i);  // Record the unpaired '(' index.
      } else if (s[i] == ')') {
        if (stack.empty())
          s[i] = '*';  // Mark the unpaired ')' as '*'.
        else
          stack.pop();  // Find a pair!
      }

    // Mark the unpaired '(' as '*'.
    while (!stack.empty())
      s[stack.top()] = '*', stack.pop();

    s.erase(remove(s.begin(), s.end(), '*'), s.end());
    return s;
  }
};",1249
1248,"class Solution {
 public:
  bool isGoodArray(vector<int>& nums) {
    int g = nums[0];

    for (const int num : nums)
      g = __gcd(g, num);

    return g == 1;
  }
};",1250
1249,"SELECT
  Prices.product_id,
  IFNULL(
    ROUND(
      SUM(Prices.price * UnitsSold.units) / SUM(UnitsSold.units),
      2
    ),
    0
  ) AS average_price
FROM Prices
LEFT JOIN UnitsSold
  ON (
    Prices.product_id = UnitsSold.product_id
    AND UnitsSold.purchase_date BETWEEN Prices.start_date AND Prices.end_date)
GROUP BY 1;",1251
1250,"class Solution {
 public:
  int oddCells(int m, int n, vector<vector<int>>& indices) {
    int ans = 0;
    // rows[i] and cols[i] :=
    //   true (flipped even times) / false (flipped odd times)
    vector<bool> rows(m);
    vector<bool> cols(n);

    for (const vector<int>& index : indices) {
      rows[index[0]] = rows[index[0]] ^ true;
      cols[index[1]] = cols[index[1]] ^ true;
    }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans += rows[i] ^ cols[j];

    return ans;
  }
};",1252
1251,"class Solution {
 public:
  vector<vector<int>> reconstructMatrix(int upper, int lower,
                                        vector<int>& colsum) {
    if (upper + lower != accumulate(colsum.begin(), colsum.end(), 0))
      return {};
    if (min(upper, lower) <
        ranges::count_if(colsum, [](int c) { return c == 2; }))
      return {};

    vector<vector<int>> ans(2, vector<int>(colsum.size()));

    for (int j = 0; j < colsum.size(); ++j)
      if (colsum[j] == 2) {
        ans[0][j] = 1;
        ans[1][j] = 1;
        --upper;
        --lower;
      }

    for (int j = 0; j < colsum.size(); ++j) {
      if (colsum[j] == 1 && upper > 0) {
        ans[0][j] = 1;
        --colsum[j];
        --upper;
      }

      if (colsum[j] == 1 && lower > 0) {
        ans[1][j] = 1;
        --lower;
      }
    }

    return ans;
  }
};",1253
1252,"class Solution {
 public:
  int closedIsland(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    // Remove the lands connected to the edge.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (grid[i][j] == 0)
            dfs(grid, i, j);

    int ans = 0;

    // Reduce to 200. Number of Islands
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          dfs(grid, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 1)
      return;

    grid[i][j] = 1;
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
  };
};",1254
1253,"class Solution {
 public:
  int maxScoreWords(vector<string>& words, vector<char>& letters,
                    vector<int>& score) {
    vector<int> count(26);
    for (const char c : letters)
      ++count[c - 'a'];
    return dfs(words, 0, count, score);
  }

 private:
  // Returns the maximum score you can get from words[s..n).
  int dfs(const vector<string>& words, int s, vector<int>& count,
          const vector<int>& score) {
    int ans = 0;
    for (int i = s; i < words.size(); ++i) {
      const int earned = useWord(words, i, count, score);
      if (earned > 0)
        ans = max(ans, earned + dfs(words, i + 1, count, score));
      unuseWord(words, i, count);
    }
    return ans;
  }

  int useWord(const vector<string>& words, int i, vector<int>& count,
              const vector<int>& score) {
    bool isValid = true;
    int earned = 0;
    for (const char c : words[i]) {
      if (--count[c - 'a'] < 0)
        isValid = false;
      earned += score[c - 'a'];
    }
    return isValid ? earned : -1;
  }

  void unuseWord(const vector<string>& words, int i, vector<int>& count) {
    for (const char c : words[i])
      ++count[c - 'a'];
  }
};",1255
1254,"class Solution {
 public:
  string encode(int num) {
    string binaryStr = bitset<30>(num + 1).to_string();
    binaryStr.erase(0, binaryStr.find_first_not_of('0'));
    return binaryStr.substr(1);
  }
};",1256
1255,"class Solution {
 public:
  string findSmallestRegion(vector<vector<string>>& regions, string region1,
                            string region2) {
    unordered_map<string, string> parent;
    unordered_set<string> ancestors;  // region1's ancestors

    for (const vector<string>& region : regions)
      for (int i = 1; i < region.size(); ++i)
        parent[region[i]] = region[0];

    // Add all the region1's ancestors.
    while (region1 != """") {
      ancestors.insert(region1);
      region1 = parent[region1];  // Region1 becomes """" in the end
    }

    // Go up from region2 until meet any of region1's ancestors.
    while (!ancestors.count(region2))
      region2 = parent[region2];

    return region2;
  }
};",1257
1256,"class Solution {
 public:
  vector<string> generateSentences(vector<vector<string>>& synonyms,
                                   string text) {
    set<string> ans;
    unordered_map<string, vector<string>> graph;
    queue<string> q{{text}};

    for (const vector<string>& synonym : synonyms) {
      const string& s = synonym[0];
      const string& t = synonym[1];
      graph[s].push_back(t);
      graph[t].push_back(s);
    }

    while (!q.empty()) {
      const string u = q.front();
      q.pop();
      ans.insert(u);
      vector<string> words = split(u);
      for (string& word : words) {
        const auto it = graph.find(word);
        if (it == graph.cend())
          continue;
        for (const string& synonym : it->second) {
          // Replace words[i] with its synonym.
          word = synonym;
          const string newText = join(words, ' ');
          if (!ans.count(newText))
            q.push(newText);
        }
      }
    }

    return {ans.begin(), ans.end()};
  }

 private:
  vector<string> split(const string& s) {
    vector<string> words;
    istringstream iss(s);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }

  string join(const vector<string>& words, char c) {
    string joined;
    for (int i = 0; i < words.size(); ++i) {
      joined += words[i];
      if (i != words.size() - 1)
        joined += c;
    }
    return joined;
  }
};",1258
1257,"class Solution {
 public:
  int numberOfWays(int numPeople) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := the number of ways i handshakes could occure s.t. none of the
    // handshakes cross
    vector<long> dp(numPeople / 2 + 1);
    dp[0] = 1;

    for (int i = 1; i <= numPeople / 2; ++i)
      for (int j = 0; j < i; ++j) {
        dp[i] += dp[j] * dp[i - 1 - j];
        dp[i] %= kMod;
      }

    return dp[numPeople / 2];
  }
};",1259
1258,"class Solution {
 public:
  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    k %= m * n;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        const int index = (i * n + j + k) % (m * n);
        const int x = index / n;
        const int y = index % n;
        ans[x][y] = grid[i][j];
      }

    return ans;
  }
};",1260
1259,"class FindElements {
 public:
  FindElements(TreeNode* root) {
    dfs(root, 0);
  }

  bool find(int target) {
    return vals.count(target);
  }

 private:
  unordered_set<int> vals;

  void dfs(TreeNode* root, int val) {
    if (root == nullptr)
      return;

    root->val = val;
    vals.insert(val);
    dfs(root->left, val * 2 + 1);
    dfs(root->right, val * 2 + 2);
  }
};",1261
1260,"class Solution {
 public:
  int maxSumDivThree(vector<int>& nums) {
    vector<int> dp(3);  // dp[i] := the maximum sum so far s.t. sum % 3 == i

    for (const int num : nums)
      for (const int sum : vector<int>(dp))
        dp[(sum + num) % 3] = max(dp[(sum + num) % 3], sum + num);

    return dp[0];
  }
};",1262
1261,"class Solution {
 public:
  int minPushBox(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> box;
    vector<int> player;
    vector<int> target;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 'B')
          box = {i, j};
        else if (grid[i][j] == 'S')
          player = {i, j};
        else if (grid[i][j] == 'T')
          target = {i, j};

    int ans = 0;
    // (boxX, boxY, playerX, playerY)
    queue<tuple<int, int, int, int>> q{
        {{box[0], box[1], player[0], player[1]}}};
    vector<vector<vector<vector<bool>>>> seen(
        m, vector<vector<vector<bool>>>(
               n, vector<vector<bool>>(m, vector<bool>(n))));
    seen[box[0]][box[1]][player[0]][player[1]] = true;

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [boxX, boxY, playerX, playerY] = q.front();
        q.pop();
        if (boxX == target[0] && boxY == target[1])
          return ans;
        for (const auto& [dx, dy] : dirs) {
          const int nextBoxX = boxX + dx;
          const int nextBoxY = boxY + dy;
          if (isInvalid(grid, nextBoxX, nextBoxY))
            continue;
          if (seen[nextBoxX][nextBoxY][boxX][boxY])
            continue;
          const int fromX = boxX + dirs[(k + 2) % 4];
          const int fromY = boxY + dirs[(k + 3) % 4];
          if (isInvalid(grid, fromX, fromY))
            continue;
          if (canGoTo(grid, playerX, playerY, fromX, fromY, boxX, boxY)) {
            seen[nextBoxX][nextBoxY][boxX][boxY] = true;
            q.emplace(nextBoxX, nextBoxY, boxX, boxY);
          }
        }
      }
      ++ans;
    }

    return -1;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  // Returns true if (playerX, playerY) can go to (fromX, fromY).
  bool canGoTo(const vector<vector<char>>& grid, int playerX, int playerY,
               int fromX, int fromY, int boxX, int boxY) {
    queue<pair<int, int>> q{{{playerX, playerY}}};
    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));
    seen[playerX][playerY] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      if (i == fromX && j == fromY)
        return true;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (isInvalid(grid, x, y))
          continue;
        if (seen[x][y])
          continue;
        if (x == boxX && y == boxY)
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

  bool isInvalid(const vector<vector<char>>& grid, int playerX, int playerY) {
    return playerX < 0 || playerX == grid.size() || playerY < 0 ||
           playerY == grid[0].size() || grid[playerX][playerY] == '#';
  }
};",1263
1262,"WITH
  UserToFriends AS (
    SELECT user1_id AS user_id, user2_id AS friend_id FROM Friendship
    UNION ALL
    SELECT user2_id AS user_id, user1_id AS friend_id FROM friendship
  )
SELECT FriendLikes.page_id AS recommended_page
FROM UserToFriends
LEFT JOIN Likes AS FriendLikes
  ON (UserToFriends.friend_id = FriendLikes.user_id)
LEFT JOIN Likes AS UserLikes
  ON (
    UserToFriends.user_id = UserLikes.user_id
    AND FriendLikes.page_id = UserLikes.page_id)
WHERE
  UserToFriends.user_id = 1
  AND UserLikes.page_id IS NULL
  AND FriendLikes.page_id IS NOT NULL
GROUP BY 1;",1264
1263,"/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 *  public:
 *   void printValue(); // Print the value of the node.
 *   ImmutableListNode* getNext(); // Returns the next node.
 * };
 */

class Solution {
 public:
  void printLinkedListInReverse(ImmutableListNode* head) {
    if (head == nullptr)
      return;

    printLinkedListInReverse(head->getNext());
    head->printValue();
  }
};",1265
1264,"class Solution {
 public:
  int minTimeToVisitAllPoints(vector<vector<int>>& points) {
    int ans = 0;

    for (int i = 1; i < points.size(); ++i)
      ans += max(abs(points[i][0] - points[i - 1][0]),
                 abs(points[i][1] - points[i - 1][1]));

    return ans;
  }
};",1266
1265,"class Solution {
 public:
  int countServers(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<int> rows(m);
    vector<int> cols(n);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          ++rows[i];
          ++cols[j];
        }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1 && (rows[i] > 1 || cols[j] > 1))
          ++ans;

    return ans;
  }
};",1267
1266,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<vector<string>> suggestedProducts(vector<string>& products,
                                           string searchWord) {
    vector<vector<string>> ans;

    for (const string& product : products)
      insert(product);

    shared_ptr<TrieNode> node = root;

    for (const char c : searchWord) {
      if (node == nullptr || node->children[c - 'a'] == nullptr) {
        node = nullptr;
        ans.push_back({});
        continue;
      }
      node = node->children[c - 'a'];
      ans.push_back(search(node));
    }

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  vector<string> search(shared_ptr<TrieNode> node) {
    vector<string> res;
    dfs(node, res);
    return res;
  }

  void dfs(shared_ptr<TrieNode> node, vector<string>& ans) {
    if (ans.size() == 3)
      return;
    if (node == nullptr)
      return;
    if (node->word != nullptr)
      ans.push_back(*node->word);
    for (shared_ptr<TrieNode> child : node->children)
      dfs(child, ans);
  }
};",1268
1267,"class Solution {
 public:
  int numWays(int steps, int arrLen) {
    constexpr int kMod = 1'000'000'007;
    const int n = min(arrLen, steps / 2 + 1);
    // dp[i] := the number of ways to stay at index i
    vector<long> dp(n);
    dp[0] = 1;

    while (steps--) {
      vector<long> newDp(n);
      for (int i = 0; i < n; ++i) {
        newDp[i] = dp[i];
        if (i - 1 >= 0)
          newDp[i] += dp[i - 1];
        if (i + 1 < n)
          newDp[i] += dp[i + 1];
        newDp[i] %= kMod;
      }
      dp = move(newDp);
    }

    return dp[0];
  }
};",1269
1268,"SELECT Employee.employee_id
FROM Employees AS Employee
INNER JOIN Employees AS DirectManager
  ON (Employee.manager_id = DirectManager.employee_id)
INNER JOIN Employees AS SkipManager
  ON (DirectManager.manager_id = SkipManager.employee_id)
WHERE
  SkipManager.manager_id = 1
  AND Employee.employee_id != 1;",1270
1269,"class Solution {
 public:
  string toHexspeak(string num) {
    const long n = stol(num);
    stringstream ss;
    ss << hex << uppercase << n;
    string ans(ss.str());

    for (char& c : ans) {
      if (c > '1' && c <= '9')
        return ""ERROR"";
      if (c == '0')
        c = 'O';
      else if (c == '1')
        c = 'I';
    }

    return ans;
  }
};",1271
1270,"class Solution {
 public:
  vector<vector<int>> removeInterval(vector<vector<int>>& intervals,
                                     vector<int>& toBeRemoved) {
    vector<vector<int>> ans;

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      if (a >= toBeRemoved[1] || b <= toBeRemoved[0]) {
        ans.push_back(interval);
      } else {  // a < toBeRemoved[1] && b > toBeRemoved[0]
        if (a < toBeRemoved[0])
          ans.push_back({a, toBeRemoved[0]});
        if (b > toBeRemoved[1])
          ans.push_back({toBeRemoved[1], b});
      }
    }

    return ans;
  }
};",1272
1271,"struct T {
  int sum;
  int count;
};

class Solution {
 public:
  int deleteTreeNodes(int nodes, vector<int>& parent, vector<int>& value) {
    vector<vector<int>> tree(nodes);

    for (int i = 1; i < parent.size(); ++i)
      tree[parent[i]].push_back(i);

    return dfs(tree, 0, value).count;
  }

 private:
  T dfs(const vector<vector<int>>& tree, int u, const vector<int>& value) {
    int sum = value[u];  // the root value
    int count = 1;       // this root

    for (const int v : tree[u]) {
      const T t = dfs(tree, v, value);
      sum += t.sum;
      count += t.count;
    }

    if (sum == 0)     // Delete this root.
      return {0, 0};  // So, its count = 0.
    return {sum, count};
  }
};",1273
1272,"/**
 * // This is Sea's API interface.
 * // You should not implement it, or speculate about its implementation
 * class Sea {
 *  public:
 *   bool hasShips(vector<int> topRight, vector<int> bottomLeft);
 * };
 */

class Solution {
 public:
  int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {
    if (topRight[0] < bottomLeft[0] || topRight[1] < bottomLeft[1])
      return 0;
    if (!sea.hasShips(topRight, bottomLeft))
      return 0;

    // sea.hashShips(topRight, bottomLeft) == true
    if (topRight[0] == bottomLeft[0] && topRight[1] == bottomLeft[1])
      return 1;

    const int mx = (topRight[0] + bottomLeft[0]) / 2;
    const int my = (topRight[1] + bottomLeft[1]) / 2;
    int ans = 0;
    // the top-right
    ans += countShips(sea, topRight, {mx + 1, my + 1});
    // the bottom-right
    ans += countShips(sea, {topRight[0], my}, {mx + 1, bottomLeft[1]});
    // the top-left
    ans += countShips(sea, {mx, topRight[1]}, {bottomLeft[0], my + 1});
    // the bottom-left
    ans += countShips(sea, {mx, my}, bottomLeft);
    return ans;
  }
};",1274
1273,"class Solution {
 public:
  string tictactoe(vector<vector<int>>& moves) {
    vector<vector<int>> row(2, vector<int>(3));
    vector<vector<int>> col(2, vector<int>(3));
    vector<int> diag1(2);
    vector<int> diag2(2);

    for (int i = 0; i < moves.size(); ++i) {
      int r = moves[i][0];
      int c = moves[i][1];
      int j = i % 2;
      if (++row[j][r] == 3 || ++col[j][c] == 3 || r == c && ++diag1[j] == 3 ||
          r + c == 2 && ++diag2[j] == 3)
        return j == 0 ? ""A"" : ""B"";
    }

    return moves.size() == 9 ? ""Draw"" : ""Pending"";
  }
};",1275
1274,"class Solution {
 public:
  vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {
    if (tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices ||
        tomatoSlices > cheeseSlices * 4)
      return {};

    int jumboBurgers = (tomatoSlices - 2 * cheeseSlices) / 2;

    return {jumboBurgers, cheeseSlices - jumboBurgers};
  }
};",1276
1275,"class Solution {
 public:
  int countSquares(vector<vector<int>>& matrix) {
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = 0; j < matrix[0].size(); ++j)
        if (matrix[i][j] == 1 && i > 0 && j > 0)
          matrix[i][j] +=
              min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]});
    return accumulate(matrix.begin(), matrix.end(), 0,
                      [](int a, const auto& A) {
      return a + accumulate(A.begin(), A.end(), 0);
    });
  }
};",1277
1276,"class Solution {
 public:
  int palindromePartition(string s, int k) {
    const int n = s.length();
    vector<vector<int>> mem(n + 1, vector<int>(k + 1, n));
    // cost[i][j] := the minimum cost to make s[i..j] palindrome
    vector<vector<int>> cost(n, vector<int>(n));

    for (int d = 1; d < n; ++d)
      for (int i = 0, j = d; j < n; ++i, ++j)
        cost[i][j] = (s[i] != s[j]) + cost[i + 1][j - 1];

    return palindromePartition(n, k, cost, mem);
  }

 private:
  // Returns the minimum cost to make k palindromes by s[0..i).
  int palindromePartition(int n, int k, const vector<vector<int>>& cost,
                          vector<vector<int>>& mem) {
    if (k == 1)
      return cost[0][n - 1];
    if (mem[n][k] < n)
      return mem[n][k];

    // Try all the possible partitions.
    for (int i = k - 1; i < n; ++i)
      mem[n][k] = min(
          mem[n][k], palindromePartition(i, k - 1, cost, mem) + cost[i][n - 1]);

    return mem[n][k];
  }
};",1278
1277,"class TrafficLight {
 public:
  void carArrived(
      // ID of the car
      int carId,
      // ID of the road the car travels on. Can be 1 (road A) or 2 (road B).
      int roadId,
      // direction of the car
      int direction,
      // Use turnGreen() to turn light to green on current road.
      function<void()> turnGreen,
      // Use crossCar() to make car cross the intersection.
      function<void()> crossCar

  ) {
    std::lock_guard<std::mutex> lock(mutex);
    if (canPassRoadId != roadId) {
      canPassRoadId = roadId;
      turnGreen();
    }
    crossCar();
  }

 private:
  int canPassRoadId = 1;  // 1 := road A, 2 := road B
  std::mutex mutex;
};",1279
1278,"SELECT
  Students.student_id,
  Students.student_name,
  Subjects.subject_name,
  COUNT(Examinations.student_id) AS attended_exams
FROM Students
CROSS JOIN Subjects
LEFT JOIN Examinations
  ON (
    Students.student_id = Examinations.student_id
    AND Subjects.subject_name = Examinations.subject_name)
GROUP BY 1, 2, 3
ORDER BY Students.student_id, Subjects.subject_name;",1280
1279,"class Solution {
 public:
  int subtractProductAndSum(int n) {
    int prod = 1;
    int summ = 0;

    for (; n > 0; n /= 10) {
      prod *= n % 10;
      summ += n % 10;
    }

    return prod - summ;
  }
};",1281
1280,"class Solution {
 public:
  vector<vector<int>> groupThePeople(vector<int>& groupSizes) {
    vector<vector<int>> ans;
    unordered_map<int, vector<int>> groupSizeToIndices;

    for (int i = 0; i < groupSizes.size(); ++i)
      groupSizeToIndices[groupSizes[i]].push_back(i);

    for (const auto& [groupSize, indices] : groupSizeToIndices) {
      vector<int> groupIndices;
      for (const int index : indices) {
        groupIndices.push_back(index);
        if (groupIndices.size() == groupSize) {
          ans.push_back(groupIndices);
          groupIndices.clear();
        }
      }
    }

    return ans;
  }
};",1282
1281,"class Solution {
 public:
  int smallestDivisor(vector<int>& nums, int threshold) {
    int l = 1;
    int r = ranges::max(nums);

    while (l < r) {
      const int m = (l + r) / 2;
      if (sumDivision(nums, m) <= threshold)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int sumDivision(const vector<int>& nums, int m) {
    int sum = 0;
    for (const int num : nums)
      sum += (num - 1) / m + 1;
    return sum;
  }
};",1283
1282,"class Solution {
 public:
  int minFlips(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    const int hash = getHash(mat, m, n);
    if (hash == 0)
      return 0;

    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    queue<int> q{{hash}};
    unordered_set<int> seen{hash};

    for (int step = 1; !q.empty(); ++step) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int curr = q.front();
        q.pop();
        for (int i = 0; i < m; ++i) {
          for (int j = 0; j < n; ++j) {
            int next = curr ^ 1 << (i * n + j);
            // Flie the four neighbors.
            for (const auto& [dx, dy] : dirs) {
              const int x = i + dx;
              const int y = j + dy;
              if (x < 0 || x == m || y < 0 || y == n)
                continue;
              next ^= 1 << (x * n + y);
            }
            if (next == 0)
              return step;
            if (seen.count(next))
              continue;
            q.push(next);
            seen.insert(next);
          }
        }
      }
    }

    return -1;
  }

 private:
  int getHash(const vector<vector<int>>& mat, int m, int n) {
    int hash = 0;
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j])
          hash |= 1 << (i * n + j);
    return hash;
  }
};",1284
1283,"WITH
  LogToRowNumber AS (
    SELECT
      log_id,
      ROW_NUMBER() OVER(ORDER BY log_id) AS `row_number`
    FROM Logs
  )
SELECT
  MIN(log_id) AS start_id,
  MAX(log_id) AS end_id
FROM LogToRowNumber
GROUP BY log_id - `row_number`;",1285
1284,"class CombinationIterator {
  public CombinationIterator(String characters, int combinationLength) {
    final int n = characters.length();
    final int k = combinationLength;

    // generate bitmasks from 0..00 to 1..11
    for (int bitmask = 0; bitmask < 1 << n; bitmask++) {
      // use bitmasks with k 1-bits
      if (Integer.bitCount(bitmask) == k) {
        // convert bitmask into combination
        // 111 --> ""abc"", 000 --> """"
        // 110 --> ""ab"", 101 --> ""ac"", 011 --> ""bc""
        StringBuilder curr = new StringBuilder();
        for (int j = 0; j < n; j++) {
          if ((bitmask & (1 << n - j - 1)) != 0) {
            curr.append(characters.charAt(j));
          }
        }
        combinations.push(curr.toString());
      }
    }
  }

  public String next() {
    return combinations.pop();
  }

  public boolean hasNext() {
    return (!combinations.isEmpty());
  }

  private Deque<String> combinations = new ArrayDeque<String>();
}",1286
1285,"class Solution {
 public:
  int findSpecialInteger(vector<int>& arr) {
    const int n = arr.size();
    const int quarter = n / 4;

    for (int i = 0; i < n - quarter; ++i)
      if (arr[i] == arr[i + quarter])
        return arr[i];

    throw;
  }
};",1287
1286,"class Solution {
 public:
  int removeCoveredIntervals(vector<vector<int>>& intervals) {
    // If the two intervals have the same `start`, put the one with a larger
    // `end` first.
    ranges::sort(intervals, [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });

    int ans = 0;
    int prevEnd = 0;

    for (const vector<int>& interval : intervals)
      // Current interval is not covered by the previous one.
      if (prevEnd < interval[1]) {
        ++ans;
        prevEnd = interval[1];
      }

    return ans;
  }
};",1288
1287,"class Solution {
 public:
  int minFallingPathSum(vector<vector<int>>& grid) {
    const int n = grid.size();

    for (int i = 1; i < n; ++i) {
      const vector<pair<int, int>> twoMinNumAndIndexs =
          getTwoMinNumAndIndexs(grid[i - 1]);
      const auto& [firstMinNum, firstMinIndex] = twoMinNumAndIndexs[0];
      const auto& [secondMinNum, _] = twoMinNumAndIndexs[1];
      for (int j = 0; j < n; ++j)
        if (j == firstMinIndex)
          grid[i][j] += secondMinNum;
        else
          grid[i][j] += firstMinNum;
    }

    return ranges::min(grid.back());
  }

 private:
  vector<pair<int, int>> getTwoMinNumAndIndexs(const vector<int>& A) {
    vector<pair<int, int>> numAndIndexs;

    for (int i = 0; i < A.size(); ++i)
      numAndIndexs.emplace_back(A[i], i);

    ranges::sort(numAndIndexs);
    return {numAndIndexs[0], numAndIndexs[1]};
  }
};",1289
1288,"class Solution {
 public:
  int getDecimalValue(ListNode* head) {
    int ans = 0;

    for (; head; head = head->next)
      ans = ans * 2 + head->val;

    return ans;
  }
};",1290
1289,"class Solution {
 public:
  vector<int> sequentialDigits(int low, int high) {
    vector<int> ans;
    queue<int> q{{1, 2, 3, 4, 5, 6, 7, 8, 9}};

    while (!q.empty()) {
      const int num = q.front();
      q.pop();
      if (num > high)
        return ans;
      if (low <= num && num <= high)
        ans.push_back(num);
      const int lastDigit = num % 10;
      if (lastDigit < 9)
        q.push(num * 10 + lastDigit + 1);
    }

    return ans;
  }
};",1291
1290,"class Solution {
 public:
  int maxSideLength(vector<vector<int>>& mat, int threshold) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        for (int length = ans; length < min(m - i, n - j); ++length) {
          if (squareSum(prefix, i, j, i + length, j + length) > threshold)
            break;
          ans = max(ans, length + 1);
        }

    return ans;
  }

 private:
  int squareSum(vector<vector<int>>& prefix, int r1, int c1, int r2, int c2) {
    return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] +
           prefix[r1][c1];
  }
};",1292
1291,"class Solution {
 public:
  int shortestPath(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    if (m == 1 && n == 1)
      return 0;

    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int steps = 0;
    queue<tuple<int, int, int>> q{{{0, 0, k}}};  // (i, j, eliminate)
    vector<vector<vector<bool>>> seen(
        m, vector<vector<bool>>(n, vector<bool>(k + 1)));
    seen[0][0][k] = true;

    while (!q.empty()) {
      ++steps;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j, eliminate] = q.front();
        q.pop();
        for (int l = 0; l < 4; ++l) {
          const int x = i + dirs[l];
          const int y = j + dirs[l + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (x == m - 1 && y == n - 1)
            return steps;
          if (grid[x][y] == 1 && eliminate == 0)
            continue;
          const int newEliminate = eliminate - grid[x][y];
          if (seen[x][y][newEliminate])
            continue;
          q.emplace(x, y, newEliminate);
          seen[x][y][newEliminate] = true;
        }
      }
    }

    return -1;
  }
};",1293
1292,"SELECT
  country_name,
  (
    CASE
      WHEN AVG(Weather.weather_state * 1.0) <= 15.0 THEN 'Cold'
      WHEN AVG(Weather.weather_state * 1.0) >= 25.0 THEN 'Hot'
      ELSE 'Warm'
    END
  ) AS weather_type
FROM Countries
INNER JOIN Weather
  USING (country_id)
WHERE day BETWEEN '2019-11-01' AND '2019-11-30'
GROUP BY 1;",1294
1293,"class Solution {
 public:
  int findNumbers(vector<int>& nums) {
    int ans = 0;

    for (int num : nums)
      if (9 < num && num < 100 || 999 < num && num < 10000 || num == 100000)
        ++ans;

    return ans;
  }
};",1295
1294,"class Solution {
 public:
  bool isPossibleDivide(vector<int>& nums, int k) {
    map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [start, _] : count) {
      const int value = count[start];
      if (value > 0)
        for (int i = start; i < start + k; ++i) {
          count[i] -= value;
          if (count[i] < 0)
            return false;
        }
    }

    return true;
  }
};",1296
1295,"class Solution {
 public:
  int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
    // Greedily consider strings with `minSize`, so ignore `maxSize`.
    int ans = 0;
    int letters = 0;
    vector<int> count(26);
    unordered_map<string, int> substringCount;

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r] - 'a'] == 1)
        ++letters;
      while (letters > maxLetters || r - l + 1 > minSize)
        if (--count[s[l++] - 'a'] == 0)
          --letters;
      if (r - l + 1 == minSize)
        ans = max(ans, ++substringCount[s.substr(l, minSize)]);
    }

    return ans;
  }
};",1297
1296,"class Solution {
 public:
  int maxCandies(vector<int>& status, vector<int>& candies,
                 vector<vector<int>>& keys, vector<vector<int>>& containedBoxes,
                 vector<int>& initialBoxes) {
    int ans = 0;
    queue<int> q;
    vector<bool> reachedClosedBoxes(status.size());

    auto pushBoxesIfPossible = [&status, &q,
                                &reachedClosedBoxes](const vector<int>& boxes) {
      for (const int box : boxes)
        if (status[box])
          q.push(box);
        else
          reachedClosedBoxes[box] = true;
    };

    pushBoxesIfPossible(initialBoxes);

    while (!q.empty()) {
      const int currBox = q.front();
      q.pop();

      // Add the candies.
      ans += candies[currBox];

      // Push `reachedClosedBoxes` by `key` obtained in this turn and change
      // their statuses.
      for (const int key : keys[currBox]) {
        if (!status[key] && reachedClosedBoxes[key])
          q.push(key);
        status[key] = 1;  // boxes[key] is now open.
      }

      // Push the boxes contained in `currBox`.
      pushBoxesIfPossible(containedBoxes[currBox]);
    }

    return ans;
  }
};",1298
1297,"class Solution {
 public:
  vector<int> replaceElements(vector<int>& arr) {
    int maxOfRight = -1;
    for (int i = arr.size() - 1; i >= 0; --i)
      maxOfRight = max(maxOfRight, exchange(arr[i], maxOfRight));
    return arr;
  }
};",1299
1298,"class Solution {
 public:
  int findBestValue(vector<int>& arr, int target) {
    const int n = arr.size();
    const double err = 1e-9;

    int prefix = 0;

    ranges::sort(arr);

    for (int i = 0; i < n; ++i) {
      int ans = round((target - prefix - err) / (double)(n - i));
      if (ans <= arr[i])
        return ans;
      prefix += arr[i];
    }

    return arr.back();
  }
};",1300
1299,"class Solution {
 public:
  vector<int> pathsWithMaxScore(vector<string>& board) {
    constexpr int kMod = 1'000'000'007;
    const int n = board.size();
    const vector<pair<int, int>> dirs{{0, 1}, {1, 0}, {1, 1}};
    // dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
    // count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to
    // (i, j)
    vector<vector<int>> count(n + 1, vector<int>(n + 1));

    dp[0][0] = 0;
    dp[n - 1][n - 1] = 0;
    count[n - 1][n - 1] = 1;

    for (int i = n - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        if (board[i][j] == 'S' || board[i][j] == 'X')
          continue;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (dp[i][j] < dp[x][y]) {
            dp[i][j] = dp[x][y];
            count[i][j] = count[x][y];
          } else if (dp[i][j] == dp[x][y]) {
            count[i][j] += count[x][y];
            count[i][j] %= kMod;
          }
        }
        // If there's path(s) from 'S' to (i, j) and the cell is not 'E'.
        if (dp[i][j] != -1 && board[i][j] != 'E') {
          dp[i][j] += board[i][j] - '0';
          dp[i][j] %= kMod;
        }
      }

    return {dp[0][0], count[0][0]};
  }
};",1301
1300,"class Solution {
 public:
  int deepestLeavesSum(TreeNode* root) {
    int ans = 0;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      ans = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        ans += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
    }

    return ans;
  }
};",1302
1301,"SELECT
  employee_id,
  COUNT(*) OVER(PARTITION BY team_id) AS team_size
FROM Employee;",1303
1302,"class Solution {
 public:
  vector<int> sumZero(int n) {
    vector<int> ans(n);

    for (int i = 0; i < n; ++i)
      ans[i] = i * 2 - n + 1;

    return ans;
  }
};",1304
1303,"class BSTIterator {
 public:
  BSTIterator(TreeNode* root) {
    pushLeftsUntilNull(root);
  }

  int peek() {
    return stack.top()->val;
  }

  void next() {
    TreeNode* node = stack.top();
    stack.pop();
    pushLeftsUntilNull(node->right);
  }

  bool hasNext() {
    return !stack.empty();
  }

 private:
  stack<TreeNode*> stack;

  void pushLeftsUntilNull(TreeNode* node) {
    while (node) {
      stack.push(node);
      node = node->left;
    }
  }
};

class Solution {
 public:
  vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
    vector<int> ans;
    BSTIterator bstIterator1(root1);
    BSTIterator bstIterator2(root2);

    while (bstIterator1.hasNext() && bstIterator2.hasNext())
      if (bstIterator1.peek() < bstIterator2.peek()) {
        ans.push_back(bstIterator1.peek());
        bstIterator1.next();
      } else {
        ans.push_back(bstIterator2.peek());
        bstIterator2.next();
      }

    while (bstIterator1.hasNext()) {
      ans.push_back(bstIterator1.peek());
      bstIterator1.next();
    }

    while (bstIterator2.hasNext()) {
      ans.push_back(bstIterator2.peek());
      bstIterator2.next();
    }

    return ans;
  }
};",1305
1304,"class Solution {
 public:
  bool canReach(vector<int>& arr, int start) {
    const int n = arr.size();
    queue<int> q{{start}};
    vector<bool> seen(n);

    while (!q.empty()) {
      const int node = q.front();
      q.pop();

      if (arr[node] == 0)
        return true;
      if (seen[node])
        continue;

      // Check the available next steps.
      if (node - arr[node] >= 0)
        q.push(node - arr[node]);
      if (node + arr[node] < n)
        q.push(node + arr[node]);

      seen[node] = true;
    }

    return false;
  }
};",1306
1305,"class Solution {
 public:
  bool isSolvable(vector<string>& words, string result) {
    usedDigit = vector<bool>(10);
    words.push_back(result);
    rows = words.size();
    for (const string& word : words)
      cols = max(cols, static_cast<int>(word.length()));
    return dfs(words, 0, 0, 0);
  }

 private:
  unordered_map<char, int> letterToDigit;
  vector<bool> usedDigit;
  int rows;
  int cols;

  bool dfs(vector<string>& words, int row, int col, int sum) {
    if (col == cols)
      return sum == 0;
    if (row == rows)
      return sum % 10 == 0 && dfs(words, 0, col + 1, sum / 10);

    string word = words[row];
    if (col >= word.length())
      return dfs(words, row + 1, col, sum);

    char letter = word[word.length() - col - 1];
    int sign = row == rows - 1 ? -1 : 1;

    if (const auto it = letterToDigit.find(letter);
        it != letterToDigit.cend() &&
        (it->second > 0 || col < word.length() - 1))
      return dfs(words, row + 1, col, sum + sign * letterToDigit[letter]);

    for (int digit = 0; digit < 10; ++digit)
      if (!usedDigit[digit] && (digit > 0 || col + 1 < word.length())) {
        letterToDigit[letter] = digit;
        usedDigit[digit] = true;
        if (dfs(words, row + 1, col, sum + sign * digit))
          return true;
        usedDigit[digit] = false;
        letterToDigit.erase(letter);
      }

    return false;
  }
};",1307
1306,"SELECT
  gender,
  day,
  SUM(score_points) OVER(
    PARTITION BY gender
    ORDER BY day
  ) AS total
FROM Scores
ORDER BY 1, 2;",1308
1307,"class Solution {
 public:
  string freqAlphabets(string s) {
    string ans;

    for (int i = 0; i < s.length();) {
      if (i + 2 < s.length() && s[i + 2] == '#') {
        ans += stoi(s.substr(i, 2)) + 'a' - 1;
        i += 3;
      } else {
        ans += (s[i] - '0') + 'a' - 1;
        i += 1;
      }
    }

    return ans;
  }
};",1309
1308,"class Solution {
 public:
  vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
    vector<int> ans;
    vector<int> xors(arr.size() + 1);

    for (int i = 0; i < arr.size(); ++i)
      xors[i + 1] = xors[i] ^ arr[i];

    for (const vector<int>& query : queries) {
      const int left = query[0];
      const int right = query[1];
      ans.push_back(xors[left] ^ xors[right + 1]);
    }

    return ans;
  }
};",1310
1309,"class Solution {
 public:
  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos,
                                        vector<vector<int>>& friends, int id,
                                        int level) {
    vector<string> ans;
    vector<bool> visited(friends.size());
    visited[id] = true;
    queue<int> queue{{id}};
    unordered_map<string, int> count;
    set<pair<int, string>> freqAndVideo;

    for (int i = 0; i < level; ++i)
      for (int j = queue.size(); j > 0; --j) {
        for (int f : friends[queue.front()])
          if (visited[f] == false) {
            visited[f] = true;
            queue.push(f);
          }
        queue.pop();
      }

    for (int i = queue.size(); i > 0; --i) {
      for (const string& video : watchedVideos[queue.front()])
        ++count[video];
      queue.pop();
    }

    for (const auto& [video, freq] : count)
      freqAndVideo.insert({freq, video});

    for (const auto& [_, video] : freqAndVideo)
      ans.push_back(video);

    return ans;
  }
};",1311
1310,"class Solution {
 public:
  int minInsertions(string s) {
    return s.length() - longestPalindromeSubseq(s);
  }

 private:
  // Same as 516. Longest Palindromic Subsequence
  int longestPalindromeSubseq(const string& s) {
    const int n = s.length();
    // dp[i][j] := the length of LPS(s[i..j])
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j])
          dp[i][j] = 2 + dp[i + 1][j - 1];
        else
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
};",1312
1311,"class Solution {
 public:
  vector<int> decompressRLElist(vector<int>& nums) {
    vector<int> ans;

    for (int i = 0; i < nums.size(); i += 2)
      ans.insert(ans.end(), nums[i], nums[i + 1]);

    return ans;
  }
};",1313
1312,"class Solution {
 public:
  vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    const int m = mat.size();
    const int n = mat[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        const int r1 = max(0, i - k) + 1;
        const int c1 = max(0, j - k) + 1;
        const int r2 = min(m - 1, i + k) + 1;
        const int c2 = min(n - 1, j + k) + 1;
        ans[i][j] = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] +
                    prefix[r1 - 1][c1 - 1];
      }

    return ans;
  }
};",1314
1313,"class Solution {
 public:
  int sumEvenGrandparent(TreeNode* root) {
    return dfs(root, 1, 1);  // The parent and the grandparent are odd at first.
  }

 private:
  int dfs(TreeNode* root, int p, int gp) {
    if (root == nullptr)
      return 0;
    return (gp % 2 == 0 ? root->val : 0) +  //
           dfs(root->left, root->val, p) +  //
           dfs(root->right, root->val, p);
  }
};",1315
1314,"class Solution {
 public:
  int distinctEchoSubstrings(string text) {
    unordered_set<string> seen;

    for (int k = 1; k <= text.length() / 2; ++k) {  // the target length
      int same = 0;
      for (int l = 0, r = k; r < text.length(); ++l, ++r) {
        if (text[l] == text[r])
          ++same;
        else
          same = 0;
        if (same == k) {
          seen.insert(text.substr(l - k + 1, k));
          // Move the window thus leaving a letter behind, so we need to
          // decrease the counter.
          --same;
        }
      }
    }

    return seen.size();
  }
};",1316
1315,"class Solution {
 public:
  vector<int> getNoZeroIntegers(int n) {
    for (int A = 1; A < n; ++A) {
      int B = n - A;
      if (to_string(A).find('0') == string::npos &&
          to_string(B).find('0') == string::npos)
        return {A, B};
    }

    throw;
  }
};",1317
1316,"class Solution {
 public:
  int minFlips(int a, int b, int c) {
    constexpr int kMaxBit = 30;
    int ans = 0;

    for (int i = 0; i < kMaxBit; ++i)
      if (c >> i & 1)
        ans += (a >> i & 1) == 0 && (b >> i & 1) == 0;
      else  // (c >> i & 1) == 0
        ans += (a >> i & 1) + (b >> i & 1);

    return ans;
  }
};",1318
1317,"class Solution {
 public:
  int makeConnected(int n, vector<vector<int>>& connections) {
    // To connect n nodes, we need at least n - 1 edges
    if (connections.size() < n - 1)
      return -1;

    int numOfConnected = 0;
    vector<vector<int>> graph(n);
    unordered_set<int> seen;

    for (const vector<int>& connection : connections) {
      const int u = connection[0];
      const int v = connection[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i)
      if (seen.insert(i).second) {
        dfs(graph, i, seen);
        ++numOfConnected;
      }

    return numOfConnected - 1;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u])
      if (seen.insert(v).second)
        dfs(graph, v, seen);
  }
};",1319
1318,"class Solution {
 public:
  int minimumDistance(string word) {
    vector<vector<vector<int>>> mem(
        27, vector<vector<int>>(27, vector<int>(word.length(), -1)));
    return minimumDistance(word, 26, 26, 0, mem);
  }

 private:
  // Returns the minimum distance to type `word`, where the left finger is on
  // the i-th letter, the right finger is on the j-th letter, and word[0..k)
  // have been written.
  int minimumDistance(const string& word, int i, int j, int k,
                      vector<vector<vector<int>>>& mem) {
    if (k == word.length())
      return 0;
    if (mem[i][j][k] != -1)
      return mem[i][j][k];
    const int c = word[k] - 'A';
    const int moveLeft = dist(i, c) + minimumDistance(word, c, j, k + 1, mem);
    const int moveRight = dist(j, c) + minimumDistance(word, i, c, k + 1, mem);
    return mem[i][j][k] = min(moveLeft, moveRight);
  }

  int dist(int a, int b) {
    if (a == 26)  // the first hovering state
      return 0;
    const int x1 = a / 6;
    const int y1 = a % 6;
    const int x2 = b / 6;
    const int y2 = b % 6;
    return abs(x1 - x2) + abs(y1 - y2);
  }
};",1320
1319,"WITH
  Dates AS (
    SELECT DISTINCT visited_on
    FROM Customer
    WHERE visited_on >= (
      SELECT DATE_ADD(MIN(visited_on), INTERVAL 6 DAY)
      FROM Customer
    )
  )
SELECT
  Dates.visited_on,
  SUM(Customer.amount) AS amount,
  ROUND(SUM(Customer.amount) / 7, 2) AS average_amount
FROM Dates
LEFT JOIN Customer
  ON (DATEDIFF(Dates.visited_on, Customer.visited_on) BETWEEN 0 AND 6)
GROUP BY 1;",1321
1320,"SELECT
  ad_id,
  IFNULL(
    ROUND(
      SUM(action = 'Clicked') * 100 /(SUM(action = 'Clicked') + SUM(action = 'Viewed')),
      2
    ),
    0
  ) AS ctr
FROM Ads
GROUP BY 1
ORDER BY ctr DESC, ad_id;",1322
1321,"class Solution {
 public:
  int maximum69Number(int num) {
    string ans = to_string(num);

    for (char& c : ans)
      if (c == '6') {
        c = '9';
        break;
      }

    return stoi(ans);
  }
};",1323
1322,"class Solution {
 public:
  vector<string> printVertically(string s) {
    vector<string> ans;
    vector<string> words = split(s);
    size_t maxLength = 0;

    for (const string& word : words)
      maxLength = max(maxLength, word.length());

    for (size_t i = 0; i < maxLength; ++i) {
      string row;
      for (const string& word : words)
        row += i < word.length() ? word[i] : ' ';
      while (row.back() == ' ')
        row.pop_back();
      ans.push_back(row);
    }

    return ans;
  }

 private:
  vector<string> split(const string& s) {
    vector<string> words;
    istringstream iss(s);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }
};",1324
1323,"class Solution {
 public:
  TreeNode* removeLeafNodes(TreeNode* root, int target) {
    if (root == nullptr)
      return nullptr;
    root->left = removeLeafNodes(root->left, target);
    root->right = removeLeafNodes(root->right, target);
    return isLeaf(root) && root->val == target ? nullptr : root;
  }

 private:
  bool isLeaf(TreeNode* root) {
    return root->left == nullptr && root->right == nullptr;
  }
};",1325
1324,"class Solution {
 public:
  int minTaps(int n, vector<int>& ranges) {
    vector<int> nums(n + 1);

    for (int i = 0; i <= n; ++i) {
      int l = max(0, i - ranges[i]);
      int r = min(n, i + ranges[i]);
      nums[l] = max(nums[l], r - l);
    }

    int ans = 0;
    int end = 0;
    int farthest = 0;

    for (int i = 0; i < n; i++) {
      farthest = max(farthest, i + nums[i]);
      if (i == end) {
        ++ans;
        end = farthest;
      }
    }

    return end == n ? ans : -1;
  }
};",1326
1325,"SELECT
  Products.product_name,
  SUM(Orders.unit) AS unit
FROM Products
INNER JOIN Orders
  USING (product_id)
WHERE DATE_FORMAT(Orders.order_date, '%Y-%m') = '2020-02'
GROUP BY product_id
HAVING SUM(Orders.unit) >= 100;",1327
1326,"class Solution {
 public:
  string breakPalindrome(string palindrome) {
    if (palindrome.length() == 1)
      return """";

    for (int i = 0; i < palindrome.length() / 2; ++i)
      if (palindrome[i] != 'a') {
        palindrome[i] = 'a';
        return palindrome;
      }

    palindrome.back() = 'b';
    return palindrome;
  }
};",1328
1327,"class Solution {
 public:
  vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();

    unordered_map<int, priority_queue<int>> count;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        count[i - j].push(mat[i][j]);

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j)
        mat[i][j] = count[i - j].top(), count[i - j].pop();

    return mat;
  }
};",1329
1328,"class Solution {
 public:
  int maxValueAfterReverse(vector<int>& nums) {
    int total = 0;
    int min = INT_MAX;
    int max = INT_MIN;

    for (int i = 0; i + 1 < nums.size(); ++i) {
      int a = nums[i];
      int b = nums[i + 1];
      total += abs(a - b);
      min = std::min(min, std::max(a, b));
      max = std::max(max, std::min(a, b));
    }
    int diff = std::max(0, (max - min) * 2);

    for (int i = 0; i + 1 < nums.size(); ++i) {
      int a = nums[i];
      int b = nums[i + 1];
      int headDiff = -abs(a - b) + abs(nums.front() - b);
      int tailDiff = -abs(a - b) + abs(nums.back() - a);
      diff = std::max({diff, headDiff, tailDiff});
    }

    return total + diff;
  }
};",1330
1329,"class Solution {
 public:
  vector<int> arrayRankTransform(vector<int>& arr) {
    vector<int> sortedArr(arr);
    unordered_map<int, int> rank;

    ranges::sort(sortedArr);

    for (const int a : sortedArr)
      if (!rank.count(a))
        rank[a] = rank.size() + 1;

    for (int& a : arr)
      a = rank[a];

    return arr;
  }
};",1331
1330,"class Solution {
 public:
  int removePalindromeSub(string s) {
    return equal(s.begin(), s.end(), s.rbegin()) ? 1 : 2;
  }
};",1332
1331,"class Solution {
 public:
  vector<int> filterRestaurants(vector<vector<int>>& restaurants,
                                int veganFriendly, int maxPrice,
                                int maxDistance) {
    vector<int> ans;
    vector<vector<int>> filtered;

    for (vector<int>& restaurant : restaurants)
      if (restaurant[2] >= veganFriendly && restaurant[3] <= maxPrice &&
          restaurant[4] <= maxDistance)
        filtered.push_back(restaurant);

    ranges::sort(filtered, [](const vector<int>& a, const vector<int>& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] > b[1];
    });

    for (const vector<int>& f : filtered)
      ans.push_back(f[0]);

    return ans;
  }
};",1333
1332,"class Solution {
 public:
  int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
    int ans = -1;
    int minCitiesCount = n;
    const vector<vector<int>> dist = floydWarshall(n, edges, distanceThreshold);

    for (int i = 0; i < n; ++i) {
      int citiesCount = 0;
      for (int j = 0; j < n; ++j)
        if (dist[i][j] <= distanceThreshold)
          ++citiesCount;
      if (citiesCount <= minCitiesCount) {
        ans = i;
        minCitiesCount = citiesCount;
      }
    }

    return ans;
  }

 private:
  vector<vector<int>> floydWarshall(int n, const vector<vector<int>>& edges,
                                    int distanceThreshold) {
    vector<vector<int>> dist(n, vector<int>(n, distanceThreshold + 1));

    for (int i = 0; i < n; ++i)
      dist[i][i] = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      dist[u][v] = w;
      dist[v][u] = w;
    }

    for (int k = 0; k < n; ++k)
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    return dist;
  }
};",1334
1333,"class Solution {
 public:
  int minDifficulty(vector<int>& jobDifficulty, int d) {
    const int n = jobDifficulty.size();
    if (n < d)
      return -1;

    // dp[i][k] := the minimum difficulty to schedule the first i jobs in k days
    vector<vector<int>> dp(n + 1, vector<int>(d + 1, INT_MAX / 2));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i)
      for (int k = 1; k <= d; ++k) {
        int maxDifficulty = 0;                  // max(job[j + 1..i])
        for (int j = i - 1; j >= k - 1; --j) {  // 1-based
          maxDifficulty = max(maxDifficulty, jobDifficulty[j]);  // 0-based
          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty);
        }
      }

    return dp[n][d];
  }
};",1335
1334,"WITH
  Users AS (
    SELECT
      Visits.user_id,
      Visits.visit_date,
      COUNT(Transactions.transaction_date) AS transaction_count
    FROM Visits
    LEFT JOIN Transactions
      ON (
        Visits.user_id = Transactions.user_id
        AND Visits.visit_date = Transactions.transaction_date)
    GROUP BY 1, 2
  ),
  RowNumbers AS (
    SELECT ROW_NUMBER() OVER() AS `row_number`
    FROM Transactions
    UNION ALL
    SELECT 0
  )
SELECT
  RowNumbers.`row_number` AS transactions_count,
  COUNT(Users.user_id) AS visits_count
FROM RowNumbers
LEFT JOIN Users
  ON (RowNumbers.`row_number` = Users.transaction_count)
WHERE RowNumbers.`row_number` <= (
    SELECT MAX(transaction_count) FROM Users
  )
GROUP BY 1
ORDER BY 1;",1336
1335,"class Solution {
 public:
  vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
    vector<int> ans;
    vector<vector<int>> rowSum;

    for (int i = 0; i < mat.size(); ++i)
      rowSum.push_back({accumulate(mat[i].begin(), mat[i].end(), 0), i});

    ranges::sort(rowSum, [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });

    for (int i = 0; i < k; ++i)
      ans.push_back(rowSum[i][1]);

    return ans;
  }
};",1337
1336,"class Solution {
 public:
  int minSetSize(vector<int>& arr) {
    const int n = arr.size();
    int sum = 0;
    unordered_map<int, int> map;
    vector<pair<int, int>> count;

    for (const int a : arr)
      ++map[a];

    for (const auto& [a, freq] : map)
      count.push_back(make_pair(a, freq));

    ranges::sort(count, [](const pair<int, int>& a, const pair<int, int>& b) {
      return a.second > b.second;
    });

    for (int i = 0; i < count.size(); ++i) {
      sum += count[i].second;
      if (sum >= n / 2)
        return i + 1;
    }

    throw;
  }
};",1338
1337,"class Solution {
 public:
  int maxProduct(TreeNode* root) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    vector<int> allSums;
    const long totalSum = treeSum(root, allSums);

    for (const long sum : allSums)
      ans = max(ans, sum * (totalSum - sum));

    return ans % kMod;
  }

 private:
  int treeSum(TreeNode* root, vector<int>& allSums) {
    if (root == nullptr)
      return 0;

    const int leftSum = treeSum(root->left, allSums);
    const int rightSum = treeSum(root->right, allSums);
    const int sum = root->val + leftSum + rightSum;
    allSums.push_back(sum);
    return sum;
  }
};",1339
1338,"class Solution {
 public:
  int maxJumps(vector<int>& arr, int d) {
    const int n = arr.size();
    // dp[i] := the maximum jumps starting from arr[i]
    vector<int> dp(n, 1);
    // a dcreasing stack that stores indices
    stack<int> stack;

    for (int i = 0; i <= n; ++i) {
      while (!stack.empty() && (i == n || arr[stack.top()] < arr[i])) {
        vector<int> indices{stack.top()};
        stack.pop();
        while (!stack.empty() && arr[stack.top()] == arr[indices[0]])
          indices.push_back(stack.top()), stack.pop();
        for (const int j : indices) {
          if (i < n && i - j <= d)
            // Can jump from i to j.
            dp[i] = max(dp[i], dp[j] + 1);
          if (!stack.empty() && j - stack.top() <= d)
            // Can jump from stack[-1] to j.
            dp[stack.top()] = max(dp[stack.top()], dp[j] + 1);
        }
      }
      stack.push(i);
    }

    return ranges::max(dp);
  }
};",1340
1339,"(
  SELECT Users.name AS results
  FROM MovieRating
  INNER JOIN Users
    USING (user_id)
  GROUP BY user_id
  ORDER BY COUNT(MovieRating.movie_id) DESC, Users.name
  LIMIT 1
)
UNION ALL
(
  SELECT Movies.title AS results
  FROM MovieRating
  INNER JOIN Movies
    USING (movie_id)
  WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02'
  GROUP BY movie_id
  ORDER BY AVG(MovieRating.rating) DESC, Movies.title
  LIMIT 1
);",1341
1340,"class Solution {
 public:
  int numberOfSteps(int num) {
    if (num == 0)
      return 0;
    const int subtractSteps = __builtin_popcount(num);
    const int divideSteps = 31 - __builtin_clz(num);
    return subtractSteps + divideSteps;
  }
};",1342
1341,"class Solution {
 public:
  int numOfSubarrays(vector<int>& arr, int k, int threshold) {
    int ans = 0;
    int windowSum = 0;

    for (int i = 0; i < arr.size(); ++i) {
      windowSum += arr[i];
      if (i >= k)
        windowSum -= arr[i - k];
      if (i >= k - 1 && windowSum / k >= threshold)
        ++ans;
    }

    return ans;
  }
};",1343
1342,"class Solution {
 public:
  double angleClock(int hour, int minutes) {
    const double hourHand = (hour % 12 + minutes / 60.0) * 30;
    const double minuteHand = minutes * 6;
    const double diff = abs(hourHand - minuteHand);
    return min(diff, 360 - diff);
  }
};",1344
1343,"class Solution {
 public:
  int minJumps(vector<int>& arr) {
    const int n = arr.size();
    // {a: indices}
    unordered_map<int, vector<int>> graph;
    queue<int> q{{0}};
    vector<bool> seen(n);
    seen[0] = true;

    for (int i = 0; i < n; ++i)
      graph[arr[i]].push_back(i);

    for (int step = 0; !q.empty(); ++step) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int i = q.front();
        q.pop();
        if (i == n - 1)
          return step;
        seen[i] = true;
        const int u = arr[i];
        if (i + 1 < n)
          graph[u].push_back(i + 1);
        if (i - 1 >= 0)
          graph[u].push_back(i - 1);
        for (const int v : graph[u]) {
          if (seen[v])
            continue;
          q.push(v);
        }
        graph[u].clear();
      }
    }

    throw;
  }
};",1345
1344,"class Solution {
 public:
  bool checkIfExist(vector<int>& arr) {
    unordered_set<int> seen;

    for (const int a : arr) {
      if (seen.count(a * 2) || a % 2 == 0 && seen.count(a / 2))
        return true;
      seen.insert(a);
    }

    return false;
  }
};",1346
1345,"class Solution {
 public:
  int minSteps(string s, string t) {
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (const char c : t)
      --count[c - 'a'];

    return accumulate(count.begin(), count.end(), 0,
                      [](int subtotal, int c) { return subtotal + abs(c); }) /
           2;
  }
};",1347
1346,"recordTweet(tweetName: str, time: int)",1348
1347,"class Solution {
 public:
  int maxStudents(vector<vector<char>>& seats) {
    return accumulate(
               seats.begin(), seats.end(), 0,
               [&](int a, const auto& seat) {
      return a + ranges::count(seat, '.');
               }) -
        hungarian(seats);
  }

 private:
  const vector<pair<int, int>> dirs{{-1, -1}, {0, -1}, {1, -1},
                                    {-1, 1},  {0, 1},  {1, 1}};

  int hungarian(const vector<vector<char>>& seats) {
    const int m = seats.size();
    const int n = seats[0].size();
    int count = 0;
    vector<vector<int>> seen(m, vector<int>(n));
    vector<vector<int>> match(m, vector<int>(n, -1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (seats[i][j] == '.' && match[i][j] == -1) {
          const int sessionId = i * n + j;
          seen[i][j] = sessionId;
          count += dfs(seats, i, j, sessionId, seen, match);
        }

    return count;
  }

  int dfs(const vector<vector<char>>& seats, int i, int j, int sessionId,
          vector<vector<int>>& seen, vector<vector<int>>& match) {
    const int m = seats.size();
    const int n = seats[0].size();

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (seats[x][y] != '.' || seen[x][y] == sessionId)
        continue;
      seen[x][y] = sessionId;
      if (match[x][y] == -1 || dfs(seats, match[x][y] / n, match[x][y] % n,
                                   sessionId, seen, match)) {
        match[x][y] = i * n + j;
        match[i][j] = x * n + y;
        return 1;
      }
    }

    return 0;
  }
};",1349
1348,"SELECT
  Students.id,
  Students.name
FROM Students
LEFT JOIN Departments
  ON (Students.department_id = Departments.id)
WHERE Departments.id IS NULL;",1350
1349,"class Solution {
 public:
  int countNegatives(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    int i = m - 1;
    int j = 0;

    while (i >= 0 && j < n) {
      if (grid[i][j] < 0) {
        ans += n - j;
        --i;
      } else {
        ++j;
      }
    }

    return ans;
  }
};",1351
1350,add(num: int),1352
1351,"class Solution {
 public:
  int maxEvents(vector<vector<int>>& events) {
    int ans = 0;
    int d = 0;  // the current day
    int i = 0;  // events' index
    priority_queue<int, vector<int>, greater<>> minHeap;

    ranges::sort(events);

    while (!minHeap.empty() || i < events.size()) {
      // If no events are available to attend today, let time flies to the next
      // available event.
      if (minHeap.empty())
        d = events[i][0];
      // All the events starting from today are newly available.
      while (i < events.size() && events[i][0] == d)
        minHeap.push(events[i++][1]);
      // Greedily attend the event that'll end the earliest since it has higher
      // chance can't be attended in the future.
      minHeap.pop();
      ++ans;
      ++d;
      // Pop the events that can't be attended.
      while (!minHeap.empty() && minHeap.top() < d)
        minHeap.pop();
    }

    return ans;
  }
};",1353
1352,"class Solution {
 public:
  bool isPossible(vector<int>& target) {
    if (target.size() == 1)
      return target[0] == 1;

    long sum = accumulate(target.begin(), target.end(), 0L);
    priority_queue<int> maxHeap;

    for (const int num : target)
      maxHeap.push(num);

    while (maxHeap.top() > 1) {
      const long max = maxHeap.top();
      maxHeap.pop();
      const long restSum = sum - max;
      // Only occurs if n == 2.
      if (restSum == 1)
        return true;
      const long updated = max % restSum;
      // updated == 0 (invalid) or didn't change.
      if (updated == 0 || updated == max)
        return false;
      maxHeap.push(updated);
      sum = sum - max + updated;
    }

    return true;
  }
};",1354
1353,"WITH
  RankedFriends AS (
    SELECT
      activity,
      RANK() OVER(ORDER BY COUNT(id) ASC) AS rank_asc,
      RANK() OVER(ORDER BY COUNT(id) DESC) AS rank_desc
    FROM Friends
    GROUP BY 1
  )
SELECT activity
FROM RankedFriends
WHERE rank_asc > 1 AND rank_desc > 1;",1355
1354,"class Solution {
 public:
  vector<int> sortByBits(vector<int>& arr) {
    ranges::sort(arr, [](const int a, int b) {
      const int x = bitset<32>(a).count();
      const int y = bitset<32>(b).count();
      return x == y ? a < b : x < y;
    });
    return arr;
  }
};",1356
1355,"getBill(product: List[int], amount: List[int])",1357
1356,"class Solution {
 public:
  // Similar to 3. Longest Substring Without Repeating Characters
  int numberOfSubstrings(string s) {
    int ans = 0;
    vector<int> count(3);

    int l = 0;
    for (const char c : s) {
      ++count[c - 'a'];
      while (count[0] > 0 && count[1] > 0 && count[2] > 0)
        --count[s[l++] - 'a'];
      // s[0..r], s[1..r], ..., s[l - 1..r] are satified strings.
      ans += l;
    }

    return ans;
  }
};",1358
1357,"class Solution {
 public:
  int countOrders(int n) {
    constexpr int kMod = 1'000'000'007;
    long ans = 1;

    for (int i = 1; i <= n; ++i)
      ans = ans * i * (i * 2 - 1) % kMod;

    return ans;
  }
};",1359
1358,"class Solution {
 public:
  int daysBetweenDates(string date1, string date2) {
    return abs(daysFrom1971(date1) - daysFrom1971(date2));
  }

 private:
  const vector<int> days{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

  int daysFrom1971(const string& date) {
    const int year = stoi(date1.substr(0, 4));
    const int month = stoi(date1.substr(5, 2));
    const int day = stoi(date1.substr(8, 2));
    int res = 0;
    for (int i = 1971; i < year; ++i)
      res += isLeapYear(i) ? 366 : 365;
    for (int i = 0; i < month; ++i)
      res += days[i];
    if (month > 2 && isLeapYear(year))
      ++res;
    res += day;
    return res;
  }

  bool isLeapYear(int year) {
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
  };
};",1360
1359,"class Solution {
 public:
  bool validateBinaryTreeNodes(int n, vector<int>& leftChild,
                               vector<int>& rightChild) {
    vector<int> inDegrees(n);
    int root = -1;

    // If the in-degree of any node > 1, return false.
    for (const int child : leftChild)
      if (child != -1 && ++inDegrees[child] == 2)
        return false;

    for (const int child : rightChild)
      if (child != -1 && ++inDegrees[child] == 2)
        return false;

    // Find the root (the node with in-degree == 0).
    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        if (root == -1)
          root = i;
        else
          return false;  // There're multiple roots.

    // Didn't find the root.
    if (root == -1)
      return false;

    return countNodes(root, leftChild, rightChild) == n;
  }

 private:
  int countNodes(int root, const vector<int>& leftChild,
                 const vector<int>& rightChild) {
    if (root == -1)
      return 0;
    return 1 +  //
           countNodes(leftChild[root], leftChild, rightChild) +
           countNodes(rightChild[root], leftChild, rightChild);
  }
};",1361
1360,"class Solution {
 public:
  vector<int> closestDivisors(int num) {
    for (int root = sqrt(num + 2); root > 0; --root)
      for (int cand : {num + 1, num + 2})
        if (cand % root == 0)
          return {root, cand / root};

    throw;
  }
};",1362
1361,"class Solution {
 public:
  string largestMultipleOfThree(vector<int>& digits) {
    string ans;
    vector<int> mod1{1, 4, 7, 2, 5, 8};
    vector<int> mod2{2, 5, 8, 1, 4, 7};
    vector<int> count(10);
    int sum = accumulate(digits.begin(), digits.end(), 0);

    for (const int digit : digits)
      ++count[digit];

    while (sum % 3 != 0)
      for (int i : sum % 3 == 1 ? mod1 : mod2)
        if (count[i]) {
          --count[i];
          sum -= i;
          break;
        }

    for (int digit = 9; digit >= 0; --digit)
      ans += string(count[digit], '0' + digit);

    return ans.size() && ans[0] == '0' ? ""0"" : ans;
  }
};",1363
1362,"SELECT
  Invoices.invoice_id,
  Customers.customer_name,
  Invoices.price,
  COUNT(Contacts.user_id) AS contacts_cnt,
  COUNT(CustomerEmails.email) AS trusted_contacts_cnt
FROM Invoices
INNER JOIN Customers
  ON (Invoices.user_id = Customers.customer_id)
LEFT JOIN Contacts
  ON (Customers.customer_id = Contacts.user_id)
LEFT JOIN Customers AS CustomerEmails
  ON (Contacts.contact_email = CustomerEmails.email)
GROUP BY 1
ORDER BY 1;",1364
1363,"class Solution {
 public:
  vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
    constexpr int kMax = 100;
    vector<int> ans;
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = 1; i <= kMax; ++i)
      count[i] += count[i - 1];

    for (const int num : nums)
      ans.push_back(num == 0 ? 0 : count[num - 1]);

    return ans;
  }
};",1365
1364,"struct Team {
  char name;
  vector<int> rank;
  Team(char name, int teamSize) : name(name), rank(teamSize) {}
};

class Solution {
 public:
  string rankTeams(vector<string>& votes) {
    const int teamSize = votes[0].size();
    string ans;
    vector<Team> teams;

    for (int i = 0; i < 26; ++i)
      teams.push_back(Team('A' + i, teamSize));

    for (const string& vote : votes)
      for (int i = 0; i < teamSize; ++i)
        ++teams[vote[i] - 'A'].rank[i];

    ranges::sort(teams, [](const Team& a, const Team& b) {
      return a.rank == b.rank ? a.name < b.name : a.rank > b.rank;
    });

    for (int i = 0; i < teamSize; ++i)
      ans += teams[i].name;

    return ans;
  }
};",1366
1365,"class Solution {
 public:
  bool isSubPath(ListNode* head, TreeNode* root) {
    if (root == nullptr)
      return false;
    return isContinuousSubPath(head, root) || isSubPath(head, root->left) ||
           isSubPath(head, root->right);
  }

 private:
  bool isContinuousSubPath(ListNode* head, TreeNode* root) {
    if (head == nullptr)
      return true;
    if (root == nullptr)
      return false;
    return head->val == root->val &&
           (isContinuousSubPath(head->next, root->left) ||
            isContinuousSubPath(head->next, root->right));
  }
};",1367
1366,"class Solution {
 public:
  int minCost(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> mem(m, vector<int>(n, -1));
    queue<pair<int, int>> q;

    dfs(grid, 0, 0, /*cost=*/0, q, mem);

    for (int cost = 1; !q.empty(); ++cost)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs)
          dfs(grid, i + dx, j + dy, cost, q, mem);
      }

    return mem.back().back();
  }

 private:
  const vector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

  void dfs(const vector<vector<int>>& grid, int i, int j, int cost,
           queue<pair<int, int>>& q, vector<vector<int>>& mem) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (mem[i][j] != -1)
      return;

    mem[i][j] = cost;
    q.emplace(i, j);
    const auto [dx, dy] = dirs[grid[i][j] - 1];
    dfs(grid, i + dx, j + dy, cost, q, mem);
  }
};",1368
1367,"WITH
  RankedUserActivity AS (
    SELECT
      *,
      COUNT(*) OVER(PARTITION BY username) AS `count`,
      RANK() OVER(
        PARTITION BY username
        ORDER BY endDate DESC
      ) AS `rank`
    FROM UserActivity
  )
SELECT
  username,
  activity,
  startDate,
  endDate
FROM RankedUserActivity
WHERE `count` = 1 OR `rank` = 2;",1369
1368,"class Solution {
 public:
  string sortString(string s) {
    string ans;
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    while (ans.length() < s.size()) {
      for (int i = 0; i < 26; ++i) {
        if (count[i] == 0)
          continue;
        ans += 'a' + i;
        --count[i];
      }
      for (int i = 25; i >= 0; --i) {
        if (count[i] == 0)
          continue;
        ans += 'a' + i;
        --count[i];
      }
    }

    return ans;
  }
};",1370
1369,"class Solution {
 public:
  int findTheLongestSubstring(string s) {
    constexpr string_view kVowels = ""aeiou"";
    int ans = 0;
    int prefix = 0;  // the binary prefix
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < s.length(); ++i) {
      const int index = kVowels.find(s[i]);
      if (index != -1)
        prefix ^= 1 << index;
      if (!prefixToIndex.count(prefix))
        prefixToIndex[prefix] = i;
      ans = max(ans, i - prefixToIndex[prefix]);
    }

    return ans;
  }
};",1371
1370,"struct T {
  int leftMax;
  int rightMax;
  int subtreeMax;
};

class Solution {
 public:
  int longestZigZag(TreeNode* root) {
    return dfs(root).subtreeMax;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {-1, -1, -1};
    const T left = dfs(root->left);
    const T right = dfs(root->right);
    const int leftZigZag = left.rightMax + 1;
    const int rightZigZag = right.leftMax + 1;
    const int subtreeMax =
        max({leftZigZag, rightZigZag, left.subtreeMax, right.subtreeMax});
    return {leftZigZag, rightZigZag, subtreeMax};
  }
};",1372
1371,"struct T {
  bool isBST;
  int max;
  int min;
  int sum;
  T() : isBST(false) {}
  T(bool isBST, int max, int min, int sum)
      : isBST(isBST), max(max), min(min), sum(sum) {}
};

class Solution {
 public:
  int maxSumBST(TreeNode* root) {
    int ans = 0;
    traverse(root, ans);
    return ans;
  }

 private:
  T traverse(TreeNode* root, int& ans) {
    if (root == nullptr)
      return T(true, INT_MIN, INT_MAX, 0);

    const T left = traverse(root->left, ans);
    const T right = traverse(root->right, ans);

    if (!left.isBST || !right.isBST)
      return T();
    if (root->val <= left.max || root->val >= right.min)
      return T();

    // The `root` is a valid BST.
    const int sum = root->val + left.sum + right.sum;
    ans = max(ans, sum);
    return T(true, max(root->val, right.max), min(root->val, left.min), sum);
  }
};",1373
1372,"class Solution {
 public:
  string generateTheString(int n) {
    string s(n, 'a');
    if (n % 2 == 0)
      s.back() = 'b';
    return s;
  }
};",1374
1373,"class Solution {
 public:
  int numTimesAllBlue(vector<int>& flips) {
    int ans = 0;
    int rightmost = 0;

    for (int i = 0; i < flips.size(); ++i) {
      rightmost = max(rightmost, flips[i]);
      // max(flips[0..i]) = rightmost = i + 1,
      // so flips[0..i] is a permutation of 1, 2, ..., i + 1.
      if (rightmost == i + 1)
        ++ans;
    }

    return ans;
  }
};",1375
1374,"class Solution {
 public:
  int numOfMinutes(int n, int headID, vector<int>& manager,
                   vector<int>& informTime) {
    int ans = 0;

    for (int i = 0; i < n; ++i)
      ans = max(ans, dfs(i, headID, manager, informTime, {}));

    return ans;
  }

 private:
  int dfs(int i, int headID, const vector<int>& manager,
          const vector<int>& informTime, unordered_map<int, int>&& mem) {
    if (const auto it = mem.find(i); it != mem.cend())
      return it->second;
    if (i == headID)
      return 0;

    const int parent = manager[i];
    return mem[i] = informTime[parent] +
                    dfs(parent, headID, manager, informTime, move(mem));
  }
};",1376
1375,"class Solution {
 public:
  double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
    vector<vector<int>> tree(n + 1);
    queue<int> q{{1}};
    vector<bool> seen(n + 1);
    vector<double> prob(n + 1);

    seen[1] = true;
    prob[1] = 1.0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    while (!q.empty() && t-- > 0)
      for (int sz = q.size(); sz > 0; --sz) {
        const int a = q.front();
        q.pop();
        const int nChildren =
            ranges::count_if(tree[a], [&seen](int b) { return !seen[b]; });
        for (const int b : tree[a]) {
          if (seen[b])
            continue;
          seen[b] = true;
          prob[b] = prob[a] / nChildren;
          q.push(b);
        }
        if (nChildren > 0)
          prob[a] = 0.0;
      }

    return prob[target];
  }
};",1377
1376,"SELECT
  EmployeeUNI.unique_id,
  Employees.name
FROM Employees
LEFT JOIN EmployeeUNI
  USING (id);",1378
1377,"class Solution {
 public:
  TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned,
                          TreeNode* target) {
    TreeNode* ans = nullptr;
    dfs(original, cloned, target, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* original, TreeNode* cloned, TreeNode* target,
           TreeNode*& ans) {
    if (ans != nullptr)
      return;
    if (original == nullptr)
      return;
    if (original == target) {
      ans = cloned;
      return;
    }
    dfs(original->left, cloned->left, target, ans);
    dfs(original->right, cloned->right, target, ans);
  }
};",1379
1378,"class Solution {
 public:
  vector<int> luckyNumbers(vector<vector<int>>& matrix) {
    for (const vector<int>& row : matrix) {
      const int minIndex = distance(row.begin(), ranges::min_element(row));
      if (row[minIndex] == maxNumOfColumn(matrix, minIndex))
        return {row[minIndex]};
    }
    return {};
  }

 private:
  int maxNumOfColumn(const vector<vector<int>>& matrix, int j) {
    int res = 0;
    for (int i = 0; i < matrix.size(); ++i)
      res = max(res, matrix[i][j]);
    return res;
  }
};",1380
1379,push(x: int),1381
1380,"class Solution {
 public:
  TreeNode* balanceBST(TreeNode* root) {
    vector<int> nums;
    inorder(root, nums);
    return build(nums, 0, nums.size() - 1);
  }

 private:
  void inorder(TreeNode* root, vector<int>& nums) {
    if (root == nullptr)
      return;
    inorder(root->left, nums);
    nums.push_back(root->val);
    inorder(root->right, nums);
  }

  // Same as 108. Convert Sorted Array to Binary Search Tree
  TreeNode* build(const vector<int>& nums, int l, int r) {
    if (l > r)
      return nullptr;
    const int m = (l + r) / 2;
    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));
  }
};",1382
1381,"class Solution {
 public:
  // Similar to 857. Minimum Cost to Hire K Workers
  int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency,
                     int k) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    long speedSum = 0;
    // (efficiency[i], speed[i]) sorted by efficiency[i] in descending order
    vector<pair<int, int>> A;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 0; i < n; ++i)
      A.emplace_back(efficiency[i], speed[i]);

    ranges::sort(A, greater<>());

    for (const auto& [e, s] : A) {
      minHeap.push(s);
      speedSum += s;
      if (minHeap.size() > k)
        speedSum -= minHeap.top(), minHeap.pop();
      ans = max(ans, speedSum * e);
    }

    return ans % kMod;
  }
};",1383
1382,"WITH
  Calendar AS (
    # We should be given a calendar in hand. Otherwise, assume we are oracle
    # and already know the testcase.
    SELECT '2018' AS year, '2018-01-01' AS start, '2018-12-31' AS end
    UNION ALL
    SELECT '2019' AS year, '2019-01-01' AS start, '2019-12-31' AS end
    UNION ALL
    SELECT '2020' AS year, '2020-01-01' AS start, '2020-12-31' AS end
  )
SELECT
  Product.product_id,
  Product.product_name,
  Calendar.year AS report_year,
  (
    DATEDIFF(
      LEAST(Sales.period_end, Calendar.end),
      GREATEST(Sales.period_start, Calendar.start)
    ) + 1
  ) * Sales.average_daily_sales AS total_amount
FROM Sales
INNER JOIN Calendar
  ON (Calendar.year BETWEEN YEAR(Sales.period_start) AND year(Sales.period_end))
INNER JOIN Product
  USING (product_id)
ORDER BY 1, 3;",1384
1383,"class Solution {
 public:
  int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
    int ans = 0;

    ranges::sort(arr2);

    for (const int a : arr1) {
      const auto it = lower_bound(begin(arr2), end(arr2), a);
      if ((it == arr2.end() || *it - a > d) &&
          (it == arr2.begin() || a - *prev(it) > d))
        ++ans;
    }

    return ans;
  }
};",1385
1384,"class Solution {
 public:
  int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {
    int ans = 0;
    unordered_map<int, int> rowToSeats;

    for (const vector<int>& reservedSeat : reservedSeats) {
      const int row = reservedSeat[0];
      const int seat = reservedSeat[1];
      rowToSeats[row] |= 1 << (seat - 1);
    }

    for (const auto& [_, seats] : rowToSeats)
      if ((seats & 0b0111111110) == 0)
        // Can fit 2 four-person groups.
        ans += 2;
      else if ((seats & 0b0111100000) == 0 ||  // The left is not occupied.
               (seats & 0b0001111000) == 0 ||  // The middle is not occupied.
               (seats & 0b0000011110) == 0)    // The right is notoccupied.
        // Can fit 1 four-person group.
        ans += 1;

    // Any empty row can fit 2 four-person groups.
    return ans + (n - rowToSeats.size()) * 2;
  }
};",1386
1385,"class Solution {
 public:
  int getKth(int lo, int hi, int k) {
    vector<pair<int, int>> powAndVals;  // (pow, val)

    for (int i = lo; i <= hi; ++i)
      powAndVals.emplace_back(getPow(i), i);

    nth_element(powAndVals.begin(), powAndVals.begin() + k - 1,
                powAndVals.end());
    return powAndVals[k - 1].second;
  }

 private:
  int getPow(int n) {
    if (n == 1)
      return 0;
    return 1 + (n % 2 == 0 ? getPow(n / 2) : getPow(n * 3 + 1));
  }
};",1387
1386,"class Solution:
  def maxSizeSlices(self, slices: List[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """"""
      Returns the maximum the sum of slices if you can pick k slices from
      slices[i..j).
      """"""
      if k == 1:
        return max(slices[i:j])
      # Note that j - i is not the number of all the left slices. Since you
      # Might have chosen not to take a slice in a previous step, there would be
      # Leftovers outside [i:j]. If you take slices[i], one of the slices your
      # Friends take will be outside of [i:j], so the length of [i:j] is reduced
      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only
      # Requires one slice).
      if j - i < 2 * k - 1:
        return -math.inf
      return max(slices[i] + dp(i + 2, j, k - 1),
                 dp(i + 1, j, k))

    k = len(slices) // 3
    return max(dp(0, len(slices) - 1, k),
               dp(1, len(slices), k))",1388
1387,"class Solution {
 public:
  vector<int> createTargetArray(vector<int>& nums, vector<int>& index) {
    vector<int> ans;
    for (int i = 0; i < nums.size(); ++i)
      ans.insert(ans.begin() + index[i], nums[i]);
    return ans;
  }
};",1389
1388,"class Solution {
 public:
  int sumFourDivisors(vector<int>& nums) {
    int ans = 0;

    for (int num : nums) {
      int divisor = 0;
      for (int i = 2; i * i <= num; ++i)
        if (num % i == 0) {
          if (divisor == 0)
            divisor = i;
          else {
            divisor = 0;
            break;
          }
        }
      if (divisor > 0 && divisor * divisor < num)
        ans += 1 + num + divisor + num / divisor;
    }

    return ans;
  }
};",1390
1389,"class Solution {
 public:
  bool hasValidPath(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // g := upscaled grid
    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        switch (grid[i][j]) {
          case 1:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
          case 2:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 3:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 4:
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 5:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            break;
          case 6:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
        }

    return dfs(g, 1, 1);
  }

 private:
  bool dfs(vector<vector<bool>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return false;
    if (!g[i][j])  // There's no path here.
      return false;
    if (i == g.size() - 2 && j == g[0].size() - 2)
      return true;

    g[i][j] = false;  // Mark as visited.
    return dfs(g, i + 1, j) || dfs(g, i - 1, j) || dfs(g, i, j + 1) ||
           dfs(g, i, j - 1);
  }
};",1391
1390,"class Solution {
 public:
  string longestPrefix(string s) {
    constexpr int kBase = 26;
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    int maxLength = 0;
    long pow = 1;
    long prefixHash = 0;  // the hash of s[0..i]
    long suffixHash = 0;  // the hash of s[j..n)

    for (int i = 0, j = n - 1; i < n - 1; ++i, --j) {
      prefixHash = (prefixHash * kBase + val(s[i])) % kMod;
      suffixHash = (val(s[j]) * pow + suffixHash) % kMod;
      pow = pow * kBase % kMod;
      if (prefixHash == suffixHash)
        maxLength = i + 1;
    }

    return s.substr(0, maxLength);
  }

 private:
  constexpr int val(char c) {
    return c - 'a';
  }
};",1392
1391,"SELECT
  stock_name,
  SUM(IF(operation = 'Buy', -price, price)) AS capital_gain_loss
FROM Stocks
GROUP BY 1;",1393
1392,"class Solution {
 public:
  int findLucky(vector<int>& arr) {
    vector<int> count(arr.size() + 1);

    for (const int a : arr)
      if (a <= arr.size())
        ++count[a];

    for (int i = arr.size(); i >= 1; --i)
      if (count[i] == i)
        return i;

    return -1;
  }
};",1394
1393,"class Solution {
 public:
  int numTeams(vector<int>& rating) {
    int ans = 0;

    for (int i = 1; i < rating.size() - 1; ++i) {
      // Calculate soldiers on the left with less/greater ratings.
      int leftLess = 0;
      int leftGreater = 0;
      for (int j = 0; j < i; ++j)
        if (rating[j] < rating[i])
          ++leftLess;
        else if (rating[j] > rating[i])
          ++leftGreater;
      // Calculate soldiers on the right with less/greater ratings.
      int rightLess = 0;
      int rightGreater = 0;
      for (int j = i + 1; j < rating.size(); ++j)
        if (rating[j] < rating[i])
          ++rightLess;
        else if (rating[j] > rating[i])
          ++rightGreater;
      ans += leftLess * rightGreater + leftGreater * rightLess;
    }

    return ans;
  }
};",1395
1394,"struct CheckIn {
  string stationName;
  int time;
};

struct CheckOut {
  int numTrips;
  int totalTime;
};

class UndergroundSystem {
 public:
  void checkIn(int id, string stationName, int t) {
    checkIns[id] = {stationName, t};
  }

  void checkOut(int id, string stationName, int t) {
    const auto [startStation, startTime] = checkIns[id];
    checkIns.erase(id);
    const string& route = startStation + ""->"" + stationName;
    ++checkOuts[route].numTrips;
    checkOuts[route].totalTime += t - startTime;
  }

  double getAverageTime(string startStation, string endStation) {
    const auto& [numTrips, totalTime] =
        checkOuts[startStation + ""->"" + endStation];
    return totalTime / (double)numTrips;
  }

 private:
  unordered_map<int, CheckIn> checkIns;       // {id: (stationName, time)}
  unordered_map<string, CheckOut> checkOuts;  // {route: (numTrips, totalTime)}
};",1396
1395,"class Solution {
 public:
  int findGoodStrings(int n, string s1, string s2, string evil) {
    vector<vector<vector<vector<int>>>> mem(
        n, vector<vector<vector<int>>>(
               evil.length(), vector<vector<int>>(2, vector<int>(2, -1))));
    // nextMatchedCount[i][j] := the number of next matched evil count, where
    // there're i matches with `evil` and the current letter is ('a' + j)
    vector<vector<int>> nextMatchedCount(evil.length(), vector<int>(26, -1));
    return count(s1, s2, evil, 0, 0, true, true, getLPS(evil), nextMatchedCount,
                 mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of good strings for s[i..n), where there're j matches
  // with `evil`, `isS1Prefix` indicates if the current letter is tightly bound
  // for `s1` and `isS2Prefix` indicates if the current letter is tightly bound
  // for `s2`.
  int count(const string& s1, const string& s2, const string& evil, int i,
            int matchedEvilCount, bool isS1Prefix, bool isS2Prefix,
            const vector<int>& evilLPS, vector<vector<int>>& nextMatchedCount,
            vector<vector<vector<vector<int>>>>& mem) {
    // s[0..i) contains `evil`, so don't consider any ongoing strings.
    if (matchedEvilCount == evil.length())
      return 0;
    // Run out of strings, so contribute one.
    if (i == s1.length())
      return 1;
    int& res = mem[i][matchedEvilCount][isS1Prefix][isS2Prefix];
    if (res != -1)
      return res;
    res = 0;
    const char minLetter = isS1Prefix ? s1[i] : 'a';
    const char maxLetter = isS2Prefix ? s2[i] : 'z';
    for (char c = minLetter; c <= maxLetter; ++c) {
      const int nextMatchedEvilCount = getNextMatchedEvilCount(
          nextMatchedCount, evil, matchedEvilCount, c, evilLPS);
      res += count(s1, s2, evil, i + 1, nextMatchedEvilCount,
                   isS1Prefix && c == s1[i], isS2Prefix && c == s2[i], evilLPS,
                   nextMatchedCount, mem);
      res %= kMod;
    }
    return res;
  }

  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const string& pattern) {
    vector<int> lps(pattern.length());
    for (int i = 1, j = 0; i < pattern.length(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }

  // j := the next index we're trying to match with `currLetter`
  int getNextMatchedEvilCount(vector<vector<int>>& nextMatchedCount,
                              const string& evil, int j, char currLetter,
                              const vector<int>& evilLPS) {
    int& res = nextMatchedCount[j][currLetter - 'a'];
    if (res != -1)
      return res;
    while (j > 0 && evil[j] != currLetter)
      j = evilLPS[j - 1];
    return res = (evil[j] == currLetter ? j + 1 : j);
  }
};",1397
1396,"SELECT
  customer_id,
  customer_name
FROM Customers
INNER JOIN Orders
  USING (customer_id)
GROUP BY 1
HAVING
  SUM(Orders.product_name = 'A') > 0
  AND SUM(Orders.product_name = 'B') > 0
  AND SUM(Orders.product_name = 'C') = 0;",1398
1397,"class Solution {
 public:
  int countLargestGroup(int n) {
    vector<int> count(9 * 4 + 1);
    for (int i = 1; i <= n; ++i)
      ++count[getDigitSum(i)];
    return ranges::count(count, ranges::max(count));
  }

 private:
  int getDigitSum(int num) {
    int digitSum = 0;
    while (num > 0) {
      digitSum += num % 10;
      num /= 10;
    }
    return digitSum;
  }
};",1399
1398,"class Solution {
 public:
  bool canConstruct(string s, int k) {
    // If |s| < k, we cannot construct k strings from the s.
    if (s.length() < k)
      return false;

    bitset<26> odd;

    for (const char c : s)
      odd.flip(c - 'a');

    // If the number of letters that have odd counts > k, the minimum number of
    // palindromic strings we can construct is > k.
    return odd.count() <= k;
  }
};",1400
1399,"class Solution {
 public:
  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,
                    int x2, int y2) {
    auto clamp = [&](int center, int mini, int maxi) {
      return max(mini, min(maxi, center));
    };

    // the closest point to the circle within the rectangle
    int closestX = clamp(x_center, x1, x2);
    int closestY = clamp(y_center, y1, y2);

    // the distance between the circle's center and its closest point
    int distanceX = x_center - closestX;
    int distanceY = y_center - closestY;

    // If the distance < the circle's radius, an intersection occurs.
    return (distanceX * distanceX) + (distanceY * distanceY) <=
           (radius * radius);
  }
};",1401
1400,"class Solution {
 public:
  int maxSatisfaction(vector<int>& satisfaction) {
    int ans = 0;
    int sumSatisfaction = 0;

    ranges::sort(satisfaction, greater<>());

    for (const int s : satisfaction) {
      sumSatisfaction += s;
      if (sumSatisfaction <= 0)
        return ans;
      ans += sumSatisfaction;
    }

    return ans;
  }
};",1402
1401,"class Solution {
 public:
  vector<int> minSubsequence(vector<int>& nums) {
    vector<int> ans;
    priority_queue<int> maxHeap(nums.begin(), nums.end());
    int half = accumulate(nums.begin(), nums.end(), 0) / 2;

    while (half >= 0) {
      ans.push_back(maxHeap.top());
      half -= maxHeap.top(), maxHeap.pop();
    }

    return ans;
  }
};",1403
1402,"class Solution {
 public:
  int numSteps(string s) {
    int ans = 0;

    // All the trailing 0s can be popped by 1 step.
    while (s.back() == '0') {
      s.pop_back();
      ++ans;
    }

    if (s == ""1"")
      return ans;

    // `s` is now odd, so add 1 to `s` and cost 1 step.
    ++ans;

    // All the 1s will become 0s and can be popped by 1 step.
    // All the 0s will become 1s and can be popped by 2 steps (adding 1 then
    // dividing by 2).
    for (const char c : s)
      ans += c == '1' ? 1 : 2;

    return ans;
  }
};",1404
1403,"class Solution {
 public:
  string longestDiverseString(int a, int b, int c, char A = 'a', char B = 'b',
                              char C = 'c') {
    if (a < b)
      return longestDiverseString(b, a, c, B, A, C);
    if (b < c)
      return longestDiverseString(a, c, b, A, C, B);
    if (b == 0)
      return string(min(a, 2), A);

    const int useA = min(a, 2);
    const int useB = (a - useA >= b) ? 1 : 0;
    return string(useA, A) + string(useB, B) +
           longestDiverseString(a - useA, b - useB, c, A, B, C);
  }
};",1405
1404,"class Solution {
 public:
  string stoneGameIII(vector<int>& stoneValue) {
    vector<int> mem(stoneValue.size(), INT_MIN);
    const int score = stoneGameIII(stoneValue, 0, mem);
    return score > 0 ? ""Alice"" : score < 0 ? ""Bob"" : ""Tie"";
  }

 private:
  // Returns the maximum relative score Alice can make from stoneValue[i..n).
  int stoneGameIII(const vector<int>& stoneValue, int i, vector<int>& mem) {
    if (i == stoneValue.size())
      return 0;
    if (mem[i] > INT_MIN)
      return mem[i];

    int sum = 0;
    for (int j = i; j < i + 3 && j < stoneValue.size(); ++j) {
      sum += stoneValue[j];
      mem[i] = max(mem[i], sum - stoneGameIII(stoneValue, j + 1, mem));
    }

    return mem[i];
  };
};",1406
1405,"SELECT
  Users.name,
  IFNULL(SUM(Rides.distance), 0) AS travelled_distance
FROM Users
LEFT JOIN Rides
  ON (Users.id = Rides.user_id)
GROUP BY Users.id
ORDER BY 2 DESC, 1;",1407
1406,"class Solution {
 public:
  vector<string> stringMatching(vector<string>& words) {
    vector<string> ans;
    for (const string& a : words)
      for (const string& b : words)
        if (a.length() < b.length() && b.find(a) != string::npos) {
          ans.push_back(a);
          break;
        }
    return ans;
  }
};",1408
1407,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  vector<int> processQueries(vector<int>& queries, int m) {
    vector<int> ans;
    // Map [-m, m] to [0, 2 * m].
    FenwickTree tree(2 * m + 1);
    unordered_map<int, int> numToIndex;

    for (int num = 1; num <= m; ++num) {
      numToIndex[num] = num + m;
      tree.update(num + m, 1);
    }

    int nextEmptyIndex = m;  // Map 0 to m.

    for (const int query : queries) {
      const int index = numToIndex[query];
      ans.push_back(tree.get(index - 1));
      // Move `query` from `index` to `nextEmptyIndex`.
      tree.update(index, -1);
      tree.update(nextEmptyIndex, 1);
      numToIndex[query] = nextEmptyIndex--;
    }

    return ans;
  }
};",1409
1408,"class Solution {
 public:
  string entityParser(string text) {
    const unordered_map<string, char> entityToChar{
        {""&quot;"", '""'}, {""&apos;"", '\''}, {""&amp;"", '&'},
        {""&gt;"", '>'},   {""&lt;"", '<'},    {""&frasl;"", '/'}};
    string ans;
    int j = 0;  // text[j..ampersandIndex - 1] is the pending substring.
    int ampersandIndex = -1;

    for (int i = 0; i < text.length(); ++i)
      if (text[i] == '&') {
        ampersandIndex = i;
      } else if (text[i] == ';' && ampersandIndex >= j) {
        const string sub = text.substr(ampersandIndex, i - ampersandIndex + 1);
        ans += text.substr(j, ampersandIndex - j);
        ans += getCharIfMatched(text, sub, entityToChar);
        j = i + 1;
      }

    return ans + text.substr(j);
  }

 private:
  string getCharIfMatched(const string& text, const string& sub,
                          const unordered_map<string, char>& entityToChar) {
    for (const auto& [entity, c] : entityToChar)
      if (entity == sub)
        return string(1, c);
    return sub;
  }
};",1410
1409,"class Solution {
 public:
  int numOfWays(int n) {
    constexpr int kMod = 1'000'000'007;
    long color2 = 6;  // 121, 131, 212, 232, 313, 323
    long color3 = 6;  // 123, 132, 213, 231, 312, 321

    for (int i = 1; i < n; ++i) {
      const long nextColor2 = color2 * 3 + color3 * 2;
      const long nextColor3 = color2 * 2 + color3 * 2;
      color2 = nextColor2 % kMod;
      color3 = nextColor3 % kMod;
    }

    return (color2 + color3) % kMod;
  }
};",1411
1410,"WITH
  RankedStudents AS (
    SELECT
      student_id,
      RANK() OVER(PARTITION BY exam_id ORDER BY score ASC) rank_asc,
      RANK() OVER(PARTITION BY exam_id ORDER BY score DESC) rank_desc
    FROM Exam
  )
SELECT * FROM Student
WHERE student_id IN (
  SELECT student_id FROM RankedStudents
  GROUP BY 1
  HAVING MIN(rank_asc) > 1 AND MIN(rank_desc) > 1
)
ORDER BY student_id;",1412
1411,"class Solution {
 public:
  int minStartValue(vector<int>& nums) {
    int sum = 0;
    int minSum = 0;

    for (const int num : nums)
      minSum = min(minSum, sum += num);

    return 1 - minSum;
  }
};",1413
1412,"class Solution {
 public:
  int findMinFibonacciNumbers(int k) {
    if (k < 2)  // k == 0 || k == 1
      return k;

    int a = 1;  // F_1
    int b = 1;  // F_2

    while (b <= k) {
      //    a, b = F_{i + 1}, F_{i + 2}
      // -> a, b = F_{i + 2}, F_{i + 3}
      const int temp = a;
      a = b;
      b = a + temp;
    }

    return 1 + findMinFibonacciNumbers(k - a);
  }
};",1414
1413,"class Solution {
 public:
  string getHappyString(int n, int k) {
    const unordered_map<char, string> nextLetters{
        {'a', ""bc""}, {'b', ""ac""}, {'c', ""ab""}};
    queue<string> q{{{""a"", ""b"", ""c""}}};

    while (q.front().length() != n) {
      const string u = q.front();
      q.pop();
      for (const char nextLetter : nextLetters.at(u.back()))
        q.push(u + nextLetter);
    }

    if (q.size() < k)
      return """";

    for (int i = 0; i < k - 1; ++i)
      q.pop();
    return q.front();
  }
};",1415
1414,"class Solution {
 public:
  int numberOfArrays(string s, int k) {
    vector<int> mem(s.length(), -1);
    return numberOfArrays(s, 0, k, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of arrays to restore s[i..n) with k.
  int numberOfArrays(const string& s, int i, int k, vector<int>& mem) {
    if (i == s.length())
      return 1;  // an empty string """"
    if (s[i] == '0')
      return 0;  // a leading zero
    if (mem[i] != -1)
      return mem[i];

    int res = 0;
    long num = 0;

    for (int j = i; j < s.length(); ++j) {
      num = num * 10 + (s[j] - '0');
      if (num > k)
        break;
      res = (res + numberOfArrays(s, j + 1, k, mem)) % kMod;
    }

    return mem[i] = res;
  }
};",1416
1415,"class Solution {
 public:
  string reformat(string s) {
    vector<char> A;
    vector<char> B;

    for (const char c : s)
      isalpha(c) ? A.push_back(c) : B.push_back(c);

    if (A.size() < B.size())
      swap(A, B);
    if (A.size() - B.size() > 1)
      return """";

    string ans;

    for (int i = 0; i < B.size(); ++i)
      ans += string{A[i], B[i]};

    if (A.size() > B.size())
      ans += A.back();
    return ans;
  }
};",1417
1416,"class Solution {
 public:
  vector<vector<string>> displayTable(vector<vector<string>>& orders) {
    vector<vector<string>> ans{{""Table""}};
    unordered_map<string, int> tableNumberToRowIndex;
    unordered_map<string, int> foodItemToColIndex;

    // Create the first row and column of ans.
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      // Initialize indices with 0s.
      tableNumberToRowIndex[tableNumber] = 0;
      foodItemToColIndex[foodItem] = 0;
    }
    for (const auto& [tableNumber, _] : tableNumberToRowIndex)
      ans.push_back({tableNumber});
    for (const auto& [foodItem, _] : foodItemToColIndex)
      ans[0].push_back(foodItem);

    // Sort the first row and the column, except ans[0][0].
    sort(ans[0].begin() + 1, ans[0].end());
    sort(ans.begin() + 1, ans.end(),
         [](const vector<string>& a, const vector<string>& b) {
      return stoi(a[0]) < stoi(b[0]);
    });

    // Set the indices after sorting.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      tableNumberToRowIndex[ans[i + 1][0]] = i;
    for (int i = 0; i < foodItemToColIndex.size(); ++i)
      foodItemToColIndex[ans[0][i + 1]] = i;

    // Get all the counts of each food item in each table.
    vector<vector<int>> count;
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      count.push_back(vector<int>(foodItemToColIndex.size()));
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      const int rowIndex = tableNumberToRowIndex[tableNumber];
      const int colIndex = foodItemToColIndex[foodItem];
      ++count[rowIndex][colIndex];
    }

    // Set the counts to `ans`.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      for (int j = 0; j < foodItemToColIndex.size(); ++j)
        ans[i + 1].push_back(to_string(count[i][j]));

    return ans;
  }
};",1418
1417,"class Solution {
 public:
  int minNumberOfFrogs(string croakOfFrogs) {
    const string kCroak = ""croak"";
    int ans = 0;
    int frogs = 0;
    vector<int> count(5);

    for (const char c : croakOfFrogs) {
      ++count[kCroak.find(c)];
      for (int i = 1; i < 5; ++i)
        if (count[i] > count[i - 1])
          return -1;
      if (c == 'c')
        ++frogs;
      else if (c == 'k')
        --frogs;
      ans = max(ans, frogs);
    }

    return frogs == 0 ? ans : -1;
  }
};",1419
1418,"class Solution {
 public:
  int numOfArrays(int n, int m, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j][k] := the number of ways to build an array of length i, where j
    // is the maximum number and k is `search_cost`
    vector<vector<vector<int>>> dp(
        n + 1, vector<vector<int>>(m + 1, vector<int>(k + 1)));

    for (int j = 1; j <= m; ++j)
      dp[1][j][1] = 1;

    for (int i = 2; i <= n; ++i)                 // for each length
      for (int j = 1; j <= m; ++j)               // for each max value
        for (int cost = 1; cost <= k; ++cost) {  // for each cost
          // 1. Appending any of [1, j] in the i-th position doesn't change the
          //    maximum and cost.
          dp[i][j][cost] = static_cast<long>(j) * dp[i - 1][j][cost] % kMod;
          // 2. Appending j in the i-th position makes j the new max and cost 1.
          for (int prevMax = 1; prevMax < j; ++prevMax) {
            dp[i][j][cost] += dp[i - 1][prevMax][cost - 1];
            dp[i][j][cost] %= kMod;
          }
        }

    int ans = 0;
    for (int j = 1; j <= m; ++j) {
      ans += dp[n][j][k];
      ans %= kMod;
    }
    return ans;
  }
};",1420
1419,"SELECT
  Queries.id,
  Queries.year,
  IFNULL(NPV.npv, 0) AS npv
FROM Queries
LEFT JOIN NPV
  USING (id, year);",1421
1420,"class Solution {
 public:
  int maxScore(string s) {
    int ans = 0;
    int zeros = 0;
    int ones = ranges::count(s, '1');

    for (int i = 0; i + 1 < s.size(); ++i) {
      if (s[i] == '0')
        ++zeros;
      else
        --ones;
      ans = max(ans, zeros + ones);
    }

    return ans;
  }
};",1422
1421,"class Solution {
 public:
  int maxScore(vector<int>& cardPoints, int k) {
    const int n = cardPoints.size();
    const int sum = accumulate(cardPoints.begin(), cardPoints.end(), 0);
    int windowSum =
        accumulate(cardPoints.begin(), cardPoints.begin() + n - k, 0);
    int ans = sum - windowSum;

    for (int i = 0; i < k; ++i) {
      windowSum -= cardPoints[i];
      windowSum += cardPoints[i + n - k];
      ans = max(ans, sum - windowSum);
    }

    return ans;
  }
};",1423
1422,"class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& nums) {
    vector<int> ans;
    unordered_map<int, vector<int>> keyToNums;  // key := row + column
    int maxKey = 0;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = 0; j < nums[i].size(); ++j) {
        const int key = i + j;
        keyToNums[key].push_back(nums[i][j]);
        maxKey = max(maxKey, key);
      }

    for (int i = 0; i <= maxKey; ++i)
      for (auto it = keyToNums[i].rbegin(); it != keyToNums[i].rend(); ++it)
        ans.push_back(*it);

    return ans;
  }
};",1424
1423,"class Solution {
 public:
  int constrainedSubsetSum(vector<int>& nums, int k) {
    // dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]
    vector<int> dp(nums.size());
    // dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0
    // in decreasing order.
    deque<int> dq;

    for (int i = 0; i < nums.size(); ++i) {
      if (dq.empty())
        dp[i] = nums[i];
      else
        dp[i] = max(dq.front(), 0) + nums[i];
      while (!dq.empty() && dq.back() < dp[i])
        dq.pop_back();
      dq.push_back(dp[i]);
      if (i >= k && dp[i - k] == dq.front())
        dq.pop_front();
    }

    return ranges::max(dp);
  }
};",1425
1424,"class Solution {
 public:
  int countElements(vector<int>& arr) {
    unordered_set<int> arrSet{arr.begin(), arr.end()};
    return ranges::count_if(arr,
                            [&arrSet](int a) { return arrSet.count(a + 1); });
  }
};",1426
1425,"class Solution {
 public:
  string stringShift(string s, vector<vector<int>>& shift) {
    const int n = s.length();
    int move = 0;

    for (const vector<int>& pair : shift) {
      const int direction = pair[0];
      const int amount = pair[1];
      if (direction == 0)
        move -= amount;
      else
        move += amount;
    }

    move = ((move % n) + n) % n;
    return s.substr(n - move) + s.substr(0, n - move);
  }
};",1427
1426,"/**
 * // This is the BinaryMatrix's API interface.
 * // You should not implement it, or speculate about its implementation
 * class BinaryMatrix {
 *  public:
 *   int get(int row, int col);
 *   vector<int> dimensions();
 * };
 */

class Solution {
 public:
  int leftMostColumnWithOne(BinaryMatrix& binaryMatrix) {
    const vector<int> dimensions = binaryMatrix.dimensions();
    const int m = dimensions[0];
    const int n = dimensions[1];
    int ans = -1;
    int l = 0;
    int r = n - 1;

    while (l <= r) {
      const int mid = (l + r) / 2;
      if (existOne(binaryMatrix, m, mid)) {
        ans = mid;
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }

    return ans;
  }

 private:
  bool existOne(BinaryMatrix& binaryMatrix, int m, int col) {
    for (int i = 0; i < m; ++i)
      if (binaryMatrix.get(i, col) == 1)
        return true;
    return false;
  }
};",1428
1427,showFirstUnique(),1429
1428,"class Solution {
 public:
  bool isValidSequence(TreeNode* root, vector<int>& arr) {
    return isValidSequence(root, arr, 0);
  }

 private:
  bool isValidSequence(TreeNode* root, const vector<int>& arr, int i) {
    if (root == nullptr)
      return false;
    if (i == arr.size() - 1)
      return root->val == arr[i] && root->left == nullptr &&
             root->right == nullptr;
    return root->val == arr[i] && (isValidSequence(root->left, arr, i + 1) ||
                                   isValidSequence(root->right, arr, i + 1));
  }
};",1430
1429,"class Solution {
 public:
  vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
    vector<bool> ans;
    const int maxCandy = ranges::max(candies);

    for (const int candy : candies)
      ans.push_back(candy + extraCandies >= maxCandy);

    return ans;
  }
};",1431
1430,"class Solution {
 public:
  int maxDiff(int num) {
    const string s = to_string(num);
    int firstNot9 = s.find_first_not_of('9');
    int firstNot01 = s.find_first_not_of(""01"");
    if (firstNot9 == string::npos)
      firstNot9 = 0;
    if (firstNot01 == string::npos)
      firstNot01 = 0;

    string a = s;
    string b = s;
    replace(a.begin(), a.end(), s[firstNot9], '9');
    replace(b.begin(), b.end(), s[firstNot01], firstNot01 == 0 ? '1' : '0');
    return stoi(a) - stoi(b);
  }
};",1432
1431,"class Solution {
 public:
  bool checkIfCanBreak(string s1, string s2) {
    vector<int> count1(26);
    vector<int> count2(26);

    for (const char c : s1)
      ++count1[c - 'a'];

    for (const char c : s2)
      ++count2[c - 'a'];

    return canBreak(count1, count2) || canBreak(count2, count1);
  }

 private:
  // Returns true if count1 can break count2.
  bool canBreak(const vector<int>& count1, const vector<int>& count2) {
    int diff = 0;
    for (int i = 0; i < 26; ++i) {
      diff += count2[i] - count1[i];
      // count2 is alphabetically greater than count1.
      if (diff < 0)
        return false;
    }
    return true;
  }
};",1433
1432,"class Solution {
 public:
  int numberWays(vector<vector<int>>& hats) {
    constexpr int nHats = 40;
    const int nPeople = hats.size();
    vector<vector<int>> hatToPeople(nHats + 1);
    vector<vector<int>> mem(nHats + 1, vector<int>(1 << nPeople, -1));

    for (int i = 0; i < nPeople; ++i)
      for (const int hat : hats[i])
        hatToPeople[hat].push_back(i);

    return numberWays(hats, 0, 1, hatToPeople, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of ways to assign hats 1, 2, ..., h to people, where
  // `assignment` is the bitmask of the current assignment.
  int numberWays(const vector<vector<int>>& hats, int assignment, int h,
                 const vector<vector<int>>& hatToPeople,
                 vector<vector<int>>& mem) {
    // All the people are assigned.
    if (assignment == (1 << hats.size()) - 1)
      return 1;
    if (h > 40)
      return 0;
    if (mem[h][assignment] != -1)
      return mem[h][assignment];

    // Don't wear the hat `h`.
    mem[h][assignment] = numberWays(hats, assignment, h + 1, hatToPeople, mem);

    for (const int p : hatToPeople[h]) {
      // The person `p` was assigned the hat `h` before.
      if (assignment & 1 << p)
        continue;
      // Assign the hat `h` to the person `p`.
      mem[h][assignment] +=
          numberWays(hats, assignment | 1 << p, h + 1, hatToPeople, mem);
      mem[h][assignment] %= kMod;
    }

    return mem[h][assignment];
  }
};",1434
1433,"SELECT '[0-5>' AS bin,
  SUM(duration <= 300) AS total
FROM Sessions
UNION ALL
SELECT '[5-10>' AS bin,
  SUM(
    duration > 300
    AND duration <= 600
  ) AS total
FROM Sessions
UNION ALL
SELECT '[10-15>' AS bin,
  SUM(
    duration > 600
    AND duration <= 900
  ) AS total
FROM Sessions
UNION ALL
SELECT '15 or more' AS bin,
  SUM(duration > 900) AS total
FROM Sessions",1435
1434,"class Solution:
  def destCity(self, paths: List[List[str]]) -> str:
    count = collections.Counter()

    for a, b in paths:
      count[a] += 1

    for a, b in paths:
      if b in count:
        count[b] -= 1
        if count[b] == 0:
          del count[b]
      else:
        return b",1436
1435,"class Solution:
  def kLengthApart(self, nums: List[int], k: int) -> bool:
    if k == 0:
      return True

    n = len(nums)

    curr = 0
    next = 1

    while curr < n and next < n:
      if nums[next] == 1:
        if nums[curr] == 1 and next - curr <= k:
          return False
        curr = next
      next += 1

    return True",1437
1436,"class Solution {
 public:
  int longestSubarray(vector<int>& nums, int limit) {
    int ans = 1;
    deque<int> minQ;
    deque<int> maxQ;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (!minQ.empty() && minQ.back() > nums[r])
        minQ.pop_back();
      minQ.push_back(nums[r]);
      while (!maxQ.empty() && maxQ.back() < nums[r])
        maxQ.pop_back();
      maxQ.push_back(nums[r]);
      while (maxQ.front() - minQ.front() > limit) {
        if (minQ.front() == nums[l])
          minQ.pop_front();
        if (maxQ.front() == nums[l])
          maxQ.pop_front();
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",1438
1437,"struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& mat, int k) {
    vector<int> row = mat[0];

    for (int i = 1; i < mat.size(); ++i)
      row = kSmallestPairSums(row, mat[i], k);

    return row.back();
  }

 private:
  // Similar to 373. Find K Pairs with Smallest Sums
  vector<int> kSmallestPairSums(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back(nums1[i] + nums2[j]);
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};",1439
1438,"SELECT Expressions.*,
  (
    CASE
      WHEN Expressions.operator = '<'
      AND LeftOperand.value < RightOperand.value THEN 'true'
      WHEN Expressions.operator = '>'
      AND LeftOperand.value > RightOperand.value THEN 'true'
      WHEN Expressions.operator = '='
      AND LeftOperand.value = RightOperand.value THEN 'true'
      ELSE 'false'
    END
  ) AS value
FROM Expressions
INNER JOIN VARIABLES AS LeftOperand
  ON (Expressions.left_operand = LeftOperand.name)
INNER JOIN VARIABLES AS RightOperand
  ON (Expressions.right_operand = RightOperand.name);",1440
1439,"class Solution:
  def buildArray(self, target: List[int], n: int) -> List[str]:
    ans = []
    i = 0  # Target pointer
    num = 1  # Curr num

    while i < len(target):
      t = target[i]
      if t == num:
        ans.append(""Push"")
        i += 1
      else:
        ans.append(""Push"")
        ans.append(""Pop"")
      num += 1

    return ans",1441
1440,"class Solution:
  def countTriplets(self, arr: List[int]) -> int:
    ans = 0
    xors = [0]
    prefix = 0

    for i, a in enumerate(arr):
      prefix ^= a
      xors.append(prefix)

    for j in range(1, len(arr)):
      for i in range(0, j):
        xors_i = xors[j] ^ xors[i]
        for k in range(j, len(arr)):
          xors_k = xors[k + 1] ^ xors[j]
          if xors_i == xors_k:
            ans += 1

    return ans",1442
1441,"class Solution {
 public:
  int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    return dfs(graph, 0, vector<bool>(n), hasApple);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, vector<bool>&& seen,
          const vector<bool>& hasApple) {
    seen[u] = true;
    int totalCost = 0;

    for (const int v : graph[u]) {
      if (seen[v])
        continue;
      const int cost = dfs(graph, v, move(seen), hasApple);
      if (cost > 0 || hasApple[v])
        totalCost += cost + 2;
    }

    return totalCost;
  }
};",1443
1442,"class Solution {
 public:
  int ways(vector<string>& pizza, int k) {
    const int M = pizza.size();
    const int N = pizza[0].size();
    vector<vector<vector<int>>> mem(M,
                                    vector<vector<int>>(N, vector<int>(k, -1)));
    vector<vector<int>> prefix(M + 1, vector<int>(N + 1));

    for (int i = 0; i < M; ++i)
      for (int j = 0; j < N; ++j)
        prefix[i + 1][j + 1] = (pizza[i][j] == 'A') + prefix[i][j + 1] +
                               prefix[i + 1][j] - prefix[i][j];

    return ways(0, 0, k - 1, M, N, prefix, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.
  int ways(int m, int n, int k, const int M, const int N,
           const vector<vector<int>>& prefix,
           vector<vector<vector<int>>>& mem) {
    if (k == 0)
      return hasApple(prefix, m, M, n, N) ? 1 : 0;
    if (mem[m][n][k] != -1)
      return mem[m][n][k];

    mem[m][n][k] = 0;

    for (int i = m + 1; i < M; ++i)  // Cut horizontally.
      if (hasApple(prefix, m, i, n, N) && hasApple(prefix, i, M, n, N)) {
        mem[m][n][k] += ways(i, n, k - 1, M, N, prefix, mem);
        mem[m][n][k] %= kMod;
      }

    for (int j = n + 1; j < N; ++j)  // Cut vertically.
      if (hasApple(prefix, m, M, n, j) && hasApple(prefix, m, M, j, N)) {
        mem[m][n][k] += ways(m, j, k - 1, M, N, prefix, mem);
        mem[m][n][k] %= kMod;
      }

    return mem[m][n][k];
  }

  // Returns true if pizza[row1..row2)[col1..col2) has apple.
  bool hasApple(const vector<vector<int>>& prefix, int row1, int row2, int col1,
                int col2) {
    return (prefix[row2][col2] - prefix[row1][col2] -  //
            prefix[row2][col1] + prefix[row1][col1]) > 0;
  };
};",1444
1443,"SELECT
  sale_date,
  SUM(IF(fruit = 'apples', sold_num, -sold_num)) AS diff
FROM Sales
GROUP BY 1;",1445
1444,"class Solution {
 public:
  int maxPower(string s) {
    int ans = 1;
    int count = 1;

    for (int i = 1; i < s.length(); ++i) {
      count = s[i] == s[i - 1] ? count + 1 : 1;
      ans = max(ans, count);
    }

    return ans;
  }
};",1446
1445,"class Solution {
 public:
  vector<string> simplifiedFractions(int n) {
    vector<string> ans;
    for (int denominator = 2; denominator <= n; ++denominator)
      for (int numerator = 1; numerator < denominator; ++numerator)
        if (__gcd(denominator, numerator) == 1)
          ans.push_back(to_string(numerator) + ""/"" + to_string(denominator));
    return ans;
  }
};",1447
1446,"class Solution {
 public:
  int goodNodes(TreeNode* root, int maxi = INT_MIN) {
    if (root == nullptr)
      return 0;

    const int newMax = max(maxi, root->val);
    return (root->val >= maxi) +            //
           goodNodes(root->left, newMax) +  //
           goodNodes(root->right, newMax);
  }
};",1448
1447,"class Solution {
 public:
  string largestNumber(vector<int>& cost, int target) {
    // dp[i] := the maximum length that cost i can achieve
    vector<int> dp(target + 1, INT_MIN);
    dp[0] = 0;  // If cost = 0, the best choice is the empty string """".

    for (int i = 1; i <= target; ++i)
      for (int d = 0; d < 9; ++d)
        if (i >= cost[d])
          dp[i] = max(dp[i], dp[i - cost[d]] + 1);

    if (dp[target] < 0)
      return ""0"";

    string ans;

    // Greedily build the ans string.
    for (int d = 8; d >= 0; --d)
      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {
        target -= cost[d];
        ans += '1' + d;
      }

    return ans;
  }
};",1449
1448,"class Solution {
 public:
  int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
    const int n = startTime.size();
    int ans = 0;

    for (int i = 0; i < n; ++i)
      if (startTime[i] <= queryTime && queryTime <= endTime[i])
        ++ans;

    return ans;
  }
};",1450
1449,"class Solution:
  def arrangeWords(self, text: str) -> str:
    words = text.split()
    count = collections.defaultdict(list)

    for word in words:
      count[len(word)].append(word.lower())

    c2 = OrderedDict(sorted(count.items()))

    ans = []

    for l in c2:
      for word in c2[l]:
        ans.append(word)

    ans[0] = ans[0].capitalize()

    return ' '.join(ans)",1451
1450,"class Solution:
  def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
    ans = []
    n = len(favoriteCompanies)
    companies = [set(comp) for comp in favoriteCompanies]

    for i in range(n):
      find = False
      for j in range(n):
        if i == j:
          continue
        if companies[i].issubset(companies[j]):
          find = True
          break
      if not find:
        ans.append(i)

    return ans",1452
1451,"struct Point {
  double x;
  double y;
  Point(double x, double y) : x(x), y(y) {}
};

class Solution {
 public:
  int numPoints(vector<vector<int>>& darts, int r) {
    int ans = 1;
    vector<Point> points = convertToPoints(darts);

    for (int i = 0; i < points.size(); ++i)
      for (int j = i + 1; j < points.size(); ++j)
        for (const Point& c : getCircles(points[i], points[j], r)) {
          int count = 0;
          for (const Point& point : points)
            if (dist(c, point) - r <= kErr)
              ++count;
          ans = max(ans, count);
        }

    return ans;
  }

 private:
  static constexpr double kErr = 1e-6;

  vector<Point> convertToPoints(const vector<vector<int>>& darts) {
    vector<Point> points;
    for (const vector<int>& dart : darts)
      points.emplace_back(dart[0], dart[1]);
    return points;
  }

  vector<Point> getCircles(const Point& p, const Point& q, int r) {
    if (dist(p, q) - 2.0 * r > kErr)
      return {};
    const Point m{(p.x + q.x) / 2, (p.y + q.y) / 2};
    const double distCM = sqrt(pow(r, 2) - pow(dist(p, q) / 2, 2));
    const double alpha = atan2(p.y - q.y, q.x - p.x);
    return {Point{m.x - distCM * sin(alpha), m.y - distCM * cos(alpha)},
            Point{m.x + distCM * sin(alpha), m.y + distCM * cos(alpha)}};
  }

  double dist(const Point& p, const Point& q) {
    return sqrt(pow(p.x - q.x, 2) + pow(p.y - q.y, 2));
  }
};",1453
1452,"WITH
  DistinctLogins AS (
    SELECT DISTINCT * FROM Logins
  ),
  RankedLogins AS (
    SELECT
      *,
      DENSE_RANK() OVER(
        PARTITION BY id
        ORDER BY login_date
      ) AS `rank`
    FROM DistinctLogins
  ),
  RankedLoginsWithGroupId AS (
    SELECT
      *,
      DATE_ADD(login_date, INTERVAL -`rank` DAY) AS group_id
    FROM RankedLogins
  )
SELECT DISTINCT
  id,
  Accounts.name
FROM RankedLoginsWithGroupId
INNER JOIN Accounts
  USING (id)
GROUP BY Accounts.id, RankedLoginsWithGroupId.group_id
HAVING COUNT(*) >= 5
ORDER BY 1;",1454
1453,"class Solution:
  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
    words = sentence.split()

    for i, word in enumerate(words):
      if word.startswith(searchWord):
        return i + 1

    return -1",1455
1454,"class Solution:
  def maxVowels(self, s: str, k: int) -> int:
    ans = 0
    maxi = 0
    kVowels = 'aeiou'

    for i, c in enumerate(s):
      if c in kVowels:
        maxi += 1
      if i >= k and s[i - k] in kVowels:
        maxi -= 1
      ans = max(ans, maxi)

    return ans",1456
1455,"class Solution {
 public:
  int pseudoPalindromicPaths(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int path, int& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      path ^= 1 << root->val;
      if ((path & (path - 1)) == 0)
        ++ans;
      return;
    }

    dfs(root->left, path ^ 1 << root->val, ans);
    dfs(root->right, path ^ 1 << root->val, ans);
  }
};",1457
1456,"class Solution {
 public:
  int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    // dp[i][j] := the maximum dot product of the two subsequences nums[0..i)
    // and nums2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        dp[i + 1][j + 1] = max({dp[i][j + 1], dp[i + 1][j],
                                max(0, dp[i][j]) + nums1[i] * nums2[j]});

    return dp[m][n];
  }
};",1458
1457,"SELECT
  P1.id AS p1,
  P2.id AS p2,
  ABS(p1.x_value - p2.x_value) * ABS(p1.y_value - p2.y_value) AS area
FROM Points AS P1, Points AS P2
WHERE
  P1.id < P2.id
  AND P1.x_value != P2.x_value
  AND P1.y_value != P2.y_value
ORDER BY area DESC, p1, p2;",1459
1458,"class Solution {
 public:
  bool canBeEqual(vector<int>& target, vector<int>& arr) {
    return unordered_multiset<int>(arr.begin(), arr.end()) ==
           unordered_multiset<int>(target.begin(), target.end());
  }
};",1460
1459,"class Solution {
 public:
  bool hasAllCodes(string s, int k) {
    const int n = 1 << k;
    if (s.length() < n)
      return false;

    // used[i] := true if i is a substring of `s`
    vector<bool> used(n);

    int window = k == 1 ? 0 : stoi(s.substr(0, k - 1), nullptr, 2);
    for (int i = k - 1; i < s.length(); ++i) {
      // Include the s[i].
      window = (window << 1) + (s[i] - '0');
      // Discard the s[i - k].
      window &= n - 1;
      used[window] = true;
    }

    return ranges::all_of(used, [](bool u) { return u; });
  }
};",1461
1460,"class Solution {
 public:
  vector<bool> checkIfPrerequisite(int numCourses,
                                   vector<vector<int>>& prerequisites,
                                   vector<vector<int>>& queries) {
    vector<bool> ans;
    vector<vector<int>> graph(numCourses);
    // isPrerequisite[i][j] := true if course i is a prerequisite of course j
    vector<vector<bool>> isPrerequisite(numCourses, vector<bool>(numCourses));

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[0];
      const int v = prerequisite[1];
      graph[u].push_back(v);
    }

    // DFS from every course.
    for (int i = 0; i < numCourses; ++i)
      dfs(graph, i, isPrerequisite[i]);

    for (const vector<int>& query : queries) {
      const int u = query[0];
      const int v = query[1];
      ans.push_back(isPrerequisite[u][v]);
    }

    return ans;
  }

  void dfs(const vector<vector<int>>& graph, int u, vector<bool>& used) {
    for (const int v : graph[u]) {
      if (used[v])
        continue;
      used[v] = true;
      dfs(graph, v, used);
    }
  }
};",1462
1461,"class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<vector<int>>> mem(m,
                                    vector<vector<int>>(n, vector<int>(n, -1)));
    return cherryPick(grid, 0, 0, n - 1, mem);
  }

 private:
  // Returns the maximum cherries we can collect, where the robot #1 is on
  // (x, y1) and the robot #2 is on (x, y2).
  int cherryPick(const vector<vector<int>>& grid, int x, int y1, int y2,
                 vector<vector<vector<int>>>& mem) {
    if (x == grid.size())
      return 0;
    if (y1 < 0 || y1 == grid[0].size() || y2 < 0 || y2 == grid[0].size())
      return 0;
    if (mem[x][y1][y2] != -1)
      return mem[x][y1][y2];

    const int currRow = grid[x][y1] + (y1 == y2 ? 0 : 1) * grid[x][y2];

    for (int d1 = -1; d1 <= 1; ++d1)
      for (int d2 = -1; d2 <= 1; ++d2)
        mem[x][y1][y2] =
            max(mem[x][y1][y2],
                currRow + cherryPick(grid, x + 1, y1 + d1, y2 + d2, mem));

    return mem[x][y1][y2];
  }
};",1463
1462,"class Solution {
 public:
  int maxProduct(vector<int>& nums) {
    int max1 = 0;
    int max2 = 0;

    for (const int num : nums)
      if (num > max1)
        max2 = std::exchange(max1, num);
      else if (num > max2)
        max2 = num;

    return (max1 - 1) * (max2 - 1);
  }
};",1464
1463,"class Solution {
 public:
  int maxArea(int h, int w, vector<int>& horizontalCuts,
              vector<int>& verticalCuts) {
    constexpr int kMod = 1'000'000'007;
    ranges::sort(horizontalCuts);
    ranges::sort(verticalCuts);

    // the maximum gap of each direction
    int maxGapX = max(verticalCuts[0], w - verticalCuts.back());
    int maxGapY = max(horizontalCuts[0], h - horizontalCuts.back());

    for (int i = 1; i < verticalCuts.size(); ++i)
      maxGapX = max(maxGapX, verticalCuts[i] - verticalCuts[i - 1]);

    for (int i = 1; i < horizontalCuts.size(); ++i)
      maxGapY = max(maxGapY, horizontalCuts[i] - horizontalCuts[i - 1]);

    return static_cast<long>(maxGapX) * maxGapY % kMod;
  }
};",1465
1464,"class Solution {
 public:
  int minReorder(int n, vector<vector<int>>& connections) {
    vector<vector<int>> graph(n);

    for (const vector<int>& connection : connections) {
      const int u = connection[0];
      const int v = connection[1];
      graph[u].push_back(v);
      graph[v].push_back(-u);  // - := u -> v
    }

    return dfs(graph, 0, -1);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, int parent) {
    int change = 0;

    for (const int v : graph[u]) {
      if (abs(v) == parent)
        continue;
      if (v > 0)
        ++change;
      change += dfs(graph, abs(v), u);
    }

    return change;
  }
};",1466
1465,"enum class BoxCase { kEqualBalls, kEqualDistantBalls };

class Solution {
 public:
  double getProbability(vector<int>& balls) {
    const int n = accumulate(balls.begin(), balls.end(), 0) / 2;
    return cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualDistantBalls) /
           cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualBalls);
  }

 private:
  const vector<int> fact{1, 1, 2, 6, 24, 120, 720};

  // Assume we have two boxes A and B.
  double cases(const vector<int>& balls, int i, int ballsCountA,
               int ballsCountB, int colorsCountA, int colorsCountB, int n,
               BoxCase boxCase) {
    if (ballsCountA > n || ballsCountB > n)
      return 0;
    if (i == balls.size())
      return boxCase == BoxCase::kEqualBalls ? 1 : colorsCountA == colorsCountB;

    double ans = 0;

    // balls taken from A for `balls[i]`
    for (int ballsTakenA = 0; ballsTakenA <= balls[i]; ++ballsTakenA) {
      const int ballsTakenB = balls[i] - ballsTakenA;
      const int newcolorsCountA = colorsCountA + (ballsTakenA > 0);
      const int newcolorsCountB = colorsCountB + (ballsTakenB > 0);
      ans += cases(balls, i + 1, ballsCountA + ballsTakenA,
                   ballsCountB + ballsTakenB, newcolorsCountA, newcolorsCountB,
                   n, boxCase) /
             (fact[ballsTakenA] * fact[ballsTakenB]);
    }

    return ans;
  }
};",1467
1466,"WITH
  SalariesWithMaxSalary AS (
    SELECT
      *,
      MAX(salary) OVER(PARTITION BY company_id) AS max_salary
    FROM Salaries
  )
SELECT
  company_id,
  employee_id,
  employee_name,
  ROUND(
    CASE
      WHEN max_salary < 1000 THEN salary
      WHEN max_salary BETWEEN 1000 AND 10000 THEN salary * 0.76
      ELSE salary * 0.51
    END
  ) AS salary
FROM SalariesWithMaxSalary;",1468
1467,"class Solution {
 public:
  vector<int> getLonelyNodes(TreeNode* root) {
    vector<int> ans;

    dfs(root, false, ans);

    return ans;
  }

 private:
  void dfs(TreeNode* root, bool isLonely, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (isLonely)
      ans.push_back(root->val);

    dfs(root->left, root->right == nullptr, ans);
    dfs(root->right, root->left == nullptr, ans);
  }
};",1469
1468,"class Solution {
 public:
  vector<int> shuffle(vector<int>& nums, int n) {
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
      ans.push_back(nums[i]);
      ans.push_back(nums[i + n]);
    }
    return ans;
  }
};",1470
1469,"class Solution {
 public:
  vector<int> getStrongest(vector<int>& arr, int k) {
    ranges::sort(arr);

    const int n = arr.size();
    const int median = arr[(n - 1) / 2];
    vector<int> ans;

    for (int l = 0, r = n - 1; k > 0; --k)
      if (median - arr[l] > arr[r] - median)
        ans.push_back(arr[l++]);
      else
        ans.push_back(arr[r--]);

    return ans;
  }
};",1471
1470,"class BrowserHistory {
 public:
  BrowserHistory(string homepage) {
    visit(homepage);
  }

  void visit(string url) {
    if (++index < urls.size())
      urls[index] = url;
    else
      urls.push_back(url);
    lastIndex = index;
  }

  string back(int steps) {
    index = max(0, index - steps);
    return urls[index];
  }

  string forward(int steps) {
    index = min(lastIndex, index + steps);
    return urls[index];
  }

 private:
  vector<string> urls;
  int index = -1;
  int lastIndex = -1;
};",1472
1471,"class Solution {
 public:
  int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n,
              int target) {
    vector<vector<vector<int>>> mem(target + 1,
                                    vector<vector<int>>(m, vector<int>(n + 1)));
    // Initialize `prevColor` to 0 (the virtual neighbor).
    const int c = minCost(houses, cost, m, n, target, 0, 0, mem);
    return c == kMax ? -1 : c;
  }

 private:
  static constexpr int kMax = 1'000'001;

  // Returns the minimum cost to paint houses[i..m) into k neighborhoods, where
  // there are houses[i - 1] colors = prevColor.
  int minCost(const vector<int>& houses, const vector<vector<int>>& cost,
              const int& m, const int& n, int k, int i, int prevColor,
              vector<vector<vector<int>>>& mem) {
    if (i == m || k < 0)
      return k == 0 ? 0 : kMax;
    if (mem[k][i][prevColor] > 0)
      return mem[k][i][prevColor];
    if (houses[i] > 0)  // The house was painted last year.
      return minCost(houses, cost, m, n, k - (prevColor != houses[i]), i + 1,
                     houses[i], mem);

    int res = kMax;

    // Try to paint the houses[i] with each color in 1..n.
    for (int color = 1; color <= n; ++color)
      res = min(res, cost[i][color - 1] + minCost(houses, cost, m, n,
                                                  k - (prevColor != color),
                                                  i + 1, color, mem));

    return mem[k][i][prevColor] = res;
  }
};",1473
1472,"class Solution {
 public:
  ListNode* deleteNodes(ListNode* head, int m, int n) {
    ListNode* curr = head;
    ListNode* prev = nullptr;  // prev.next == curr

    while (curr != nullptr) {
      // Set the m-th node as `prev`.
      for (int i = 0; i < m & curr != nullptr; ++i) {
        prev = curr;
        curr = curr->next;
      }
      // Set the (m + n + 1)-th node as `curr`.
      for (int i = 0; i < n && curr != nullptr; ++i)
        curr = curr->next;
      // Delete the nodes [m + 1..n - 1].
      prev->next = curr;
    }

    return head;
  }
};",1474
1473,"class Solution {
 public:
  vector<int> finalPrices(vector<int>& prices) {
    vector<int> ans{prices};
    stack<int> stack;

    for (int j = 0; j < prices.size(); ++j) {
      // stack[-1] : = i in the problem description.
      while (!stack.empty() && prices[j] <= prices[stack.top()])
        ans[stack.top()] -= prices[j], stack.pop();
      stack.push(j);
    }

    return ans;
  }
};",1475
1474,"updateSubrectangle(row1: int, col1: int, row2: int, col2: int, newValue: int)",1476
1475,"class Solution {
 public:
  int minSumOfLengths(vector<int>& arr, int target) {
    int ans = INT_MAX;
    int leftLength = INT_MAX;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < arr.size(); ++i) {
      prefix += arr[i];
      prefixToIndex[prefix] = i;
    }

    prefix = 0;

    for (int i = 0; i < arr.size(); ++i) {
      prefix += arr[i];
      if (const auto it = prefixToIndex.find(prefix - target);
          it != prefixToIndex.cend())
        leftLength = min(leftLength, i - it->second);
      if (leftLength < INT_MAX)
        if (const auto it = prefixToIndex.find(prefix + target);
            it != prefixToIndex.cend())
          ans = min(ans, leftLength + it->second - i);
    }

    return ans == INT_MAX ? -1 : ans;
  }
};",1477
1476,"class Solution {
 public:
  int minDistance(vector<int>& houses, int k) {
    const int n = houses.size();
    vector<vector<int>> mem(n, vector<int>(k + 1, INT_MAX));
    // cost[i][j] := the minimum cost to allocate mailboxes between houses[i]
    // and houses[j]
    vector<vector<int>> cost(n, vector<int>(n));

    ranges::sort(houses);

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        const int median = houses[(i + j) / 2];
        for (int x = i; x <= j; ++x)
          cost[i][j] += abs(houses[x] - median);
      }

    return minDistance(houses, 0, k, cost, mem);
  }

 private:
  static constexpr int kMax = 1'000'000;

  // Returns the minimum distance to allocate k mailboxes for houses[i..n).
  int minDistance(const vector<int>& houses, int i, int k,
                  const vector<vector<int>>& cost, vector<vector<int>>& mem) {
    if (i == houses.size() && k == 0)
      return 0;
    if (i == houses.size() || k == 0)
      return kMax;
    if (mem[i][k] != INT_MAX)
      return mem[i][k];

    for (int j = i; j < houses.size(); ++j)
      mem[i][k] = min(
          mem[i][k], cost[i][j] + minDistance(houses, j + 1, k - 1, cost, mem));

    return mem[i][k];
  }
};",1478
1477,"SELECT
  Items.item_category AS Category,
  SUM(IF(WEEKDAY(Orders.order_date) = 0, Orders.quantity, 0)) AS Monday,
  SUM(IF(WEEKDAY(Orders.order_date) = 1, Orders.quantity, 0)) AS Tuesday,
  SUM(IF(WEEKDAY(Orders.order_date) = 2, Orders.quantity, 0)) AS Wednesday,
  SUM(IF(WEEKDAY(Orders.order_date) = 3, Orders.quantity, 0)) AS Thursday,
  SUM(IF(WEEKDAY(Orders.order_date) = 4, Orders.quantity, 0)) AS Friday,
  SUM(IF(WEEKDAY(Orders.order_date) = 5, Orders.quantity, 0)) AS Saturday,
  SUM(IF(WEEKDAY(Orders.order_date) = 6, Orders.quantity, 0)) AS Sunday
FROM Items
LEFT JOIN Orders
  USING (item_id)
GROUP BY 1
ORDER BY 1;",1479
1478,"class Solution {
 public:
  vector<int> runningSum(vector<int>& nums) {
    vector<int> ans;
    int sum = 0;
    for (const int num : nums)
      ans.push_back(sum += num);
    return ans;
  }
};",1480
1479,"class Solution {
 public:
  int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
    unordered_map<int, int> count;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int a : arr)
      ++count[a];

    for (const auto& [_, freq] : count)
      minHeap.push(freq);

    // Greedily remove the k least frequent numbers to have the least number of
    // unique integers.
    while (k > 0)
      k -= minHeap.top(), minHeap.pop();

    return minHeap.size() + (k < 0 ? 1 : 0);
  }
};",1481
1480,"class Solution {
 public:
  int minDays(vector<int>& bloomDay, int m, int k) {
    if (bloomDay.size() < static_cast<long>(m) * k)
      return -1;

    int l = ranges::min(bloomDay);
    int r = ranges::max(bloomDay);

    while (l < r) {
      const int mid = (l + r) / 2;
      if (getBouquetCount(bloomDay, k, mid) >= m)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }

 private:
  // Returns the number of bouquets (k flowers needed) can be made after the
  // `waitingDays`..
  int getBouquetCount(const vector<int>& bloomDay, int k, int waitingDays) {
    int bouquetCount = 0;
    int requiredFlowers = k;
    for (const int day : bloomDay)
      if (day > waitingDays) {
        // Reset `requiredFlowers` since there was not enough adjacent flowers.
        requiredFlowers = k;
      } else if (--requiredFlowers == 0) {
        // Use k adjacent flowers to make a bouquet.
        ++bouquetCount;
        requiredFlowers = k;
      }
    return bouquetCount;
  }
};",1482
1481,"class TreeAncestor {
 public:
  TreeAncestor(int n, vector<int>& parent)
      : maxLevel(32 - __builtin_clz(n)), dp(n, vector<int>(maxLevel)) {
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < maxLevel; ++j)
        if (j == 0)  // Node i's 2^0 ancestor is its direct parent.
          dp[i][j] = parent[i];
        else if (dp[i][j - 1] == -1)  // There's no such ancestor.
          dp[i][j] = -1;
        else  // A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})
          dp[i][j] = dp[dp[i][j - 1]][j - 1];
  }

  int getKthAncestor(int node, int k) {
    for (int j = 0; j < maxLevel && node != -1; ++j)
      if (k & 1 << j)
        node = dp[node][j];
    return node;
  }

 private:
  const int maxLevel;
  vector<vector<int>> dp;  // dp[i][j] := node i's 2^j-th ancestor
};",1483
1482,"SELECT
  sell_date,
  COUNT(DISTINCT product) AS num_sold,
  GROUP_CONCAT(DISTINCT product ORDER BY product) AS products
FROM Activities
GROUP BY 1;",1484
1483,"class Solution {
 public:
  NodeCopy* copyRandomBinaryTree(Node* root) {
    if (root == nullptr)
      return nullptr;
    if (const auto it = map.find(root); it != map.cend())
      return it->second;

    NodeCopy* newNode = new NodeCopy(root->val);
    map[root] = newNode;

    newNode->left = copyRandomBinaryTree(root->left);
    newNode->right = copyRandomBinaryTree(root->right);
    newNode->random = copyRandomBinaryTree(root->random);
    return newNode;
  }

 private:
  unordered_map<Node*, NodeCopy*> map;
};",1485
1484,"class Solution {
 public:
  int xorOperation(int n, int start) {
    int ans = 0;
    for (int i = 0; i < n; ++i)
      ans ^= start + 2 * i;
    return ans;
  }
};",1486
1485,"class Solution {
 public:
  vector<string> getFolderNames(vector<string>& names) {
    vector<string> ans;
    unordered_map<string, int> nameToSuffix;

    for (const string& name : names)
      if (const auto it = nameToSuffix.find(name); it != nameToSuffix.cend()) {
        int suffix = it->second;
        string newName = getName(name, ++suffix);
        while (nameToSuffix.count(newName))
          newName = getName(name, ++suffix);
        nameToSuffix[name] = suffix;
        nameToSuffix[newName] = 0;
        ans.push_back(newName);
      } else {
        nameToSuffix[name] = 0;
        ans.push_back(name);
      }

    return ans;
  }

 private:
  string getName(const string& name, int suffix) {
    return name + ""("" + to_string(suffix) + "")"";
  }
};",1487
1486,"class Solution {
 public:
  vector<int> avoidFlood(vector<int>& rains) {
    vector<int> ans(rains.size(), -1);
    unordered_map<int, int> lakeIdToFullDay;
    set<int> emptyDays;  // indices of rains[i] == 0

    for (int i = 0; i < rains.size(); ++i) {
      const int lakeId = rains[i];
      if (lakeId == 0) {
        emptyDays.insert(i);
        continue;
      }
      if (const auto itFullDay = lakeIdToFullDay.find(lakeId);
          itFullDay != lakeIdToFullDay.cend()) {
        // The lake was full in a previous day. Greedily find the closest day
        // to make the lake empty.
        const auto itEmptyDay = emptyDays.upper_bound(itFullDay->second);
        if (itEmptyDay == emptyDays.cend())  // Not found.
          return {};
        // Empty the lake at this day.
        ans[*itEmptyDay] = lakeId;
        emptyDays.erase(itEmptyDay);
      }
      // The lake with `lakeId` becomes full at the day `i`.
      lakeIdToFullDay[lakeId] = i;
    }

    // Empty an arbitrary lake if there are remaining empty days.
    for (const int emptyDay : emptyDays)
      ans[emptyDay] = 1;

    return ans;
  }
};",1488
1487,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<vector<int>> findCriticalAndPseudoCriticalEdges(
      int n, vector<vector<int>>& edges) {
    vector<int> criticalEdges;
    vector<int> pseudoCriticalEdges;

    // Record the index information, so edges[i] := (u, v, weight, index).
    for (int i = 0; i < edges.size(); ++i)
      edges[i].push_back(i);

    // Sort by the weight.
    sort(
        edges.begin(), edges.end(),
        [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });

    const int mstWeight = getMSTWeight(n, edges, {}, -1);

    for (const vector<int>& edge : edges) {
      const int index = edge[3];
      // Deleting the `edge` increases the MST's weight or makes the MST
      // invalid.
      if (getMSTWeight(n, edges, {}, index) > mstWeight)
        criticalEdges.push_back(index);
      // If an edge can be in any MST, we can always add `edge` to the edge set.
      else if (getMSTWeight(n, edges, edge, -1) == mstWeight)
        pseudoCriticalEdges.push_back(index);
    }

    return {criticalEdges, pseudoCriticalEdges};
  }

 private:
  int getMSTWeight(int n, const vector<vector<int>>& edges,
                   const vector<int>& firstEdge, int deletedEdgeIndex) {
    int mstWeight = 0;
    UnionFind uf(n);

    if (!firstEdge.empty()) {
      uf.unionByRank(firstEdge[0], firstEdge[1]);
      mstWeight += firstEdge[2];
    }

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int weight = edge[2];
      const int index = edge[3];
      if (index == deletedEdgeIndex)
        continue;
      if (uf.find(u) == uf.find(v))
        continue;
      uf.unionByRank(u, v);
      mstWeight += weight;
    }

    const int root = uf.find(0);
    for (int i = 0; i < n; ++i)
      if (uf.find(i) != root)
        return INT_MAX;

    return mstWeight;
  }
};",1489
1488,"class Solution {
 public:
  Node* cloneTree(Node* root) {
    if (root == nullptr)
      return nullptr;
    if (const auto it = map.find(root); it != map.cend())
      return it->second;

    Node* newNode = new Node(root->val);
    map[root] = newNode;

    for (Node* child : root->children)
      newNode->children.push_back(cloneTree(child));

    return newNode;
  }

 private:
  unordered_map<Node*, Node*> map;
};",1490
1489,"class Solution {
 public:
  double average(vector<int>& salary) {
    const double sum = accumulate(salary.begin(), salary.end(), 0.0);
    const int max = ranges::max(salary);
    const int min = ranges::min(salary);
    return (sum - max - min) / (salary.size() - 2);
  }
};",1491
1490,"class Solution {
 public:
  int kthFactor(int n, int k) {
    // If i is a divisor of n, then n / i is also a divisor of n. So, we can
    // find all the divisors of n by processing the numbers <= sqrt(n).
    int factor = 1;
    int i = 0;  // the i-th factor

    for (; factor * factor < n; ++factor)
      if (n % factor == 0 && ++i == k)
        return factor;

    for (factor = n / factor; factor >= 1; --factor)
      if (n % factor == 0 && ++i == k)
        return n / factor;

    return -1;
  }
};",1492
1491,"class Solution {
 public:
  int longestSubarray(vector<int>& nums) {
    int ans = 0;
    int count0 = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        ++count0;
      while (count0 == 2)
        if (nums[l++] == 0)
          --count0;
      ans = max(ans, r - l);
    }

    return ans;
  }
};",1493
1492,"class Solution {
 public:
  int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {
    // dp[i] := the minimum number of semesters to take the courses, where i is
    // the bitmask of the taken courses
    vector<int> dp(1 << n, n);
    // prereq[i] := the bitmask of all the dependencies of the i-th course
    vector<int> prereq(n);

    for (const vector<int>& r : relations) {
      const int prevCourse = r[0] - 1;
      const int nextCourse = r[1] - 1;
      prereq[nextCourse] |= 1 << prevCourse;
    }

    dp[0] = 0;  // Don't need time to finish 0 course.

    for (int i = 0; i < dp.size(); ++i) {
      // the bitmask of all the courses can be taken
      int coursesCanBeTaken = 0;
      // Can take the j-th course if i contains all of j's prerequisites.
      for (int j = 0; j < n; ++j)
        if (i & prereq[j] == prereq[j])
          coursesCanBeTaken |= 1 << j;
      // Don't take any course which is already taken.
      // (i represents set of courses that are already taken)
      coursesCanBeTaken &= ~i;
      // Enumerate every bitmask subset of `coursesCanBeTaken`.
      for (int s = coursesCanBeTaken; s; s = (s - 1) & coursesCanBeTaken)
        if (__builtin_popcount(s) <= k)
          // Any combination of courses (if <= k) can be taken now.
          // i | s := combining courses taken with courses can be taken.
          dp[i | s] = min(dp[i | s], dp[i] + 1);
    }

    return dp.back();
  }
};",1494
1493,"SELECT DISTINCT Content.title
FROM Content
INNER JOIN TVProgram
  USING (content_id)
WHERE
  Content.kids_content = 'Y'
  AND Content.content_type = 'Movies'
  AND DATE_FORMAT(TVProgram.program_date, '%Y-%m') = '2020-06';",1495
1494,"class Solution {
 public:
  bool isPathCrossing(string path) {
    set<int> seen;

    seen.insert(0);

    int x = 0;
    int y = 0;

    for (const char c : path) {
      switch (c) {
        case 'N':
          ++y;
          break;
        case 'S':
          --y;
          break;
        case 'E':
          ++x;
          break;
        case 'W':
          --x;
          break;
      }
      const int key = x * 20001 + y;
      if (seen.count(key))
        return true;
      seen.insert(key);
    }

    return false;
  }
};",1496
1495,"class Solution {
 public:
  bool canArrange(vector<int>& arr, int k) {
    vector<int> bucket(k);

    for (const int a : arr) {
      int i = a % k;
      if (i < 0)
        i += k;
      ++bucket[i];
    }

    for (int i = 0; i < k; ++i)
      if (i == 0) {
        if (bucket[i] % 2 != 0)
          return false;
      } else if ((bucket[i] + bucket[k - i]) % 2 != 0) {
        return false;
      }

    return true;
  }
};",1497
1496,"class Solution {
 public:
  int numSubseq(vector<int>& nums, int target) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    vector<int> pows(n, 1);  // pows[i] = 2^i % kMod

    for (int i = 1; i < n; ++i)
      pows[i] = pows[i - 1] * 2 % kMod;

    ranges::sort(nums);

    for (int l = 0, r = n - 1; l <= r;)
      if (nums[l] + nums[r] <= target) {
        ans += pows[r - l];
        ans %= kMod;
        ++l;
      } else {
        --r;
      }

    return ans;
  }
};",1498
1497,"class Solution {
 public:
  int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
    int ans = INT_MIN;
    priority_queue<pair<int, int>> maxHeap;  // (y - x, x)

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      while (!maxHeap.empty() && x - maxHeap.top().second > k)
        maxHeap.pop();
      if (!maxHeap.empty())
        ans = max(ans, x + y + maxHeap.top().first);
      maxHeap.emplace(y - x, x);
    }

    return ans;
  }
};",1499
1498,join(ownedChunks: List[int]),1500
1499,"SELECT Country.name AS country
FROM Person
INNER JOIN Country
  ON (SUBSTRING(Person.phone_number, 1, 3) = Country.country_code)
INNER JOIN Calls
  ON (Person.id IN (Calls.caller_id, Calls.callee_id))
GROUP BY 1
HAVING AVG(Calls.duration) > (
    SELECT AVG(duration) FROM Calls
  );",1501
1500,"class Solution {
 public:
  bool canMakeArithmeticProgression(vector<int>& arr) {
    const int n = arr.size();
    const int max = ranges::max(arr);
    const int min = ranges::min(arr);
    const int range = max - min;
    if (range % (n - 1) != 0)
      return false;
    const int diff = range / (n - 1);
    if (diff == 0)
      return true;

    unordered_set<int> seen;

    for (const int a : arr) {
      if ((a - min) % diff != 0)
        return false;
      if (!seen.insert(a).second)
        return false;
    }

    return true;
  }
};",1502
1501,"class Solution {
 public:
  int getLastMoment(int n, vector<int>& left, vector<int>& right) {
    const int maxLeft = left.empty() ? 0 : ranges::max(left);
    const int minRight = right.empty() ? n : ranges::min(right);
    return max(maxLeft, n - minRight);
  }
};",1503
1502,"class Solution {
 public:
  int numSubmat(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;

    for (int baseRow = 0; baseRow < m; ++baseRow) {
      vector<int> row(n, 1);
      for (int i = baseRow; i < m; ++i) {
        for (int j = 0; j < n; ++j)
          row[j] &= mat[i][j];
        ans += count(row);
      }
    }

    return ans;
  }

 private:
  int count(vector<int>& row) {
    int ans = 0;
    int length = 0;

    for (const int a : row) {
      length = a == 0 ? 0 : length + 1;
      ans += length;
    }

    return ans;
  }
};",1504
1503,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += i & -i;
    }
  }

  int get(int i) {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= i & -i;
    }
    return sum;
  }

 private:
  vector<int> sums;
};

class Solution {
 public:
  string minInteger(string num, int k) {
    const int n = num.length();
    string ans;
    FenwickTree tree(n);
    vector<bool> used(n);
    vector<queue<int>> numToIndices(10);

    for (int i = 0; i < n; ++i)
      numToIndices[num[i] - '0'].push(i);

    while (k > 0 && ans.length() < n)
      for (int d = 0; d < 10; ++d) {
        if (numToIndices[d].empty())
          continue;
        const int i = numToIndices[d].front();
        const int cost = i - tree.get(i);  // Note the offset 1 in FenwickTree.
        if (cost > k)
          continue;
        k -= cost;
        ans += '0' + d;
        used[i] = true;
        tree.update(i + 1, 1);
        numToIndices[d].pop();
        break;  // Scan from 0 -> 9 again.
      }

    for (int i = 0; i < n; ++i)
      if (!used[i])
        ans += num[i];

    return ans;
  }
};",1505
1504,"class Solution {
 public:
  Node* findRoot(vector<Node*> tree) {
    int sum = 0;

    for (Node* node : tree) {
      sum ^= node->val;
      for (Node* child : node->children)
        sum ^= child->val;
    }

    for (Node* node : tree)
      if (node->val == sum)
        return node;

    throw;
  }
};",1506
1505,"class Solution {
 public:
  string reformatDate(string date) {
    const unordered_map<string, string> monthToNumString{
        {""Jan"", ""01""}, {""Feb"", ""02""}, {""Mar"", ""03""}, {""Apr"", ""04""},
        {""May"", ""05""}, {""Jun"", ""06""}, {""Jul"", ""07""}, {""Aug"", ""08""},
        {""Sep"", ""09""}, {""Oct"", ""10""}, {""Nov"", ""11""}, {""Dec"", ""12""},
    };
    const int index1 = date.find_first_of(' ');
    const int index2 = date.find_first_of(' ', index1 + 1);
    const string day = index1 == 4 ? date.substr(0, 2) : string(""0"") + date[0];
    const string month =
        monthToNumString.at(date.substr(index1 + 1, index2 - (index1 + 1)));
    const string year = date.substr(index2 + 1);
    return year + ""-"" + month + ""-"" + day;
  }
};",1507
1506,"class Solution {
 public:
  int rangeSum(vector<int>& nums, int n, int left, int right) {
    constexpr int kMod = 1'000'000'007;

    auto subarraysAndSumNoGreaterThan = [&](int m) -> pair<int, long> {
      int count = 0;   // the number of subarrays <= m
      long total = 0;  // sum(subarrays)
      int sum = 0;     // the current sum
      int window = 0;  // the window sum

      for (int i = 0, j = 0; j < n; ++j) {
        sum += nums[j] * (j - i + 1);
        window += nums[j];  // Extend each subarray that ends in j.
        while (window > m) {
          sum -= window;
          window -= nums[i++];  // Shrink the window.
        }
        count += j - i + 1;
        total += sum;
      }

      return {count, total};
    };

    // [L, R] is the possible range of the sum of any subarray.
    const int L = ranges::min(nums);
    const int R = accumulate(nums.begin(), nums.end(), 0);

    auto firstKSubarraysSum = [&](int k) -> long {
      int l = L;
      int r = R;

      while (l < r) {
        const int m = l + (r - l) / 2;
        if (subarraysAndSumNoGreaterThan(m).first < k)
          l = m + 1;
        else
          r = m;
      }

      const auto& [count, total] = subarraysAndSumNoGreaterThan(l);
      // If count != k, there're subarray(s) have the same sum as l.
      return total - l * (count - k);
    };

    return (firstKSubarraysSum(right) - firstKSubarraysSum(left - 1)) % kMod;
  }
};",1508
1507,"class Solution {
 public:
  int minDifference(vector<int>& nums) {
    const int n = nums.size();
    if (n < 5)
      return 0;

    int ans = INT_MAX;

    ranges::sort(nums);

    // 1. Change nums[0..i) to nums[i].
    // 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].
    for (int i = 0; i <= 3; ++i)
      ans = min(ans, nums[n - 4 + i] - nums[i]);

    return ans;
  }
};",1509
1508,"class Solution {
 public:
  bool winnerSquareGame(int n) {
    // dp[i] := the winning result for n = i
    vector<bool> dp(n + 1);

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        if (!dp[i - j * j]) {  // Removing j^2 stones make the opponent lose.
          dp[i] = true;        // So, we win.
          break;
        }

    return dp[n];
  }
};",1510
1509,"SELECT
  Customers.customer_id,
  Customers.name
FROM Customers
INNER JOIN Orders
  USING (customer_id)
INNER JOIN Product
  USING (product_id)
GROUP BY 1
HAVING
  SUM(
    IF(
      DATE_FORMAT(Orders.order_date, '%Y-%m') = '2020-06',
      Orders.quantity * price,
      0
    )
  ) >= 100
  AND SUM(
    IF(
      DATE_FORMAT(Orders.order_date, '%Y-%m') = '2020-07',
      Orders.quantity * price,
      0
    )
  ) >= 100;",1511
1510,"class Solution {
 public:
  int numIdenticalPairs(vector<int>& nums) {
    int ans = 0;
    vector<int> count(101);

    for (const int num : nums)
      ans += count[num]++;

    return ans;
  }
};",1512
1511,"class Solution {
 public:
  int numSub(string s) {
    constexpr int kMod = 1'000'000'007;

    int ans = 0;
    int l = -1;

    for (int i = 0; i < s.length(); ++i) {
      if (s[i] == '0')
        l = i;  // Handle the reset value.
      ans = (ans + i - l) % kMod;
    }

    return ans;
  }
};",1513
1512,"class Solution {
 public:
  double maxProbability(int n, vector<vector<int>>& edges,
                        vector<double>& succProb, int start, int end) {
    // {a: [(b, probability_ab)]}
    vector<vector<pair<int, double>>> graph(n);
    // (the probability to reach u, u)
    priority_queue<pair<double, int>> maxHeap;
    maxHeap.emplace(1.0, start);
    vector<bool> seen(n);

    for (int i = 0; i < edges.size(); ++i) {
      const int u = edges[i][0];
      const int v = edges[i][1];
      const double prob = succProb[i];
      graph[u].emplace_back(v, prob);
      graph[v].emplace_back(u, prob);
    }

    while (!maxHeap.empty()) {
      const auto [prob, u] = maxHeap.top();
      maxHeap.pop();
      if (u == end)
        return prob;
      if (seen[u])
        continue;
      seen[u] = true;
      for (const auto& [nextNode, edgeProb] : graph[u]) {
        if (seen[nextNode])
          continue;
        maxHeap.emplace(prob * edgeProb, nextNode);
      }
    }

    return 0;
  }
};",1514
1513,"class Solution {
 public:
  double getMinDistSum(vector<vector<int>>& positions) {
    constexpr double kErr = 1e-6;
    double currX = 50;
    double currY = 50;
    double ans = distSum(positions, currX, currY);
    double step = 1;

    while (step > kErr) {
      bool shouldDecreaseStep = true;
      for (const auto& [dx, dy] : vector<pair<double, double>>{
               {0, step}, {0, -step}, {step, 0}, {-step, 0}}) {
        const double x = currX + dx;
        const double y = currY + dy;
        const double newDistSum = distSum(positions, x, y);
        if (newDistSum < ans) {
          ans = newDistSum;
          currX = x;
          currY = y;
          shouldDecreaseStep = false;
        }
      }
      if (shouldDecreaseStep)
        step /= 10;
    }

    return ans;
  }

 private:
  double distSum(const vector<vector<int>>& positions, double a, double b) {
    double sum = 0;
    for (const vector<int>& p : positions)
      sum += sqrt(pow(a - p[0], 2) + pow(b - p[1], 2));
    return sum;
  }
};",1515
1514,"class Solution {
 public:
  Node* moveSubTree(Node* root, Node* p, Node* q) {
    if (find(q->children.begin(), q->children.end(), p) != q->children.end())
      return root;

    // Create a dummy node for the case when root == p.
    Node* dummy = new Node(0, {root});

    // Get each parent of p and q.
    Node* pParent = getParent(dummy, p);
    Node* qParent = getParent(p, q);

    // Get p's original index in p's parent.
    vector<Node*>& pSiblings = pParent->children;
    const int pIndex =
        find(pSiblings.begin(), pSiblings.end(), p) - pSiblings.begin();
    pSiblings.erase(pSiblings.begin() + pIndex);

    q->children.push_back(p);

    // If q is in p's subtree, qParent != nullptr.
    if (qParent != nullptr) {
      vector<Node*>& qSiblings = qParent->children;
      qSiblings.erase(remove(qSiblings.begin(), qSiblings.end(), q),
                      qSiblings.end());
      pSiblings.insert(pSiblings.begin() + pIndex, q);
    }

    return dummy->children[0];
  }

 private:
  Node* getParent(Node* root, Node* target) {
    for (Node* child : root->children) {
      if (child == target)
        return root;
      Node* res = getParent(child, target);
      if (res != nullptr)
        return res;
    }
    return nullptr;
  }
};",1516
1515,"SELECT *
FROM Users
WHERE REGEXP_LIKE(mail, '^[A-Za-z]+[A-Za-z0-9\_\.\-]*@leetcode\\.com$');",1517
1516,"class Solution {
 public:
  int numWaterBottles(int numBottles, int numExchange) {
    int ans = numBottles;

    while (numBottles >= numExchange) {
      ans += numBottles / numExchange;
      numBottles = numBottles / numExchange + numBottles % numExchange;
    }

    return ans;
  }
};",1518
1517,"class Solution {
 public:
  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
    vector<int> ans(n);
    vector<vector<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, -1, labels, ans);
    return ans;
  }

 private:
  vector<int> dfs(const vector<vector<int>>& tree, int u, int parent,
                  const string& labels, vector<int>& ans) {
    // count[i] := the number of letters down from ('a' + i)
    vector<int> count(26);

    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      vector<int> childCount = dfs(tree, v, u, labels, ans);
      for (int i = 0; i < 26; ++i)
        count[i] += childCount[i];
    }

    ans[u] = ++count[labels[u] - 'a'];  // the u itself
    return count;
  }
};",1519
1518,"class Solution {
 public:
  vector<string> maxNumOfSubstrings(string s) {
    const int n = s.length();
    vector<string> ans;
    // leftmost[i] := the leftmost index of ('a' + i)
    vector<int> leftmost(26, n);
    // rightmost[i] := the rightmost index of ('a' + i)
    vector<int> rightmost(26, -1);

    for (int i = 0; i < n; ++i) {
      leftmost[s[i] - 'a'] = min(leftmost[s[i] - 'a'], i);
      rightmost[s[i] - 'a'] = i;
    }

    auto getNewRight = [&](int i) {
      int right = rightmost[s[i] - 'a'];
      for (int j = i; j <= right; ++j) {
        if (leftmost[s[j] - 'a'] < i)  // Find a letter's leftmost index < i.
          return -1;
        // Expand the right dynamically.
        right = max(right, rightmost[s[j] - 'a']);
      }
      return right;
    };

    int right = -1;  // the rightmost index of the last substring
    for (int i = 0; i < n; ++i) {
      // the current index is the first appearance
      if (i == leftmost[s[i] - 'a']) {
        const int newRight = getNewRight(i);
        if (newRight == -1)
          continue;  // Find a letter's leftmost index < i.
        if (i <= right && !ans.empty())
          ans.back() = s.substr(i, newRight - i + 1);
        else
          ans.push_back(s.substr(i, newRight - i + 1));
        right = newRight;
      }
    }

    return ans;
  }
};",1520
1519,"class Solution {
 public:
  int closestToTarget(vector<int>& arr, int target) {
    int ans = INT_MAX;
    // S(j) := arr[i] & arr[i + 1] & ... & arr[j] for all 0 <= i <= j (fixed)
    unordered_set<int> s;

    for (const int a : arr) {
      unordered_set<int> s2{a};
      for (const int b : s)
        s2.insert(a & b);
      for (const int c : s = s2)
        ans = min(ans, abs(c - target));
    }

    return ans;
  }
};",1521
1520,"class Solution {
 public:
  int diameter(Node* root) {
    int ans = 0;
    maxDepth(root, ans);
    return ans;
  }

 private:
  int maxDepth(Node* root, int& ans) {
    int max1 = 0;
    int max2 = 0;

    for (Node* child : root->children) {
      const int depth = maxDepth(child, ans);
      if (depth > max1) {
        max2 = max1;
        max1 = depth;
      } else if (depth > max2) {
        max2 = depth;
      }
    }

    ans = max(ans, max1 + max2);
    return 1 + max1;
  }
};",1522
1521,"class Solution {
 public:
  int countOdds(int low, int high) {
    return (high + 1) / 2 - low / 2;
  }
};",1523
1522,"class Solution {
 public:
  int numOfSubarrays(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    long ans = 0;
    // dp0[i] := the number of subarrays that end in arr[i - 1] with an even sum
    vector<int> dp0(n + 1);
    // dp1[i] := the number of subarrays that end in arr[i - 1] with an odd sum
    vector<int> dp1(n + 1);

    for (int i = 1; i <= n; ++i) {
      if (arr[i - 1] & 1) {
        dp0[i] = dp1[i - 1];
        dp1[i] = dp0[i - 1] + 1;
      } else {
        dp0[i] = dp0[i - 1] + 1;
        dp1[i] = dp1[i - 1];
      }
      ans = (ans + dp1[i]) % kMod;
    }

    return ans;
  }
};",1524
1523,"class Solution {
 public:
  int numSplits(string s) {
    const int n = s.length();
    int ans = 0;
    // prefix[i] := the number of unique letters in s[0..i]
    vector<int> prefix(n);
    // suffix[i] := of unique letters in s[i..n)
    vector<int> suffix(n);
    unordered_set<int> seen;

    for (int i = 0; i < n; ++i) {
      seen.insert(s[i]);
      prefix[i] = seen.size();
    }

    seen.clear();

    for (int i = n - 1; i >= 0; --i) {
      seen.insert(s[i]);
      suffix[i] = seen.size();
    }

    for (int i = 0; i + 1 < n; ++i)
      if (prefix[i] == suffix[i + 1])
        ++ans;

    return ans;
  }
};",1525
1524,"class Solution {
 public:
  int minNumberOperations(vector<int>& target) {
    int ans = target.front();

    for (int i = 1; i < target.size(); ++i)
      if (target[i] > target[i - 1])
        ans += target[i] - target[i - 1];

    return ans;
  }
};",1526
1525,"SELECT *
FROM Patients
WHERE
  conditions LIKE 'DIAB1%'
  OR conditions LIKE '% DIAB1%';",1527
1526,"class Solution {
 public:
  string restoreString(string s, vector<int>& indices) {
    string ans(s.length(), '.');

    for (int i = 0; i < indices.size(); ++i)
      ans[indices[i]] = s[i];

    return ans;
  }
};",1528
1527,"class Solution {
 public:
  int minFlips(string target) {
    int ans = 0;
    int state = 0;

    for (const char c : target)
      if (c - '0' != state) {
        state = c - '0';
        ++ans;
      }

    return ans;
  }
};",1529
1528,"class Solution {
 public:
  int countPairs(TreeNode* root, int distance) {
    int ans = 0;

    dfs(root, distance, ans);

    return ans;
  }

 private:
  vector<int> dfs(TreeNode* root, int distance, int& ans) {
    vector<int> d(distance + 1);  // {distance: the number of leaf nodes}
    if (root == nullptr)
      return d;
    if (root->left == nullptr && root->right == nullptr) {
      d[0] = 1;
      return d;
    }

    const vector<int> dl = dfs(root->left, distance, ans);
    const vector<int> dr = dfs(root->right, distance, ans);

    for (int i = 0; i < distance; ++i)
      for (int j = 0; j < distance; ++j)
        if (i + j + 2 <= distance)
          ans += dl[i] * dr[j];

    for (int i = 0; i < distance; ++i)
      d[i + 1] = dl[i] + dr[i];

    return d;
  }
};",1530
1529,"class Solution {
 public:
  int getLengthOfOptimalCompression(string s, int k) {
    vector<vector<int>> mem(s.length(), vector<int>(k + 1, kMax));
    return compression(s, 0, k, mem);
  }

 private:
  static constexpr int kMax = 101;

  // Returns the length of the optimal compression of s[i..n) with at most k
  // deletion.
  int compression(const string& s, int i, int k, vector<vector<int>>& mem) {
    if (k < 0)
      return kMax;
    if (i == s.length() || s.length() - i <= k)
      return 0;
    if (mem[i][k] != kMax)
      return mem[i][k];

    int maxFreq = 0;  // the maximum frequency in s[i..j]
    vector<int> count(128);

    // Make letters in s[i..j] be the same.
    // Keep the letter that has the maximum frequency in this range and remove
    // the other letters.
    for (int j = i; j < s.length(); ++j) {
      maxFreq = max(maxFreq, ++count[s[j]]);
      mem[i][k] = min(  //
          mem[i][k],    //
          getLength(maxFreq) +
              compression(s, j + 1, k - (j - i + 1 - maxFreq), mem));
    }

    return mem[i][k];
  }

  // Returns the length to compress `maxFreq`.
  int getLength(int maxFreq) {
    if (maxFreq == 1)
      return 1;  // c
    if (maxFreq < 10)
      return 2;  // [1-9]c
    if (maxFreq < 100)
      return 3;  // [1-9][0-9]c
    return 4;    // [1-9][0-9][0-9]c
  }
};",1531
1530,"WITH
  OrdersWithRowNumber AS (
    SELECT
      order_id,
      order_date,
      customer_id,
      ROW_NUMBER() OVER(
        PARTITION BY customer_id
        ORDER BY order_date DESC
      ) AS `row_number`
    FROM Orders
  )
SELECT
  Customers.name AS customer_name,
  Customers.customer_id,
  OrdersWithRowNumber.order_id,
  OrdersWithRowNumber.order_date
FROM OrdersWithRowNumber
INNER JOIN Customers
  USING (customer_id)
WHERE `row_number` <= 3
ORDER BY customer_name, customer_id, order_date DESC;",1532
1531,"/**
 * // This is the ArrayReader's API interface.
 * // You should not implement it, or speculate about its implementation
 * class ArrayReader {
 *  public:
 *   // Compares the sum of arr[l..r] with the sum of arr[x..y]
 *   // return 1 if sum(arr[l..r]) > sum(arr[x..y])
 *   // return 0 if sum(arr[l..r]) == sum(arr[x..y])
 *   // return -1 if sum(arr[l..r]) < sum(arr[x..y])
 *   int compareSub(int l, int r, int x, int y);
 *
 *   // Returns the length of the array
 *   int length();
 * };
 */

class Solution {
 public:
  int getIndex(ArrayReader& reader) {
    int l = 0;
    int r = reader.length() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if ((r - l) % 2 == 0) {
        const int res = reader.compareSub(l, m - 1, m + 1, r);
        if (res == 0)
          return m;
        if (res == 1) {
          r = m - 1;
        } else {  // res == -1
          l = m + 1;
        }
      } else {
        const int res = reader.compareSub(l, m, m + 1, r);
        // res is either 1 or -1.
        if (res == 1) {
          r = m;
        } else {  // res == -1
          l = m + 1;
        }
      }
    }

    return l;
  }
};",1533
1532,"class Solution {
 public:
  int countGoodTriplets(vector<int>& arr, int a, int b, int c) {
    int ans = 0;
    for (int i = 0; i < arr.size(); ++i)
      for (int j = i + 1; j < arr.size(); ++j)
        for (int k = j + 1; k < arr.size(); ++k)
          if (abs(arr[i] - arr[j]) <= a &&  //
              abs(arr[j] - arr[k]) <= b &&  //
              abs(arr[i] - arr[k]) <= c)
            ++ans;
    return ans;
  }
};",1534
1533,"class Solution {
 public:
  int getWinner(vector<int>& arr, int k) {
    int ans = arr[0];
    int wins = 0;

    for (int i = 1; i < arr.size() && wins < k; ++i)
      if (arr[i] > ans) {
        ans = arr[i];
        wins = 1;
      } else {
        ++wins;
      }

    return ans;
  }
};",1535
1534,"class Solution {
 public:
  int minSwaps(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    // suffixZeros[i] := the number of suffix zeros in the i-th row
    vector<int> suffixZeros;

    for (const vector<int> row : grid) {
      const auto itLastOne = find(row.rbegin(), row.rend(), 1);
      const int suffixZeroCount = distance(row.rbegin(), itLastOne);
      suffixZeros.push_back(suffixZeroCount);
    }

    for (int i = 0; i < n; ++i) {
      const int neededZeros = n - 1 - i;
      // Get the first row with suffix zeros >= `neededZeros` in
      // suffixZeros[i:..n).
      const auto it = find_if(suffixZeros.begin() + i, suffixZeros.end(),
                              [&](int count) { return count >= neededZeros; });
      if (it == suffixZeros.end())
        return -1;
      const int j = distance(suffixZeros.begin(), it);
      // Move the rows[j] to the rows[i].
      for (int k = j; k > i; --k)
        suffixZeros[k] = suffixZeros[k - 1];
      ans += j - i;
    }

    return ans;
  }
};",1536
1535,"class Solution {
 public:
  int maxSum(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;
    // Keep the running the sum of `nums1` and `nums2` before the next
    // rendezvous. Since `nums1` and `nums2` are increasing, move forward on the
    // smaller one to ensure we don't miss any rendezvous. When meet rendezvous,
    // choose the better path.
    long ans = 0;
    // sum(nums1) in (the prevoious rendezvous, the next rendezvous)
    long sum1 = 0;
    // sum(nums2) in (the prevoious rendezvous, the next rendezvous)
    long sum2 = 0;
    int i = 0;  // nums1's index
    int j = 0;  // nums2's index

    while (i < nums1.size() && j < nums2.size())
      if (nums1[i] < nums2[j]) {
        sum1 += nums1[i++];
      } else if (nums1[i] > nums2[j]) {
        sum2 += nums2[j++];
      } else {  // An rendezvous happens.
        ans += max(sum1, sum2) + nums1[i];
        sum1 = 0;
        sum2 = 0;
        ++i;
        ++j;
      }

    while (i < nums1.size())
      sum1 += nums1[i++];

    while (j < nums2.size())
      sum2 += nums2[j++];

    return (ans + max(sum1, sum2)) % kMod;
  }
};",1537
1536,"/**
 * // This is the ArrayReader's API interface.
 * // You should not implement it, or speculate about its implementation
 * class ArrayReader {
 *  public:
 *   // Compares 4 different elements in the array
 *   // Returns 4 if the values of the 4 elements are the same (0 or 1).
 *   // Returns 2 if three elements have a value equal to 0 and one element has
 *   //           value equal to 1 or vice versa.
 *   // Returns 0 if two element have a value equal to 0 and two elements have
 *   //           a value equal to 1.
 *   int query(int a, int b, int c, int d);
 *
 *   // Returns the length of the array
 *   int length();
 * };
 */

class Solution {
 public:
  int guessMajority(ArrayReader& reader) {
    const int n = reader.length();
    const int query0123 = reader.query(0, 1, 2, 3);
    const int query1234 = reader.query(1, 2, 3, 4);
    // the number of numbers that are same as `nums[0]`
    int count0 = 1;
    // the number of numbers that are different from `nums[0]`
    int countNot0 = 0;
    // any index i s.t. nums[i] != nums[0]
    int indexNot0 = -1;

    // Find which group nums[1..3] belong to.
    for (int i = 1; i <= 3; ++i) {
      vector<int> abcd = getABCD(i);
      if (reader.query(abcd[0], abcd[1], abcd[2], abcd[3]) == query1234) {
        ++count0;
      } else {
        ++countNot0;
        indexNot0 = i;
      }
    }

    // Find which group nums[4..n) belong to.
    for (int i = 4; i < n; ++i)
      if (reader.query(1, 2, 3, i) == query0123) {
        ++count0;
      } else {
        ++countNot0;
        indexNot0 = i;
      }

    if (count0 == countNot0)
      return -1;
    if (count0 > countNot0)
      return 0;
    return indexNot0;
  }

  // Returns [0..4] except i.
 private:
  vector<int> getABCD(int i) {
    vector<int> abcd{0};
    for (int j = 1; j <= 3; ++j)
      if (j != i)
        abcd.push_back(j);
    abcd.push_back(4);
    return abcd;
  }
};",1538
1537,"class Solution {
 public:
  int findKthPositive(vector<int>& arr, int k) {
    int l = 0;
    int r = arr.size();

    // Find the first index l s.t. nMissing(l) = A[l] - l - 1 >= k.
    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] - m - 1 >= k)
        r = m;
      else
        l = m + 1;
    }

    // The k-th missing positive
    // = A[l - 1] + k - nMissing(l - 1)
    // = A[l - 1] + k - (A[l - 1] - (l - 1) - 1)
    // = A[l - 1] + k - (A[l - 1] - l)
    // = l + k
    return l + k;
  }
};",1539
1538,"class Solution {
 public:
  bool canConvertString(string s, string t, int k) {
    if (s.length() != t.length())
      return false;

    // e.g. s = ""aab"", t = ""bbc"", so shiftCount[1] = 3
    // Case 1: a -> b, need 1 move.
    // Case 2: a -> b, need 1 + 26 moves.
    // Case 3: b -> c, need 1 + 26 * 2 moves.
    vector<int> shiftCount(26);

    for (int i = 0; i < s.length(); ++i)
      ++shiftCount[(t[i] - s[i] + 26) % 26];

    for (int shift = 1; shift < 26; ++shift)
      if (shift + 26 * (shiftCount[shift] - 1) > k)
        return false;

    return true;
  }
};",1540
1539,"class Solution {
 public:
  int minInsertions(string s) {
    int neededRight = 0;   // Increment by 2 for each '('.
    int missingLeft = 0;   // Increment by 1 for each missing '('.
    int missingRight = 0;  // Increment by 1 for each missing ')'.

    for (const char c : s)
      if (c == '(') {
        if (neededRight % 2 == 1) {
          // e.g. ""()(...""
          ++missingRight;
          --neededRight;
        }
        neededRight += 2;
      } else if (--neededRight < 0) {  // c == ')'
        // e.g. ""()))...""
        ++missingLeft;
        neededRight += 2;
      }

    return neededRight + missingLeft + missingRight;
  }
};",1541
1540,"class Solution {
 public:
  int longestAwesome(string s) {
    int ans = 0;
    int prefix = 0;  // the binary prefix
    vector<int> prefixToIndex(1024, s.length());
    prefixToIndex[0] = -1;

    for (int i = 0; i < s.length(); ++i) {
      prefix ^= 1 << s[i] - '0';
      ans = max(ans, i - prefixToIndex[prefix]);
      for (int j = 0; j < 10; ++j)
        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j]);
      prefixToIndex[prefix] = min(prefixToIndex[prefix], i);
    }

    return ans;
  }
};",1542
1541,"SELECT
  LOWER(TRIM(product_name)) AS product_name,
  DATE_FORMAT(sale_date, '%Y-%m') AS sale_date,
  COUNT(*) AS total
FROM Sales
GROUP BY 1, 2
ORDER BY 1, 2;",1543
1542,"class Solution {
 public:
  string makeGood(string s) {
    string ans;
    for (const char c : s)
      if (!ans.empty() && isBadPair(ans.back(), c))
        ans.pop_back();
      else
        ans.push_back(c);
    return ans;
  }

  bool isBadPair(char a, char b) {
    return a != b && tolower(a) == tolower(b);
  }
};",1544
1543,"class Solution {
 public:
  char findKthBit(int n, int k) {
    if (n == 1)
      return '0';
    const int midIndex = pow(2, n - 1);  // 1-indexed
    if (k == midIndex)
      return '1';
    if (k < midIndex)
      return findKthBit(n - 1, k);
    return findKthBit(n - 1, midIndex * 2 - k) == '0' ? '1' : '0';
  }
};",1545
1544,"class Solution {
 public:
  int maxNonOverlapping(vector<int>& nums, int target) {
    // Ending the subarray ASAP always has a better result.
    int ans = 0;
    int prefix = 0;
    unordered_set<int> prefixes{0};

    // Greedily find the subarrays that equal to the target.
    for (const int num : nums) {
      // Check if there is a subarray ends in here and equals to the target.
      prefix += num;
      if (prefixes.count(prefix - target)) {
        // Find one and discard all the prefixes that have been used.
        ++ans;
        prefix = 0;
        prefixes = {0};
      } else {
        prefixes.insert(prefix);
      }
    }

    return ans;
  }
};",1546
1545,"class Solution {
 public:
  int minCost(int n, vector<int>& cuts) {
    cuts.push_back(0);
    cuts.push_back(n);
    ranges::sort(cuts);
    vector<vector<int>> mem(cuts.size(), vector<int>(cuts.size(), INT_MAX));
    return minCost(cuts, 0, cuts.size() - 1, mem);
  }

 private:
  // Returns minCost(cuts[i..j]).
  int minCost(const vector<int>& cuts, int i, int j, vector<vector<int>>& mem) {
    if (j - i <= 1)
      return 0;
    if (mem[i][j] != INT_MAX)
      return mem[i][j];

    for (int k = i + 1; k < j; ++k)
      mem[i][j] = min(mem[i][j], cuts[j] - cuts[i] + minCost(cuts, i, k, mem) +
                                     minCost(cuts, k, j, mem));

    return mem[i][j];
  }
};",1547
1546,"class Solution {
 public:
  vector<int> mostSimilar(int n, vector<vector<int>>& roads,
                          vector<string>& names, vector<string>& targetPath) {
    this->names = names;
    this->targetPath = targetPath;
    // cost[i][j] := the minimum cost to start from names[i] in path[j]
    this->cost.resize(names.size(), vector<int>(targetPath.size(), -1));
    // next[i][j] := the best next of names[i] in path[j]
    this->next.resize(names.size(), vector<int>(targetPath.size()));
    this->graph.resize(n);

    for (const vector<int>& road : roads) {
      graph[road[0]].push_back(road[1]);
      graph[road[1]].push_back(road[0]);
    }

    int minDist = INT_MAX;
    int start = 0;

    for (int i = 0; i < n; ++i) {
      const int dist = dfs(i, 0);
      if (dist < minDist) {
        minDist = dist;
        start = i;
      }
    }

    vector<int> ans;

    while (ans.size() < targetPath.size()) {
      ans.push_back(start);
      start = next[start][ans.size() - 1];
    }

    return ans;
  }

 private:
  vector<string> names;
  vector<string> targetPath;
  vector<vector<int>> cost;
  vector<vector<int>> next;
  vector<vector<int>> graph;

  int dfs(int nameIndex, int pathIndex) {
    if (cost[nameIndex][pathIndex] != -1)
      return cost[nameIndex][pathIndex];

    const int editDist = names[nameIndex] != targetPath[pathIndex];
    if (pathIndex == targetPath.size() - 1)
      return editDist;

    int minDist = INT_MAX;

    for (const int v : graph[nameIndex]) {
      const int dist = dfs(v, pathIndex + 1);
      if (dist < minDist) {
        minDist = dist;
        next[nameIndex][pathIndex] = v;
      }
    }

    return cost[nameIndex][pathIndex] = editDist + minDist;
  }
};",1548
1547,"WITH
  RankedProducts AS (
    SELECT
      Products.product_name,
      Products.product_id,
      Orders.order_id,
      Orders.order_date,
      RANK() OVER(
        PARTITION BY Products.product_name
        ORDER BY Orders.order_date DESC
      ) `rank`
    FROM Products
    INNER JOIN Orders
      USING (product_id)
  )
SELECT
  RankedProducts.product_name,
  RankedProducts.product_id,
  RankedProducts.order_id,
  RankedProducts.order_date
FROM RankedProducts
WHERE `rank` = 1
ORDER BY 1, 2, 3;",1549
1548,"class Solution {
 public:
  bool threeConsecutiveOdds(vector<int>& arr) {
    int count = 0;
    for (const int a : arr) {
      count = a % 2 == 1 ? count + 1 : 0;
      if (count == 3)
        return true;
    }
    return false;
  }
};",1550
1549,"class Solution {
 public:
  int minOperations(int n) {
    //     median := median of arr
    //   diffs[i] := median - arr[i] where i <= i <= n / 2
    //        ans := sum(diffs)
    // e.g.
    // n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]
    //        ans = (4 + 2) * 2 / 2 = 6
    // n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]
    //        ans = (5 + 1) * 3 / 2 = 9
    const int halfSize = n / 2;
    const int median = (arr(n) + arr(1)) / 2;
    const int firstDiff = median - arr(1);
    const int lastDiff = median - arr(halfSize);
    return (firstDiff + lastDiff) * halfSize / 2;
  }

 private:
  // Returns the i-th element of `arr`, where 1 <= i <= n.
  int arr(int i) {
    return (i - 1) * 2 + 1;
  }
};",1551
1550,"class Solution {
 public:
  int maxDistance(vector<int>& position, int m) {
    ranges::sort(position);

    int l = 1;
    int r = position.back() - position.front();

    while (l < r) {
      const int mid = r - (r - l) / 2;
      if (numBalls(position, mid) >= m)  // There're too many balls.
        l = mid;
      else  // There're too few balls.
        r = mid - 1;
    }

    return l;
  }

 private:
  int numBalls(const vector<int>& position, int force) {
    int balls = 0;
    int prevPosition = -force;
    for (const int pos : position)
      if (pos - prevPosition >= force) {
        ++balls;
        prevPosition = pos;
      }
    return balls;
  }
};",1552
1551,"class Solution {
 public:
  int minDays(int n) {
    if (n <= 1)
      return n;
    if (const auto it = mem.find(n); it != mem.cend())
      return it->second;
    return mem[n] = 1 + min(minDays(n / 3) + n % 3,  //
                            minDays(n / 2) + n % 2);
  }

 private:
  unordered_map<int, int> mem;
};",1553
1552,"class Solution {
 public:
  bool differByOne(vector<string>& dict) {
    unordered_set<string> seen;

    for (string& word : dict) {
      for (char& c : word) {
        const char cache = c;
        for (char next = 'a'; next <= 'z'; ++next) {
          if (next == cache)
            continue;
          c = next;
          if (seen.count(word))
            return true;
        }
        c = cache;
      }
      seen.insert(word);
    }

    return false;
  }
};",1554
1553,"WITH
  UpdatedUsers AS (
    SELECT
      Users.user_id,
      Users.user_name,
      Users.credit + SUM(
        CASE
          WHEN Users.user_id = Transactions.paid_by THEN -Transactions.amount
          WHEN Users.user_id = Transactions.paid_to THEN Transactions.amount
          ELSE 0
        END
      ) AS credit
    FROM Users
    LEFT JOIN Transactions
      ON (Users.user_id IN (Transactions.paid_by, Transactions.paid_to))
    GROUP BY 1
  )
SELECT
  *,
  IF(credit < 0, 'Yes', 'No') AS credit_limit_breached
FROM UpdatedUsers;",1555
1554,"class Solution {
 public:
  string thousandSeparator(int n) {
    const string s = to_string(n);
    string ans;

    for (int i = 0; i < s.length(); ++i) {
      if (i > 0 && (s.length() - i) % 3 == 0)
        ans += '.';
      ans += s[i];
    }

    return ans;
  }
};",1556
1555,"class Solution {
 public:
  vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
    vector<int> ans;
    vector<int> inDegrees(n);

    for (const vector<int>& edge : edges)
      ++inDegrees[edge[1]];

    for (int i = 0; i < inDegrees.size(); ++i)
      if (inDegrees[i] == 0)
        ans.push_back(i);

    return ans;
  }
};",1557
1556,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    return accumulate(nums.begin(), nums.end(), 0, [](int subtotal, int num) {
      return subtotal + __builtin_popcount(num);
    }) + (maxNum == 0 ? 0 : (int)log2(maxNum));
  }
};",1558
1557,"class Solution {
 public:
  bool containsCycle(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (seen[i][j])
          continue;
        if (dfs(grid, i, j, -1, -1, grid[i][j], seen))
          return true;
      }

    return false;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  bool dfs(const vector<vector<char>>& grid, int i, int j, int prevI, int prevJ,
           char c, vector<vector<bool>>& seen) {
    seen[i][j] = true;

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
        continue;
      if (x == prevI && y == prevJ)
        continue;
      if (grid[x][y] != c)
        continue;
      if (seen[x][y])
        return true;
      if (dfs(grid, x, y, i, j, c, seen))
        return true;
    }

    return false;
  }
};",1559
1558,"class Solution {
 public:
  vector<int> mostVisited(int n, vector<int>& rounds) {
    // Case 1: If start <= end, [start, end] is the most visited.
    //
    //      s --------- n
    // 1 -------------- n
    // 1 ------ e
    //
    // Case 2: If start > end, [1, end] and [start, n] are the most visited.
    //
    //             s -- n
    // 1 -------------- n
    // 1 ------ e
    const int start = rounds.front();
    const int end = rounds.back();
    vector<int> ans;
    for (int i = 1; i <= n; ++i)
      if (start <= end) {
        if (start <= i && i <= end)
          ans.push_back(i);
      } else {  // start > end
        if (i >= start || i <= end)
          ans.push_back(i);
      }
    return ans;
  }
};",1560
1559,"class Solution {
 public:
  int maxCoins(vector<int>& piles) {
    ranges::sort(piles);

    int ans = 0;

    // piles = [S S M L M L], pick all the M.
    for (int i = piles.size() / 3; i < piles.size(); i += 2)
      ans += piles[i];

    return ans;
  }
};",1561
1560,"class Solution {
 public:
  int findLatestStep(vector<int>& arr, int m) {
    if (arr.size() == m)
      return arr.size();

    int ans = -1;
    int step = 0;
    // sizes[i] := the size of the group starting from i or ending in i
    // (1-indexed)
    vector<int> sizes(arr.size() + 2);

    for (const int i : arr) {
      ++step;
      // In the previous step, there exists a group with a size of m.
      if (sizes[i - 1] == m || sizes[i + 1] == m)
        ans = step - 1;
      const int head = i - sizes[i - 1];
      const int tail = i + sizes[i + 1];
      sizes[head] = tail - head + 1;
      sizes[tail] = tail - head + 1;
    }

    return ans;
  }
};",1562
1561,"class Solution {
 public:
  int stoneGameV(vector<int>& stoneValue) {
    const int n = stoneValue.size();
    vector<vector<int>> mem(n, vector<int>(n, INT_MIN));
    vector<int> prefix(n + 1);
    partial_sum(stoneValue.begin(), stoneValue.end(), prefix.begin() + 1);
    return stoneGameV(stoneValue, 0, n - 1, prefix, mem);
  }

 private:
  // Returns the maximum score that Alice can obtain from stoneValue[i..j].
  int stoneGameV(const vector<int>& stoneValue, int i, int j,
                 const vector<int>& prefix, vector<vector<int>>& mem) {
    if (i == j)
      return 0;
    if (mem[i][j] > 0)
      return mem[i][j];

    // Try all the possible partitions.
    for (int p = i; p < j; ++p) {
      // sum(stoneValue[i..p])
      const int leftSum = prefix[p + 1] - prefix[i];
      const int throwRight =
          leftSum + stoneGameV(stoneValue, i, p, prefix, mem);
      // sum(stoneValue[p + 1..j])
      const int rightSum = prefix[j + 1] - prefix[p + 1];
      const int throwLeft =
          rightSum + stoneGameV(stoneValue, p + 1, j, prefix, mem);
      if (leftSum < rightSum)  // Bob throws the right row.
        mem[i][j] = max(mem[i][j], throwRight);
      else if (leftSum > rightSum)  // Bob throws the left row.
        mem[i][j] = max(mem[i][j], throwLeft);
      else  // Alice decides which row to throw.
        mem[i][j] = max({mem[i][j], throwLeft, throwRight});
    }

    return mem[i][j];
  }
};",1563
1562,warehouse,1564
1563,"SELECT
  DATE_FORMAT(order_date, '%Y-%m') AS month,
  COUNT(order_id) AS order_count,
  COUNT(DISTINCT customer_id) AS customer_count
FROM Orders
WHERE invoice > 20
GROUP BY 1;",1565
1564,"class Solution {
 public:
  bool containsPattern(vector<int>& arr, int m, int k) {
    int count = 0;
    for (int i = m; i < arr.size(); ++i) {
      count = arr[i] == arr[i - m] ? count + 1 : 0;
      if (count == m * k - m)
        return true;
    }
    return false;
  }
};",1566
1565,"class Solution {
 public:
  int getMaxLen(vector<int>& nums) {
    int ans = 0;
    // the maximum length of subarrays ending in `num` with a negative product
    int neg = 0;
    // the maximum length of subarrays ending in `num` with a positive product
    int pos = 0;

    for (const int num : nums) {
      pos = num == 0 ? 0 : pos + 1;
      neg = num == 0 || neg == 0 ? 0 : neg + 1;
      if (num < 0)
        swap(pos, neg);
      ans = max(ans, pos);
    }

    return ans;
  }
};",1567
1566,"class Solution {
 public:
  int minDays(vector<vector<int>>& grid) {
    if (disconnected(grid))
      return 0;

    // Try to remove 1 land.
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 1) {
          grid[i][j] = 0;
          if (disconnected(grid))
            return 1;
          grid[i][j] = 1;
        }

    // Remove 2 lands.
    return 2;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  bool disconnected(const vector<vector<int>>& grid) {
    int islandsCount = 0;
    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j) {
        if (grid[i][j] == 0 || seen[i][j])
          continue;
        if (++islandsCount > 1)
          return true;
        dfs(grid, i, j, seen);
      }
    return islandsCount != 1;
  }

  void dfs(const vector<vector<int>>& grid, int i, int j,
           vector<vector<bool>>& seen) {
    seen[i][j] = true;
    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
        continue;
      if (grid[x][y] == 0 || seen[x][y])
        continue;
      dfs(grid, x, y, seen);
    }
  }
};",1568
1567,"class Solution {
 public:
  int numOfWays(vector<int>& nums) {
    comb = generate(nums.size() + 1);
    return ways(nums) - 1;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  // comb[n][k] := C(n, k)
  vector<vector<int>> comb;

  int ways(const vector<int>& nums) {
    if (nums.size() <= 2)
      return 1;

    vector<int> left;
    vector<int> right;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < nums[0])
        left.push_back(nums[i]);
      else
        right.push_back(nums[i]);

    long ans = comb[nums.size() - 1][left.size()];
    ans = (ans * ways(left)) % kMod;
    ans = (ans * ways(right)) % kMod;
    return ans;
  }

  // Same as 118. Pascal's Triangle
  vector<vector<int>> generate(int numRows) {
    vector<vector<int>> comb;

    for (int i = 0; i < numRows; ++i)
      comb.push_back(vector<int>(i + 1, 1));

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < comb[i].size() - 1; ++j)
        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % kMod;

    return comb;
  }
};",1569
1568,"class SparseVector {
 public:
  SparseVector(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i)
      if (nums[i])
        indexToNum[i] = nums[i];
  }

  // Returns the dot product of the two sparse vectors.
  int dotProduct(SparseVector& vec) {
    if (indexToNum.size() < vec.indexToNum.size())
      return vec.dotProduct(*this);

    int ans = 0;

    for (const auto& [index, num] : vec.indexToNum)
      if (const auto it = indexToNum.find(index); it != indexToNum.cend())
        ans += num * it->second;

    return ans;
  }

 private:
  unordered_map<int, int> indexToNum;  // {index: num}
};",1570
1569,"SELECT
  Warehouse.name AS warehouse_name,
  SUM(
    Warehouse.units * Products.width * Products.length * Products.height
  ) AS volume
FROM Warehouse
INNER JOIN Products
  USING (product_id)
GROUP BY 1;",1571
1570,"class Solution {
 public:
  int diagonalSum(vector<vector<int>>& mat) {
    const int n = mat.size();
    int ans = 0;

    for (int i = 0; i < n; ++i) {
      ans += mat[i][i];
      ans += mat[n - 1 - i][i];
    }

    return n % 2 == 0 ? ans : ans - mat[n / 2][n / 2];
  }
};",1572
1571,"class Solution {
 public:
  int numWays(string s) {
    constexpr int kMod = 1'000'000'007;
    const int ones = ranges::count(s, '1');
    if (ones % 3 != 0)
      return 0;
    if (ones == 0) {
      const long n = s.size();
      return (n - 1) * (n - 2) / 2 % kMod;
    }

    int s1End = -1;
    int s2Start = -1;
    int s2End = -1;
    int s3Start = -1;
    int onesSoFar = 0;

    for (int i = 0; i < s.length(); ++i) {
      if (s[i] == '1')
        ++onesSoFar;
      if (s1End == -1 && onesSoFar == ones / 3)
        s1End = i;
      else if (s2Start == -1 && onesSoFar == ones / 3 + 1)
        s2Start = i;
      if (s2End == -1 && onesSoFar == ones / 3 * 2)
        s2End = i;
      else if (s3Start == -1 && onesSoFar == ones / 3 * 2 + 1)
        s3Start = i;
    }

    return static_cast<long>(s2Start - s1End) * (s3Start - s2End) % kMod;
  }
};",1573
1572,"class Solution {
 public:
  int findLengthOfShortestSubarray(vector<int>& arr) {
    const int n = arr.size();
    int l = 0;
    int r = n - 1;

    // arr[0..l] is non-decreasing.
    while (l < n - 1 && arr[l + 1] >= arr[l])
      ++l;
    // arr[r..n - 1] is non-decreasing.
    while (r > 0 && arr[r - 1] <= arr[r])
      --r;
    // Remove arr[l + 1..n - 1] or arr[0..r - 1].
    int ans = min(n - 1 - l, r);

    // Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers
    // at the rightmost indices, l and n - 1, and greedily shrink them toward
    // the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],
    // we ensure that `arr` becomes non-decreasing.
    int i = l;
    int j = n - 1;
    while (i >= 0 && j >= r && j > i) {
      if (arr[i] <= arr[j])
        --j;
      else
        --i;
      ans = min(ans, j - i);
    }

    return ans;
  }
};",1574
1573,"class Solution {
 public:
  int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
    vector<vector<int>> mem(locations.size(), vector<int>(fuel + 1, -1));
    return countRoutes(locations, start, finish, fuel, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of ways to reach the `finish` city from the i-th city
  // with `fuel` fuel.
  int countRoutes(const vector<int>& locations, int i, int finish, int fuel,
                  vector<vector<int>>& mem) {
    if (fuel < 0)
      return 0;
    if (mem[i][fuel] != -1)
      return mem[i][fuel];

    int res = i == finish ? 1 : 0;
    for (int j = 0; j < locations.size(); ++j) {
      if (j == i)
        continue;
      res += countRoutes(locations, j, finish,
                         fuel - abs(locations[i] - locations[j]), mem);
      res %= kMod;
    }

    return mem[i][fuel] = res;
  }
};",1575
1574,"class Solution {
 public:
  string modifyString(string s) {
    string ans;

    for (int i = 0; i < s.length(); ++i)
      if (s[i] == '?')
        ans += nextAvailable(ans, s, i);
      else
        ans += s[i];

    return ans;
  }

 private:
  char nextAvailable(const string& ans, const string& s, int i) {
    char c = 'a';
    while ((i > 0 && ans[i - 1] == c) ||  //
           (i + 1 < s.size() && c == s[i + 1]))
      ++c;
    return c;
  }
};",1576
1575,"class Solution {
 public:
  int numTriplets(vector<int>& nums1, vector<int>& nums2) {
    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1);
  }

 private:
  // Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].
  int countTriplets(const vector<int>& A, const vector<int>& B) {
    int res = 0;
    unordered_map<int, int> count;

    for (const int b : B)
      ++count[b];

    for (const int a : A) {
      const long target = static_cast<long>(a) * a;
      for (const auto& [b, freq] : count) {
        if (target % b > 0 || !count.count(target / b))
          continue;
        if (target / b == b)
          res += freq * (freq - 1);
        else
          res += freq * count[target / b];
      }
    }

    return res / 2;
  }
};",1577
1576,"class Solution {
 public:
  int minCost(string colors, vector<int>& neededTime) {
    int ans = 0;
    int maxNeededTime = neededTime[0];

    for (int i = 1; i < colors.length(); ++i)
      if (colors[i] == colors[i - 1]) {
        ans += min(maxNeededTime, neededTime[i]);
        // For each continuous group, Bob needs to remove every balloon except
        // the one with the maximum `neededTime`. So, he should hold the balloon
        // with the highest `neededTime` in his hand.
        maxNeededTime = max(maxNeededTime, neededTime[i]);
      } else {
        // If the current balloon is different from the previous one, discard
        // the balloon from the previous group and hold the new one in hand.
        maxNeededTime = neededTime[i];
      }

    return ans;
  }
};",1578
1577,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    --count;
    return true;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
    UnionFind alice(n);
    UnionFind bob(n);
    int requiredEdges = 0;

    // Greedily put type 3 edges in the front.
    sort(
        edges.begin(), edges.end(),
        [](const vector<int>& a, const vector<int>& b) { return a[0] > b[0]; });

    for (const vector<int>& edge : edges) {
      const int type = edge[0];
      const int u = edge[1] - 1;
      const int v = edge[2] - 1;
      switch (type) {
        case 3:  // Can be traversed by Alice and Bob.
          // Note that we should use | instead of || because if the first
          // expression is true, short-circuiting will skip the second
          // expression.
          if (alice.unionByRank(u, v) | bob.unionByRank(u, v))
            ++requiredEdges;
          break;
        case 2:  // Can be traversed by Bob.
          if (bob.unionByRank(u, v))
            ++requiredEdges;
        case 1:  // Can be traversed by Alice.
          if (alice.unionByRank(u, v))
            ++requiredEdges;
      }
    }

    return alice.getCount() == 1 && bob.getCount() == 1
               ? edges.size() - requiredEdges
               : -1;
  }
};",1579
1578,"class Solution {
 public:
  int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) {
    int l = 0;
    int r = warehouse.size() - 1;

    ranges::sort(boxes, greater<>());

    for (const int box : boxes) {
      if (l > r)
        return warehouse.size();
      if (box <= warehouse[l])
        ++l;
      else if (box <= warehouse[r])
        --r;
    }

    return l + (warehouse.size() - r - 1);
  }
};",1580
1579,"SELECT
  Visits.customer_id,
  COUNT(Visits.visit_id) AS count_no_trans
FROM Visits
LEFT JOIN Transactions
  USING (visit_id)
WHERE Transactions.transaction_id IS NULL
GROUP BY 1;",1581
1580,"class Solution {
 public:
  int numSpecial(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    vector<int> rowOnes(m);
    vector<int> colOnes(n);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 1) {
          ++rowOnes[i];
          ++colOnes[j];
        }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 1 && rowOnes[i] == 1 && colOnes[j] == 1)
          ++ans;

    return ans;
  }
};",1582
1581,"class Solution {
 public:
  int unhappyFriends(int n, vector<vector<int>>& preferences,
                     vector<vector<int>>& pairs) {
    int ans = 0;
    vector<int> matches(n);
    vector<unordered_map<int, int>> prefer(n);

    for (const vector<int>& pair : pairs) {
      const int x = pair[0];
      const int y = pair[1];
      matches[x] = y;
      matches[y] = x;
    }

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n - 1; ++j)
        prefer[i][preferences[i][j]] = j;

    for (int x = 0; x < n; ++x)
      for (const auto& [u, _] : prefer[x]) {
        const int y = matches[x];
        const int v = matches[u];
        if (prefer[x][u] < prefer[x][y] && prefer[u][x] < prefer[u][v]) {
          ++ans;
          break;
        }
      }

    return ans;
  }
};",1583
1582,"class Solution {
 public:
  int minCostConnectPoints(vector<vector<int>>& points) {
    // dist[i] := the minimum distance to connect the points[i]
    vector<int> dist(points.size(), INT_MAX);
    int ans = 0;

    for (int i = 0; i < points.size() - 1; ++i) {
      for (int j = i + 1; j < points.size(); ++j) {
        // Try to connect the points[i] with the points[j].
        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +
                                   abs(points[i][1] - points[j][1]));
        // Swap the points[j] (the point with the mnimum distance) with the
        // points[i + 1].
        if (dist[j] < dist[i + 1]) {
          swap(points[j], points[i + 1]);
          swap(dist[j], dist[i + 1]);
        }
      }
      ans += dist[i + 1];
    }

    return ans;
  }
};",1584
1583,"class Solution {
 public:
  bool isTransformable(string s, string t) {
    if (getCount(s) != getCount(t))
      return false;

    vector<queue<int>> positions(10);

    for (int i = 0; i < s.length(); ++i)
      positions[s[i] - '0'].push(i);

    // For each digit in `t`, check if we can put this digit in `s` at the same
    // position as `t`. Ensure that all the left digits are equal to or greater
    // than it. This is because the only operation we can perform is sorting in
    // ascending order. If there is a digit to the left that is smaller than it,
    // we can never move it to the same position as in `t`. However, if all the
    // digits to its left are equal to or greater than it, we can move it one
    // position to the left until it reaches the same position as in `t`.
    for (const char c : t) {
      const int d = c - '0';
      const int front = positions[d].front();
      positions[d].pop();
      for (int smaller = 0; smaller < d; ++smaller)
        if (!positions[smaller].empty() && positions[smaller].front() < front)
          return false;
    }
    return true;
  }

 private:
  vector<int> getCount(const string& s) {
    vector<int> count(10);
    for (const char c : s)
      ++count[c - '0'];
    return count;
  }
};",1585
1584,next(),1586
1585,"SELECT
  Users.name,
  SUM(amount) AS balance
FROM Users
INNER JOIN Transactions
  USING (account)
GROUP BY 1
HAVING balance > 10000;",1587
1586,"class Solution {
 public:
  int sumOddLengthSubarrays(vector<int>& arr) {
    int ans = 0;
    // Maintain two sums of subarrays ending in the previous index.
    // Each time we meet a new number, we'll consider ""how many times"" it should
    // contribute to the newly built subarrays by calculating the number of
    // previous even/odd-length subarrays.
    int prevEvenSum = 0;  // the sum of even-length subarrays
    int prevOddSum = 0;   // the sum of odd-length subarrays

    for (int i = 0; i < arr.size(); ++i) {
      // (i + 1) / 2 := the number of previous odd-length subarrays.
      const int currEvenSum = prevOddSum + ((i + 1) / 2) * arr[i];
      // i / 2 + 1 := the number of previous even-length subarrays
      // (including 0).
      const int currOddSum = prevEvenSum + (i / 2 + 1) * arr[i];
      ans += currOddSum;
      prevEvenSum = currEvenSum;
      prevOddSum = currOddSum;
    }

    return ans;
  }
};",1588
1587,"class Solution {
 public:
  int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    // count[i] := the number of times nums[i] has been requested
    vector<int> count(nums.size());

    for (const vector<int>& request : requests) {
      const int start = request[0];
      const int end = request[1];
      ++count[start];
      if (end + 1 < nums.size())
        --count[end + 1];
    }

    for (int i = 1; i < nums.size(); ++i)
      count[i] += count[i - 1];

    ranges::sort(count);
    ranges::sort(nums);

    for (int i = 0; i < nums.size(); ++i) {
      ans += static_cast<long>(nums[i]) * count[i];
      ans %= kMod;
    }

    return ans;
  }
};",1589
1588,"class Solution {
 public:
  int minSubarray(vector<int>& nums, int p) {
    const long sum = accumulate(nums.begin(), nums.end(), 0L);
    const int remainder = sum % p;
    if (remainder == 0)
      return 0;

    unordered_map<int, int> prefixToIndex{{0, -1}};
    int ans = nums.size();
    int prefix = 0;

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      prefix %= p;
      const int target = (prefix - remainder + p) % p;
      if (const auto it = prefixToIndex.find(target);
          it != prefixToIndex.cend())
        ans = min(ans, i - it->second);
      prefixToIndex[prefix] = i;
    }

    return ans == nums.size() ? -1 : ans;
  }
};",1590
1589,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool isPrintable(vector<vector<int>>& targetGrid) {
    constexpr int kMaxColor = 60;
    const int m = targetGrid.size();
    const int n = targetGrid[0].size();
    // graph[u] := {v1, v2} means v1 and v2 cover u
    vector<unordered_set<int>> graph(kMaxColor + 1);

    for (int color = 1; color <= kMaxColor; ++color) {
      // Get the rectangle of the current color.
      int minI = m;
      int minJ = n;
      int maxI = -1;
      int maxJ = -1;
      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (targetGrid[i][j] == color) {
            minI = min(minI, i);
            minJ = min(minJ, j);
            maxI = max(maxI, i);
            maxJ = max(maxJ, j);
          }
      // Add any color covering the current as the children.
      for (int i = minI; i <= maxI; ++i)
        for (int j = minJ; j <= maxJ; ++j)
          if (targetGrid[i][j] != color)
            graph[color].insert(targetGrid[i][j]);
    }

    vector<State> states(kMaxColor + 1);

    for (int color = 1; color <= kMaxColor; ++color)
      if (hasCycle(graph, color, states))
        return false;

    return true;
  }

 private:
  bool hasCycle(const vector<unordered_set<int>>& graph, int u,
                vector<State>& states) {
    if (states[u] == State::kVisiting)
      return true;
    if (states[u] == State::kVisited)
      return false;

    states[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, states))
        return true;
    states[u] = State::kVisited;

    return false;
  }
};",1591
1590,"class Solution {
 public:
  string reorderSpaces(string text) {
    const int spaces = ranges::count(text, ' ');
    string ans;
    vector<string> words;

    istringstream iss(text);
    string word;

    while (iss >> word)
      words.push_back(word);

    if (words.size() == 1)
      return word + string(spaces, ' ');

    const int gapSize = spaces / (words.size() - 1);
    const int remains = spaces % (words.size() - 1);

    for (int i = 0; i < words.size() - 1; ++i)
      ans += words[i] + string(gapSize, ' ');
    ans += words.back() + string(remains, ' ');

    return ans;
  }
};",1592
1591,"class Solution {
 public:
  int maxUniqueSplit(string s) {
    size_t ans = 0;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, unordered_set<string>&& seen,
           size_t& ans) {
    if (start == s.length()) {
      ans = max(ans, seen.size());
      return;
    }

    for (int i = 1; start + i <= s.length(); ++i) {
      const string cand = s.substr(start, i);
      if (seen.count(cand))
        continue;
      seen.insert(cand);
      dfs(s, start + i, move(seen), ans);
      seen.erase(cand);
    }
  }
};",1593
1592,"class Solution {
 public:
  int maxProductPath(vector<vector<int>>& grid) {
    constexpr int kMod = 1'000'000'007;
    const int m = grid.size();
    const int n = grid[0].size();
    // dpMin[i][j] := the minimum product from (0, 0) to (i, j)
    // dpMax[i][j] := the maximum product from (0, 0) to (i, j)
    vector<vector<long>> dpMin(m, vector<long>(n));
    vector<vector<long>> dpMax(m, vector<long>(n));

    dpMin[0][0] = dpMax[0][0] = grid[0][0];

    for (int i = 1; i < m; ++i)
      dpMin[i][0] = dpMax[i][0] = dpMin[i - 1][0] * grid[i][0];

    for (int j = 1; j < n; ++j)
      dpMin[0][j] = dpMax[0][j] = dpMin[0][j - 1] * grid[0][j];

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (grid[i][j] < 0) {
          dpMin[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
          dpMax[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
        } else {
          dpMin[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
          dpMax[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
        }

    const long maxi = max(dpMin.back().back(), dpMax.back().back());
    return maxi < 0 ? -1 : maxi % kMod;
  }
};",1594
1593,"class Solution {
 public:
  int connectTwoGroups(vector<vector<int>>& cost) {
    const int m = cost.size();
    const int n = cost[0].size();
    vector<vector<int>> mem(m, vector<int>(1 << n, INT_MAX));
    // minCosts[j] := the minimum cost of connecting group2's point j
    vector<int> minCosts(n);

    for (int j = 0; j < n; ++j) {
      int minCostIndex = 0;
      for (int i = 1; i < m; ++i)
        if (cost[i][j] < cost[minCostIndex][j])
          minCostIndex = i;
      minCosts[j] = cost[minCostIndex][j];
    }

    return connectTwoGroups(cost, 0, 0, minCosts, mem);
  }

 private:
  // Returns the minimum cost to connect group1's points[i..n) with group2's
  // points, where `mask` is the bitmask of the connected points in group2.
  int connectTwoGroups(const vector<vector<int>>& cost, int i, int mask,
                       const vector<int>& minCosts, vector<vector<int>>& mem) {
    if (i == cost.size()) {
      // All the points in group 1 are connected, so greedily assign the
      // minimum cost for the unconnected points of group2.
      int res = 0;
      for (int j = 0; j < cost[0].size(); ++j)
        if ((mask & 1 << j) == 0)
          res += minCosts[j];
      return res;
    }
    if (mem[i][mask] != INT_MAX)
      return mem[i][mask];

    for (int j = 0; j < cost[0].size(); ++j)
      mem[i][mask] =
          min(mem[i][mask],
              cost[i][j] +
                  connectTwoGroups(cost, i + 1, mask | 1 << j, minCosts, mem));

    return mem[i][mask];
  }
};",1595
1594,"WITH
  RankedOrders AS (
    SELECT
      Orders.customer_id,
      Orders.product_id,
      Products.product_name,
      RANK() OVER(
        PARTITION BY Orders.customer_id
        ORDER BY COUNT(Orders.product_id) DESC
      ) AS `rank`
    FROM Orders
    INNER JOIN Products
      USING (product_id)
    GROUP BY 1, 2
  )
SELECT
  customer_id,
  product_id,
  product_name
FROM RankedOrders
WHERE `rank` = 1;",1596
1595,"class Solution {
 public:
  Node* expTree(string s) {
    stack<Node*> nodes;
    stack<char> ops;  // [operators | parentheses]

    for (const char c : s)
      if (isdigit(c)) {
        nodes.push(new Node(c));
      } else if (c == '(') {
        ops.push(c);
      } else if (c == ')') {
        while (ops.top() != '(')
          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));
        ops.pop();  // Remove '('.
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        while (!ops.empty() && compare(ops.top(), c))
          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));
        ops.push(c);
      }

    while (!ops.empty())
      nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));

    return nodes.top();
  }

 private:
  Node* buildNode(char op, Node* right, Node* left) {
    return new Node(op, left, right);
  }

  // Returns true if op1 is a operator and priority(op1) >= priority(op2).
  bool compare(char op1, char op2) {
    if (op1 == '(' || op1 == ')')
      return false;
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }

  char pop(stack<char>& ops) {
    const char op = ops.top();
    ops.pop();
    return op;
  }

  Node* pop(stack<Node*>& nodes) {
    Node* node = nodes.top();
    nodes.pop();
    return node;
  }
};",1597
1596,"class Solution {
 public:
  int minOperations(vector<string>& logs) {
    int ans = 0;

    for (const string& log : logs) {
      if (log == ""./"")
        continue;
      if (log == ""../"")
        ans = max(0, ans - 1);
      else
        ++ans;
    }

    return ans;
  }
};",1598
1597,"class Solution {
 public:
  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,
                             int runningCost) {
    int waiting = 0;
    int profit = 0;
    int maxProfit = 0;
    int rotate = 0;
    int maxRotate = -1;
    int i = 0;

    while (waiting > 0 || i < customers.size()) {
      if (i < customers.size())
        waiting += customers[i++];
      // Onboard new customers.
      const int newOnboard = min(waiting, 4);
      waiting -= newOnboard;
      profit += newOnboard * boardingCost - runningCost;
      ++rotate;
      if (profit > maxProfit) {
        maxProfit = profit;
        maxRotate = rotate;
      }
    }

    return maxRotate;
  }
};",1599
1598,"class ThroneInheritance {
 public:
  ThroneInheritance(string kingName) : kingName(kingName) {}

  void birth(string parentName, string childName) {
    family[parentName].push_back(childName);
  }

  void death(string name) {
    dead.insert(name);
  }

  vector<string> getInheritanceOrder() {
    vector<string> ans;
    dfs(kingName, ans);
    return ans;
  }

 private:
  unordered_set<string> dead;
  unordered_map<string, vector<string>> family;
  string kingName;

  void dfs(const string& name, vector<string>& ans) {
    if (!dead.count(name))
      ans.push_back(name);
    if (!family.count(name))
      return;

    for (const string& child : family[name])
      dfs(child, ans);
  }
};",1600
1599,"class Solution {
 public:
  int maximumRequests(int n, vector<vector<int>>& requests) {
    int ans = 0;
    vector<int> degrees(n);  // degrees[i] := degrees of the i-th building

    function<void(int, int)> dfs = [&](int i, int processedReqs) {
      if (i == requests.size()) {
        if (ranges::all_of(degrees, [](int d) { return d == 0; }))
          ans = max(ans, processedReqs);
        return;
      }

      // Skip the requests[i].
      dfs(i + 1, processedReqs);

      // Process the requests[i].
      --degrees[requests[i][0]];
      ++degrees[requests[i][1]];
      dfs(i + 1, processedReqs + 1);
      --degrees[requests[i][1]];
      ++degrees[requests[i][0]];
    };

    dfs(0, 0);

    return ans;
  }
};",1601
1600,"class Solution {
 public:
  TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {
    TreeNode* ans = nullptr;
    int targetDepth = -1;
    dfs(root, u, 0, targetDepth, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, TreeNode* u, int depth, int& targetDepth,
           TreeNode*& ans) {
    if (root == nullptr)
      return;
    if (root == u) {
      targetDepth = depth;
      return;
    }
    if (depth == targetDepth && ans == nullptr) {
      ans = root;
      return;
    }
    dfs(root->left, u, depth + 1, targetDepth, ans);
    dfs(root->right, u, depth + 1, targetDepth, ans);
  }
};",1602
1601,"class ParkingSystem {
 public:
  ParkingSystem(int big, int medium, int small) {
    count = {big, medium, small};
  }

  bool addCar(int carType) {
    return count[carType - 1]-- > 0;
  }

 private:
  vector<int> count;
};",1603
1602,"class Solution {
 public:
  vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {
    vector<string> ans;
    unordered_map<string, vector<int>> nameToMinutes;

    for (int i = 0; i < keyName.size(); ++i) {
      const int minutes = getMinutes(keyTime[i]);
      nameToMinutes[keyName[i]].push_back(minutes);
    }

    for (auto& [name, minutes] : nameToMinutes)
      if (hasAlert(minutes))
        ans.push_back(name);

    ranges::sort(ans);
    return ans;
  }

 private:
  // Returns true if any worker uses the key-card three or more times in an
  // one-hour period.
  bool hasAlert(vector<int>& minutes) {
    if (minutes.size() > 70)
      return true;
    ranges::sort(minutes);
    for (int i = 2; i < minutes.size(); ++i)
      if (minutes[i - 2] + 60 >= minutes[i])
        return true;
    return false;
  }

  int getMinutes(const string& time) {
    const int h = stoi(time.substr(0, 2));
    const int m = stoi(time.substr(3));
    return 60 * h + m;
  }
};",1604
1603,"class Solution {
 public:
  vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {
    const int m = rowSum.size();
    const int n = colSum.size();
    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        ans[i][j] = min(rowSum[i], colSum[j]);
        rowSum[i] -= ans[i][j];
        colSum[j] -= ans[i][j];
      }

    return ans;
  }
};",1605
1604,"class Solution {
 public:
  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
    vector<int> ans;
    vector<int> times(k);
    set<int> idleServers;
    // (endTime, server)
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;

    for (int i = 0; i < k; ++i)
      idleServers.insert(i);

    for (int i = 0; i < arrival.size(); ++i) {
      // Pop all the servers that are available now.
      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {
        idleServers.insert(minHeap.top().second);
        minHeap.pop();
      }
      // Get the next available server.
      const int server = getNextAvailableServer(idleServers, i, k);
      if (server == -1)
        continue;
      ++times[server];
      minHeap.emplace(arrival[i] + load[i], server);
      idleServers.erase(server);
    }

    const int busiest = ranges::max(times);
    for (int i = 0; i < k; ++i)
      if (times[i] == busiest)
        ans.push_back(i);
    return ans;
  }

 private:
  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,
                             int k) {
    if (idleServers.empty())
      return -1;
    const auto it = idleServers.lower_bound(ithRequest % k);
    return it == idleServers.cend() ? *idleServers.begin() : *it;
  }
};",1606
1605,"SELECT Seller.seller_name
FROM Seller
LEFT JOIN Orders
  ON (
    Seller.seller_id = Orders.seller_id
    AND YEAR(Orders.sale_date) = 2020)
WHERE Orders.order_id IS NULL
ORDER BY 1;",1607
1606,"class Solution {
 public:
  int specialArray(vector<int>& nums) {
    ranges::sort(nums);

    if (nums[0] >= nums.size())
      return nums.size();

    for (int i = 1; i < nums.size(); ++i) {
      const int count = nums.size() - i;
      if (nums[i - 1] < count && nums[i] >= count)
        return count;
    }

    return -1;
  }
};",1608
1607,"class Solution {
 public:
  bool isEvenOddTree(TreeNode* root) {
    queue<TreeNode*> q{{root}};
    bool isEven = true;

    for (; !q.empty(); isEven = !isEven) {
      int prevVal = isEven ? INT_MIN : INT_MAX;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        if (isEven && (node->val % 2 == 0 || node->val <= prevVal))
          return false;  // invalid case on even level
        if (!isEven && (node->val % 2 == 1 || node->val >= prevVal))
          return false;  // invalid case on odd level
        prevVal = node->val;
        if (node->left != nullptr)
          q.push(node->left);
        if (node->right != nullptr)
          q.push(node->right);
      }
    }

    return true;
  }
};",1609
1608,"class Solution {
 public:
  int visiblePoints(vector<vector<int>>& points, int angle,
                    vector<int>& location) {
    const int posX = location[0];
    const int posY = location[1];
    int maxVisible = 0;
    int same = 0;
    vector<double> pointAngles;

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      if (x == posX && y == posY)
        ++same;
      else
        pointAngles.push_back(getAngle(y - posY, x - posX));
    }

    ranges::sort(pointAngles);

    const int n = pointAngles.size();
    for (int i = 0; i < n; ++i)
      pointAngles.push_back(pointAngles[i] + 360);

    for (int l = 0, r = 0; r < pointAngles.size(); ++r) {
      while (pointAngles[r] - pointAngles[l] > angle)
        ++l;
      maxVisible = max(maxVisible, r - l + 1);
    }

    return maxVisible + same;
  }

 private:
  double getAngle(int dy, int dx) {
    return atan2(dy, dx) * 180 / M_PI;
  }
};",1610
1609,"class Solution {
 public:
  int minimumOneBitOperations(int n) {
    // Observation: e.g. n = 2^2
    //        100 (2^2 needs 2^3 - 1 ops)
    // op1 -> 101
    // op2 -> 111
    // op1 -> 110
    // op2 -> 010 (2^1 needs 2^2 - 1 ops)
    // op1 -> 011
    // op2 -> 001 (2^0 needs 2^1 - 1 ops)
    // op1 -> 000
    //
    // So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k
    // also takes 2^(k + 1) - 1 ops.

    // e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.
    //   - If the second bit is 1, you only need to consider the cost of turning
    //     the last 2 bits to 0.
    //   - If the second bit is 0, you need to add up the cost of flipping the
    //     second bit from 0 to 1.
    // XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.
    // Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.
    if (n == 0)
      return 0;
    // x is the largest 2^k <= n.
    // x | x >> 1 -> x >> 1 needs 1 op.
    //     x >> 1 -> 0      needs x = 2^k - 1 ops.
    int x = 1;
    while (x * 2 <= n)
      x <<= 1;
    return minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1;
  }
};",1611
1610,"class Solution {
 public:
  bool checkEquivalence(Node* root1, Node* root2) {
    vector<int> count(26);
    dfs(root1, count, 1);
    dfs(root2, count, -1);
    return ranges::count_if(count, [](int c) { return c != 0; }) == 0;
  }

 private:
  void dfs(Node* root, vector<int>& count, int add) {
    if (root == nullptr)
      return;
    if ('a' <= root->val && root->val <= 'z')
      count[root->val - 'a'] += add;
    dfs(root->left, count, add);
    dfs(root->right, count, add);
  }
};",1612
1611,"WITH
  RECURSIVE Ids AS (
    SELECT 1 AS id
    UNION ALL
    SELECT id + 1
    FROM Ids
    WHERE id < (
        SELECT MAX(customer_id)
        FROM Customers
      )
  )
SELECT Ids.id AS ids
FROM Ids
LEFT JOIN Customers
  ON (Ids.id = Customers.customer_id)
WHERE Customers.customer_id IS NULL
ORDER BY 1;",1613
1612,"class Solution {
 public:
  int maxDepth(string s) {
    int ans = 0;
    int opened = 0;

    for (const char c : s)
      if (c == '(')
        ans = max(ans, ++opened);
      else if (c == ')')
        --opened;

    return ans;
  }
};",1614
1613,"class Solution {
 public:
  int maximalNetworkRank(int n, vector<vector<int>>& roads) {
    vector<int> degrees(n);

    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      ++degrees[u];
      ++degrees[v];
    }

    // Find the first maximum and the second maximum degrees.
    int maxDegree1 = 0;
    int maxDegree2 = 0;
    for (const int degree : degrees) {
      if (degree > maxDegree1) {
        maxDegree2 = maxDegree1;
        maxDegree1 = degree;
      } else if (degree > maxDegree2) {
        maxDegree2 = degree;
      }
    }

    // There can be multiple nodes with `maxDegree1` or `maxDegree2`.
    // Find the counts of such nodes.
    int countMaxDegree1 = 0;
    int countMaxDegree2 = 0;
    for (const int degree : degrees)
      if (degree == maxDegree1)
        ++countMaxDegree1;
      else if (degree == maxDegree2)
        ++countMaxDegree2;

    if (countMaxDegree1 == 1) {
      // Case 1: If there is only one node with degree = `maxDegree1`, then
      // we'll need to use the node with degree = `maxDegree2`. The answer in
      // general will be (maxDegree1 + maxDegree2), but if the two nodes that
      // we're considering are connected, then we'll have to subtract 1.
      const int edgeCount =
          getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +
          getEdgeCount(roads, degrees, maxDegree2, maxDegree1);
      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount ? 1 : 0);
    } else {
      // Case 2: If there are more than one node with degree = `maxDegree1`,
      // then we can consider `maxDegree1` twice, and we don't need to use
      // `maxDegree2`. The answer in general will be 2 * maxDegree1, but if the
      // two nodes that we're considering are connected, then we'll have to
      // subtract 1.
      const int edgeCount =
          getEdgeCount(roads, degrees, maxDegree1, maxDegree1);
      const int maxPossibleEdgeCount =
          countMaxDegree1 * (countMaxDegree1 - 1) / 2;
      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount ? 1 : 0);
    }
  }

 private:
  // Returns the number of edges (u, v) where degress[u] == degreeU and
  // degrees[v] == degreeV.
  int getEdgeCount(const vector<vector<int>>& roads, const vector<int>& degrees,
                   int degreeU, int degreeV) {
    int edgeCount = 0;
    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      if (degrees[u] == degreeU && degrees[v] == degreeV)
        ++edgeCount;
    }
    return edgeCount;
  }
};",1615
1614,"class Solution {
 public:
  bool checkPalindromeFormation(string a, string b) {
    return check(a, b) || check(b, a);
  }

 private:
  bool check(const string& a, const string& b) {
    for (int i = 0, j = a.length() - 1; i < j; ++i, --j)
      if (a[i] != b[j])
        // a[0:i] + a[i..j] + b[j + 1:] or
        // a[0:i] + b[i..j] + b[j + 1:]
        return isPalindrome(a, i, j) || isPalindrome(b, i, j);
    return true;
  }

  bool isPalindrome(const string& s, int i, int j) {
    while (i < j)
      if (s[i++] != s[j--])
        return false;
    return true;
  }
};",1616
1615,"class Solution {
 public:
  vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
    const int maxMask = 1 << n;
    const vector<vector<int>> dist = floydWarshall(n, edges);
    vector<int> ans(n - 1);

    // mask := the subset of the cities
    for (int mask = 0; mask < maxMask; ++mask) {
      const int maxDist = getMaxDist(mask, dist, n);
      if (maxDist > 0)
        ++ans[maxDist - 1];
    }

    return ans;
  }

 private:
  vector<vector<int>> floydWarshall(int n, const vector<vector<int>>& edges) {
    vector<vector<int>> dist(n, vector<int>(n, n));

    for (int i = 0; i < n; ++i)
      dist[i][i] = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      dist[u][v] = 1;
      dist[v][u] = 1;
    }

    for (int k = 0; k < n; ++k)
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    return dist;
  }

  int getMaxDist(int mask, const vector<vector<int>>& dist, int n) {
    int maxDist = 0;
    int edgeCount = 0;
    int cityCount = 0;
    for (int u = 0; u < n; ++u) {
      if ((mask >> u & 1) == 0)  // u is not in the subset.
        continue;
      ++cityCount;
      for (int v = u + 1; v < n; ++v) {
        if ((mask >> v & 1) == 0)  // v is not in the subset.
          continue;
        if (dist[u][v] == 1)  // u and v are connected.
          ++edgeCount;
        maxDist = max(maxDist, dist[u][v]);
      }
    }
    return edgeCount == cityCount - 1 ? maxDist : 0;
  }
};",1617
1616,"/**
 * // This is the FontInfo's API interface.
 * // You should not implement it, or speculate about its implementation
 * class FontInfo {
 *  public:
 *   // Return the width of char ch when fontSize is used.
 *   int getWidth(int fontSize, char ch);
 *
 *   // Return Height of any char when fontSize is used.
 *   int getHeight(int fontSize)
 * };
 */
class Solution {
 public:
  int maxFont(string text, int w, int h, vector<int>& fonts,
              FontInfo fontInfo) {
    vector<int> count(26);

    for (const char c : text)
      ++count[c - 'a'];

    int l = 0;
    int r = fonts.size() - 1;

    while (l < r) {
      const int m = (l + r + 1) / 2;
      if (fontInfo.getHeight(fonts[m]) <= h &&
          getWidthSum(count, fonts[m], fontInfo) <= w)
        l = m;
      else
        r = m - 1;
    }

    return getWidthSum(count, fonts[l], fontInfo) <= w ? fonts[l] : -1;
  }

 private:
  int getWidthSum(const vector<int>& count, int font, FontInfo& fontInfo) {
    int width = 0;
    for (int i = 0; i < 26; ++i)
      width += count[i] * fontInfo.getWidth(font, (char)('a' + i));
    return width;
  }
};",1618
1617,"class Solution {
 public:
  double trimMean(vector<int>& arr) {
    int offset = arr.size() / 20;
    nth_element(arr.begin(), arr.begin() + offset, arr.end());
    nth_element(arr.begin() + offset, arr.end() - offset, arr.end());
    double sum = accumulate(arr.begin() + offset, arr.end() - offset, 0.0);
    return sum / (arr.size() - offset * 2);
  }
};",1619
1618,"class Solution {
 public:
  vector<int> bestCoordinate(vector<vector<int>>& towers, int radius) {
    constexpr int kMax = 50;
    const int n = towers.size();
    vector<int> ans(2);
    int maxQuality = 0;

    for (int i = 0; i <= kMax; ++i)
      for (int j = 0; j <= kMax; ++j) {
        int qualitySum = 0;
        for (const vector<int>& tower : towers) {
          const double d = dist(tower, i, j);
          if (d <= radius) {
            const int q = tower[2];
            qualitySum += static_cast<int>(q / (1 + d));
          }
        }
        if (qualitySum > maxQuality) {
          maxQuality = qualitySum;
          ans = {i, j};
        }
      }

    return ans;
  }

 private:
  // Returns the distance between the tower and the coordinate.
  double dist(const vector<int>& tower, int i, int j) {
    return sqrt(pow(tower[0] - i, 2) + pow(tower[1] - j, 2));
  }
};",1620
1619,"class Solution {
 public:
  int numberOfSets(int n, int k) {
    vector<vector<vector<int>>> mem(
        n, vector<vector<int>>(k + 1, vector<int>(2, -1)));
    return numberOfSets(0, k, /*drawing=*/false, n, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int numberOfSets(int i, int k, bool drawing, int n,
                   vector<vector<vector<int>>>& mem) {
    if (k == 0)  // Find a way to draw k segments.
      return 1;
    if (i == n)  // Reach the end.
      return 0;
    if (mem[i][k][drawing] != -1)
      return mem[i][k][drawing];
    if (drawing)
      // 1. Keep drawing at i and move to i + 1.
      // 2. Stop at i so decrease k. We can start from i for the next segment.
      return mem[i][k][drawing] = (numberOfSets(i + 1, k, true, n, mem) +
                                   numberOfSets(i, k - 1, false, n, mem)) %
                                  kMod;
    // 1. Skip i and move to i + 1.
    // 2. Start at i and move to i + 1.
    return mem[i][k][drawing] = (numberOfSets(i + 1, k, false, n, mem) +
                                 numberOfSets(i + 1, k, true, n, mem)) %
                                kMod;
  }
};",1621
1620,append(val: int),1622
1621,"SELECT
  SchoolA.student_name AS member_A,
  SchoolB.student_name AS member_B,
  SchoolC.student_name AS member_C
FROM SchoolA, SchoolB, SchoolC
WHERE
  SchoolA.student_id != SchoolB.student_id
  AND SchoolA.student_id != SchoolC.student_id
  AND SchoolB.student_id != SchoolC.student_id
  AND SchoolA.student_name != SchoolB.student_name
  AND SchoolA.student_name != SchoolC.student_name
  AND SchoolB.student_name != SchoolC.student_name;",1623
1622,"class Solution {
 public:
  int maxLengthBetweenEqualCharacters(string s) {
    int ans = -1;
    vector<int> lastSeen(26, -1);

    for (int i = 0; i < s.length(); ++i) {
      const int c = s[i] - 'a';
      if (lastSeen[c] == -1)
        lastSeen[c] = i;
      else
        ans = max(ans, i - lastSeen[c] - 1);
    }

    return ans;
  }
};",1624
1623,"class Solution {
 public:
  string findLexSmallestString(string s, int a, int b) {
    string ans = s;

    dfs(s, a, b, {}, ans);

    return ans;
  }

 private:
  void dfs(string s, int a, int b, unordered_set<string>&& seen, string& ans) {
    if (seen.count(s))
      return;

    seen.insert(s);
    ans = min(ans, s);

    dfs(add(s, a), a, b, move(seen), ans);
    dfs(rotate(s, b), a, b, move(seen), ans);
  }

  string add(string& s, int a) {
    for (int i = 1; i < s.length(); i += 2)
      s[i] = '0' + (s[i] - '0' + a) % 10;
    return s;
  }

  string rotate(const string& s, int b) {
    const int n = s.length();
    return s.substr(n - b, n) + s.substr(0, n - b);
  }
};",1625
1624,"struct Player {
  int age;
  int score;
  Player(int age, int score) : age(age), score(score) {}
};

class Solution {
 public:
  int bestTeamScore(vector<int>& scores, vector<int>& ages) {
    const int n = scores.size();
    vector<Player> players;
    // dp[i] := the maximum score of choosing the players[0..i] with the
    // players[i] being selected
    vector<int> dp(n);

    for (int i = 0; i < n; ++i)
      players.emplace_back(ages[i], scores[i]);

    ranges::sort(players, [](const Player& a, const Player& b) {
      return a.age == b.age ? a.score > b.score : a.age > b.age;
    });

    for (int i = 0; i < n; ++i) {
      // For each player, choose it first.
      dp[i] = players[i].score;
      // players[j].age >= players[i].age since we sort in descending order.
      // So, we only have to check that players[j].score >= players[i].score.
      for (int j = 0; j < i; ++j)
        if (players[j].score >= players[i].score)
          dp[i] = max(dp[i], dp[j] + players[i].score);
    }

    return ranges::max(dp);
  }
};",1626
1625,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
    return true;
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<bool> areConnected(int n, int threshold,
                            vector<vector<int>>& queries) {
    vector<bool> ans;
    UnionFind uf(n + 1);

    for (int z = threshold + 1; z <= n; ++z)
      for (int x = z * 2; x <= n; x += z)
        uf.unionByRank(z, x);

    for (const vector<int>& query : queries) {
      const int a = query[0];
      const int b = query[1];
      ans.push_back(uf.find(a) == uf.find(b));
    }

    return ans;
  }
};",1627
1626,"/**
 * This is the interface for the expression tree Node.
 * You should not remove it, and you can define some classes to implement it.
 */

class Node {
 public:
  virtual ~Node(){};
  virtual int evaluate() const = 0;

 protected:
  // define your fields here
};

class ExpNode : public Node {
 public:
  ExpNode(const string& val, ExpNode* left, ExpNode* right)
      : val(val), left(left), right(right) {}

  int evaluate() const override {
    return left == nullptr && right == nullptr
               ? stoi(val)
               : op.at(val)(left->evaluate(), right->evaluate());
  }

 private:
  static const inline unordered_map<string, function<long(long, long)>> op{
      {""+"", std::plus<long>()},
      {""-"", std::minus<long>()},
      {""*"", std::multiplies<long>()},
      {""/"", std::divides<long>()}};
  const string val;
  const ExpNode* const left;
  const ExpNode* const right;
};

/**
 * This is the TreeBuilder class.
 * You can treat it as the driver code that takes the postinfix input
 * and returns the expression tree represnting it as a Node.
 */

class TreeBuilder {
 public:
  Node* buildTree(vector<string>& postfix) {
    stack<ExpNode*> stack;

    for (const string& val : postfix)
      if (val == ""+"" || val == ""-"" || val == ""*"" || val == ""/"") {
        ExpNode* right = stack.top();
        stack.pop();
        ExpNode* left = stack.top();
        stack.pop();
        stack.push(new ExpNode(val, left, right));
      } else {
        stack.push(new ExpNode(val, nullptr, nullptr));
      }

    return stack.top();
  }
};",1628
1627,"class Solution {
 public:
  char slowestKey(vector<int>& releaseTimes, string keysPressed) {
    char ans = keysPressed[0];
    int maxDuration = releaseTimes[0];

    for (int i = 1; i < keysPressed.length(); ++i) {
      const int duration = releaseTimes[i] - releaseTimes[i - 1];
      if (duration > maxDuration ||
          (duration == maxDuration && keysPressed[i] > ans)) {
        ans = keysPressed[i];
        maxDuration = duration;
      }
    }

    return ans;
  }
};",1629
1628,"class Solution {
 public:
  vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l,
                                        vector<int>& r) {
    vector<bool> ans;

    for (int i = 0; i < l.size(); ++i)
      ans.push_back(isArithmetic(nums, l[i], r[i]));

    return ans;
  }

 private:
  bool isArithmetic(vector<int>& nums, int l, int r) {
    if (r - l < 2)
      return true;

    unordered_set<int> numsSet;
    int mini = INT_MAX;
    int maxi = INT_MIN;

    for (int i = l; i <= r; ++i) {
      mini = min(mini, nums[i]);
      maxi = max(maxi, nums[i]);
      numsSet.insert(nums[i]);
    }

    if ((maxi - mini) % (r - l) != 0)
      return false;

    const int interval = (maxi - mini) / (r - l);

    for (int k = 1; k <= r - l; ++k)
      if (!numsSet.count(mini + k * interval))
        return false;

    return true;
  }
};",1630
1629,"struct T {
  int i;
  int j;
  int d;
  T(int i, int j, int d) : i(i), j(j), d(d) {}
};

class Solution {
 public:
  int minimumEffortPath(vector<vector<int>>& heights) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = heights.size();
    const int n = heights[0].size();
    auto compare = [](const T& a, const T& b) { return a.d > b.d; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    // diff[i][j] := the maximum absolute difference to reach (i, j)
    vector<vector<int>> diff(m, vector<int>(n, INT_MAX));
    vector<vector<bool>> seen(m, vector<bool>(n));

    minHeap.emplace(0, 0, 0);
    diff[0][0] = 0;

    while (!minHeap.empty()) {
      const auto [i, j, d] = minHeap.top();
      minHeap.pop();
      if (i == m - 1 && j == n - 1)
        return d;
      seen[i][j] = true;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        const int newDiff = abs(heights[i][j] - heights[x][y]);
        const int maxDiff = max(diff[i][j], newDiff);
        if (diff[x][y] > maxDiff) {
          diff[x][y] = maxDiff;
          minHeap.emplace(x, y, maxDiff);
        }
      }
    }

    throw;
  }
};",1631
1630,"class UnionFind {
 public:
  void union_(int u, int v) {
    if (!id.count(u))
      id[u] = u;
    if (!id.count(v))
      id[v] = v;
    const int i = find(u);
    const int j = find(v);
    if (i != j)
      id[i] = j;
  }

  unordered_map<int, vector<int>> getGroupIdToValues() {
    unordered_map<int, vector<int>> groupIdToValues;
    for (const auto& [u, _] : id)
      groupIdToValues[find(u)].push_back(u);
    return groupIdToValues;
  }

 private:
  unordered_map<int, int> id;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    // {val: [(i, j)]}
    map<int, vector<pair<int, int>>> valToGrids;
    // rank[i] := the maximum rank of the row or column so far
    vector<int> maxRankSoFar(m + n);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        valToGrids[matrix[i][j]].emplace_back(i, j);

    for (const auto& [val, grids] : valToGrids) {
      UnionFind uf;
      for (const auto& [i, j] : grids)
        // Union i-th row with j-th col.
        uf.union_(i, j + m);
      for (const auto& [groupId, values] : uf.getGroupIdToValues()) {
        // Get the maximum rank of all the included rows and columns.
        int maxRank = 0;
        for (const int i : values)
          maxRank = max(maxRank, maxRankSoFar[i]);
        // Update all the rows and columns to maxRank + 1.
        for (const int i : values)
          maxRankSoFar[i] = maxRank + 1;
      }
      for (const auto& [i, j] : grids)
        ans[i][j] = maxRankSoFar[i];
    }

    return ans;
  }
};",1632
1631,"SELECT
  contest_id,
  ROUND(
    COUNT(user_id) * 100 / (
      SELECT COUNT(*)
      FROM Users
    ),
    2
  ) AS percentage
FROM Register
GROUP BY 1
ORDER BY percentage DESC, contest_id;",1633
1632,"/**
 * Definition for polynomial singly-linked list.
 * struct PolyNode {
 *   int coefficient, power;
 *   PolyNode *next;
 *   PolyNode(): coefficient(0), power(0), next(nullptr) {};
 *   PolyNode(int x, int y): coefficient(x), power(y), next(nullptr) {};
 *   PolyNode(int x, int y, PolyNode* next): coefficient(x), power(y),
 *                                           next(next) {};
 * };
 */

class Solution {
 public:
  PolyNode* addPoly(PolyNode* poly1, PolyNode* poly2) {
    PolyNode* dummy = new PolyNode();
    PolyNode* curr = dummy;
    PolyNode* p = poly1;  // poly1's pointer
    PolyNode* q = poly2;  // poly2's pointer

    while (p != nullptr && q != nullptr) {
      if (p->power > q->power) {
        curr->next = new PolyNode(p->coefficient, p->power);
        curr = curr->next;
        p = p->next;
      } else if (p->power < q->power) {
        curr->next = new PolyNode(q->coefficient, q->power);
        curr = curr->next;
        q = q->next;
      } else {  // p->power == q->power
        const int sumCoefficient = p->coefficient + q->coefficient;
        if (sumCoefficient != 0) {
          curr->next = new PolyNode(sumCoefficient, p->power);
          curr = curr->next;
        }
        p = p->next;
        q = q->next;
      }
    }

    while (p != nullptr) {
      curr->next = new PolyNode(p->coefficient, p->power);
      curr = curr->next;
      p = p->next;
    }

    while (q != nullptr) {
      curr->next = new PolyNode(q->coefficient, q->power);
      curr = curr->next;
      q = q->next;
    }

    return dummy->next;
  }
};",1634
1633,"WITH
  RECURSIVE Calendar AS (
    SELECT 1 AS month
    UNION ALL
    SELECT month + 1
    FROM Calendar
    WHERE month < 12
  )
SELECT
  Calendar.month,
  (
    SELECT COUNT(*)
    FROM Drivers
    WHERE
      YEAR(Drivers.join_date) < '2020'
      OR (
        YEAR(Drivers.join_date) = '2020'
        AND MONTH(Drivers.join_date) <= Calendar.month)
  ) AS active_drivers,
  (
    SELECT COUNT(*)
    FROM AcceptedRides
    INNER JOIN Rides
      USING (ride_id)
    WHERE
      YEAR(Rides.requested_at) = '2020'
      AND MONTH(Rides.requested_at) = Calendar.month
  ) AS accepted_rides
FROM Calendar;",1635
1634,"struct T {
  int num;
  int freq;
  T(int num, int freq) : num(num), freq(freq) {}
};

class Solution {
 public:
  vector<int> frequencySort(vector<int>& nums) {
    vector<int> ans;
    auto compare = [](const T& a, const T& b) {
      return a.freq == b.freq ? a.num < b.num : a.freq > b.freq;
    };
    priority_queue<T, vector<T>, decltype(compare)> heap(compare);
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      heap.emplace(num, freq);

    while (!heap.empty()) {
      const auto [num, freq] = heap.top();
      heap.pop();
      for (int i = 0; i < freq; ++i)
        ans.push_back(num);
    }

    return ans;
  }
};",1636
1635,"class Solution {
 public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    int ans = 0;
    vector<int> xs;

    for (const vector<int>& point : points) {
      const int x = point[0];
      xs.push_back(x);
    }

    ranges::sort(xs);

    for (int i = 1; i < xs.size(); ++i)
      ans = max(ans, xs[i] - xs[i - 1]);

    return ans;
  }
};",1637
1636,"class Solution {
 public:
  int countSubstrings(string s, string t) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i)
      ans += count(s, t, i, 0);

    for (int j = 1; j < t.length(); ++j)
      ans += count(s, t, 0, j);

    return ans;
  }

 private:
  // Returns the number of substrings of s[i..n) and t[j..n) that differ by one
  // letter.
  int count(const string& s, const string& t, int i, int j) {
    int res = 0;
    // the number of substrings starting at s[i] and t[j] ending in the current
    // index with zero different letter
    int dp0 = 0;
    // the number of substrings starting at s[i] and t[j] ending in the current
    // index with one different letter
    int dp1 = 0;

    for (; i < s.length() && j < t.length(); ++i, ++j) {
      if (s[i] == t[j]) {
        ++dp0;
      } else {
        dp1 = dp0 + 1;
        dp0 = 0;
      }
      res += dp1;
    }

    return res;
  }
};",1638
1637,"class Solution {
 public:
  int numWays(vector<string>& words, string target) {
    const int wordLength = words[0].length();
    vector<vector<int>> mem(target.length(), vector<int>(wordLength, -1));
    // counts[j] := the count map of words[i][j], where 0 <= i < |words|
    vector<vector<int>> counts(wordLength, vector<int>(26));

    for (int i = 0; i < wordLength; ++i)
      for (const string& word : words)
        ++counts[i][word[i] - 'a'];

    return numWays(target, 0, 0, counts, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of ways to form target[i..n) using word[j..n).
  int numWays(const string& target, int i, int j,
              const vector<vector<int>>& counts, vector<vector<int>>& mem) {
    if (i == target.length())
      return 1;
    if (j == counts.size())
      return 0;
    if (mem[i][j] != -1)
      return mem[i][j];
    return mem[i][j] = (numWays(target, i + 1, j + 1, counts, mem) *
                            static_cast<long>(counts[j][target[i] - 'a']) +
                        numWays(target, i, j + 1, counts, mem)) %
                       kMod;
  };
};",1639
1638,"class Solution {
 public:
  bool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {
    vector<int> concatenated;
    unordered_map<int, vector<int>> startToPiece;

    for (const vector<int>& piece : pieces)
      startToPiece[piece[0]] = piece;

    for (const int a : arr)
      if (startToPiece.count(a))
        for (const int num : startToPiece[a])
          concatenated.push_back(num);

    return concatenated == arr;
  }
};",1640
1639,"class Solution {
 public:
  int countVowelStrings(int n) {
    // dp[0] := the number of lexicographically sorted string that end in 'a'
    // dp[1] := the number of lexicographically sorted string that end in 'e'
    // dp[2] := the number of lexicographically sorted string that end in 'i'
    // dp[3] := the number of lexicographically sorted string that end in 'o'
    // dp[4] := the number of lexicographically sorted string that end in 'u'
    vector<int> dp(5, 1);

    for (int i = 2; i <= n; ++i) {
      vector<int> newDp(5);
      for (int j = 0; j < 5; ++j)
        for (int k = 0; k <= j; ++k)
          newDp[j] += dp[k];
      dp = move(newDp);
    }

    return accumulate(dp.begin(), dp.end(), 0);
  }
};",1641
1640,"class Solution {
 public:
  int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
    priority_queue<int, vector<int>, greater<int>> minHeap;

    for (int i = 1; i < heights.size(); ++i) {
      const int diff = heights[i] - heights[i - 1];
      if (diff <= 0)
        continue;
      minHeap.push(diff);
      // If we run out of ladders, greedily use as less bricks as possible.
      if (minHeap.size() > ladders)
        bricks -= minHeap.top(), minHeap.pop();
      if (bricks < 0)
        return i - 1;
    }

    return heights.size() - 1;
  }
};",1642
1641,"class Solution {
 public:
  string kthSmallestPath(vector<int>& destination, int k) {
    string ans;
    int v = destination[0];
    int h = destination[1];
    const int totalSteps = v + h;
    const vector<vector<int>> comb = getComb(totalSteps - 1, v);

    for (int i = 0; i < totalSteps; ++i) {
      // If 'H' is picked, we can reach ranks [1, availableRank].
      const int availableRank = comb[h + v - 1][v];
      if (availableRank >= k) {  // Should pick 'H'.
        ans += 'H';
        --h;
      } else {  // Should pick 'V'.
        k -= availableRank;
        ans += 'V';
        --v;
      }
    }

    return ans;
  }

 private:
  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)
  vector<vector<int>> getComb(int n, int k) {
    vector<vector<int>> comb(n + 1, vector<int>(k + 1));
    for (int i = 0; i <= n; ++i)
      comb[i][0] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j)
        comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];
    return comb;
  }
};",1643
1642,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    bool seenP = false;
    bool seenQ = false;
    TreeNode* lca = getLCA(root, p, q, seenP, seenQ);
    return seenP && seenQ ? lca : nullptr;
  }

 private:
  TreeNode* getLCA(TreeNode* root, TreeNode* p, TreeNode* q, bool& seenP,
                   bool& seenQ) {
    if (root == nullptr)
      return nullptr;
    // Need to traverse the entire tree to update `seenP` and `seenQ`.
    TreeNode* left = getLCA(root->left, p, q, seenP, seenQ);
    TreeNode* right = getLCA(root->right, p, q, seenP, seenQ);
    if (root == p) {
      seenP = true;
      return root;
    }
    if (root == q) {
      seenQ = true;
      return root;
    }
    if (left != nullptr && right != nullptr)
      return root;
    return left == nullptr ? right : left;
  }
};",1644
1643,"WITH
  RECURSIVE Calendar AS (
    SELECT 1 AS month
    UNION ALL
    SELECT month + 1
    FROM Calendar
    WHERE month < 12
  )
SELECT
  Calendar.month,
  IFNULL(
    ROUND(
      (
        SELECT COUNT(DISTINCT AcceptedRides.driver_id)
        FROM AcceptedRides
        INNER JOIN Rides
          USING (ride_id)
        WHERE
          YEAR(Rides.requested_at) = '2020'
          AND MONTH(Rides.requested_at) = Calendar.month
      ) / (
        SELECT COUNT(*)
        FROM Drivers
        WHERE YEAR(Drivers.join_date) < '2020'
          OR (
            YEAR(Drivers.join_date) = '2020'
            AND MONTH(Drivers.join_date) <= Calendar.month)
      ) * 100,
      2
    ),
    0
  ) AS working_percentage
FROM Calendar;",1645
1644,"class Solution {
 public:
  int getMaximumGenerated(int n) {
    if (n == 0)
      return 0;
    if (n == 1)
      return 1;

    vector<int> nums(n + 1);
    nums[1] = 1;

    for (int i = 1; (2 * i + 1) <= n; ++i) {
      nums[2 * i] = nums[i];
      nums[2 * i + 1] = nums[i] + nums[i + 1];
    }

    return ranges::max(nums);
  }
};",1646
1645,"class Solution {
 public:
  int minDeletions(string s) {
    int ans = 0;
    vector<int> count(26);
    unordered_set<int> usedFreq;

    for (const char c : s)
      ++count[c - 'a'];

    for (int freq : count)
      while (freq > 0 && !usedFreq.insert(freq).second) {
        --freq;  // Delete ('a' + i).
        ++ans;
      }

    return ans;
  }
};",1647
1646,"class Solution {
 public:
  int maxProfit(vector<int>& inventory, int orders) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    long largestCount = 1;

    ranges::sort(inventory, greater<>());

    for (int i = 0; i < inventory.size(); ++i, ++largestCount)
      if (i == inventory.size() - 1 || inventory[i] > inventory[i + 1]) {
        // If we are at the last inventory, or inventory[i] > inventory[i + 1].
        // In either case, we will pick inventory[i - largestCount + 1..i].
        const int pick = (i == inventory.size() - 1)
                             ? inventory[i]
                             : inventory[i] - inventory[i + 1];
        if (largestCount * pick >= orders) {
          // We have run out of orders, so we need to recalculate the number of
          // balls that we actually pick for inventory[i - largestCount + 1..i].
          const int actualPick = orders / largestCount;
          const int remaining = orders % largestCount;
          return (ans +
                  largestCount *
                      trapezoid(inventory[i], inventory[i] - actualPick + 1) +
                  remaining * static_cast<long>(inventory[i] - actualPick)) %
                 kMod;
        }
        ans += largestCount * trapezoid(inventory[i], inventory[i] - pick + 1);
        ans %= kMod;
        orders -= largestCount * pick;
      }

    throw;
  }

 private:
  long trapezoid(long a, long b) {
    return (a + b) * (a - b + 1) / 2;
  }
};",1648
1647,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int createSortedArray(vector<int>& instructions) {
    constexpr int kMod = 1'000'000'007;
    const int max = ranges::max(instructions);
    int ans = 0;
    FenwickTree tree(max);

    for (int i = 0; i < instructions.size(); ++i) {
      ans += min(tree.get(instructions[i] - 1), i - tree.get(instructions[i]));
      ans %= kMod;
      tree.update(instructions[i], 1);
    }

    return ans;
  }
};",1649
1648,"class Solution {
 public:
  // Same as 160. Intersection of Two Linked Lists
  Node* lowestCommonAncestor(Node* p, Node* q) {
    Node* a = p;
    Node* b = q;

    while (a != b) {
      a = a == nullptr ? q : a->parent;
      b = b == nullptr ? p : b->parent;
    }

    return a;
  }
};",1650
1649,"WITH
  RECURSIVE Calendar AS (
    SELECT 2 AS MONTH
    UNION ALL
    SELECT MONTH + 1
    FROM Calendar
    WHERE MONTH < 11
  )
SELECT
  Calendar.month - 1 AS MONTH,
  IFNULL(
    ROUND(
      (
        SELECT SUM(AcceptedRides.ride_distance)
        FROM Rides
        INNER JOIN AcceptedRides
          USING (ride_id)
        WHERE
          YEAR(Rides.requested_at) = '2020'
          AND MONTH(Rides.requested_at) IN (
            Calendar.month - 1,
            Calendar.month,
            Calendar.month + 1
          )
      ) / 3,
      2
    ),
    0
  ) AS average_ride_distance,
  IFNULL(
    ROUND(
      (
        SELECT SUM(AcceptedRides.ride_duration)
        FROM Rides
        INNER JOIN AcceptedRides
          USING (ride_id)
        WHERE
          YEAR(Rides.requested_at) = '2020'
          AND MONTH(Rides.requested_at) IN (
            Calendar.month - 1,
            Calendar.month,
            Calendar.month + 1
          )
      ) / 3,
      2
    ),
    0
  ) AS average_ride_duration
FROM Calendar;",1651
1650,"class Solution {
 public:
  vector<int> decrypt(vector<int>& code, int k) {
    const int n = code.size();
    vector<int> ans(n);
    if (k == 0)
      return ans;

    int sum = 0;
    int start = k > 0 ? 1 : n + k;  // the start of the next k numbers
    int end = k > 0 ? k : n - 1;    // the end of the next k numbers

    for (int i = start; i <= end; ++i)
      sum += code[i];

    for (int i = 0; i < n; ++i) {
      ans[i] = sum;
      sum -= code[start++ % n];
      sum += code[++end % n];
    }

    return ans;
  }
};",1652
1651,"class Solution {
 public:
  // Same as 926. Flip String to Monotone Increasing
  int minimumDeletions(string s) {
    // the number of characters to be deleted to make the substring so far
    // balanced
    int dp = 0;
    int countB = 0;

    for (const char c : s)
      if (c == 'a')
        // 1. Delete 'a'.
        // 2. Keep 'a' and delete the previous 'b's.
        dp = min(dp + 1, countB);
      else
        ++countB;

    return dp;
  }
};",1653
1652,"enum class Direction { kForward, kBackward };

class Solution {
 public:
  int minimumJumps(vector<int>& forbidden, int a, int b, int x) {
    int furthest = x + a + b;
    unordered_set<int> seenForward;
    unordered_set<int> seenBackward;

    for (const int pos : forbidden) {
      seenForward.insert(pos);
      seenBackward.insert(pos);
      furthest = max(furthest, pos + a + b);
    }

    // (direction, position)
    queue<pair<Direction, int>> q{{{Direction::kForward, 0}}};

    for (int ans = 0; !q.empty(); ++ans)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [dir, pos] = q.front();
        q.pop();
        if (pos == x)
          return ans;
        const int forward = pos + a;
        const int backward = pos - b;
        if (forward <= furthest && seenForward.insert(forward).second)
          q.emplace(Direction::kForward, forward);
        // It cannot jump backward twice in a row.
        if (dir == Direction::kForward && backward >= 0 &&
            seenBackward.insert(backward).second)
          q.emplace(Direction::kBackward, backward);
      }

    return -1;
  }
};",1654
1653,"class Solution {
 public:
  bool canDistribute(vector<int>& nums, vector<int>& quantity) {
    // validDistribution[i][j] := true if it's possible to distribute the i-th
    // freq into a subset of quantity represented by the bitmask j
    const vector<int> freqs = getFreqs(nums);
    const vector<vector<bool>> validDistribution =
        getValidDistribuition(freqs, quantity);
    const int n = freqs.size();
    const int m = quantity.size();
    const int maxMask = 1 << m;
    // dp[i][j] := true if it's possible to distribute freqs[i..n), where j is
    // the bitmask of the selected quantity
    vector<vector<bool>> dp(n + 1, vector<bool>(maxMask));
    dp[n][maxMask - 1] = true;

    for (int i = n - 1; i >= 0; --i)
      for (int mask = 0; mask < maxMask; ++mask) {
        dp[i][mask] = dp[i + 1][mask];
        const int availableMask = ~mask & (maxMask - 1);
        for (int submask = availableMask; submask > 0;
             submask = (submask - 1) & availableMask)
          if (validDistribution[i][submask])
            dp[i][mask] = dp[i][mask] || dp[i + 1][mask | submask];
      }

    return dp[0][0];
  }

 private:
  vector<int> getFreqs(const vector<int>& nums) {
    vector<int> freqs;
    unordered_map<int, int> count;
    for (const int num : nums)
      ++count[num];
    for (const auto& [_, freq] : count)
      freqs.push_back(freq);
    return freqs;
  }

  vector<vector<bool>> getValidDistribuition(const vector<int>& freqs,
                                             const vector<int>& quantity) {
    const int maxMask = 1 << quantity.size();
    vector<vector<bool>> validDistribution(freqs.size(), vector<bool>(maxMask));
    for (int i = 0; i < freqs.size(); ++i)
      for (int mask = 0; mask < maxMask; ++mask)
        if (freqs[i] >= getQuantitySum(quantity, mask))
          validDistribution[i][mask] = true;
    return validDistribution;
  }

  // Returns the sum of the selected quantity represented by `mask`.
  int getQuantitySum(const vector<int>& quantity, int mask) {
    int sum = 0;
    for (int i = 0; i < quantity.size(); ++i)
      if (mask >> i & 1)
        sum += quantity[i];
    return sum;
  }
};",1655
1654,"insert(idKey: int, value: int)",1656
1655,"class Solution {
 public:
  bool closeStrings(string word1, string word2) {
    if (word1.length() != word2.length())
      return false;

    unordered_map<char, int> count1;
    unordered_map<char, int> count2;
    string s1;           // Unique chars in word1
    string s2;           // Unique chars in word2
    vector<int> freqs1;  // Freqs of unique chars in word1
    vector<int> freqs2;  // Freqs of unique chars in word2

    for (const char c : word1)
      ++count1[c];

    for (const char c : word2)
      ++count2[c];

    for (const auto& [c, freq] : count1) {
      s1 += c;
      freqs1.push_back(freq);
    }

    for (const auto& [c, freq] : count2) {
      s2 += c;
      freqs2.push_back(freq);
    }

    ranges::sort(s1);
    ranges::sort(s2);

    if (s1 != s2)
      return false;

    ranges::sort(freqs1);
    ranges::sort(freqs2);
    return freqs1 == freqs2;
  }
};",1657
1656,"class Solution {
 public:
  int minOperations(vector<int>& nums, int x) {
    const int targetSum = accumulate(nums.begin(), nums.end(), 0) - x;
    if (targetSum == 0)
      return nums.size();
    const int maxLen = maxSubArrayLen(nums, targetSum);
    return maxLen == -1 ? -1 : nums.size() - maxLen;
  }

 private:
  // Same as 325. Maximum Size Subarray Sum Equals k
  int maxSubArrayLen(vector<int>& nums, int k) {
    int res = -1;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      const int target = prefix - k;
      if (const auto it = prefixToIndex.find(target);
          it != prefixToIndex.cend())
        res = max(res, i - it->second);
      // No need to check the existence of the prefix since it's unique.
      prefixToIndex[prefix] = i;
    }

    return res;
  }
};",1658
1657,"class Solution {
 public:
  int getMaxGridHappiness(int m, int n, int introvertsCount,
                          int extrovertsCount) {
    const int twoToThePowerOfN = pow(2, n);
    vector<vector<vector<vector<vector<int>>>>> mem(
        m * n, vector<vector<vector<vector<int>>>>(
                   twoToThePowerOfN,
                   vector<vector<vector<int>>>(
                       twoToThePowerOfN,
                       vector<vector<int>>(introvertsCount + 1,
                                           vector<int>(extrovertsCount + 1)))));
    return getMaxGridHappiness(m, n, 0, 0, 0, introvertsCount, extrovertsCount,
                               mem);
  }

 private:
  // Calculates the cost based on left and up neighbors.
  //
  // The `diff` parameter represents the happiness change due to the current
  // placed person in (i, j). We add `diff` each time we encounter a neighbor
  // (left or up) who is already placed.
  //
  // Case 1: If the neighbor is an introvert, we subtract 30 from cost.
  // Case 2: If the neighbor is an extrovert, we add 20 to from cost.
  int getPlacementCost(int n, int i, int j, int inMask, int exMask, int diff) {
    int cost = 0;
    if (i > 0) {
      if ((1 << (n - 1)) & inMask)
        cost += diff - 30;
      if ((1 << (n - 1)) & exMask)
        cost += diff + 20;
    }
    if (j > 0) {
      if (1 & inMask)
        cost += diff - 30;
      if (1 & exMask)
        cost += diff + 20;
    }
    return cost;
  }

  int getMaxGridHappiness(int m, int n, int pos, int inMask, int exMask,
                          int inCount, int exCount,
                          vector<vector<vector<vector<vector<int>>>>>& mem) {
    // `inMask` is the placement of introvert people in the last n cells.
    // e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means
    //
    // ? 1 0
    // 1 x ? (x := current position)
    const int i = pos / n;
    const int j = pos % n;
    if (i == m)
      return 0;
    if (mem[pos][inMask][exMask][inCount][exCount] > 0)
      return mem[pos][inMask][exMask][inCount][exCount];

    const int shiftedInMask = (inMask << 1) & ((1 << n) - 1);
    const int shiftedExMask = (exMask << 1) & ((1 << n) - 1);

    const int skip = getMaxGridHappiness(m, n, pos + 1, shiftedInMask,
                                         shiftedExMask, inCount, exCount, mem);
    const int placeIntrovert =
        inCount > 0
            ? 120 + getPlacementCost(n, i, j, inMask, exMask, -30) +
                  getMaxGridHappiness(m, n, pos + 1, shiftedInMask | 1,
                                      shiftedExMask, inCount - 1, exCount, mem)
            : INT_MIN;
    const int placeExtrovert =
        exCount > 0 ? 40 + getPlacementCost(n, i, j, inMask, exMask, 20) +
                          getMaxGridHappiness(m, n, pos + 1, shiftedInMask,
                                              shiftedExMask | 1, inCount,
                                              exCount - 1, mem)
                    : INT_MIN;
    return mem[pos][inMask][exMask][inCount][exCount] =
               max({skip, placeIntrovert, placeExtrovert});
  }
};",1659
1658,"class Solution {
 public:
  TreeNode* correctBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;
    if (root->right != nullptr && seen.count(root->right->val))
      return nullptr;
    seen.insert(root->val);
    root->right = correctBinaryTree(root->right);
    root->left = correctBinaryTree(root->left);
    return root;
  }

 private:
  unordered_set<int> seen;
};",1660
1659,"SELECT
  StartActivity.machine_id,
  ROUND(
    AVG(EndActivity.timestamp - StartActivity.timestamp),
    3
  ) AS processing_time
FROM Activity AS StartActivity
INNER JOIN Activity AS EndActivity
  USING (machine_id, process_id)
WHERE
  StartActivity.activity_type = 'start'
  AND EndActivity.activity_type = 'end'
GROUP BY 1;",1661
1660,"class Solution {
 public:
  bool arrayStringsAreEqual(std::vector<std::string>& word1,
                            std::vector<std::string>& word2) {
    int i = 0;  // word1's index
    int j = 0;  // word2's index
    int a = 0;  // word1[i]'s index
    int b = 0;  // word2[j]'s index

    while (i < word1.size() && j < word2.size()) {
      if (word1[i][a] != word2[j][b])
        return false;
      if (++a == word1[i].size()) {
        ++i;
        a = 0;
      }
      if (++b == word2[j].size()) {
        ++j;
        b = 0;
      }
    }

    return i == word1.size() && j == word2.size();
  }
};",1662
1661,"class Solution {
 public:
  string getSmallestString(int n, int k) {
    string ans;

    for (int i = 0; i < n; ++i) {
      const int remainingLetters = n - 1 - i;
      const int rank = max(1, k - remainingLetters * 26);
      ans += 'a' + rank - 1;
      k -= rank;
    }

    return ans;
  }
};",1663
1662,"class Solution {
 public:
  int waysToMakeFair(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    vector<int> even(n + 1);  // the sum of even-indexed nums[0..i)
    vector<int> odd(n + 1);   // the sum of odd-indexed nums[0..i)

    for (int i = 1; i <= n; ++i) {
      odd[i] = odd[i - 1];
      even[i] = even[i - 1];
      if (i % 2 == 0)
        even[i] += nums[i - 1];
      else
        odd[i] += nums[i - 1];
    }

    const int sum = even.back() + odd.back();

    for (int i = 0; i < n; ++i) {
      const int evenSum = even[i] + odd.back() - odd[i + 1];
      const int oddSum = sum - nums[i] - evenSum;
      if (evenSum == oddSum)
        ++ans;
    }

    return ans;
  }
};",1664
1663,"class Solution {
 public:
  int minimumEffort(vector<vector<int>>& tasks) {
    int ans = 0;
    int prevSaved = 0;

    ranges::sort(tasks, [](const vector<int>& a, const vector<int>& b) {
      return a[1] - a[0] > b[1] - b[0];
    });

    for (const vector<int>& task : tasks) {
      const int actual = task[0];
      const int minimum = task[1];
      if (prevSaved < minimum) {
        ans += minimum - prevSaved;
        prevSaved = minimum - actual;
      } else {
        prevSaved -= actual;
      }
    }

    return ans;
  }
};",1665
1664,"class Solution {
 public:
  Node* flipBinaryTree(Node* root, Node* leaf) {
    return reroot(root, leaf, nullptr);
  }

 private:
  Node* reroot(Node* root, Node* node, Node* newParent) {
    Node* oldParent = node->parent;
    node->parent = newParent;

    // Clean up the child if it's the new parent.
    if (node->left == newParent)
      node->left = nullptr;
    if (node->right == newParent)
      node->right = nullptr;

    // We meet the original root, so we're done.
    if (node == root)
      return node;

    if (node->left)
      node->right = node->left;
    node->left = reroot(root, oldParent, node);

    return node;
  }
};",1666
1665,"SELECT
  user_id,
  CONCAT(
    UPPER(SUBSTRING(name, 1, 1)),
    LOWER(SUBSTRING(name, 2))
  ) AS name
FROM Users
ORDER BY 1;",1667
1666,"class Solution {
 public:
  int maxRepeating(string sequence, string word) {
    int ans = 1;
    string repeating = word;
    while (sequence.find(repeating) != string::npos) {
      ++ans;
      repeating += word;
    }
    return ans - 1;
  }
};",1668
1667,"class Solution {
 public:
  ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
    ListNode* nodeBeforeA = list1;
    for (int i = 0; i < a - 1; ++i)
      nodeBeforeA = nodeBeforeA->next;

    ListNode* nodeB = nodeBeforeA->next;
    for (int i = 0; i < b - a; ++i)
      nodeB = nodeB->next;

    nodeBeforeA->next = list2;
    ListNode* lastNodeInList2 = list2;

    while (lastNodeInList2->next != nullptr)
      lastNodeInList2 = lastNodeInList2->next;

    lastNodeInList2->next = nodeB->next;
    nodeB->next = nullptr;
    return list1;
  }
};",1669
1668,pushFront(val: int),1670
1669,"class Solution {
 public:
  int minimumMountainRemovals(vector<int>& nums) {
    vector<int> l = lengthOfLIS(nums);
    vector<int> r = reversed(lengthOfLIS(reversed(nums)));
    int maxMountainSeq = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (l[i] > 1 && r[i] > 1)
        maxMountainSeq = max(maxMountainSeq, l[i] + r[i] - 1);

    return nums.size() - maxMountainSeq;
  }

 private:
  vector<int> lengthOfLIS(vector<int> nums) {
    // tail[i] := the minimum tail of all the increasing subsequences having
    // length i + 1
    // It's easy to see that tail must be an increasing array.
    vector<int> tail;
    // dp[i] := the length of LIS ending in nums[i]
    vector<int> dp;

    for (const int num : nums) {
      if (tail.empty() || num > tail.back())
        tail.push_back(num);
      else
        tail[firstGreaterEqual(tail, num)] = num;
      dp.push_back(tail.size());
    }

    return dp;
  }

  int firstGreaterEqual(const vector<int>& A, int target) {
    return ranges::lower_bound(A, target) - A.begin();
  }

  vector<int> reversed(const vector<int>& nums) {
    return {nums.rbegin(), nums.rend()};
  }
};",1671
1670,"class Solution {
 public:
  int maximumWealth(vector<vector<int>>& accounts) {
    return accumulate(accounts.begin(), accounts.end(), 0,
                      [](int maxAccountSum, const vector<int>& account) {
      return max(maxAccountSum, accumulate(account.begin(), account.end(), 0));
    });
  }
};",1672
1671,"class Solution {
 public:
  vector<int> mostCompetitive(vector<int>& nums, int k) {
    vector<int> ans;

    for (int i = 0; i < nums.size(); ++i) {
      // If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough
      // numbers, and we can safely pop an element from ans.
      while (!ans.empty() && ans.back() > nums[i] &&
             ans.size() - 1 + nums.size() - i >= k)
        ans.pop_back();
      if (ans.size() < k)
        ans.push_back(nums[i]);
    }

    return ans;
  }
};",1673
1672,"class Solution {
 public:
  int minMoves(vector<int>& nums, int limit) {
    const int n = nums.size();
    int ans = n;
    // delta[i] := the number of moves needed when target goes from i - 1 to i
    vector<int> delta(limit * 2 + 2);

    for (int i = 0; i < n / 2; ++i) {
      const int a = nums[i];
      const int b = nums[n - 1 - i];
      --delta[min(a, b) + 1];
      --delta[a + b];
      ++delta[a + b + 1];
      ++delta[max(a, b) + limit + 1];
    }

    // Initially, we need `moves` when the target is 2.
    for (int i = 2, moves = n; i <= limit * 2; ++i) {
      moves += delta[i];
      ans = min(ans, moves);
    }

    return ans;
  }
};",1674
1673,"class Solution {
 public:
  int minimumDeviation(vector<int>& nums) {
    int ans = INT_MAX;
    int mini = INT_MAX;
    priority_queue<int> maxHeap;

    for (const int num : nums) {
      const int evenNum = num % 2 == 0 ? num : num * 2;
      mini = min(mini, evenNum);
      maxHeap.push(evenNum);
    }

    while (maxHeap.top() % 2 == 0) {
      const int maxi = maxHeap.top();
      maxHeap.pop();
      ans = min(ans, maxi - mini);
      mini = min(mini, maxi / 2);
      maxHeap.push(maxi / 2);
    }

    return min(ans, maxHeap.top() - mini);
  }
};",1675
1674,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*>& nodes) {
    unordered_set<TreeNode*> nodesSet{nodes.begin(), nodes.end()};
    return lca(root, nodesSet);
  }

 private:
  TreeNode* lca(TreeNode* root, unordered_set<TreeNode*>& nodesSet) {
    if (root == nullptr)
      return nullptr;
    if (nodesSet.count(root))
      return root;
    TreeNode* left = lca(root->left, nodesSet);
    TreeNode* right = lca(root->right, nodesSet);
    if (left != nullptr && right != nullptr)
      return root;
    return left == nullptr ? right : left;
  }
};",1676
1675,"SELECT
  Product.name,
  IFNULL(SUM(Invoice.rest), 0) AS rest,
  IFNULL(SUM(Invoice.paid), 0) AS paid,
  IFNULL(SUM(Invoice.canceled), 0) AS canceled,
  IFNULL(SUM(Invoice.refunded), 0) AS refunded
FROM Product
LEFT JOIN Invoice
  USING (product_id)
GROUP BY 1
ORDER BY 1;",1677
1676,"class Solution {
 public:
  string interpret(string command) {
    string ans;
    for (int i = 0; i < command.size();)
      if (command[i] == 'G') {
        ans += ""G"";
        ++i;
      } else if (command[i + 1] == ')') {
        ans += ""o"";
        i += 2;
      } else {
        ans += ""al"";
        i += 4;
      }
    return ans;
  }
};",1678
1677,"class Solution {
 public:
  int maxOperations(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      if (const auto it = count.find(k - num); it != count.end())
        ans += min(freq, it->second);

    return ans / 2;
  }
};",1679
1678,"class Solution {
 public:
  int concatenatedBinary(int n) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;

    for (int i = 1; i <= n; ++i)
      ans = ((ans << numberOfBits(i)) % kMod + i) % kMod;

    return ans;
  }

 private:
  int numberOfBits(int n) {
    return log2(n) + 1;
  }
};",1680
1679,"class Solution {
 public:
  int minimumIncompatibility(vector<int>& nums, int k) {
    constexpr int kMaxCompatibility = (16 - 1) * (16 / 2);
    const int n = nums.size();
    const int subsetSize = n / k;
    const int maxMask = 1 << n;
    const vector<int> incompatibilities =
        getIncompatibilities(nums, subsetSize);
    // dp[i] := the minimum possible sum of incompatibilities of the subset
    // of numbers represented by the bitmask i
    vector<int> dp(maxMask, kMaxCompatibility);
    dp[0] = 0;

    for (int mask = 1; mask < maxMask; ++mask) {
      // The number of 1s in `mask` isn't a multiple of `subsetSize`.
      if (__builtin_popcount(mask) % subsetSize != 0)
        continue;
      // https://cp-algorithms.com/algebra/all-submasks.html
      for (int submask = mask; submask > 0; submask = (submask - 1) & mask)
        if (incompatibilities[submask] != -1)  // valid subset
          dp[mask] =
              min(dp[mask], dp[mask - submask] + incompatibilities[submask]);
    }

    return dp.back() == kMaxCompatibility ? -1 : dp.back();
  }

 private:
  static constexpr int kMaxNum = 16;

  // Returns an incompatibilities array where
  // * incompatibilities[i] := the incompatibility of the subset of numbers
  //   represented by the bitmask i
  // * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not
  //   `subsetSize`
  vector<int> getIncompatibilities(const vector<int>& nums, int subsetSize) {
    const int maxMask = 1 << nums.size();
    vector<int> incompatibilities(maxMask, -1);
    for (int mask = 0; mask < maxMask; ++mask)
      if (__builtin_popcount(mask) == subsetSize &&
          isUnique(nums, mask, subsetSize))
        incompatibilities[mask] = getIncompatibility(nums, mask);
    return incompatibilities;
  }

  // Returns true if the numbers selected by `mask` are unique.
  //
  // e.g. If we call isUnique(0b1010, 2, [1, 2, 1, 4]), `used` variable
  // will be 0b1, which only has one 1 (less than `subsetSize`). In this case,
  // we should return false.
  bool isUnique(const vector<int>& nums, int mask, int subsetSize) {
    int used = 0;
    for (int i = 0; i < nums.size(); ++i)
      if (mask >> i & 1)
        used |= 1 << nums[i];
    return __builtin_popcount(used) == subsetSize;
  }

  // Returns the incompatibility of the selected numbers represented by the
  // `mask`.
  int getIncompatibility(const vector<int>& nums, int mask) {
    int mini = kMaxNum;
    int maxi = 0;
    for (int i = 0; i < nums.size(); ++i)
      if (mask >> i & 1) {
        maxi = max(maxi, nums[i]);
        mini = min(mini, nums[i]);
      }
    return maxi - mini;
  }
};",1681
1680,"class Solution {
 public:
  int longestPalindromeSubseq(string s) {
    const int n = s.length();
    vector<vector<vector<int>>> mem(n, vector<vector<int>>(n, vector<int>(27)));
    return lps(s, 0, n - 1, 26, mem);
  }

 private:
  // Returns the length of LPS(s[i..j]), where the previous letter is ('a' + k).
  int lps(const string& s, int i, int j, int k,
          vector<vector<vector<int>>>& mem) {
    if (i >= j)
      return 0;
    if (mem[i][j][k] > 0)
      return mem[i][j][k];
    if (s[i] == s[j] && s[i] != 'a' + k)
      return mem[i][j][k] = lps(s, i + 1, j - 1, s[i] - 'a', mem) + 2;
    return mem[i][j][k] =
               max(lps(s, i + 1, j, k, mem), lps(s, i, j - 1, k, mem));
  }
};",1682
1681,"SELECT tweet_id
FROM Tweets
WHERE CHAR_LENGTH(content) > 15;",1683
1682,"class Solution {
 public:
  int countConsistentStrings(string allowed, vector<string>& words) {
    return accumulate(words.begin(), words.end(), 0,
                      [&allowed](int subtotal, const string& word) {
      return subtotal + ranges::all_of(word, [&allowed](char c) {
        return allowed.find(c) != string::npos;
      });
    });
  }
};",1684
1683,"class Solution {
 public:
  vector<int> getSumAbsoluteDifferences(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans;
    // prefix[i] := sum(nums[0..i])
    vector<int> prefix(n);
    // suffix[i] := sum(nums[i..n - 1])
    vector<int> suffix(n);

    prefix[0] = nums[0];
    for (int i = 1; i < n; ++i)
      prefix[i] = prefix[i - 1] + nums[i];

    suffix[n - 1] = nums[n - 1];
    for (int i = n - 2; i >= 0; --i)
      suffix[i] = suffix[i + 1] + nums[i];

    for (int i = 0; i < nums.size(); ++i) {
      const int left = nums[i] * (i + 1) - prefix[i];
      const int right = suffix[i] - nums[i] * (n - i);
      ans.push_back(left + right);
    }

    return ans;
  }
};",1685
1684,"class Solution {
 public:
  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {
    const int n = aliceValues.size();
    vector<vector<int>> values;
    int a = 0;
    int b = 0;

    for (int i = 0; i < n; ++i)
      values.push_back({aliceValues[i], bobValues[i]});

    ranges::sort(values, [](const vector<int>& a, const vector<int>& b) {
      return a[0] + a[1] > b[0] + b[1];
    });

    for (int i = 0; i < n; ++i)
      if (i % 2 == 0)
        a += values[i][0];
      else
        b += values[i][1];

    return a > b ? 1 : a < b ? -1 : 0;
  }
};",1686
1685,"class Solution {
 public:
  int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes,
                    int maxWeight) {
    const int n = boxes.size();
    // dp[i] := the minimum trips to deliver boxes[0..i) and return to the
    // storage
    vector<int> dp(n + 1);
    int trips = 2;
    int weight = 0;

    for (int l = 0, r = 0; r < n; ++r) {
      weight += boxes[r][1];

      // The current box is different from the previous one, need to make one
      // more trip.
      if (r > 0 && boxes[r][0] != boxes[r - 1][0])
        ++trips;

      while (r - l + 1 > maxBoxes || weight > maxWeight ||
             // Loading boxes[l] in the previous turn is always no bad than
             // loading it in this turn.
             (l < r && dp[l + 1] == dp[l])) {
        weight -= boxes[l][1];
        if (boxes[l][0] != boxes[l + 1][0])
          --trips;
        ++l;
      }

      //   min trips to deliver boxes[0..r]
      // = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]
      dp[r + 1] = dp[l] + trips;
    }

    return dp[n];
  }
};",1687
1686,"class Solution {
 public:
  int numberOfMatches(int n) {
    return n - 1;
  }
};",1688
1687,"class Solution {
 public:
  int minPartitions(string n) {
    return ranges::max(n) - '0';
  }
};",1689
1688,"class Solution {
 public:
  int stoneGameVII(vector<int>& stones) {
    const int n = stones.size();
    vector<vector<int>> mem(n, vector<int>(n));
    vector<int> prefix(n + 1);
    partial_sum(stones.begin(), stones.end(), prefix.begin() + 1);
    return stoneGameVII(stones, 0, n - 1, prefix, mem);
  }

 private:
  // Returns the maximum score you can get more than your opponent in
  // stones[i..j].
  int stoneGameVII(const vector<int>& stones, int i, int j,
                   const vector<int>& prefix, vector<vector<int>>& mem) {
    if (i == j)
      return 0;
    if (mem[i][j] > 0)
      return mem[i][j];
    // Remove stones[i] to get sum(stones[i + 1..j]).
    const int removeLeft = prefix[j + 1] - prefix[i + 1] -
                           stoneGameVII(stones, i + 1, j, prefix, mem);
    // Remove stones[j] to get sum(stones[i..j - 1]).
    const int removeRight = prefix[j] - prefix[i] -  //
                            stoneGameVII(stones, i, j - 1, prefix, mem);
    return mem[i][j] = max(removeLeft, removeRight);
  }
};",1690
1689,"class Solution {
 public:
  int maxHeight(vector<vector<int>>& cuboids) {
    // For each cuboid, sort it so that c[0] <= c[1] <= c[2].
    for (vector<int>& cuboid : cuboids)
      ranges::sort(cuboid);

    ranges::sort(cuboids);

    // dp[i] := the maximum height with cuboids[i] in the bottom
    vector<int> dp(cuboids.size());

    for (int i = 0; i < cuboids.size(); ++i)
      dp[i] = cuboids[i][2];

    for (int i = 1; i < cuboids.size(); ++i)
      for (int j = 0; j < i; ++j)
        if (cuboids[j][0] <= cuboids[i][0] &&  //
            cuboids[j][1] <= cuboids[i][1] &&  //
            cuboids[j][2] <= cuboids[i][2])
          dp[i] = max(dp[i], dp[j] + cuboids[i][2]);

    return ranges::max(dp);
  }
};",1691
1690,"class Solution {
 public:
  int waysToDistribute(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := the number of ways to distribute i candies to j bags
    // dp[i][j] = 0, if i < j
    //          = 1, if i == j
    //          = dp[i - 1][j - 1] (the new candy occupies a bag)
    //          + dp[i - 1][j] * j (the new candy is in any of the j bags)
    vector<vector<long>> dp(n + 1, vector<long>(k + 1));

    for (int i = 0; i <= k; ++i)
      dp[i][i] = 1;

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j)
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * j) % kMod;

    return dp[n][k];
  }
};",1692
1691,"SELECT
  date_id,
  make_name,
  COUNT(DISTINCT lead_id) AS unique_leads,
  COUNT(DISTINCT partner_id) AS unique_partners
FROM DailySales
GROUP BY 1, 2;",1693
1692,"class Solution {
 public:
  string reformatNumber(string number) {
    string ans;

    number.erase(remove(number.begin(), number.end(), '-'), number.end());
    number.erase(remove(number.begin(), number.end(), ' '), number.end());

    int i = 0;  // number's index
    for (i = 0; i + 4 < number.length(); i += 3)
      ans += number.substr(i, 3) + '-';

    const int countFinalDigits = number.length() - i;
    if (countFinalDigits < 4)
      ans += number.substr(i);
    else  // countFinalDigits == 4
      ans += number.substr(i, 2) + '-' + number.substr(i + 2);

    return ans;
  }
};",1694
1693,"class Solution {
 public:
  int maximumUniqueSubarray(vector<int>& nums) {
    int ans = 0;
    int score = 0;
    unordered_set<int> seen;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (!seen.insert(nums[r]).second) {
        score -= nums[l];
        seen.erase(nums[l++]);
      }
      score += nums[r];
      ans = max(ans, score);
    }

    return ans;
  }
};",1695
1694,"class Solution {
 public:
  int maxResult(vector<int>& nums, int k) {
    // Stores dp[i] within the bounds.
    deque<int> maxQ{0};
    // dp[i] := the maximum score to consider nums[0..i]
    vector<int> dp(nums.size());
    dp[0] = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
      // Pop the index if it's out-of-bounds.
      if (maxQ.front() + k < i)
        maxQ.pop_front();
      dp[i] = dp[maxQ.front()] + nums[i];
      // Pop indices that won't be chosen in the future.
      while (!maxQ.empty() && dp[maxQ.back()] <= dp[i])
        maxQ.pop_back();
      maxQ.push_back(i);
    }

    return dp.back();
  }
};",1696
1695,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,
                                         vector<vector<int>>& queries) {
    vector<bool> ans(queries.size());
    UnionFind uf(n);

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    ranges::sort(queries,
                 [](const auto& a, const auto& b) { return a[2] < b[2]; });
    ranges::sort(edgeList,
                 [](const auto& a, const auto& b) { return a[2] < b[2]; });

    int i = 0;  // i := edgeList's index
    for (const vector<int>& query : queries) {
      // Union edges whose distances < limit (query[2]).
      while (i < edgeList.size() && edgeList[i][2] < query[2])
        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);
      if (uf.find(query[0]) == uf.find(query[1]))
        ans[q.back()] = true;
    }

    return ans;
  }
};",1697
1696,"class Solution {
 public:
  int countDistinct(string s) {
    const int n = s.length();
    int ans = 0;
    vector<long> pow(n + 1);     // pow[i] := kBase^i
    vector<long> hashes(n + 1);  // hashes[i] := the hash of s[0..i)

    pow[0] = 1;
    for (int i = 1; i <= n; ++i) {
      pow[i] = pow[i - 1] * kBase % kMod;
      hashes[i] = (hashes[i - 1] * kBase + val(s[i - 1])) % kMod;
    }

    for (int length = 1; length <= n; ++length) {
      unordered_set<int> seen;
      for (int i = 0; i + length <= n; ++i)
        seen.insert(getHash(i, i + length, hashes, pow));
      ans += seen.size();
    }

    return ans;
  }

 private:
  static constexpr int kBase = 26;
  static constexpr int kMod = 1'000'000'007;

  // Returns the hash of s[l..r).
  long getHash(int l, int r, const vector<long>& hashes,
               const vector<long>& pow) {
    const long hash = (hashes[r] - hashes[l] * pow[r - l]) % kMod;
    return hash < 0 ? hash + kMod : hash;
  }

  constexpr int val(char c) {
    return c - 'a';
  }
};",1698
1697,"SELECT
  LEAST(from_id, to_id) AS person1,
  GREATEST(from_id, to_id) AS person2,
  COUNT(*) AS call_count,
  SUM(duration) AS total_duration
FROM Calls
GROUP BY 1, 2;",1699
1698,"class Solution {
 public:
  int countStudents(vector<int>& students, vector<int>& sandwiches) {
    vector<int> count(2);

    for (const int student : students)
      ++count[student];

    for (int i = 0; i < sandwiches.size(); ++i) {
      if (count[sandwiches[i]] == 0)
        return sandwiches.size() - i;
      --count[sandwiches[i]];
    }

    return 0;
  }
};",1700
1699,"class Solution {
 public:
  double averageWaitingTime(vector<vector<int>>& customers) {
    double wait = 0;
    double curr = 0;

    for (const vector<int>& c : customers) {
      curr = max(curr, 1.0 * c[0]) + c[1];
      wait += curr - c[0];
    }

    return 1.0 * wait / customers.size();
  }
};",1701
1700,"class Solution {
 public:
  string maximumBinaryString(string binary) {
    //     e.g. binary = ""100110""
    // Do Operation 2 -> ""100011""
    // Do Operation 1 -> ""111011""
    // So, the index of the only '0' is prefixOnes + zeros - 1.
    const int zeros = ranges::count(binary, '0');
    const int prefixOnes = binary.find('0');

    // Make the entire string as 1s.
    binary.assign(binary.length(), '1');

    // Make the only '0' if necessary.
    if (prefixOnes != string::npos)
      binary[prefixOnes + zeros - 1] = '0';
    return binary;
  }
};",1702
1701,"class Solution {
 public:
  int minMoves(vector<int>& nums, int k) {
    vector<int> ones;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == 1)
        ones.push_back(i);

    // Returns the median index of [i..i + k).
    auto getMedIndex = [&](int i) { return (i + (i + k - 1)) / 2; };

    // Calculate the first group: window[0] = A[0..k).
    const int median = ones[getMedIndex(0)];
    int moves = 0;
    for (int i = 0; i < k; ++i)
      moves += abs(ones[i] - median);

    int ans = moves;

    for (int i = 1; i <= ones.size() - k; ++i) {
      const int oldMedianIndex = ones[getMedIndex(i - 1)];
      const int newMedianIndex = ones[getMedIndex(i)];
      if (k & 1)
        moves += newMedianIndex - oldMedianIndex;
      moves -= newMedianIndex - ones[i - 1];
      moves += ones[i + k - 1] - newMedianIndex;
      ans = min(ans, moves);
    }

    auto nThSum = [&](int n) { return n * (n + 1) / 2; };
    return ans - nThSum((k - 1) / 2) - nThSum(k / 2);
  }
};",1703
1702,"class Solution {
 public:
  bool halvesAreAlike(string s) {
    const string a = s.substr(0, s.length() / 2);
    const string b = s.substr(s.length() / 2);
    const int aVowelsCount =
        ranges::count_if(a, [=](char c) { return isVowel(c); });
    const int bVowelsCount =
        ranges::count_if(b, [=](char c) { return isVowel(c); });
    return aVowelsCount == bVowelsCount;
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }
};",1704
1703,"class Solution {
 public:
  int eatenApples(vector<int>& apples, vector<int>& days) {
    const int n = apples.size();
    int ans = 0;
    using P = pair<int, int>;  // (the rotten day, the number of apples)
    priority_queue<P, vector<P>, greater<>> minHeap;

    for (int i = 0; i < n || !minHeap.empty(); ++i) {  // i := day
      // Remove the rotten apples.
      while (!minHeap.empty() && minHeap.top().first <= i)
        minHeap.pop();
      // Add today's apples.
      if (i < n && apples[i] > 0)
        minHeap.emplace(i + days[i], apples[i]);
      // Eat one apple today.
      if (!minHeap.empty()) {
        const auto [rottenDay, numApples] = minHeap.top();
        minHeap.pop();
        if (numApples > 1)
          minHeap.emplace(rottenDay, numApples - 1);
        ++ans;
      }
    }

    return ans;
  }
};",1705
1704,"class Solution {
 public:
  vector<int> findBall(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // dp[i] := status of the i-th column
    // -1 := empty, 0 := b0, 1 := b1, ...
    vector<int> dp(n);
    // ans[i] := the i-th ball's final position
    vector<int> ans(n, -1);

    iota(dp.begin(), dp.end(), 0);

    for (int i = 0; i < m; ++i) {
      vector<int> newDp(n, -1);
      for (int j = 0; j < n; ++j) {
        // out-of-bounds
        if (j + grid[i][j] < 0 || j + grid[i][j] == n)
          continue;
        // Stuck
        if (grid[i][j] == 1 && grid[i][j + 1] == -1 ||
            grid[i][j] == -1 && grid[i][j - 1] == 1)
          continue;
        newDp[j + grid[i][j]] = dp[j];
      }
      dp = move(newDp);
    }

    for (int i = 0; i < n; ++i)
      if (dp[i] != -1)
        ans[dp[i]] = i;

    return ans;
  }
};",1706
1705,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  TrieNode() : children(2) {}
};

class BitTrie {
 public:
  BitTrie(int maxBit) : maxBit(maxBit) {}

  void insert(int num) {
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
    }
  }

  int getMaxXor(int num) {
    int maxXor = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = num >> i & 1;
      const int toggleBit = bit ^ 1;
      if (node->children[toggleBit] != nullptr) {
        maxXor = maxXor | 1 << i;
        node = node->children[toggleBit];
      } else if (node->children[bit] != nullptr) {
        node = node->children[bit];
      } else {  // There's nothing in the Bit Trie.
        return 0;
      }
    }
    return maxXor;
  }

 private:
  const int maxBit;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

struct IndexedQuery {
  int queryIndex;
  int x;
  int m;
};

class Solution {
 public:
  vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
    vector<int> ans(queries.size(), -1);
    const int maxNumInNums = ranges::max(nums);
    const int maxNumInQuery =
        ranges::max_element(queries,
                            [](const vector<int>& a, const vector<int>& b) {
      return a[0] < b[0];
    })->at(0);
    const int maxBit = static_cast<int>(log2(max(maxNumInNums, maxNumInQuery)));
    BitTrie bitTrie(maxBit);

    ranges::sort(nums);

    int i = 0;  // nums' index
    for (const auto& [queryIndex, x, m] : getIndexedQueries(queries)) {
      while (i < nums.size() && nums[i] <= m)
        bitTrie.insert(nums[i++]);
      if (i > 0 && nums[i - 1] <= m)
        ans[queryIndex] = bitTrie.getMaxXor(x);
    }

    return ans;
  }

 private:
  vector<IndexedQuery> getIndexedQueries(const vector<vector<int>>& queries) {
    vector<IndexedQuery> indexedQueries;
    for (int i = 0; i < queries.size(); ++i)
      indexedQueries.push_back({i, queries[i][0], queries[i][1]});
    ranges::sort(
        indexedQueries,
        [](const IndexedQuery& a, const IndexedQuery& b) { return a.m < b.m; });
    return indexedQueries;
  }
};",1707
1706,"class Solution {
 public:
  vector<int> largestSubarray(vector<int>& nums, int k) {
    const auto it = max_element(nums.begin(), nums.end() - k + 1);
    return std::vector<int>(it, it + k);
  }
};",1708
1707,"WITH
  UserToWindow AS (
    SELECT
      user_id,
      DATEDIFF(
        LEAD(visit_date, 1, '2021-01-01') OVER(
          PARTITION BY user_id
          ORDER BY visit_date
        ),
        visit_date
      ) AS `window`
    FROM userVisits
  )
SELECT
  user_id,
  MAX(`window`) AS biggest_window
FROM UserToWindow
GROUP BY user_id;",1709
1708,"class Solution {
 public:
  int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {
    int ans = 0;

    ranges::sort(boxTypes, [](const vector<int>& a, const vector<int>& b) {
      return b[1] < a[1];
    });

    for (const vector<int>& boxType : boxTypes) {
      const int boxes = boxType[0];
      const int units = boxType[1];
      if (boxes >= truckSize)
        return ans + truckSize * units;
      ans += boxes * units;
      truckSize -= boxes;
    }

    return ans;
  }
};",1710
1709,"class Solution {
 public:
  int countPairs(vector<int>& deliciousness) {
    constexpr int kMod = 1'000'000'007;
    constexpr int kMaxBit = 20 + 1;
    const int kMaxPower = pow(2, kMaxBit);
    int ans = 0;
    unordered_map<int, int> count;

    for (const int d : deliciousness) {
      for (int power = 1; power <= kMaxPower; power *= 2)
        if (const auto it = count.find(power - d); it != count.cend()) {
          ans += it->second;
          ans %= kMod;
        }
      ++count[d];
    }

    return ans;
  }
};",1711
1710,"class Solution {
 public:
  int waysToSplit(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    vector<int> prefix(n);

    partial_sum(nums.begin(), nums.end(), prefix.begin());

    // Finds the first index j s.t.
    // mid = prefix[j] - prefix[i] >= left = prefix[i].
    auto firstGreaterEqual = [&](int i) {
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        const int m = (l + r) / 2;
        if (prefix[m] - prefix[i] >= prefix[i])
          r = m;
        else
          l = m + 1;
      }
      return l;
    };

    // Finds the first index k s.t.
    // mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k].
    auto firstGreater = [&](int i) {
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        const int m = (l + r) / 2;
        if (prefix[m] - prefix[i] > prefix.back() - prefix[m])
          r = m;
        else
          l = m + 1;
      }
      return l;
    };

    for (int i = 0; i < n - 2; ++i) {
      const int j = firstGreaterEqual(i);
      if (j == n - 1)
        break;
      const int mid = prefix[j] - prefix[i];
      const int right = prefix.back() - prefix[j];
      if (mid > right)
        continue;
      const int k = firstGreater(i);
      ans = (ans + k - j) % kMod;
    }

    return ans;
  }
};",1712
1711,"class Solution {
 public:
  int minOperations(vector<int>& target, vector<int>& arr) {
    vector<int> indices;
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < target.size(); ++i)
      numToIndex[target[i]] = i;

    for (const int a : arr)
      if (const auto it = numToIndex.find(a); it != numToIndex.end())
        indices.push_back(it->second);

    return target.size() - lengthOfLIS(indices);
  }

 private:
  // Same as 300. Longest Increasing Subsequence
  int lengthOfLIS(vector<int>& nums) {
    // tail[i] := the minimum tail of all the increasing subsequences having
    // length i + 1
    // It's easy to see that tail must be an increasing array.
    vector<int> tail;

    for (const int num : nums)
      if (tail.empty() || num > tail.back())
        tail.push_back(num);
      else
        tail[firstGreaterEqual(tail, num)] = num;

    return tail.size();
  }

 private:
  int firstGreaterEqual(const vector<int>& A, int target) {
    return ranges::lower_bound(A, target) - A.begin();
  }
};",1713
1712,"class Solution {
 public:
  vector<int> solve(vector<int>& nums, vector<vector<int>>& queries) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    const int sqrtN = static_cast<int>(sqrt(n));
    vector<int> ans;
    // prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n
    vector<vector<int>> prefix(n, vector<int>(sqrtN));

    // Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < sqrtN; ++j)
        prefix[i][j] = nums[i];

    for (int x = n - 1; x >= 0; --x)
      for (int y = 1; y < sqrtN; ++y)
        if (x + y < n) {
          prefix[x][y] += prefix[x + y][y];
          prefix[x][y] %= kMod;
        }

    for (const vector<int>& query : queries) {
      const int x = query[0];
      const int y = query[1];
      if (y < sqrtN) {
        ans.push_back(prefix[x][y]);
      } else {
        int sum = 0;
        for (int i = x; i < n; i += y)
          sum = (sum + nums[i]) % kMod;
        ans.push_back(sum);
      }
    }

    return ans;
  }
};",1714
1713,"SELECT
  SUM(Boxes.apple_count + IFNULL(Chests.apple_count, 0)) AS apple_count,
  SUM(Boxes.orange_count + IFNULL(Chests.orange_count, 0)) AS orange_count
FROM Boxes
LEFT JOIN Chests
  USING (chest_id);",1715
1714,"class Solution {
 public:
  int totalMoney(int n) {
    const int weeks = n / 7;
    const int firstWeek = trapezoid(1, 7);
    const int lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1);
    const int remainingDays = trapezoid(1 + weeks, n % 7 + weeks);
    return (firstWeek + lastFullWeek) * weeks / 2 + remainingDays;
  }

  // Returns sum(a..b).
  int trapezoid(int a, int b) {
    return (a + b) * (b - a + 1) / 2;
  }
};",1716
1715,"class Solution {
 public:
  int maximumGain(string s, int x, int y) {
    // The assumption that gain(""ab"") > gain(""ba"") while removing ""ba"" first is
    // optimal is contradicted. Only ""b(ab)a"" satisfies the condition of
    // preventing two ""ba"" removals, but after removing ""ab"", we can still
    // remove one ""ba"", resulting in a higher gain. Thus, removing ""ba"" first is
    // not optimal.
    return x > y ? gain(s, ""ab"", x, ""ba"", y) : gain(s, ""ba"", y, ""ab"", x);
  }

 private:
  // Returns the points gained by first removing sub1 (""ab"" | ""ba"") from s with
  // point1, then removing sub2 (""ab"" | ""ba"") from s with point2.
  int gain(const string& s, const string& sub1, int point1, const string& sub2,
           int point2) {
    int points = 0;
    vector<char> stack1;
    vector<char> stack2;

    // Remove ""sub1"" from s with point1 gain.
    for (const char c : s)
      if (!stack1.empty() && stack1.back() == sub1[0] && c == sub1[1]) {
        stack1.pop_back();
        points += point1;
      } else {
        stack1.push_back(c);
      }

    // Remove ""sub2"" from s with point2 gain.
    for (const char c : stack1)
      if (!stack2.empty() && stack2.back() == sub2[0] && c == sub2[1]) {
        stack2.pop_back();
        points += point2;
      } else {
        stack2.push_back(c);
      }

    return points;
  }
};",1717
1716,"class Solution {
 public:
  vector<int> constructDistancedSequence(int n) {
    vector<int> ans(2 * n - 1);
    dfs(n, 0, 0, ans);
    return ans;
  }

 private:
  bool dfs(int n, int i, int mask, vector<int>& ans) {
    if (i == ans.size())
      return true;
    if (ans[i] > 0)
      return dfs(n, i + 1, mask, ans);

    // Greedily fill in `ans` in descending order.
    for (int num = n; num >= 1; --num) {
      if (mask >> num & 1)
        continue;
      if (num == 1) {
        ans[i] = num;
        if (dfs(n, i + 1, mask | 1 << num, ans))
          return true;
        ans[i] = 0;
      } else {  // num in [2, n]
        if (i + num >= ans.size() || ans[i + num] > 0)
          continue;
        ans[i] = num;
        ans[i + num] = num;
        if (dfs(n, i + 1, mask | 1 << num, ans))
          return true;
        ans[i + num] = 0;
        ans[i] = 0;
      }
    }

    return false;
  }
};",1718
1717,"class Solution {
 public:
  int checkWays(vector<vector<int>>& pairs) {
    constexpr int kMax = 501;
    unordered_map<int, vector<int>> graph;
    vector<int> degrees(kMax);
    vector<vector<bool>> connected(kMax, vector<bool>(kMax));

    for (const vector<int>& pair : pairs) {
      const int u = pair[0];
      const int v = pair[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
      ++degrees[u];
      ++degrees[v];
      connected[u][v] = true;
      connected[v][u] = true;
    }

    // For each node, sort its children by degrees in descending order.
    for (auto& [_, children] : graph)
      ranges::sort(children, [&degrees](int a, int b) {
        return degrees[b] < degrees[a];
      });

    const int root = getRoot(degrees, graph.size());
    if (root == -1)
      return 0;
    if (!dfs(graph, root, degrees, connected, {}, vector<bool>(kMax)))
      return 0;
    return hasMoreThanOneWay ? 2 : 1;
  }

 private:
  bool hasMoreThanOneWay = false;

  // Returns the root by finding the node with a degree that equals to n - 1.
  int getRoot(const vector<int>& degrees, int n) {
    for (int i = 1; i < degrees.size(); ++i)
      if (degrees[i] == n - 1)
        return i;
    return -1;
  }

  // Returns true if each node rooted at u is connected to all of its ancestors.
  bool dfs(const unordered_map<int, vector<int>>& graph, int u,
           vector<int>& degrees, vector<vector<bool>>& connected,
           vector<int>&& ancestors, vector<bool>&& seen) {
    seen[u] = true;

    for (const int ancestor : ancestors)
      if (!connected[u][ancestor])
        return false;

    ancestors.push_back(u);

    for (const int v : graph.at(u)) {
      if (seen[v])
        continue;
      // We can swap u with v, so there are more than one way.
      if (degrees[v] == degrees[u])
        hasMoreThanOneWay = true;
      if (!dfs(graph, v, degrees, connected, move(ancestors), move(seen)))
        return false;
    }

    ancestors.pop_back();
    return true;
  }
};",1719
1718,"class Solution {
 public:
  vector<int> decode(vector<int>& encoded, int first) {
    vector<int> ans(encoded.size() + 1);
    ans[0] = first;

    for (int i = 0; i < encoded.size(); ++i)
      ans[i + 1] = ans[i] ^ encoded[i];

    return ans;
  }
};",1720
1719,"class Solution {
 public:
  ListNode* swapNodes(ListNode* head, int k) {
    ListNode* p = nullptr;  // Points the k-th node from the beginning.
    ListNode* q = nullptr;  // Points the k-th node from the end.

    for (ListNode* curr = head; curr != nullptr; curr = curr->next) {
      if (q != nullptr)
        q = q->next;
      if (--k == 0) {
        p = curr;
        q = head;
      }
    }

    swap(p->val, q->val);
    return head;
  }
};",1721
1720,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minimumHammingDistance(vector<int>& source, vector<int>& target,
                             vector<vector<int>>& allowedSwaps) {
    const int n = source.size();
    int ans = 0;
    UnionFind uf(n);
    vector<unordered_map<int, int>> groupIdToCount(n);

    for (const vector<int>& allowedSwap : allowedSwaps) {
      const int a = allowedSwap[0];
      const int b = allowedSwap[1];
      uf.unionByRank(a, b);
    }

    for (int i = 0; i < n; ++i)
      ++groupIdToCount[uf.find(i)][source[i]];

    for (int i = 0; i < n; ++i) {
      const int groupId = uf.find(i);
      unordered_map<int, int>& count = groupIdToCount[groupId];
      if (!count.count(target[i]))
        ++ans;
      else if (--count[target[i]] == 0)
        count.erase(target[i]);
    }

    return ans;
  }
};",1722
1721,"class Solution {
 public:
  int minimumTimeRequired(std::vector<int>& jobs, int k) {
    int ans = accumulate(jobs.begin(), jobs.end(), 0);
    vector<int> times(k);

    ranges::sort(jobs, greater<>());
    dfs(jobs, 0, times, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& jobs, int s, vector<int>& times, int& ans) {
    if (s == jobs.size()) {
      ans = min(ans, ranges::max(times));
      return;
    }
    for (int i = 0; i < times.size(); ++i) {
      if (times[i] + jobs[s] >= ans)
        continue;
      times[i] += jobs[s];
      dfs(jobs, s + 1, times, ans);
      times[i] -= jobs[s];
      if (times[i] == 0)
        return;
    }
  };
};",1723
1722,"query(p: int, q: int, limit: int)",1724
1723,"class Solution {
 public:
  int countGoodRectangles(vector<vector<int>>& rectangles) {
    vector<int> minSides;

    for (const vector<int>& rectangle : rectangles) {
      const int x = rectangle[0];
      const int y = rectangle[1];
      minSides.push_back(min(x, y));
    }

    const int maxLen = ranges::max(minSides);
    return ranges::count(minSides, maxLen);
  }
};",1725
1724,"class Solution {
 public:
  int tupleSameProduct(vector<int>& nums) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = 0; j < i; ++j)
        ans += count[nums[i] * nums[j]]++ * 8;

    return ans;
  }
};",1726
1725,"class Solution {
 public:
  int largestSubmatrix(vector<vector<int>>& matrix) {
    const int n = matrix[0].size();
    int ans = 0;
    vector<int> hist(n);

    for (const vector<int>& row : matrix) {
      // Accumulate the histogram if possible.
      for (int i = 0; i < n; ++i)
        hist[i] = row[i] == 0 ? 0 : hist[i] + 1;

      // Get the sorted histogram.
      vector<int> sortedHist(hist);
      ranges::sort(sortedHist);

      // Greedily calculate the answer.
      for (int i = 0; i < n; ++i)
        ans = max(ans, sortedHist[i] * (n - i));
    }

    return ans;
  }
};",1727
1726,"class Solution {
 public:
  bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {
    const int m = grid.size();
    const int n = grid[0].size();
    int nFloors = 0;
    int cat;    // cat's position
    int mouse;  // mouse's position

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (grid[i][j] != '#')
          ++nFloors;
        if (grid[i][j] == 'C')
          cat = hash(i, j, n);
        else if (grid[i][j] == 'M')
          mouse = hash(i, j, n);
      }

    vector<vector<vector<int>>> mem(
        m * n, vector<vector<int>>(m * n, vector<int>(nFloors * 2, -1)));
    return canMouseWin(grid, cat, mouse, 0, catJump, mouseJump, m, n, nFloors,
                       mem);
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  // Returns true if the mouse can win, where the cat is on (i / 8, i % 8), the
  // mouse is on (j / 8, j % 8), and the turns is k.
  bool canMouseWin(const vector<string>& grid, int cat, int mouse, int turn,
                   const int& catJump, const int& mouseJump, const int& m,
                   const int& n, const int& nFloors,
                   vector<vector<vector<int>>>& mem) {
    // We already search the whole touchable grid.
    if (turn == nFloors * 2)
      return false;
    if (mem[cat][mouse][turn] != -1)
      return mem[cat][mouse][turn];

    if (turn % 2 == 0) {
      // the mouse's turn
      const int i = mouse / n;
      const int j = mouse % n;
      for (const auto& [dx, dy] : dirs) {
        for (int jump = 0; jump <= mouseJump; ++jump) {
          const int x = i + dx * jump;
          const int y = j + dy * jump;
          if (x < 0 || x == m || y < 0 || y == n)
            break;
          if (grid[x][y] == '#')
            break;
          // The mouse eats the food, so the mouse wins.
          if (grid[x][y] == 'F')
            return mem[cat][mouse][turn] = true;
          if (canMouseWin(grid, cat, hash(x, y, n), turn + 1, catJump,
                          mouseJump, m, n, nFloors, mem))
            return mem[cat][mouse][turn] = true;
        }
      }
      // The mouse can't win, so the mouse loses.
      return mem[cat][mouse][turn] = false;
    } else {
      // the cat's turn
      const int i = cat / n;
      const int j = cat % n;
      for (const auto& [dx, dy] : dirs) {
        for (int jump = 0; jump <= catJump; ++jump) {
          const int x = i + dx * jump;
          const int y = j + dy * jump;
          if (x < 0 || x == m || y < 0 || y == n)
            break;
          if (grid[x][y] == '#')
            break;
          // The cat eats the food, so the mouse loses.
          if (grid[x][y] == 'F')
            return mem[cat][mouse][turn] = false;
          const int nextCat = hash(x, y, n);
          // The cat catches the mouse, so the mouse loses.
          if (nextCat == mouse)
            return mem[cat][mouse][turn] = false;
          if (!canMouseWin(grid, nextCat, mouse, turn + 1, catJump, mouseJump,
                           m, n, nFloors, mem))
            return mem[cat][mouse][turn] = false;
        }
      }
      // The cat can't win, so the mouse wins.
      return mem[cat][mouse][turn] = true;
    }
  }

  int hash(int i, int j, int n) {
    return i * n + j;
  }
};",1728
1727,"SELECT
  user_id,
  COUNT(follower_id) AS followers_count
FROM Followers
GROUP BY 1
ORDER BY 1;",1729
1728,"class Solution {
 public:
  int getFood(vector<vector<char>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    queue<pair<int, int>> q{{getStartLocation(grid)}};

    for (int ans = 0; !q.empty(); ++ans)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] == 'X')
            continue;
          if (grid[x][y] == '#')
            return ans + 1;
          q.emplace(x, y);
          grid[x][y] = 'X';  // Mark as visited.
        }
      }

    return -1;
  }

 private:
  pair<int, int> getStartLocation(const vector<vector<char>>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == '*')
          return {i, j};
    throw;
  }
};",1730
1729,"SELECT
  Manager.employee_id,
  Manager.name,
  COUNT(Employee.employee_id) AS reports_count,
  ROUND(AVG(Employee.age)) AS average_age
FROM Employees AS Manager
INNER JOIN Employees AS Employee
  ON (Employee.reports_to = Manager.employee_id)
GROUP BY 1
ORDER BY 1;",1731
1730,"class Solution {
 public:
  int largestAltitude(vector<int>& gain) {
    int ans = 0;
    int currAltitude = 0;
    for (const int g : gain) {
      currAltitude += g;
      ans = max(ans, currAltitude);
    }
    return ans;
  }
};",1732
1731,"class Solution {
 public:
  int minimumTeachings(int n, vector<vector<int>>& languages,
                       vector<vector<int>>& friendships) {
    vector<unordered_set<int>> languageSets;
    unordered_set<int> needTeach;
    unordered_map<int, int> languageCount;

    for (const vector<int>& language : languages)
      languageSets.push_back({language.begin(), language.end()});

    // Find friends that can't communicate.
    for (const vector<int>& friendship : friendships) {
      const int u = friendship[0] - 1;
      const int v = friendship[1] - 1;
      if (cantTalk(languageSets, u, v)) {
        needTeach.insert(u);
        needTeach.insert(v);
      }
    }

    // Find the most popular language.
    for (const int u : needTeach)
      for (const int language : languageSets[u])
        ++languageCount[language];

    // Teach the most popular language to people who don't understand.
    int maxCount = 0;
    for (const auto& [_, freq] : languageCount)
      maxCount = max(maxCount, freq);

    return needTeach.size() - maxCount;
  }

 private:
  // Returns true if u can't talk with v.
  bool cantTalk(const vector<unordered_set<int>>& languageSets, int u, int v) {
    for (const int language : languageSets[u])
      if (languageSets[v].count(language))
        return false;
    return true;
  }
};",1733
1732,"class Solution {
 public:
  vector<int> decode(vector<int>& encoded) {
    // Our goal is to find the value of a1, which will allow us to decode a2,
    // a3, ..., an. This can be achieved by performing XOR operation between
    // each element in `encoded` and a1.
    //
    // e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3]
    //               encoded = [a1^a2, a2^a3]
    //    accumulatedEncoded = [a1^a2, a1^a3]
    //    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)
    //    a2 = a1^(a1^a2)
    //    a3 = a2^(a2^a3)
    const int n = encoded.size() + 1;
    int nXors = 0;
    for (int i = 1; i <= n; i++)
      nXors ^= i;

    // Instead of constructing the array, we can track of the running XOR value
    // of `accumulatedEncoded`.
    int runningXors = 0;
    int xors = 0;  // xors(accumulatedEncoded)

    for (const int encode : encoded) {
      runningXors ^= encode;
      xors ^= runningXors;
    }

    vector<int> ans{xors ^ nXors};

    for (const int encode : encoded)
      ans.push_back(ans.back() ^ encode);

    return ans;
  }
};",1734
1733,"class Solution {
 public:
  vector<int> waysToFillArray(vector<vector<int>>& queries) {
    constexpr int kMax = 10000;
    constexpr int kMaxFreq = 13;  // 2^13 = 8192 < kMax
    const vector<int> minPrimeFactors = sieveEratosthenes(kMax + 1);
    const auto [fact, invFact] = getFactAndInvFact(kMax + kMaxFreq - 1);
    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int n = query[0];
      const int k = query[1];
      int res = 1;
      for (const auto& [_, freq] : getPrimeFactorsCount(k, minPrimeFactors))
        res = static_cast<long>(res) * nCk(n - 1 + freq, freq, fact, invFact) %
              kMod;
      ans.push_back(res);
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Gets the minimum prime factor of i, where 1 < i <= n.
  vector<int> sieveEratosthenes(int n) {
    vector<int> minPrimeFactors(n + 1);
    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);
    for (int i = 2; i * i < n; ++i)
      if (minPrimeFactors[i] == i)  // `i` is prime.
        for (int j = i * i; j < n; j += i)
          minPrimeFactors[j] = min(minPrimeFactors[j], i);
    return minPrimeFactors;
  }

  unordered_map<int, int> getPrimeFactorsCount(
      int num, const vector<int>& minPrimeFactors) {
    unordered_map<int, int> count;
    while (num > 1) {
      const int divisor = minPrimeFactors[num];
      while (num % divisor == 0) {
        num /= divisor;
        ++count[divisor];
      }
    }
    return count;
  }

  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {
    vector<long> fact(n + 1);
    vector<long> invFact(n + 1);
    vector<long> inv(n + 1);
    fact[0] = invFact[0] = 1;
    inv[0] = inv[1] = 1;
    for (int i = 1; i <= n; ++i) {
      if (i >= 2)
        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;
      fact[i] = fact[i - 1] * i % kMod;
      invFact[i] = invFact[i - 1] * inv[i] % kMod;
    }
    return {fact, invFact};
  }

  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {
    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;
  }
};",1735
1734,"class Solution {
 public:
  string maximumTime(string time) {
    string ans = time;
    if (time[0] == '?')
      ans[0] = time[1] == '?' || time[1] <= '3' ? '2' : '1';
    if (time[1] == '?')
      ans[1] = ans[0] == '2' ? '3' : '9';
    if (time[3] == '?')
      ans[3] = '5';
    if (time[4] == '?')
      ans[4] = '9';
    return ans;
  }
};",1736
1735,"class Solution {
 public:
  int minCharacters(string a, string b) {
    const int m = a.length();
    const int n = b.length();
    vector<int> countA(26);
    vector<int> countB(26);

    for (const char c : a)
      ++countA[c - 'a'];

    for (const char c : b)
      ++countB[c - 'a'];

    int ans = INT_MAX;
    int prevA = 0;  // the number of characters in a <= c
    int prevB = 0;  // the number of characters in b <= c

    for (char c = 'a'; c <= 'z'; ++c) {
      // the condition 3
      ans = min(ans, m + n - countA[c - 'a'] - countB[c - 'a']);
      // the conditions 1 and 2
      if (c > 'a')
        ans = min({ans, m - prevA + prevB, n - prevB + prevA});
      prevA += countA[c - 'a'];
      prevB += countB[c - 'a'];
    }

    return ans;
  }
};",1737
1736,"class Solution {
 public:
  int kthLargestValue(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> xors(m + 1, vector<int>(n + 1));
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j) {
        xors[i][j] = xors[i - 1][j] ^ xors[i][j - 1] ^ xors[i - 1][j - 1] ^
                     matrix[i - 1][j - 1];
        minHeap.push(xors[i][j]);
        if (minHeap.size() > k)
          minHeap.pop();
      }

    return minHeap.top();
  }
};",1738
1737,"class Solution {
 public:
  int minimumBoxes(int n) {
    int nBoxes = 0;
    int nextTouchings = 0;   // j
    int currLevelBoxes = 0;  // 1 + 2 + ... + j

    // Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)
    // >= n.
    while (nBoxes < n) {
      ++nextTouchings;
      currLevelBoxes += nextTouchings;
      nBoxes += currLevelBoxes;
    }

    // If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.
    if (nBoxes == n)
      return currLevelBoxes;

    // Otherwise, need to remove the boxes in the current level and rebuild it.
    nBoxes -= currLevelBoxes;
    currLevelBoxes -= nextTouchings;
    nextTouchings = 0;

    while (nBoxes < n) {
      ++nextTouchings;
      nBoxes += nextTouchings;
    }

    return currLevelBoxes + nextTouchings;
  }
};",1739
1738,"class Solution {
 public:
  int findDistance(TreeNode* root, int p, int q) {
    TreeNode* lca = getLCA(root, p, q);
    return dist(lca, p) + dist(lca, q);
  }

 private:
  TreeNode* getLCA(TreeNode* root, int p, int q) {
    if (root == nullptr || root->val == p || root->val == q)
      return root;
    TreeNode* left = getLCA(root->left, p, q);
    TreeNode* right = getLCA(root->right, p, q);
    if (left != nullptr && right != nullptr)
      return root;
    return left == nullptr ? right : left;
  }

  int dist(TreeNode* lca, int target) {
    if (lca == nullptr)
      return 10000;
    if (lca->val == target)
      return 0;
    return 1 + min(dist(lca->left, target), dist(lca->right, target));
  }
};",1740
1739,"SELECT
  event_day AS day,
  emp_id,
  SUM(out_time - in_time) AS total_time
FROM Employees
GROUP BY 1, 2;",1741
1740,"class Solution {
 public:
  int countBalls(int lowLimit, int highLimit) {
    const int maxDigitSum = 9 * 5;  // 99999
    int ans = 0;
    vector<int> count(maxDigitSum + 1);

    for (int num = lowLimit; num <= highLimit; ++num)
      ans = max(ans, ++count[getDigitSum(num)]);

    return ans;
  }

 private:
  int getDigitSum(int num) {
    int digitSum = 0;
    while (num > 0) {
      digitSum += num % 10;
      num /= 10;
    }
    return digitSum;
  }
};",1742
1741,"class Solution {
 public:
  vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
    vector<int> ans;
    unordered_map<int, vector<int>> numToAdjs;

    for (const vector<int>& pair : adjacentPairs) {
      const int u = pair[0];
      const int v = pair[1];
      numToAdjs[u].push_back(v);
      numToAdjs[v].push_back(u);
    }

    for (const auto& [num, adjs] : numToAdjs)
      if (adjs.size() == 1) {
        ans.push_back(num);
        ans.push_back(adjs[0]);
        break;
      }

    while (ans.size() < adjacentPairs.size() + 1) {
      const int tail = ans.back();
      const int prev = ans[ans.size() - 2];
      const vector<int>& adjs = numToAdjs[tail];
      if (adjs[0] == prev)
        ans.push_back(adjs[1]);
      else
        ans.push_back(adjs[0]);
    }

    return ans;
  }
};",1743
1742,"class Solution {
 public:
  vector<bool> canEat(vector<int>& candiesCount, vector<vector<int>>& queries) {
    const int n = candiesCount.size();
    vector<bool> ans;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + candiesCount[i]);

    for (const vector<int>& query : queries) {
      const int type = query[0];
      const int day = query[1];
      const int cap = query[2];
      // the minimum day required to eat
      const long minDay = prefix[type] / cap;
      // the maximum day required to eat
      const long maxDay = prefix[type + 1] - 1;
      ans.push_back(minDay <= day && day <= maxDay);
    }

    return ans;
  }
};",1744
1743,"class Solution {
 public:
  bool checkPartitioning(string s) {
    const int n = s.length();
    vector<vector<int>> mem(n, vector<int>(n, -1));

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j + 1 < n; ++j)
        if (isPalindrome(s, 0, i, mem) &&      //
            isPalindrome(s, i + 1, j, mem) &&  //
            isPalindrome(s, j + 1, n - 1, mem))
          return true;

    return false;
  }

 private:
  // Returns true if s[i..j] is a palindrome.
  // Returns false if s[i..j] is not a palindrome.
  bool isPalindrome(const string& s, int i, int j, vector<vector<int>>& mem) {
    if (i > j)
      return true;
    if (mem[i][j] != -1)
      return mem[i][j];
    if (s[i] == s[j])
      return mem[i][j] = isPalindrome(s, i + 1, j - 1, mem);
    return mem[i][j] = false;
  }
};",1745
1744,"class Solution {
 public:
  int maxSumAfterOperation(vector<int>& nums) {
    int ans = INT_MIN;
    int regular = 0;
    int squared = 0;

    for (const int num : nums) {
      squared = max({num * num, regular + num * num, squared + num});
      regular = max(num, regular + num);
      ans = max(ans, squared);
    }

    return ans;
  }
};",1746
1745,"WITH
  LogInfoNeighbors AS (
    SELECT
      *,
      LEAD(ip_address) OVER(
        PARTITION BY account_id
        ORDER BY login
      ) AS next_ip_address,
      LEAD(login) OVER(
        PARTITION BY account_id
        ORDER BY login
      ) next_login
    FROM LogInfo
  )
SELECT DISTINCT account_id
FROM LogInfoNeighbors
WHERE
  next_login <= logout
  AND ip_address != next_ip_address;",1747
1746,"class Solution {
 public:
  int sumOfUnique(vector<int>& nums) {
    constexpr int kMax = 100;
    int ans = 0;
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = 1; i <= kMax; ++i)
      if (count[i] == 1)
        ans += i;

    return ans;
  }
};",1748
1747,"class Solution {
 public:
  int maxAbsoluteSum(vector<int>& nums) {
    int ans = INT_MIN;
    int maxSum = 0;
    int minSum = 0;

    for (const int num : nums) {
      maxSum = max(num, maxSum + num);
      minSum = min(num, minSum + num);
      ans = max({ans, maxSum, -minSum});
    }

    return ans;
  }
};",1749
1748,"class Solution {
 public:
  int minimumLength(string s) {
    int i = 0;
    int j = s.length() - 1;

    while (i < j && s[i] == s[j]) {
      const char c = s[i];
      while (i <= j && s[i] == c)
        ++i;
      while (i <= j && s[j] == c)
        --j;
    }

    return j - i + 1;
  }
};",1750
1749,"class Solution {
 public:
  int maxValue(vector<vector<int>>& events, int k) {
    vector<vector<int>> mem(events.size(), vector<int>(k + 1, -1));
    ranges::sort(events);
    return maxValue(events, 0, k, mem);
  }

 private:
  // Returns the maximum sum of values that you can receive by attending
  // events[i..n), where k is the maximum number of attendancevents.
  int maxValue(const vector<vector<int>>& events, int i, int k,
               vector<vector<int>>& mem) {
    if (k == 0 || i == events.size())
      return 0;
    if (mem[i][k] != -1)
      return mem[i][k];

    // Binary search `events` to find the first index j
    // s.t. events[j][0] > events[i][1].
    const auto it = upper_bound(
        events.begin() + i, events.end(), events[i][1],
        [](int end, const vector<int>& event) { return event[0] > end; });
    const int j = distance(events.begin(), it);
    return mem[i][k] = max(events[i][2] + maxValue(events, j, k - 1, mem),
                           maxValue(events, i + 1, k, mem));
  }
};",1751
1750,"class Solution {
 public:
  bool check(vector<int>& nums) {
    const int n = nums.size();
    int rotates = 0;

    for (int i = 0; i < n; ++i)
      if (nums[i] > nums[(i + 1) % n] && ++rotates > 1)
        return false;

    return true;
  }
};",1752
1751,"class Solution {
 public:
  int maximumScore(int a, int b, int c) {
    // the maximum <= the minimum + the middle
    const int x = (a + b + c) / 2;
    // the maximum > the minimum + the middle
    const int y = a + b + c - max({a, b, c});
    return min(x, y);
  }
};",1753
1752,"class Solution {
 public:
  string largestMerge(string word1, string word2) {
    if (word1.empty())
      return word2;
    if (word2.empty())
      return word1;
    return word1 > word2 ? word1[0] + largestMerge(word1.substr(1), word2)
                         : word2[0] + largestMerge(word1, word2.substr(1));
  }
};",1754
1753,"class Solution {
 public:
  int minAbsDifference(vector<int>& nums, int goal) {
    const int n = nums.size() / 2;
    const vector<int> lNums(nums.begin(), nums.begin() + n);
    const vector<int> rNums(nums.begin() + n, nums.end());
    int ans = INT_MAX;
    vector<int> lSums;
    vector<int> rSums;

    dfs(lNums, 0, 0, lSums);
    dfs(rNums, 0, 0, rSums);
    ranges::sort(rSums);

    for (const int lSum : lSums) {
      const int i = firstGreaterEqual(rSums, goal - lSum);
      if (i < rSums.size())  // 2^n
        ans = min(ans, abs(goal - lSum - rSums[i]));
      if (i > 0)
        ans = min(ans, abs(goal - lSum - rSums[i - 1]));
    }

    return ans;
  }

 private:
  void dfs(const vector<int>& A, int i, int path, vector<int>& sums) {
    if (i == A.size()) {
      sums.push_back(path);
      return;
    }
    dfs(A, i + 1, path + A[i], sums);
    dfs(A, i + 1, path, sums);
  }

  int firstGreaterEqual(const vector<int>& A, int target) {
    return ranges::lower_bound(A, target) - A.begin();
  }
};",1755
1754,fetch(k: int),1756
1755,"SELECT product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y';",1757
1756,"class Solution {
 public:
  int minOperations(string s) {
    int cost10;  // the cost to make s ""1010""

    for (int i = 0; i < s.length(); ++i)
      if (s[i] - '0' == i % 2)
        ++cost10;

    const int cost01 = s.length() - cost10;  // the cost to make s ""0101""
    return min(cost10, cost01);
  }
};",1758
1757,"class Solution {
 public:
  int countHomogenous(string s) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    int count = 0;
    char currentChar = '@';

    for (const char c : s) {
      count = c == currentChar ? count + 1 : 1;
      currentChar = c;
      ans += count;
      ans %= kMod;
    }

    return ans;
  }
};",1759
1758,"class Solution {
 public:
  int minimumSize(vector<int>& nums, int maxOperations) {
    int l = 1;
    int r = ranges::max(nums);

    while (l < r) {
      const int m = (l + r) / 2;
      if (numOperations(nums, m) <= maxOperations)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns the number of operations required to make m penalty.
  int numOperations(const vector<int>& nums, int m) {
    int operations = 0;
    for (const int num : nums)
      operations += (num - 1) / m;
    return operations;
  }
};",1760
1759,"class Solution {
 public:
  int minTrioDegree(int n, vector<vector<int>>& edges) {
    int ans = INT_MAX;
    vector<unordered_set<int>> graph(n);
    vector<int> degrees(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      // Store the mapping from `min(u, v)` to `max(u, v)` to speed up.
      graph[min(u, v)].insert(max(u, v));
      ++degrees[u];
      ++degrees[v];
    }

    for (int u = 0; u < n; ++u)
      for (const int v : graph[u])
        for (const int w : graph[u])
          if (graph[v].count(w))
            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6);

    return ans == INT_MAX ? -1 : ans;
  }
};",1761
1760,"class Solution {
 public:
  vector<int> findBuildings(vector<int>& heights) {
    vector<int> stack;

    for (int i = 0; i < heights.size(); ++i) {
      while (!stack.empty() && heights[stack.back()] <= heights[i])
        stack.pop_back();
      stack.push_back(i);
    }

    return stack;
  }
};",1762
1761,"class Solution {
 public:
  string longestNiceSubstring(string s) {
    if (s.length() < 2)
      return """";

    unordered_set<char> seen{s.begin(), s.end()};

    for (int i = 0; i < s.size(); ++i)
      // If both upper and lower case letters exists in the string, keep moving,
      // else take the erroneous character as a partition and check for its left
      // and right parts to be nice strings.
      if (!seen.count(toggleCase(s[i]))) {
        const string prefix = longestNiceSubstring(s.substr(0, i));
        const string suffix = longestNiceSubstring(s.substr(i + 1));
        return prefix.length() >= suffix.length() ? prefix : suffix;
      }

    return s;
  }

 private:
  char toggleCase(char c) {
    return islower(c) ? toupper(c) : tolower(c);
  }
};",1763
1762,"class Solution {
 public:
  bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {
    int i = 0;  // groups' index
    int j = 0;  // nums' index

    while (i < groups.size() && j < nums.size())
      if (isMatch(groups[i], nums, j)) {
        j += groups[i].size();
        ++i;
      } else {
        ++j;
      }

    return i == groups.size();
  }

 private:
  // Returns true if group == nums[j..j + |group|].
  bool isMatch(const vector<int>& group, const vector<int>& nums, int j) {
    if (j + group.size() > nums.size())
      return false;
    for (int i = 0; i < group.size(); ++i)
      if (group[i] != nums[j + i])
        return false;
    return true;
  }
};",1764
1763,"class Solution {
 public:
  vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = isWater.size();
    const int n = isWater[0].size();
    vector<vector<int>> ans(m, vector<int>(n, -1));
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (isWater[i][j] == 1) {
          q.emplace(i, j);
          ans[i][j] = 0;
        }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (ans[x][y] != -1)
          continue;
        ans[x][y] = ans[i][j] + 1;
        q.emplace(x, y);
      }
    }

    return ans;
  }
};",1765
1764,"class Solution {
 public:
  vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {
    vector<int> ans(nums.size(), -1);
    vector<vector<int>> tree(nums.size());
    // stacks[i] := (node, depth)s of nodes with value i
    vector<stack<pair<int, int>>> stacks(kMax + 1);

    for (const vector<int> edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, /*prev=*/-1, /*depth=*/0, nums, stacks, ans);
    return ans;
  }

 private:
  static constexpr int kMax = 50;

  void dfs(const vector<vector<int>>& tree, int u, int prev, int depth,
           const vector<int>& nums, vector<stack<pair<int, int>>>& stacks,
           vector<int>& ans) {
    ans[u] = getAncestor(u, stacks, nums);
    stacks[nums[u]].push({u, depth});

    for (const int v : tree[u])
      if (prev != v)
        dfs(tree, v, u, depth + 1, nums, stacks, ans);

    stacks[nums[u]].pop();
  }

  int getAncestor(int u, const vector<stack<pair<int, int>>>& stacks,
                  const vector<int>& nums) {
    int maxNode = -1;
    int maxDepth = -1;
    for (int i = 1; i <= kMax; ++i)
      if (!stacks[i].empty() && stacks[i].top().second > maxDepth &&
          __gcd(nums[u], i) == 1) {
        maxNode = stacks[i].top().first;
        maxDepth = stacks[i].top().second;
      }
    return maxNode;
  }
};",1766
1765,"WITH
  RECURSIVE TaskToSubtask AS (
    SELECT task_id, subtasks_count AS subtask_id FROM Tasks
    UNION ALL
    SELECT task_id, subtask_id - 1 FROM TaskToSubtask
    WHERE subtask_id > 1
  )
SELECT * FROM TaskToSubtask
EXCEPT
SELECT * FROM Executed;",1767
1766,"class Solution {
 public:
  string mergeAlternately(string word1, string word2) {
    const int n = min(word1.length(), word2.length());
    string prefix;

    for (int i = 0; i < n; ++i) {
      prefix += word1[i];
      prefix += word2[i];
    }

    return prefix + word1.substr(n) + word2.substr(n);
  }
};",1768
1767,"class Solution {
 public:
  vector<int> minOperations(string boxes) {
    vector<int> ans(boxes.length());

    for (int i = 0, count = 0, moves = 0; i < boxes.length(); ++i) {
      ans[i] += moves;
      count += boxes[i] - '0';
      moves += count;
    }

    for (int i = boxes.length() - 1, count = 0, moves = 0; i >= 0; --i) {
      ans[i] += moves;
      count += boxes[i] - '0';
      moves += count;
    }

    return ans;
  }
};",1769
1768,"class Solution {
 public:
  int maximumScore(vector<int>& nums, vector<int>& multipliers) {
    vector<vector<int>> mem(multipliers.size(),
                            vector<int>(multipliers.size(), -1));
    return maximumScore(nums, 0, multipliers, 0, mem);
  }

 private:
  // Returns the maximum score of nums[s..e] and multipliers[i].
  int maximumScore(const vector<int>& nums, int s,
                   const vector<int>& multipliers, int i,
                   vector<vector<int>>& mem) {
    if (i == multipliers.size())
      return 0;
    if (mem[s][i] != -1)
      return mem[s][i];

    // The number of nums picked on the start side is s.
    // The number of nums picked on the end side is i - s.
    // So, e = n - (i - s) - 1.
    const int e = nums.size() - (i - s) - 1;
    const int pickStart = nums[s] * multipliers[i] +
                          maximumScore(nums, s + 1, multipliers, i + 1, mem);
    const int pickEnd = nums[e] * multipliers[i] +
                        maximumScore(nums, s, multipliers, i + 1, mem);
    return mem[s][i] = max(pickStart, pickEnd);
  }
};",1770
1769,"class Solution {
 public:
  int longestPalindrome(string word1, string word2) {
    const string& s = word1 + word2;
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := the length of LPS(s[i..j])
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          dp[i][j] = 2 + dp[i + 1][j - 1];
          if (i < word1.length() && j >= word1.length())
            ans = max(ans, dp[i][j]);
        } else {
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
      }

    return ans;
  }
};",1771
1770,"class Solution {
 public:
  vector<string> sortFeatures(vector<string>& features,
                              vector<string>& responses) {
    vector<string> ans;
    vector<pair<int, int>> featCount;  // {i: count[features[i]]}
    unordered_map<string, int> count;

    for (const string& res : responses) {
      istringstream iss(res);
      unordered_set<string> seen;
      for (string token; getline(iss, token, ' ');)
        seen.insert(token);
      for (const string& token : seen)
        ++count[token];
    }

    for (int i = 0; i < features.size(); ++i)
      featCount.emplace_back(i, count[features[i]]);

    ranges::sort(featCount,
                 [](const pair<int, int>& a, const pair<int, int>& b) {
      return a.second == b.second ? a.first < b.first : a.second > b.second;
    });

    for (const auto& [i, count] : featCount)
      ans.push_back(features[i]);

    return ans;
  }
};",1772
1771,"class Solution {
 public:
  int countMatches(vector<vector<string>>& items, string ruleKey,
                   string ruleValue) {
    const int index = ruleKey == ""type"" ? 0 : ruleKey == ""color"" ? 1 : 2;
    return ranges::count_if(items, [index, &ruleValue](const auto& item) {
      return item[index] == ruleValue;
    });
  }
};",1773
1772,"class Solution {
 public:
  int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts,
                  int target) {
    int ans = INT_MAX;

    for (const int baseCost : baseCosts)
      dfs(toppingCosts, 0, target, baseCost, ans);

    return ans;
  }

 private:
  void dfs(const vector<int>& toppingCosts, int i, int target, int currCost,
           int& ans) {
    if (abs(currCost - target) < abs(ans - target))
      ans = currCost;
    if (i == toppingCosts.size() || currCost >= target)
      return;

    for (int k = 0; k < 3; ++k)
      dfs(toppingCosts, i + 1, target, currCost + k * toppingCosts[i], ans);
  }
};",1774
1773,"class Solution {
 public:
  int minOperations(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())
      return -1;

    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
    if (sum1 > sum2)
      return minOperations(nums2, nums1);

    int ans = 0;
    // increasing in `nums1` and decreasing in `nums2`
    vector<int> count(6);

    for (const int num : nums1)
      ++count[6 - num];

    for (const int num : nums2)
      ++count[num - 1];

    for (int i = 5; sum2 > sum1;) {
      while (count[i] == 0)
        --i;
      sum1 += i;
      --count[i];
      ++ans;
    }

    return ans;
  }
};",1775
1774,"struct Car {
  int pos;
  int speed;
  double collisionTime;
  Car(int pos, int speed, double collisionTime)
      : pos(pos), speed(speed), collisionTime(collisionTime) {}
};

class Solution {
 public:
  vector<double> getCollisionTimes(vector<vector<int>>& cars) {
    vector<double> ans(cars.size());
    stack<Car> stack;

    for (int i = cars.size() - 1; i >= 0; --i) {
      const int pos = cars[i][0];
      const int speed = cars[i][1];
      while (!stack.empty() && (speed <= stack.top().speed ||
                                getCollisionTime(stack.top(), pos, speed) >=
                                    stack.top().collisionTime))
        stack.pop();
      if (stack.empty()) {
        stack.emplace(pos, speed, INT_MAX);
        ans[i] = -1;
      } else {
        const double collisionTime = getCollisionTime(stack.top(), pos, speed);
        stack.emplace(pos, speed, collisionTime);
        ans[i] = collisionTime;
      }
    }

    return ans;
  }

 private:
  double getCollisionTime(const Car& car, int pos, int speed) {
    return (car.pos - pos) / (double)(speed - car.speed);
  }
};",1776
1775,"SELECT
  product_id,
  MAX(CASE WHEN store = 'store1' THEN price END) AS store1,
  MAX(CASE WHEN store = 'store2' THEN price END) AS store2,
  MAX(CASE WHEN store = 'store3' THEN price END) AS store3
FROM Products
GROUP BY 1;",1777
1776,"/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *  public:
 *   bool canMove(char direction);
 *   void move(char direction);
 *   boolean isTarget();
 * };
 */

enum class Grid { kUnvisited, kStart, kTarget, kBlocked, kEmpty };

class Solution {
 public:
  int findShortestPath(GridMaster& master) {
    constexpr int m = 500;
    constexpr int startX = m;
    constexpr int startY = m;
    vector<vector<Grid>> grid(m * 2, vector<Grid>(m * 2, Grid::kUnvisited));

    // Build the grid information by DFS.
    dfs(master, grid, startX, startY);

    int ans = 0;
    queue<pair<int, int>> q{{{startX, startY}}};
    grid[startX][startY] = Grid::kBlocked;

    // Find the steps by BFS.
    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (grid[x][y] == Grid::kTarget)
            return ans;
          if (grid[x][y] == Grid::kBlocked)
            continue;
          grid[x][y] = Grid::kBlocked;
          q.emplace(x, y);
        }
      }
    }

    return -1;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  static constexpr char charTable[4] = {'R', 'D', 'L', 'U'};

  void dfs(GridMaster& master, vector<vector<Grid>>& grid, int i, int j) {
    if (grid[i][j] != Grid::kUnvisited)
      return;
    if (master.isTarget())
      grid[i][j] = Grid::kTarget;
    else
      grid[i][j] = Grid::kEmpty;

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k][0];
      const int y = j + dirs[k][1];
      const char d = charTable[k];
      const char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d)) {
        master.move(d);
        dfs(master, grid, x, y);
        master.move(undoD);
      } else {
        grid[x][y] = Grid::kBlocked;
      }
    }
  }
};",1778
1777,"class Solution {
 public:
  int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
    int ans = -1;
    int minDist = INT_MAX;

    for (int i = 0; i < points.size(); ++i) {
      const int dx = x - points[i][0];
      const int dy = y - points[i][1];
      if (dx == 0 || dy == 0) {
        const int dist = abs(dx + dy);
        if (dist < minDist) {
          minDist = dist;
          ans = i;
        }
      }
    }

    return ans;
  }
};",1779
1778,"class Solution {
 public:
  bool checkPowersOfThree(int n) {
    while (n > 1) {
      const int r = n % 3;
      if (r == 2)
        return false;
      n /= 3;
    }

    return true;
  }
};",1780
1779,"class Solution {
 public:
  int beautySum(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i) {
      vector<int> count(26);
      for (int j = i; j < s.length(); ++j) {
        ++count[s[j] - 'a'];
        ans += ranges::max(count) - getMinFreq(count);
      }
    }

    return ans;
  }

 private:
  // Returns the minimum frequency > 0.
  int getMinFreq(const vector<int>& count) {
    int minFreq = INT_MAX;
    for (const int freq : count)
      if (freq > 0)
        minFreq = min(minFreq, freq);
    return minFreq;
  }
};",1781
1780,"class Solution {
 public:
  vector<int> countPairs(int n, vector<vector<int>>& edges,
                         vector<int>& queries) {
    vector<int> ans(queries.size());

    // count[i] := the number of edges of node i
    vector<int> count(n + 1);

    // shared[i][j] := the number of edges incident to i or j, where i < j
    vector<unordered_map<int, int>> shared(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      ++count[u];
      ++count[v];
      ++shared[min(u, v)][max(u, v)];
    }

    vector<int> sortedCount(count);
    ranges::sort(sortedCount);

    int k = 0;
    for (const int query : queries) {
      for (int i = 1, j = n; i < j;)
        if (sortedCount[i] + sortedCount[j] > query)
          // sortedCount[i] + sortedCount[j] > query
          // sortedCount[i + 1] + sortedCount[j] > query
          // ...
          // sortedCount[j - 1] + sortedCount[j] > query
          // So, there are (j - 1) - i + 1 = j - i pairs > query
          ans[k] += (j--) - i;
        else
          ++i;
      for (int i = 1; i <= n; ++i)
        for (const auto& [j, sh] : shared[i])
          if (count[i] + count[j] > query && count[i] + count[j] - sh <= query)
            --ans[k];
      ++k;
    }

    return ans;
  }
};",1782
1781,"SELECT
  Players.player_id,
  Players.player_name,
  SUM(Players.player_id = Championships.Wimbledon) + SUM(Players.player_id = Championships.Fr_open) + SUM(Players.player_id = Championships.US_open) + SUM(Players.player_id = Championships.Au_open) AS grand_slams_count
FROM Players
INNER JOIN Championships
  ON (
    Players.player_id IN (
      Championships.Wimbledon,
      Championships.Fr_open,
      Championships.US_open,
      Championships.Au_open
    )
  )
GROUP BY 1;",1783
1782,"class Solution {
 public:
  bool checkOnesSegment(string s) {
    return s.find(""01"") == string::npos;
  }
};",1784
1783,"class Solution {
 public:
  int minElements(vector<int>& nums, int limit, int goal) {
    const long sum = accumulate(nums.begin(), nums.end(), 0L);
    const double diff = abs(goal - sum);
    return ceil(diff / limit);
  }
};",1785
1784,"class Solution {
 public:
  int countRestrictedPaths(int n, vector<vector<int>>& edges) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    constexpr int kMod = 1'000'000'007;
    // ways[i] := the number of restricted path from i to n
    vector<long> ways(graph.size());
    // dist[i] := the distance to the last node of i
    vector<long> dist(graph.size(), LLONG_MAX);
    using P = pair<long, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[dst] = 0;
    ways[dst] = 1;
    minHeap.emplace(dist[dst], dst);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (d > dist[u])
        continue;
      for (const auto& [v, w] : graph[u]) {
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
        if (dist[v] < dist[u]) {
          ways[u] += ways[v];
          ways[u] %= kMod;
        }
      }
    }

    return ways[src];
  }
};",1786
1785,"class Solution {
 public:
  int minChanges(vector<int>& nums, int k) {
    constexpr int kMax = 1024;
    const int n = nums.size();
    // counts[i] := the counter that maps at the i-th position
    vector<unordered_map<int, int>> counts(k);
    // dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k -
    // 1]) is j
    vector<vector<int>> dp(k, vector<int>(kMax, n));

    for (int i = 0; i < n; ++i)
      ++counts[i % k][nums[i]];

    auto countAt = [n, k](int i) -> int { return n / k + (n % k > i ? 1 : 0); };

    // Initialize the DP array.
    for (int j = 0; j < kMax; ++j)
      dp[k - 1][j] =
          countAt(k - 1) - (counts[k - 1].count(j) ? counts[k - 1][j] : 0);

    for (int i = k - 2; i >= 0; --i) {
      // The worst-case scenario is changing all the i-th position numbers to a
      // non-existent value in the current bucket.
      const int changeAll = countAt(i) + ranges::min(dp[i + 1]);
      for (int j = 0; j < kMax; ++j) {
        dp[i][j] = changeAll;
        for (const auto& [num, freq] : counts[i]) {
          // the cost to change every number in the i-th position to `num`
          const int cost = countAt(i) - freq;
          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost);
        }
      }
    }

    return dp[0][0];
  }
};",1787
1786,"class Solution {
 public:
  int maximumBeauty(vector<int>& flowers) {
    int ans = INT_MIN;
    int prefix = 0;
    unordered_map<int, int> flowerToPrefix;

    for (const int flower : flowers) {
      if (const auto it = flowerToPrefix.find(flower);
          it != flowerToPrefix.cend())
        ans = max(ans, prefix - it->second + flower * 2);
      prefix += max(0, flower);
      if (!flowerToPrefix.count(flower))
        flowerToPrefix[flower] = prefix;
    }

    return ans;
  }
};",1788
1787,"SELECT
  employee_id,
  department_id
FROM Employee
WHERE primary_flag = 'Y'
UNION DISTINCT
SELECT
  employee_id,
  department_id
FROM Employee
GROUP BY 1
HAVING COUNT(*) = 1;",1789
1788,"class Solution {
 public:
  // Similar to 859. Buddy Strings
  bool areAlmostEqual(string s1, string s2) {
    vector<int> diffIndices;
    for (int i = 0; i < s1.length(); ++i)
      if (s1[i] != s2[i])
        diffIndices.push_back(i);
    return diffIndices.empty() || (diffIndices.size() == 2 &&
                                   s1[diffIndices[0]] == s2[diffIndices[1]] &&
                                   s1[diffIndices[1]] == s2[diffIndices[0]]);
  }
};",1790
1789,"class Solution {
 public:
  int findCenter(vector<vector<int>>& edges) {
    return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]
               ? edges[0][0]
               : edges[0][1];
  }
};",1791
1790,"class Solution {
 public:
  double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
    // (extra pass ratio, pass, total)
    priority_queue<tuple<double, int, int>> maxHeap;

    for (const vector<int>& c : classes) {
      const int pass = c[0];
      const int total = c[1];
      maxHeap.emplace(extraPassRatio(pass, total), pass, total);
    }

    for (int i = 0; i < extraStudents; ++i) {
      const auto [_, pass, total] = maxHeap.top();
      maxHeap.pop();
      maxHeap.emplace(extraPassRatio(pass + 1, total + 1), pass + 1, total + 1);
    }

    double ratioSum = 0;

    while (!maxHeap.empty()) {
      const auto [_, pass, total] = maxHeap.top();
      maxHeap.pop();
      ratioSum += pass / static_cast<double>(total);
    }

    return ratioSum / classes.size();
  }

 private:
  // Returns the extra pass ratio if a brilliant student joins.
  double extraPassRatio(int pass, int total) {
    return (pass + 1) / static_cast<double>(total + 1) -
           pass / static_cast<double>(total);
  }
};",1792
1791,"class Solution {
 public:
  // Similar to 84. Largest Rectangle in Histogram
  int maximumScore(vector<int>& nums, int k) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= nums.size(); ++i) {
      while (!stack.empty() &&
             (i == nums.size() || nums[stack.top()] > nums[i])) {
        const int h = nums[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        if ((stack.empty() || stack.top() + 1 <= k) && i - 1 >= k)
          ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};",1793
1792,"class Solution {
 public:
  int countQuadruples(const string& s1, const string& s2) {
    // To minimize j - a, the length of the substring should be 1. This is
    // because for substrings with a size greater than 1, a will decrease,
    // causing j - a to become larger.
    int ans = 0;
    int diff = INT_MAX;  // diff := j - a
    vector<int> firstJ(26, -1);
    vector<int> lastA(26, -1);

    for (int j = s1.length() - 1; j >= 0; --j)
      firstJ[s1[j] - 'a'] = j;

    for (int a = 0; a < s2.length(); ++a)
      lastA[s2[a] - 'a'] = a;

    for (int i = 0; i < 26; ++i) {
      if (firstJ[i] == -1 || lastA[i] == -1)
        continue;
      if (firstJ[i] - lastA[i] < diff) {
        diff = firstJ[i] - lastA[i];
        ans = 0;
      }
      if (firstJ[i] - lastA[i] == diff)
        ++ans;
    }

    return ans;
  }
};",1794
1793,"SELECT
  product_id,
  'store1' AS store,
  store1 AS price
FROM Products
WHERE store1 IS NOT NULL
UNION ALL
SELECT
  product_id,
  'store2',
  store2
FROM Products
WHERE store2 IS NOT NULL
UNION ALL
SELECT
  product_id,
  'store3',
  store3
FROM Products
WHERE store3 IS NOT NULL;",1795
1794,"class Solution {
 public:
  int secondHighest(string s) {
    int maxDigit = -1;
    int secondMaxDigit = -1;

    for (const char c : s)
      if (isdigit(c)) {
        const int digit = c - '0';
        if (digit > maxDigit) {
          secondMaxDigit = maxDigit;
          maxDigit = digit;
        } else if (maxDigit > digit && digit > secondMaxDigit) {
          secondMaxDigit = digit;
        }
      }

    return secondMaxDigit;
  }
};",1796
1795,"generate(tokenId: str, currentTime: int)",1797
1796,"class Solution {
 public:
  int getMaximumConsecutive(vector<int>& coins) {
    int ans = 1;  // the next value we want to make

    ranges::sort(coins);

    for (const int coin : coins) {
      if (coin > ans)
        return ans;
      ans += coin;
    }

    return ans;
  }
};",1798
1797,"class Solution {
 public:
  int maxScore(vector<int>& nums) {
    const int n = nums.size() / 2;
    vector<vector<int>> mem(n + 1, vector<int>(1 << n * 2));
    return maxScore(nums, 1, 0, mem);
  }

 private:
  // Returns the maximum score you can receive after performing the k to n
  // operations, where `mask` is the bitmask of the chosen numbers.
  int maxScore(const vector<int>& nums, int k, int mask,
               vector<vector<int>>& mem) {
    if (k == mem.size())
      return 0;
    if (mem[k][mask] > 0)
      return mem[k][mask];

    for (int i = 0; i < nums.size(); ++i)
      for (int j = i + 1; j < nums.size(); ++j) {
        const int chosenMask = 1 << i | 1 << j;
        if ((mask & chosenMask) == 0)
          mem[k][mask] = max(mem[k][mask],
                             k * __gcd(nums[i], nums[j]) +
                                 maxScore(nums, k + 1, mask | chosenMask, mem));
      }

    return mem[k][mask];
  }
};",1799
1798,"class Solution {
 public:
  int maxAscendingSum(vector<int>& nums) {
    int ans = 0;
    int sum = nums[0];

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1]) {
        sum += nums[i];
      } else {
        ans = max(ans, sum);
        sum = nums[i];
      }

    return max(ans, sum);
  }
};",1800
1799,"class Solution {
 public:
  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    priority_queue<vector<int>> buysMaxHeap;
    priority_queue<vector<int>, vector<vector<int>>, greater<>> sellsMinHeap;

    for (const vector<int>& order : orders) {
      if (order[2] == 0)
        buysMaxHeap.push(order);
      else
        sellsMinHeap.push(order);
      while (!buysMaxHeap.empty() && !sellsMinHeap.empty() &&
             buysMaxHeap.top()[0] >= sellsMinHeap.top()[0]) {
        const int minAmount = min(buysMaxHeap.top()[1], sellsMinHeap.top()[1]);
        vector<int> buysMaxHeapTop = buysMaxHeap.top();
        buysMaxHeap.pop();
        buysMaxHeapTop[1] -= minAmount;
        if (buysMaxHeapTop[1] > 0)
          buysMaxHeap.push(buysMaxHeapTop);

        vector<int> sellsMinHeapTop = sellsMinHeap.top();
        sellsMinHeap.pop();
        sellsMinHeapTop[1] -= minAmount;
        if (sellsMinHeapTop[1] > 0)
          sellsMinHeap.push(sellsMinHeapTop);
      }
    }

    while (!buysMaxHeap.empty()) {
      ans += buysMaxHeap.top()[1], buysMaxHeap.pop();
      ans %= kMod;
    }

    while (!sellsMinHeap.empty()) {
      ans += sellsMinHeap.top()[1], sellsMinHeap.pop();
      ans %= kMod;
    }

    return ans;
  }
};",1801
1800,"class Solution {
 public:
  int maxValue(int n, int index, int maxSum) {
    maxSum -= n;

    int l = 0;
    int r = maxSum;

    // Find the first value x s.t. if A[index] = x, then sum(A) >= maxSum.
    while (l < r) {
      const int m = (l + r) / 2;
      if (getSum(n, index, m) >= maxSum)
        r = m;
      else
        l = m + 1;
    }

    return getSum(n, index, l) > maxSum ? l : l + 1;
  }

 private:
  // Returns the minimum sum if nums[index] = x.
  long getSum(int n, int index, int x) {
    long l = min(index, x - 1);
    long r = min(n - index, x);
    long lSum = ((x - 1) + (x - 1 - l + 1)) * l / 2;
    long rSum = (x + (x - r + 1)) * r / 2;
    return lSum + rSum;
  }
};",1802
1801,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(2) {}
};

class Solution {
 public:
  int countPairs(vector<int>& nums, int low, int high) {
    int ans = 0;

    for (const int num : nums) {
      ans += getCount(num, high + 1) - getCount(num, low);
      insert(num);
    }

    return ans;
  }

 private:
  static constexpr int kHeight = 14;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(int num) {
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      ++node->count;
    }
  }

  // Returns the number of numbers < limit.
  int getCount(int num, int limit) {
    int count = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = num >> i & 1;
      const int bitLimit = limit >> i & 1;
      if (bitLimit == 1) {
        if (node->children[bit] != nullptr)
          count += node->children[bit]->count;
        node = node->children[bit ^ 1];
      } else {
        node = node->children[bit];
      }
      if (node == nullptr)
        break;
    }
    return count;
  }
};",1803
1802,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int prefixCount = 0;
  int wordCount = 0;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  void insert(string word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      ++node->prefixCount;
    }
    ++node->wordCount;
  }

  int countWordsEqualTo(string word) {
    shared_ptr<TrieNode> node = find(word);
    return node ? node->wordCount : 0;
  }

  int countWordsStartingWith(string prefix) {
    shared_ptr<TrieNode> node = find(prefix);
    return node ? node->prefixCount : 0;
  }

  void erase(string word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      node = node->children[i];
      --node->prefixCount;
    }
    --node->wordCount;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  shared_ptr<TrieNode> find(const string& s) {
    shared_ptr<TrieNode> node = root;
    for (const char c : s) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return nullptr;
      node = node->children[i];
    }
    return node;
  }
};",1804
1803,"class Solution {
 public:
  int numDifferentIntegers(string word) {
    unordered_set<string> nums;
    string curr;

    for (const char c : word)
      if (isdigit(c)) {
        curr += c;
      } else if (curr.length() > 0) {
        nums.insert(removeLeadingZeros(curr));
        curr = """";
      }

    if (curr.length() > 0)
      nums.insert(removeLeadingZeros(curr));
    return nums.size();
  }

 private:
  string removeLeadingZeros(const string& s) {
    const int index = s.find_first_not_of('0');
    return index == string::npos ? ""0"" : s.substr(index);
  }
};",1805
1804,"class Solution {
 public:
  int reinitializePermutation(int n) {
    int ans = 0;
    int i = 1;

    do {
      if (i < n / 2)
        i = i * 2;
      else
        i = (i - n / 2) * 2 + 1;
      ++ans;
    } while (i != 1);

    return ans;
  }
};",1806
1805,"class Solution {
 public:
  string evaluate(string s, vector<vector<string>>& knowledge) {
    string ans;
    unordered_map<string, string> map;

    for (const vector<string>& list : knowledge)
      map[""("" + list[0] + "")""] = list[1];

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (c == '(') {
        const int j = s.find_first_of(')', i);
        const string& key = s.substr(i, j - i + 1);
        ans += map.count(key) ? map[key] : ""?"";
        i = j;
      } else {
        ans += c;
      }
    }

    return ans;
  }
};",1807
1806,"class Solution {
 public:
  int maxNiceDivisors(int primeFactors) {
    if (primeFactors <= 3)
      return primeFactors;
    if (primeFactors % 3 == 0)
      return modPow(3, primeFactors / 3) % kMod;
    if (primeFactors % 3 == 1)
      return 4L * modPow(3, (primeFactors - 4) / 3) % kMod;
    return 2L * modPow(3, (primeFactors - 2) / 3) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",1808
1807,"SELECT Playback.session_id
FROM Playback
LEFT JOIN Ads
  ON (
    Playback.customer_id = Ads.customer_id
    AND Ads.timestamp BETWEEN Playback.start_time AND Playback.end_time)
WHERE Ads.ad_id IS NULL;",1809
1808,"/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *  public:
 *   bool canMove(char direction);
 *   int move(char direction);
 *   boolean isTarget();
 * };
 */

class Solution {
 public:
  int findShortestPath(GridMaster& master) {
    constexpr int m = 100;
    constexpr int startX = m;
    constexpr int startY = m;

    vector<int> target{m * 2, m * 2};
    vector<vector<int>> grid(m * 2, vector<int>(m * 2, -1));
    vector<vector<bool>> seen(m * 2, vector<bool>(m * 2));

    // Build the grid information by DFS.
    dfs(master, grid, startX, startY, target);

    priority_queue<vector<int>, vector<vector<int>>, greater<>> minHeap;
    minHeap.push({0, startX, startY});

    // Find the steps by BFS.
    while (!minHeap.empty()) {
      const vector<int> tuple = minHeap.top();
      const int cost = tuple[0];
      const int i = tuple[1];
      const int j = tuple[2];
      minHeap.pop();
      if (i == target[0] && j == target[1])
        return cost;
      if (seen[i][j])
        continue;
      seen[i][j] = true;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == 2 * m || y < 0 || y == 2 * m)
          continue;
        if (seen[x][y] || grid[x][y] == -1)
          continue;
        const int nextCost = cost + grid[x][y];
        minHeap.push({nextCost, x, y});
      }
    }

    return -1;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
  static constexpr char charTable[4] = {'R', 'D', 'L', 'U'};

  void dfs(GridMaster& master, vector<vector<int>>& grid, int i, int j,
           vector<int>& target) {
    if (master.isTarget()) {
      target[0] = i;
      target[1] = j;
    }

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k][0];
      const int y = j + dirs[k][1];
      const char d = charTable[k];
      const char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d) && grid[x][y] == -1) {
        grid[x][y] = master.move(d);
        dfs(master, grid, x, y, target);
        master.move(undoD);
      }
    }
  }
};",1810
1809,"WITH
  UserToContest AS (
    SELECT gold_medal AS user_id, contest_id FROM Contests
    UNION ALL
    SELECT silver_medal AS user_id, contest_id FROM Contests
    UNION ALL
    SELECT bronze_medal AS user_id, contest_id FROM Contests
  ),
  UserToContestWithGroupId AS (
    SELECT
      user_id,
      contest_id - ROW_NUMBER() OVER(
        PARTITION BY user_id
        ORDER BY contest_id
      ) AS group_id
    FROM UserToContest
  ),
  CandidateUserIds AS (
    -- consecutive medal winners
    SELECT user_id
    FROM UserToContestWithGroupId
    GROUP BY user_id, group_id
    HAVING COUNT(*) >= 3
    UNION DISTINCT
    -- gold medal winners
    SELECT gold_medal AS user_id
    FROM Contests
    GROUP BY user_id
    HAVING COUNT(*) >= 3
  )
SELECT
  Users.name,
  Users.mail
FROM CandidateUserIds
INNER JOIN Users
  USING (user_id);",1811
1810,"class Solution {
 public:
  bool squareIsWhite(string coordinates) {
    const char letter = coordinates[0];
    const char digit = coordinates[1];
    return letter % 2 != digit % 2;
  }
};",1812
1811,"class Solution {
 public:
  bool areSentencesSimilar(string sentence1, string sentence2) {
    if (sentence1.length() == sentence2.length())
      return sentence1 == sentence2;

    vector<string> words1 = split(sentence1);
    vector<string> words2 = split(sentence2);
    const int m = words1.size();
    const int n = words2.size();
    if (m > n)
      return areSentencesSimilar(sentence2, sentence1);

    int i = 0;  // words1's index
    while (i < m && words1[i] == words2[i])
      ++i;
    while (i < m && words1[i] == words2[i + n - m])
      ++i;

    return i == m;
  }

 private:
  vector<string> split(const string& sentence) {
    vector<string> words;
    istringstream iss(sentence);

    for (string s; iss >> s;)
      words.push_back(s);

    return words;
  }
};",1813
1812,"class Solution {
 public:
  int countNicePairs(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    unordered_map<int, long> count;

    for (const int num : nums)
      ++count[num - rev(num)];

    for (const auto& [_, freq] : count) {
      ans += freq * (freq - 1) / 2;
      ans %= kMod;
    }

    return ans;
  }

 private:
  int rev(int n) {
    int x = 0;
    while (n) {
      x = x * 10 + (n % 10);
      n /= 10;
    }
    return x;
  }
};",1814
1813,"class Solution {
 public:
  int maxHappyGroups(int batchSize, vector<int>& groups) {
    int happy = 0;
    vector<int> freq(batchSize);

    for (int g : groups) {
      g %= batchSize;
      if (g == 0) {
        ++happy;
      } else if (freq[batchSize - g]) {
        --freq[batchSize - g];
        ++happy;
      } else {
        ++freq[g];
      }
    }

    return happy + dp(freq, 0, batchSize);
  }

 private:
  map<vector<int>, int> mem;

  // Returns the maximum number of partitions can be formed.
  int dp(const vector<int>& freq, int remainder, const int& batchSize) {
    if (const auto it = mem.find(freq); it != mem.cend())
      return it->second;

    int ans = 0;

    if (ranges::any_of(freq, [](int f) { return f != 0; })) {
      for (int i = 0; i < freq.size(); ++i)
        if (freq[i]) {
          vector<int> newFreq(freq);
          --newFreq[i];
          ans = max(ans, dp(newFreq, (remainder + i) % batchSize, batchSize));
        }
      if (remainder == 0)
        ++ans;
    }

    return mem[freq] = ans;
  }
};",1815
1814,"class Solution {
 public:
  string truncateSentence(string s, int k) {
    for (int i = 0; i < s.length(); ++i)
      if (s[i] == ' ' && --k == 0)
        return s.substr(0, i);
    return s;
  }
};",1816
1815,"class Solution {
 public:
  vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {
    vector<int> ans(k);
    unordered_map<int, unordered_set<int>> idToTimes;

    for (const vector<int>& log : logs)
      idToTimes[log[0]].insert(log[1]);

    for (const auto& [_, mins] : idToTimes)
      ++ans[mins.size() - 1];

    return ans;
  }
};",1817
1816,"class Solution {
 public:
  int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;
    long sumDiff = 0;
    long maxDecrement = 0;
    set<int> sorted(nums1.begin(), nums1.end());

    for (int i = 0; i < nums1.size(); ++i) {
      const long currDiff = abs(nums1[i] - nums2[i]);
      sumDiff += currDiff;
      const auto it = sorted.lower_bound(nums2[i]);
      if (it != sorted.begin())
        maxDecrement = max(maxDecrement, currDiff - abs(*prev(it) - nums2[i]));
      if (it != sorted.end())
        maxDecrement = max(maxDecrement, currDiff - abs(*it - nums2[i]));
    }

    return (sumDiff - maxDecrement) % kMod;
  }
};",1818
1817,"class Solution {
 public:
  int countDifferentSubsequenceGCDs(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    int ans = 0;
    // factor[i] := the GCD of numbers having factor i
    vector<int> factor(maxNum + 1);

    for (const int num : nums)
      for (int i = 1; i * i <= num; ++i)
        if (num % i == 0) {
          const int j = num / i;
          factor[i] = __gcd(factor[i], num);
          factor[j] = __gcd(factor[j], num);
        }

    for (int i = 1; i <= maxNum; ++i)
      if (factor[i] == i)
        ++ans;

    return ans;
  }
};",1819
1818,"class Solution {
 public:
  int maximumInvitations(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<int> mates(n, -1);  // mates[i] := the i-th girl's mate

    for (int i = 0; i < m; ++i)
      if (canInvite(grid, i, vector<bool>(n), mates))
        ++ans;

    return ans;
  }

 private:
  // Returns true if the i-th boy can make an invitation.
  bool canInvite(const vector<vector<int>>& grid, int i, vector<bool>&& seen,
                 vector<int>& mates) {
    // The i-th boy asks each girl.
    for (int j = 0; j < seen.size(); ++j) {
      if (!grid[i][j] || seen[j])
        continue;
      seen[j] = true;
      if (mates[j] == -1 || canInvite(grid, mates[j], move(seen), mates)) {
        mates[j] = i;  // Match the j-th girl with i-th boy.
        return true;
      }
    }

    return false;
  }
};",1820
1819,"SELECT DISTINCT customer_id
FROM Customers
WHERE year = 2021 AND revenue > 0;",1821
1820,"class Solution {
 public:
  int arraySign(vector<int>& nums) {
    int sign = 1;

    for (const int num : nums) {
      if (num == 0)
        return 0;
      if (num < 0)
        sign = -sign;
    }

    return sign;
  }
};",1822
1821,"class Solution {
 public:
  int findTheWinner(int n, int k) {
    // friends[i] := true if i-th friend is left
    vector<bool> friends(n);

    int friendCount = n;
    int fp = 0;  // friends' index

    while (friendCount > 1) {
      for (int i = 0; i < k; ++i, ++fp)
        while (friends[fp % n])  // The friend is not there.
          ++fp;                  // Point to the next one.
      friends[(fp - 1) % n] = true;
      --friendCount;
    }

    const auto it =
        find_if(friends.begin(), friends.end(), [](int f) { return !f; });
    return distance(friends.begin(), it) + 1;
  }
};",1823
1822,"class Solution {
 public:
  int minSideJumps(vector<int>& obstacles) {
    constexpr int kInf = 1e6;
    // dp[i] := the minimum jump to reach the i-th lane
    vector<int> dp{kInf, 1, 0, 1};

    for (const int obstacle : obstacles) {
      if (obstacle > 0)
        dp[obstacle] = kInf;
      for (int i = 1; i <= 3; ++i)  // the current
        if (i != obstacle)
          for (int j = 1; j <= 3; ++j)  // the previous
            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});
    }

    return ranges::min(dp);
  }
};",1824
1823,while,1825
1824,"class Solution {
 public:
  int badSensor(vector<int>& sensor1, vector<int>& sensor2) {
    const bool oneDefect = canReplace(sensor2, sensor1);
    const bool twoDefect = canReplace(sensor1, sensor2);
    if (oneDefect && twoDefect)
      return -1;
    if (!oneDefect && !twoDefect)
      return -1;
    return oneDefect ? 1 : 2;
  }

 private:
  bool canReplace(const vector<int>& A, const vector<int>& B) {
    int i = 0;  // A's index
    int j = 0;  // B's index
    int droppedValue = -1;

    while (i < A.size())
      if (A[i] == B[j]) {
        ++i;
        ++j;
      } else {
        droppedValue = A[i];
        ++i;
      }

    return j == B.size() - 1 && B[j] != droppedValue;
  }
};",1826
1825,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
    int ans = 0;
    int last = 0;

    for (const int num : nums) {
      ans += max(0, last - num + 1);
      last = max(num, last + 1);
    }

    return ans;
  }
};",1827
1826,"class Solution {
 public:
  vector<int> countPoints(vector<vector<int>>& points,
                          vector<vector<int>>& queries) {
    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int xj = query[0];
      const int yj = query[1];
      const int rj = query[2];
      int count = 0;
      for (const vector<int>& point : points) {
        const int xi = point[0];
        const int yi = point[1];
        if (squared(xi - xj) + squared(yi - yj) <= squared(rj))
          ++count;
      }
      ans.push_back(count);
    }

    return ans;
  }

 private:
  int squared(int x) {
    return x * x;
  }
};",1828
1827,"class Solution {
 public:
  vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
    const int max = (1 << maximumBit) - 1;
    vector<int> ans;
    int xors = 0;

    for (const int num : nums) {
      xors ^= num;
      ans.push_back(xors ^ max);
    }

    reverse(ans.begin(), ans.end());
    return ans;
  }
};",1829
1828,"class Solution {
 public:
  int makeStringSorted(string s) {
    const int n = s.length();
    const auto [fact, invFact] = getFactAndInvFact(n);
    int ans = 0;
    vector<int> count(26);

    for (int i = n - 1; i >= 0; --i) {
      const int order = s[i] - 'a';
      ++count[order];
      long perm = accumulate(count.begin(), count.begin() + order, 0) *
                  fact[n - 1 - i] % kMod;
      for (int j = 0; j < 26; ++j)
        perm = perm * invFact[count[j]] % kMod;
      ans = (ans + perm) % kMod;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {
    vector<long> fact(n + 1);
    vector<long> invFact(n + 1);
    vector<long> inv(n + 1);
    fact[0] = invFact[0] = 1;
    inv[0] = inv[1] = 1;
    for (int i = 1; i <= n; ++i) {
      if (i >= 2)
        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;
      fact[i] = fact[i - 1] * i % kMod;
      invFact[i] = invFact[i - 1] * inv[i] % kMod;
    }
    return {fact, invFact};
  }
};",1830
1829,"WITH
  RankedTransactions AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY DATE(day)
        ORDER BY amount DESC
      ) AS `rank`
    FROM Transactions
  )
SELECT transaction_id
FROM RankedTransactions
WHERE `rank` = 1
ORDER BY 1;",1831
1830,"class Solution {
 public:
  bool checkIfPangram(string sentence) {
    return unordered_set(sentence.begin(), sentence.end()).size() == 26;
  }
};",1832
1831,"class Solution {
 public:
  int maxIceCream(vector<int>& costs, int coins) {
    ranges::sort(costs);

    for (int i = 0; i < costs.size(); ++i)
      if (coins >= costs[i])
        coins -= costs[i];
      else
        return i;

    return costs.size();
  }
};",1833
1832,"class Solution {
 public:
  vector<int> getOrder(vector<vector<int>>& tasks) {
    const int n = tasks.size();

    // Add index information.
    for (int i = 0; i < tasks.size(); ++i)
      tasks[i].push_back(i);

    vector<int> ans;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;
    int i = 0;      // tasks' index
    long time = 0;  // the current time

    ranges::sort(tasks);
    while (i < n || !minHeap.empty()) {
      if (minHeap.empty())
        time = max(time, static_cast<long>(tasks[i][0]));
      while (i < n && time >= tasks[i][0]) {
        minHeap.emplace(tasks[i][1], tasks[i][2]);
        ++i;
      }
      const auto [procTime, index] = minHeap.top();
      minHeap.pop();
      time += procTime;
      ans.push_back(index);
    }

    return ans;
  }
};",1834
1833,"class Solution {
 public:
  int getXORSum(vector<int>& arr1, vector<int>& arr2) {
    const int xors1 = accumulate(arr1.begin(), arr1.end(), 0, bit_xor<>());
    const int xors2 = accumulate(arr2.begin(), arr2.end(), 0, bit_xor<>());
    return xors1 & xors2;
  }
};",1835
1834,"class Solution {
 public:
  ListNode* deleteDuplicatesUnsorted(ListNode* head) {
    ListNode dummy(0, head);
    unordered_map<int, int> count;

    for (ListNode* curr = head; curr; curr = curr->next)
      ++count[curr->val];

    ListNode* curr = &dummy;

    while (curr) {
      while (curr->next && count.count(curr->next->val) &&
             count[curr->next->val] > 1)
        curr->next = curr->next->next;
      curr = curr->next;
    }

    return dummy.next;
  }
};",1836
1835,"class Solution {
 public:
  int sumBase(int n, int k) {
    int ans = 0;

    while (n) {
      ans += n % k;
      n /= k;
    }

    return ans;
  }
};",1837
1836,"class Solution {
 public:
  int maxFrequency(vector<int>& nums, int k) {
    int ans = 0;
    long sum = 0;

    ranges::sort(nums);

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum + k < static_cast<long>(nums[r]) * (r - l + 1))
        sum -= nums[l++];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",1838
1837,"class Solution {
 public:
  int longestBeautifulSubstring(string word) {
    int ans = 0;
    int count = 1;

    for (int l = 0, r = 1; r < word.length(); ++r) {
      const char curr = word[r];
      const char prev = word[r - 1];
      if (curr >= prev) {
        if (curr > prev)
          ++count;
        if (count == 5)
          ans = max(ans, r - l + 1);
      } else {
        count = 1;
        l = r;
      }
    }

    return ans;
  }
};",1839
1838,"class Solution {
 public:
  int maxBuilding(int n, vector<vector<int>>& restrictions) {
    vector<vector<int>> A(restrictions);

    A.push_back({1, 0});
    A.push_back({n, n - 1});
    ranges::sort(A);

    for (int i = 1; i < A.size(); ++i) {
      const int dist = A[i][0] - A[i - 1][0];
      A[i][1] = min(A[i][1], A[i - 1][1] + dist);
    }

    for (int i = A.size() - 2; i >= 0; --i) {
      const int dist = A[i + 1][0] - A[i][0];
      A[i][1] = min(A[i][1], A[i + 1][1] + dist);
    }

    int ans = 0;

    for (int i = 1; i < A.size(); ++i) {
      const int l = A[i - 1][0];
      const int r = A[i][0];
      const int hL = A[i - 1][1];
      const int hR = A[i][1];
      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) / 2);
    }

    return ans;
  }
};",1840
1839,"SELECT
  Teams.team_name,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id
      OR Matches.away_team_id = Teams.team_id THEN 1
      ELSE 0
    END
  ) AS matches_played,
  SUM(
    CASE
      WHEN Teams.team_id = Matches.home_team_id
      AND Matches.home_team_goals > Matches.away_team_goals THEN 3
      WHEN Teams.team_id = Matches.away_team_id
      AND Matches.home_team_goals < Matches.away_team_goals THEN 3
      WHEN Matches.home_team_goals = Matches.away_team_goals THEN 1
      ELSE 0
    END
  ) AS points,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id THEN Matches.home_team_goals
      ELSE Matches.away_team_goals
    END
  ) AS goal_for,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id THEN Matches.away_team_goals
      ELSE Matches.home_team_goals
    END
  ) AS goal_against,
  SUM(
    CASE
      WHEN Matches.home_team_id = Teams.team_id THEN Matches.home_team_goals - Matches.away_team_goals
      ELSE Matches.away_team_goals - Matches.home_team_goals
    END
  ) AS goal_diff
FROM Matches
INNER JOIN Teams
  ON (
    Matches.home_team_id = Teams.team_id
    OR Matches.away_team_id = Teams.team_id
  )
GROUP BY 1
ORDER BY points DESC, goal_diff DESC, team_name;",1841
1840,"class Solution {
 public:
  string nextPalindrome(string num) {
    const int n = num.length();
    vector<int> A(n / 2);

    for (int i = 0; i < A.size(); ++i)
      A[i] = num[i] - '0';

    if (!nextPermutation(A))
      return """";

    string s;

    for (const int a : A)
      s += '0' + a;

    if (n % 2 == 1)
      return s + num[n / 2] + string(s.rbegin(), s.rend());
    return s + string(s.rbegin(), s.rend());
  }

 private:
  // Returns true if `nums` has the next permutation.
  bool nextPermutation(vector<int>& nums) {
    const int n = nums.size();

    // From the back to the front, find the first num < nums[i + 1].
    int i;
    for (i = n - 2; i >= 0; --i)
      if (nums[i] < nums[i + 1])
        break;

    if (i < 0)
      return false;

    // From the back to the front, find the first num > nums[i] and swap it with
    // nums[i].
    for (int j = n - 1; j > i; --j)
      if (nums[j] > nums[i]) {
        swap(nums[i], nums[j]);
        break;
      }

    // Reverse nums[i + 1..n - 1].
    reverse(nums, i + 1, n - 1);
    return true;
  }

  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};",1842
1841,"WITH
  SuspiciousAccountToMonth AS (
    SELECT
      Transactions.account_id,
      DATE_FORMAT(Transactions.day, '%Y%m') AS month,
      Accounts.max_income
    FROM Transactions
    INNER JOIN Accounts
      USING (account_id)
    WHERE Transactions.type = 'Creditor'
    GROUP BY 1, 2
    HAVING SUM(Transactions.amount) > Accounts.max_income
  )
SELECT DISTINCT CurrMonth.account_id
FROM SuspiciousAccountToMonth AS CurrMonth
INNER JOIN SuspiciousAccountToMonth AS NextMonth
  USING (account_id)
WHERE PERIOD_DIFF(NextMonth.month, CurrMonth.month) = 1;",1843
1842,"class Solution {
 public:
  string replaceDigits(string s) {
    for (int i = 0; i < s.length(); ++i)
      s[i] += s[i - 1] - '0';
    return s;
  }
};",1844
1843,reserver(),1845
1844,"class Solution {
 public:
  int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {
    ranges::sort(arr);
    arr[0] = 1;

    for (int i = 1; i < arr.size(); ++i)
      arr[i] = min(arr[i], arr[i - 1] + 1);

    return arr.back();
  }
};",1846
1845,"class Solution {
 public:
  vector<int> closestRoom(vector<vector<int>>& rooms,
                          vector<vector<int>>& queries) {
    vector<int> ans(queries.size());
    set<int> roomIds;

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    auto descSize = [](const auto& a, const auto& b) { return a[1] > b[1]; };
    ranges::sort(rooms, descSize);
    ranges::sort(queries, descSize);

    int i = 0;  // rooms' index
    for (const vector<int>& query : queries) {
      while (i < rooms.size() && rooms[i][1] >= query[1])
        roomIds.insert(rooms[i++][0]);
      ans[query[2]] = searchClosestRoomId(roomIds, query[0]);
    }

    return ans;
  }

 private:
  int searchClosestRoomId(set<int>& roomIds, int preferred) {
    const auto it = roomIds.lower_bound(preferred);
    const int id1 = it == roomIds.cbegin() ? -1 : *(prev(it));
    const int id2 = it == roomIds.cend() ? -1 : *it;
    if (id1 == -1)
      return id2;
    if (id2 == -1)
      return id1;
    if (abs(preferred - id1) <= abs(preferred - id2))
      return id1;
    return id2;
  }
};",1847
1846,"class Solution {
 public:
  int getMinDistance(vector<int>& nums, int target, int start) {
    int ans = INT_MAX;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == target)
        ans = min(ans, abs(i - start));

    return ans;
  }
};",1848
1847,"class Solution {
 public:
  bool splitString(string s) {
    return isValid(s, 0, -1, 0);
  }

 private:
  bool isValid(const string& s, int start, long prev, int segment) {
    if (start == s.length() && segment > 1)
      return true;

    long curr = 0;
    for (int i = start; i < s.length(); ++i) {
      curr = curr * 10 + s[i] - '0';
      if (curr > 9999999999L)
        return false;
      if ((prev == -1 || curr == prev - 1) &&
          isValid(s, i + 1, curr, segment + 1)) {
        return true;
      }
    }

    return false;
  }
};",1849
1848,"class Solution {
 public:
  int getMinSwaps(string num, int k) {
    string perm = num;

    while (k--)
      next_permutation(perm.begin(), perm.end());

    return countSteps(num, perm);
  }

 private:
  int countSteps(const string& A, string& B) {
    int count = 0;

    for (int i = 0, j = 0; i < A.length(); ++i) {
      j = i;
      while (A[i] != B[j])
        ++j;
      while (i < j) {
        swap(B[j], B[j - 1]);
        --j;
        ++count;
      }
    }

    return count;
  }
};",1850
1849,"struct T {
  int size;
  int right;
  T(int size, int right) : size(size), right(right) {}
};

class Solution {
 public:
  vector<int> minInterval(vector<vector<int>>& intervals,
                          vector<int>& queries) {
    vector<int> ans(queries.size(), -1);
    auto compare = [](const T& a, const T& b) { return a.size > b.size; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<int>> qs;

    for (int i = 0; i < queries.size(); ++i)
      qs.push_back({queries[i], i});

    ranges::sort(intervals);
    ranges::sort(qs);

    int i = 0;  // intervals' index
    for (const vector<int>& q : qs) {
      while (i < intervals.size() && intervals[i][0] <= q[0]) {
        minHeap.emplace(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]);
        ++i;
      }
      while (!minHeap.empty() && minHeap.top().right < q[0])
        minHeap.pop();
      if (!minHeap.empty())
        ans[q[1]] = minHeap.top().size;
    }

    return ans;
  }
};",1851
1850,"class Solution {
 public:
  vector<int> distinctNumbers(vector<int>& nums, int k) {
    vector<int> ans;
    int distinct = 0;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i) {
      if (++count[nums[i]] == 1)
        ++distinct;
      if (i >= k && --count[nums[i - k]] == 0)
        --distinct;
      if (i >= k - 1)
        ans.push_back(distinct);
    }

    return ans;
  }
};",1852
1851,"SELECT DATE_FORMAT(day, '%W, %M %e, %Y') AS day
FROM Days",1853
1852,"class Solution {
 public:
  int maximumPopulation(vector<vector<int>>& logs) {
    constexpr int kMinYear = 1950;
    constexpr int kMaxYear = 2050;
    int ans = 0;
    int maxPopulation = 0;
    int runningPopulation = 0;
    // population[i] := the population of year i
    vector<int> population(kMaxYear + 1);

    for (const vector<int>& log : logs) {
      const int birth = log[0];
      const int death = log[1];
      ++population[birth];
      --population[death];
    }

    for (int year = kMinYear; year <= kMaxYear; ++year) {
      runningPopulation += population[year];
      if (runningPopulation > maxPopulation) {
        maxPopulation = runningPopulation;
        ans = year;
      }
    }

    return ans;
  }
};",1854
1853,"class Solution {
 public:
  int maxDistance(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;
    int i = 0;
    int j = 0;

    while (i < nums1.size() && j < nums2.size())
      if (nums1[i] > nums2[j])
        ++i;
      else
        ans = max(ans, j++ - i);

    return ans;
  }
};",1855
1854,"class Solution {
 public:
  int maxSumMinProduct(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    stack<int> stack;
    vector<long> prefix(nums.size() + 1);

    for (int i = 0; i < nums.size(); ++i)
      prefix[i + 1] = prefix[i] + nums[i];

    for (int i = 0; i <= nums.size(); ++i) {
      while (!stack.empty() &&
             (i == nums.size() || nums[stack.top()] > nums[i])) {
        const int minVal = nums[stack.top()];
        stack.pop();
        const long sum =
            stack.empty() ? prefix[i] : prefix[i] - prefix[stack.top() + 1];
        ans = max(ans, minVal * sum);
      }
      stack.push(i);
    }

    return ans % kMod;
  }
};",1856
1855,"class Solution {
 public:
  int largestPathValue(string colors, vector<vector<int>>& edges) {
    const int n = colors.length();
    int ans = 0;
    int processed = 0;
    vector<vector<int>> graph(n);
    vector<int> inDegrees(n);
    queue<int> q;
    vector<vector<int>> count(n, vector<int>(26));

    // Build the graph.
    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      ++inDegrees[v];
    }

    // Perform topological sorting.
    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        q.push(i);

    while (!q.empty()) {
      const int out = q.front();
      q.pop();
      ++processed;
      ans = max(ans, ++count[out][colors[out] - 'a']);
      for (const int in : graph[out]) {
        for (int i = 0; i < 26; ++i)
          count[in][i] = max(count[in][i], count[out][i]);
        if (--inDegrees[in] == 0)
          q.push(in);
      }
    }

    return processed == n ? ans : -1;
  }
};",1857
1856,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string longestWord(vector<string>& words) {
    string ans;

    for (const string& word : words)
      insert(word);

    for (const string& word : words) {
      if (!allPrefixed(word))
        continue;
      if (ans.length() < word.length() ||
          (ans.length() == word.length() && ans > word))
        ans = word;
    }

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool allPrefixed(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      node = node->children[i];
      if (!node->isWord)
        return false;
    }
    return true;
  }
};",1858
1857,"class Solution {
 public:
  string sortSentence(string s) {
    vector<string> words;
    istringstream iss(s);
    string word;

    while (iss >> word)
      words.push_back(word);

    ranges::sort(words, [](const string& a, const string& b) {
      return a.back() < b.back();
    });

    string ans = trim(words[0]);

    for (int i = 1; i < words.size(); ++i)
      ans += "" "" + trim(words[i]);

    return ans;
  }

 private:
  string trim(const string& s) {
    return s.substr(0, s.length() - 1);
  }
};",1859
1858,x = memory1,1860
1859,"class Solution {
 public:
  vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
    const int m = box.size();
    const int n = box[0].size();
    vector<vector<char>> ans(n, vector<char>(m, '.'));

    for (int i = 0; i < m; ++i)
      for (int j = n - 1, k = n - 1; j >= 0; --j)
        if (box[i][j] != '.') {
          if (box[i][j] == '*')
            k = j;
          ans[k--][m - i - 1] = box[i][j];
        }

    return ans;
  }
};",1861
1860,"class Solution {
 public:
  int sumOfFlooredPairs(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int kMax = ranges::max(nums);
    long ans = 0;
    // count[i] := the number of `nums` <= i
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = 1; i <= kMax; ++i)
      count[i] += count[i - 1];

    for (int i = 1; i <= kMax; ++i)
      if (count[i] > count[i - 1]) {
        long sum = 0;
        for (int j = 1; i * j <= kMax; ++j) {
          const int lo = i * j - 1;
          const int hi = i * (j + 1) - 1;
          sum += (count[min(hi, kMax)] - count[lo]) * j;
        }
        ans += sum * (count[i] - count[i - 1]);
        ans %= kMod;
      }

    return ans;
  }
};",1862
1861,"class Solution {
 public:
  int subsetXORSum(vector<int>& nums) {
    return dfs(nums, 0, 0);
  }

 private:
  int dfs(const vector<int>& nums, int i, int xors) {
    if (i == nums.size())
      return xors;

    const int x = dfs(nums, i + 1, xors);
    const int y = dfs(nums, i + 1, nums[i] ^ xors);
    return x + y;
  }
};",1863
1862,"class Solution {
 public:
  int minSwaps(string s) {
    const int ones = ranges::count(s, '1');
    const int zeros = s.length() - ones;
    if (abs(ones - zeros) > 1)
      return -1;
    if (ones > zeros)
      return countSwaps(s, '1');
    if (zeros > ones)
      return countSwaps(s, '0');
    return min(countSwaps(s, '1'), countSwaps(s, '0'));
  }

 private:
  int countSwaps(const string& s, char curr) {
    int swaps = 0;
    for (const char c : s) {
      if (c != curr)
        ++swaps;
      curr ^= 1;
    }
    return swaps / 2;
  }
};",1864
1863,"add(index: int, val: int)",1865
1864,"class Solution {
 public:
  long rearrangeSticks(int n, int k) {
    if (n == k)
      return 1;
    if (k == 0)
      return 0;
    if (dp[n][k])
      return dp[n][k];
    return dp[n][k] = (rearrangeSticks(n - 1, k - 1) +
                       rearrangeSticks(n - 1, k) * (n - 1)) %
                      kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> dp = vector<vector<int>>(1001, vector<int>(1001));
};",1866
1865,"WITH
  GroupedOrders AS (
    SELECT
      order_id,
      MAX(quantity) AS max_quantity,
      MAX(AVG(quantity)) OVER() AS max_avg_quantity
    FROM OrdersDetails
    GROUP BY 1
  )
SELECT order_id
FROM GroupedOrders
WHERE max_quantity > max_avg_quantity;",1867
1866,"class Solution {
 public:
  vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1,
                                   vector<vector<int>>& encoded2) {
    vector<vector<int>> ans;
    int i = 0;  // encoded1's index
    int j = 0;  // encodes2's index

    while (i < encoded1.size() && j < encoded2.size()) {
      const int mult = encoded1[i][0] * encoded2[j][0];
      const int minFreq = min(encoded1[i][1], encoded2[j][1]);
      if (!ans.empty() && mult == ans.back()[0])
        ans.back()[1] += minFreq;
      else
        ans.push_back({mult, minFreq});
      encoded1[i][1] -= minFreq;
      encoded2[j][1] -= minFreq;
      if (encoded1[i][1] == 0)
        ++i;
      if (encoded2[j][1] == 0)
        ++j;
    }

    return ans;
  }
};",1868
1867,"class Solution {
 public:
  bool checkZeroOnes(string s) {
    int longestOnes = 0;
    int longestZeros = 0;
    int currentOnes = 0;
    int currentZeros = 0;

    for (const char c : s)
      if (c == '0') {
        currentOnes = 0;
        longestZeros = max(longestZeros, ++currentZeros);
      } else {
        currentZeros = 0;
        longestOnes = max(longestOnes, ++currentOnes);
      }

    return longestOnes > longestZeros;
  }
};",1869
1868,r = 10^7,1870
1869,"class Solution {
 public:
  bool canReach(string s, int minJump, int maxJump) {
    int count = 0;
    vector<bool> dp(s.length());
    dp[0] = true;

    for (int i = minJump; i < s.length(); ++i) {
      count += dp[i - minJump];
      if (i - maxJump > 0)
        count -= dp[i - maxJump - 1];
      dp[i] = count && s[i] == '0';
    }

    return dp.back();
  }
};",1871
1870,"class Solution {
 public:
  int stoneGameVIII(vector<int>& stones) {
    const int n = stones.size();
    vector<int> prefix(n);
    // dp[i] := the maximum score difference the current player can get when the
    // game starts at i, i.e. stones[0..i] are merged into the value prefix[i]
    vector<int> dp(n, INT_MIN);

    partial_sum(stones.begin(), stones.end(), prefix.begin());

    // Must take all when there're only two stones left.
    dp[n - 2] = prefix.back();

    for (int i = n - 3; i >= 0; --i)
      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1]);

    return dp[0];
  }
};",1872
1871,"SELECT
  employee_id,
  IF(employee_id % 2 = 1 AND LEFT(name, 1) != 'M', salary, 0) AS bonus
FROM Employees
ORDER BY 1;",1873
1872,"class Solution {
 public:
  int minProductSum(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;

    ranges::sort(nums1);
    ranges::sort(nums2, greater<>());

    for (int i = 0; i < nums1.size(); ++i)
      ans += nums1[i] * nums2[i];

    return ans;
  }
};",1874
1873,"WITH
  EmployeesWithCountPerSalary AS (
    SELECT
      *,
      COUNT(employee_id) OVER(PARTITION BY salary) AS count_per_salary
    FROM Employees
  )
SELECT
  employee_id,
  name,
  salary,
  DENSE_RANK() OVER(ORDER BY salary) AS team_id
FROM EmployeesWithCountPerSalary
WHERE count_per_salary > 1
ORDER BY team_id, employee_id;",1875
1874,"class Solution {
 public:
  int countGoodSubstrings(string s) {
    int ans = 0;

    for (int i = 0; i + 2 < s.length(); ++i) {
      const char a = s[i];
      const char b = s[i + 1];
      const char c = s[i + 2];
      if (a == b || a == c || b == c)
        continue;
      ++ans;
    }

    return ans;
  }
};",1876
1875,"class Solution {
 public:
  int minPairSum(vector<int>& nums) {
    int ans = 0;

    ranges::sort(nums);

    for (int i = 0, j = nums.size() - 1; i < j;)
      ans = max(ans, nums[i++] + nums[j--]);

    return ans;
  }
};",1877
1876,"class Solution {
 public:
  vector<int> getBiggestThree(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    set<int> sums;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        for (int sz = 0; i + sz < m && i - sz >= 0 && j + 2 * sz < n; ++sz) {
          const int sum = sz == 0 ? grid[i][j] : getSum(grid, i, j, sz);
          sums.insert(sum);
          if (sums.size() > 3)
            sums.erase(sums.begin());
        }

    return vector<int>(sums.rbegin(), sums.rend());
  }

 private:
  // Returns the sum of the rhombus, where the top grid is (i, j) and the edge
  // size is `sz`.
  int getSum(const vector<vector<int>>& grid, int i, int j, int sz) {
    int x = i;
    int y = j;
    int sum = 0;

    // Go left down.
    for (int k = 0; k < sz; ++k)
      sum += grid[--x][++y];

    // Go right down.
    for (int k = 0; k < sz; ++k)
      sum += grid[++x][++y];

    // Go right up.
    for (int k = 0; k < sz; ++k)
      sum += grid[++x][--y];

    // Go left up.
    for (int k = 0; k < sz; ++k)
      sum += grid[--x][--y];

    return sum;
  }
};",1878
1877,"class Solution {
 public:
  int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
    return dfs(nums1, nums2, vector<int>(1 << nums2.size(), INT_MAX), 0, 0);
  }

 private:
  int dfs(const vector<int>& nums1, const vector<int>& nums2, vector<int>&& dp,
          int i, int mask) {
    if (i == nums1.size())
      return 0;
    if (dp[mask] < INT_MAX)
      return dp[mask];

    for (int j = 0; j < nums2.size(); ++j)
      if ((mask >> j & 1) == 0)
        dp[mask] = min(dp[mask],  //
                       (nums1[i] ^ nums2[j]) +
                           dfs(nums1, nums2, move(dp), i + 1, mask | 1 << j));

    return dp[mask];
  }
};",1879
1878,"class Solution {
 public:
  bool isSumEqual(string firstWord, string secondWord, string targetWord) {
    const int first = getNumber(firstWord);
    const int second = getNumber(secondWord);
    const int target = getNumber(targetWord);
    return first + second == target;
  }

 private:
  int getNumber(const string& word) {
    int num = 0;
    for (const char c : word)
      num = num * 10 + (c - 'a');
    return num;
  }
};",1880
1879,"class Solution {
 public:
  string maxValue(string n, int x) {
    bool isNegative = n[0] == '-';

    for (int i = 0; i < n.length(); ++i)
      if (!isNegative && n[i] - '0' < x || isNegative && n[i] - '0' > x)
        return n.substr(0, i) + (char)('0' + x) + n.substr(i);

    return n + (char)('0' + x);
  }
};",1881
1880,"struct T {
  int weight;
  int index;
  int freeTime;
  T(int weight, int index, int freeTime)
      : weight(weight), index(index), freeTime(freeTime) {}
};

class Solution {
 public:
  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {
    const int n = servers.size();
    const int m = tasks.size();
    vector<int> ans(m);
    auto compareFree = [](const T& a, const T& b) {
      return a.weight == b.weight ? a.index > b.index : a.weight > b.weight;
    };
    auto compareUsed = [](const T& a, const T& b) {
      if (a.freeTime != b.freeTime)
        return a.freeTime > b.freeTime;
      if (a.weight != b.weight)
        return a.weight > b.weight;
      return a.index > b.index;
    };
    priority_queue<T, vector<T>, decltype(compareFree)> free(compareFree);
    priority_queue<T, vector<T>, decltype(compareUsed)> used(compareUsed);

    for (int i = 0; i < n; ++i)
      free.emplace(servers[i], i, 0);

    for (int i = 0; i < m; ++i) {  // i := the current time
      const int executionTime = tasks[i];
      // Pop all the servers that'll be free at time i.
      while (!used.empty() && used.top().freeTime <= i) {
        const T curr = used.top();
        used.pop();
        free.push(curr);
      }
      if (free.empty()) {
        T server = used.top();
        used.pop();
        ans[i] = server.index;
        server.freeTime += executionTime;
        used.push(server);
      } else {
        T server = free.top();
        free.pop();
        ans[i] = server.index;
        server.freeTime = i + executionTime;
        used.push(server);
      }
    }

    return ans;
  }
};",1882
1881,"class Solution {
 public:
  int minSkips(vector<int>& dist, int speed, int hoursBefore) {
    constexpr double kInf = 1e7;
    constexpr double kEps = 1e-9;
    const int n = dist.size();
    // dp[i][j] := the minimum time, where i is the number of roads we traversed
    // so far and j is the number of skips we did
    vector<vector<double>> dp(n + 1, vector<double>(n + 1, kInf));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const double d = dist[i - 1];
      dp[i][0] = ceil(dp[i - 1][0] + d / speed - kEps);
      for (int j = 1; j <= i; ++j)
        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,
                       ceil(dp[i - 1][j] + d / speed - kEps));
    }

    for (int j = 0; j <= n; ++j)
      if (dp[n][j] <= hoursBefore)
        return j;

    return -1;
  }
};",1883
1882,"class Solution {
 public:
  int twoEggDrop(int n) {
    return superEggDrop(2, n);
  }

 private:
  // Same as 887. Super Egg Drop
  int superEggDrop(int k, int n) {
    vector<vector<int>> mem(k + 1, vector<int>(n + 1, -1));
    return drop(k, n, mem);
  }

  // Returns the minimum number of moves to know f with k eggs and n floors.
  int drop(int k, int n, vector<vector<int>>& mem) {
    if (k == 0)  // no eggs -> done
      return 0;
    if (k == 1)  // one egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0)  // no floor -> done
      return 0;
    if (n == 1)  // one floor -> drop from that floor
      return 1;
    if (mem[k][n] != -1)
      return mem[k][n];

    //   broken[i] := drop(k - 1, i - 1) is increasing with i
    // unbroken[i] := drop(k,     n - i) is decreasing with i
    // mem[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n
    // Find the first index i s.t broken[i] >= unbroken[i], which minimizes
    // max(broken[i], unbroken[i]).

    int l = 1;
    int r = n + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      const int broken = drop(k - 1, m - 1, mem);
      const int unbroken = drop(k, n - m, mem);
      if (broken >= unbroken)
        r = m;
      else
        l = m + 1;
    }

    return mem[k][n] = 1 + drop(k - 1, l - 1, mem);
  }
};",1884
1883,"class Solution {
 public:
  long long countPairs(vector<int>& nums1, vector<int>& nums2) {
    long long ans = 0;
    vector<int> A(nums1.size());

    for (int i = 0; i < A.size(); ++i)
      A[i] = nums1[i] - nums2[i];

    ranges::sort(A);

    for (int i = 0; i < A.size(); ++i) {
      const auto it = lower_bound(A.begin() + i + 1, A.end(), -A[i] + 1);
      ans += A.cend() - it;
    }

    return ans;
  }
};",1885
1884,"class Solution {
 public:
  bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {
    for (int i = 0; i < 4; ++i) {
      if (mat == target)
        return true;
      rotate(mat);
    }
    return false;
  }

 private:
  void rotate(vector<vector<int>>& M) {
    reverse(M.begin(), M.end());
    for (int i = 0; i < M.size(); ++i)
      for (int j = i + 1; j < M.size(); ++j)
        swap(M[i][j], M[j][i]);
  }
};",1886
1885,"class Solution {
 public:
  int reductionOperations(vector<int>& nums) {
    int ans = 0;

    ranges::sort(nums);

    for (int i = nums.size() - 1; i > 0; --i)
      if (nums[i] != nums[i - 1])
        ans += nums.size() - i;

    return ans;
  }
};",1887
1886,"class Solution {
 public:
  int minFlips(string s) {
    const int n = s.length();
    // count[0][0] := the number of 0s in the even indices
    // count[0][1] := the number of 0s in the odd indices
    // count[1][0] := the number of 1s in the even indices
    // count[1][1] := the number of 1s in the odd indices
    vector<vector<int>> count(2, vector<int>(2));

    for (int i = 0; i < n; ++i)
      ++count[s[i] - '0'][i % 2];

    // min(make all 0s in the even indices + make all 1s in the odd indices,
    //     make all 1s in the even indices + make all 0s in the odd indices)
    int ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1]);

    for (int i = 0; i < n; ++i) {
      --count[s[i] - '0'][i % 2];
      ++count[s[i] - '0'][(n + i) % 2];
      ans = min({ans, count[1][0] + count[0][1], count[0][0] + count[1][1]});
    }

    return ans;
  }
};",1888
1887,"class Solution {
 public:
  int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {
    constexpr int kMod = 1'000'000'007;
    constexpr long kInf = 1e11;
    const long packagesSum = accumulate(packages.begin(), packages.end(), 0L);
    long minBoxesSum = kInf;

    ranges::sort(packages);

    for (vector<int>& box : boxes) {
      ranges::sort(box);
      if (box.back() < packages.back())
        continue;
      long accu = 0;
      long i = 0;
      for (const int b : box) {
        const long j = firstGreaterEqual(packages, b + 1);
        accu += b * (j - i);
        i = j;
      }
      minBoxesSum = min(minBoxesSum, accu);
    }

    return minBoxesSum == kInf ? -1 : (minBoxesSum - packagesSum) % kMod;
  }

 private:
  int firstGreaterEqual(const vector<int>& A, int target) {
    return ranges::lower_bound(A, target) - A.begin();
  }
};",1889
1888,"SELECT
  user_id,
  MAX(time_stamp) AS last_stamp
FROM Logins
WHERE YEAR(time_stamp) = 2020
GROUP BY 1;",1890
1889,"class Solution {
 public:
  int maxLength(vector<int>& ribbons, int k) {
    int l = 1;
    int r = accumulate(ribbons.begin(), ribbons.end(), 0L) / k + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (!isCutPossible(ribbons, m, k))
        r = m;
      else
        l = m + 1;
    }

    return l - 1;
  }

 private:
  bool isCutPossible(const vector<int>& ribbons, int length, int k) {
    int count = 0;
    for (const int ribbon : ribbons)
      count += ribbon / length;
    return count >= k;
  }
};",1891
1890,"WITH
  UserToFriends AS (
    SELECT user1_id AS user_id, user2_id AS friend_id FROM Friendship
    UNION ALL
    SELECT user2_id AS user_id, user1_id AS friend_id FROM friendship
  )
SELECT
  UserToFriends.user_id,
  FriendLikes.page_id,
  COUNT(DISTINCT UserToFriends.friend_id) AS friends_likes
FROM UserToFriends
LEFT JOIN Likes AS FriendLikes
  ON (UserToFriends.friend_id = FriendLikes.user_id)
LEFT JOIN Likes AS UserLikes
  ON (
    UserToFriends.user_id = UserLikes.user_id
    AND FriendLikes.page_id = UserLikes.page_id)
WHERE UserLikes.page_id IS NULL
GROUP BY 1, 2;",1892
1891,k = right - left + 1,1893
1892,"class Solution {
 public:
  int chalkReplacer(vector<int>& chalk, int k) {
    k %= accumulate(chalk.begin(), chalk.end(), 0L);
    if (k == 0)
      return 0;

    for (int i = 0; i < chalk.size(); ++i) {
      k -= chalk[i];
      if (k < 0)
        return i;
    }

    throw;
  }
};",1894
1893,"class Solution {
 public:
  int largestMagicSquare(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // prefixRow[i][j] := the sum of the first j numbers in the i-th row
    vector<vector<int>> prefixRow(m, vector<int>(n + 1));
    // prefixCol[i][j] := the sum of the first j numbers in the i-th column
    vector<vector<int>> prefixCol(n, vector<int>(m + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j];
        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j];
      }

    for (int k = min(m, n); k >= 2; --k)
      if (containsMagicSquare(grid, prefixRow, prefixCol, k))
        return k;

    return 1;
  }

 private:
  // Returns true if the grid contains any magic square of size k x k.
  bool containsMagicSquare(const vector<vector<int>>& grid,
                           const vector<vector<int>>& prefixRow,
                           const vector<vector<int>>& prefixCol, int k) {
    for (int i = 0; i + k - 1 < grid.size(); ++i)
      for (int j = 0; j + k - 1 < grid[0].size(); ++j)
        if (isMagicSquare(grid, prefixRow, prefixCol, i, j, k))
          return true;
    return false;
  }

  // Returns true if grid[i..i + k)[j..j + k) is a magic square.
  bool isMagicSquare(const vector<vector<int>>& grid,
                     const vector<vector<int>>& prefixRow,
                     const vector<vector<int>>& prefixCol, int i, int j,
                     int k) {
    int diag = 0;
    int antiDiag = 0;
    for (int d = 0; d < k; ++d) {
      diag += grid[i + d][j + d];
      antiDiag += grid[i + d][j + k - 1 - d];
    }
    if (diag != antiDiag)
      return false;
    for (int d = 0; d < k; ++d) {
      if (getSum(prefixRow, i + d, j, j + k - 1) != diag)
        return false;
      if (getSum(prefixCol, j + d, i, i + k - 1) != diag)
        return false;
    }
    return true;
  }

  // Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).
  int getSum(const vector<vector<int>>& prefix, int i, int l, int r) {
    return prefix[i][r + 1] - prefix[i][l];
  }
};",1895
1894,"class Solution {
 public:
  int minOperationsToFlip(string expression) {
    // [(the expression, the cost to toggle the expression)]
    stack<pair<char, int>> stack;
    pair<char, int> lastPair;

    for (const char e : expression) {
      if (e == '(' || e == '&' || e == '|') {
        // These aren't expressions, so the cost is meaningless.
        stack.push({e, 0});
        continue;
      }
      if (e == ')') {
        lastPair = stack.top();
        stack.pop();
        stack.pop();  // Pop '('.
      } else {        // e == '0' || e == '1'
        // Store the '0' or '1'. The cost to change their values is just 1,
        // whether it's changing '0' to '1' or '1' to '0'.
        lastPair = {e, 1};
      }
      if (!stack.empty() &&
          (stack.top().first == '&' || stack.top().first == '|')) {
        const char op = stack.top().first;
        stack.pop();
        const auto [a, costA] = stack.top();
        stack.pop();
        const auto [b, costB] = lastPair;
        // Determine the cost to toggle op(a, b).
        if (op == '&') {
          if (a == '0' && b == '0')
            // Change '&' to '|' and a|b to '1'.
            lastPair = {'0', 1 + min(costA, costB)};
          else if (a == '0' && b == '1')
            // Change '&' to '|'.
            lastPair = {'0', 1};
          else if (a == '1' && b == '0')
            // Change '&' to '|'.
            lastPair = {'0', 1};
          else  // a == '1' and b == '1'
            // Change a|b to '0'.
            lastPair = {'1', min(costA, costB)};
        } else {  // op == '|'
          if (a == '0' && b == '0')
            // Change a|b to '1'.
            lastPair = {'0', min(costA, costB)};
          else if (a == '0' && b == '1')
            // Change '|' to '&'.
            lastPair = {'1', 1};
          else if (a == '1' && b == '0')
            // Change '|' to '&'.
            lastPair = {'1', 1};
          else  // a == '1' and b == '1'
            // Change '|' to '&' and a|b to '0'.
            lastPair = {'1', 1 + min(costA, costB)};
        }
      }
      stack.push(lastPair);
    }

    return stack.top().second;
  }
};",1896
1895,"class Solution {
 public:
  bool makeEqual(vector<string>& words) {
    vector<int> count(26);

    for (const string& word : words)
      for (const char c : word)
        ++count[c - 'a'];

    return ranges::all_of(count,
                          [&](const int c) { return c % words.size() == 0; });
  }
};",1897
1896,"class Solution {
 public:
  int maximumRemovals(string s, string p, vector<int>& removable) {
    int l = 0;
    int r = removable.size() + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      const string removed = remove(s, removable, m);
      if (isSubsequence(p, removed))
        l = m + 1;
      else
        r = m;
    }

    return l - 1;
  }

 private:
  string remove(const string& s, const vector<int>& removable, int k) {
    string removed(s);
    for (int i = 0; i < k; ++i)
      removed[removable[i]] = '*';
    return removed;
  }

  bool isSubsequence(const string& p, const string& s) {
    int i = 0;  // p's index
    for (int j = 0; j < s.length(); ++j)
      if (p[i] == s[j])
        if (++i == p.length())
          return true;
    return false;
  }
};",1898
1897,"class Solution {
 public:
  bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
    vector<int> merged(target.size());

    for (const vector<int>& triplet : triplets)
      if (equal(triplet.begin(), triplet.end(), target.begin(),
                [](int a, int b) { return a <= b; }))
        transform(triplet.begin(), triplet.end(), merged.begin(),
                  merged.begin(), [](int a, int b) { return max(a, b); });

    return merged == target;
  }
};",1899
1898,"class Solution {
 public:
  vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
    using P = pair<int, int>;
    vector<vector<vector<P>>> mem(n + 1,
                                  vector<vector<P>>(n + 1, vector<P>(n + 1)));
    const auto [a, b] = solve(firstPlayer, n - secondPlayer + 1, n, mem);
    return {a, b};
  }

 private:
  // Returns the (earliest, latest) pair, the first player is the l-th player
  // from the front, the second player is the r-th player from the end, and
  // there're k people.
  pair<int, int> solve(int l, int r, int k,
                       vector<vector<vector<pair<int, int>>>>& mem) {
    if (l == r)
      return {1, 1};
    if (l > r)
      swap(l, r);
    if (mem[l][r][k] != pair<int, int>{0, 0})
      return mem[l][r][k];

    int a = INT_MAX;
    int b = INT_MIN;

    // Enumerate all the possible positions.
    for (int i = 1; i <= l; ++i)
      for (int j = l - i + 1; j <= r - i; ++j) {
        if (i + j > (k + 1) / 2 || i + j < l + r - k / 2)
          continue;
        const auto [x, y] = solve(i, j, (k + 1) / 2, mem);
        a = min(a, x + 1);
        b = max(b, y + 1);
      }

    return mem[l][r][k] = {a, b};
  }
};",1900
1899,"class Solution {
 public:
  vector<int> findPeakGrid(vector<vector<int>>& mat) {
    int l = 0;
    int r = mat.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (ranges::max(mat[m]) >= ranges::max(mat[m + 1]))
        r = m;
      else
        l = m + 1;
    }

    return {l, getMaxIndex(mat[l])};
  }

 private:
  int getMaxIndex(const vector<int>& A) {
    pair<int, int> res{0, A[0]};
    for (int i = 1; i < A.size(); ++i)
      if (A[i] > res.second)
        res = {i, A[i]};
    return res.first;
  }
};",1901
1900,"class Solution {
 public:
  int maxDepthBST(vector<int>& order) {
    int ans = 1;
    map<int, int> valToDepth;

    for (const int val : order) {
      const auto l = valToDepth.upper_bound(val);
      const auto r = valToDepth.lower_bound(val);
      const int leftDepth = l == valToDepth.cbegin() ? 0 : prev(l)->second;
      const int rightDepth = r == valToDepth.cend() ? 0 : r->second;
      const int depth = max(leftDepth, rightDepth) + 1;
      ans = max(ans, depth);
      valToDepth[val] = depth;
    }

    return ans;
  }
};",1902
1901,"class Solution {
 public:
  string largestOddNumber(string num) {
    for (int i = num.length() - 1; i >= 0; --i)
      if ((num[i] - '0') & 1)
        return num.substr(0, i + 1);
    return """";
  }
};",1903
1902,"class Solution {
 public:
  int numberOfRounds(string loginTime, string logoutTime) {
    const int start = getMinutes(loginTime);
    int finish = getMinutes(logoutTime);
    if (start > finish)
      finish += 60 * 24;
    return max(0, finish / 15 - (start + 14) / 15);
  }

 private:
  int getMinutes(const string& time) {
    const int h = stoi(time.substr(0, 2));
    const int m = stoi(time.substr(3));
    return 60 * h + m;
  }
};",1904
1903,"class Solution {
 public:
  int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
    int ans = 0;

    for (int i = 0; i < grid2.size(); ++i)
      for (int j = 0; j < grid2[0].size(); ++j)
        if (grid2[i][j] == 1)
          ans += dfs(grid1, grid2, i, j);

    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i,
          int j) {
    if (i < 0 || i == grid1.size() || j < 0 || j == grid2[0].size())
      return 1;
    if (grid2[i][j] != 1)
      return 1;

    grid2[i][j] = 2;  // Mark 2 as visited.

    return dfs(grid1, grid2, i + 1, j) & dfs(grid1, grid2, i - 1, j) &
           dfs(grid1, grid2, i, j + 1) & dfs(grid1, grid2, i, j - 1) &
           grid1[i][j];
  }
};",1905
1904,"class Solution {
 public:
  vector<int> minDifference(vector<int>& nums, vector<vector<int>>& queries) {
    vector<vector<int>> numToIndices(101);

    for (int i = 0; i < nums.size(); ++i)
      numToIndices[nums[i]].push_back(i);

    if (numToIndices[nums[0]].size() == nums.size())
      return vector<int>(queries.size(), -1);

    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int l = query[0];
      const int r = query[1];
      int prevNum = -1;
      int minDiff = 101;
      for (int num = 1; num <= 100; ++num) {
        const auto& indices = numToIndices[num];
        const auto it = ranges::lower_bound(indices, l);
        if (it == indices.cend() || *it > r)
          continue;
        if (prevNum != -1)
          minDiff = min(minDiff, num - prevNum);
        prevNum = num;
      }
      ans.push_back(minDiff == 101 ? -1 : minDiff);
    }

    return ans;
  }
};",1906
1905,"SELECT
  'Low Salary' AS Category,
  SUM(income < 20000) AS accounts_count
FROM Accounts
UNION ALL
SELECT
  'Average Salary' Category,
  SUM(income >= 20000 AND income <= 50000) AS accounts_count
FROM Accounts
UNION ALL
SELECT
  'High Salary' category,
  SUM(income > 50000) AS accounts_count
FROM Accounts;",1907
1906,"class Solution {
 public:
  bool nimGame(vector<int>& piles) {
    return accumulate(piles.begin(), piles.end(), 0, bit_xor<>()) > 0;
  }
};",1908
1907,"class Solution {
 public:
  bool canBeIncreasing(vector<int>& nums) {
    bool removed = false;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i - 1] >= nums[i]) {
        if (removed)
          return false;
        removed = true;  // Remove nums[i - 1].
        if (i > 1 && nums[i - 2] >= nums[i])
          nums[i] = nums[i - 1];  // Remove nums[i] instead.
      }

    return true;
  }
};",1909
1908,"class Solution {
 public:
  string removeOccurrences(string s, string part) {
    const int n = s.length();
    const int k = part.length();

    string t(n, ' ');
    int j = 0;  // t's index

    for (int i = 0; i < n; ++i) {
      t[j++] = s[i];
      if (j >= k && t.substr(j - k, k) == part)
        j -= k;
    }

    return t.substr(0, j);
  }
};",1910
1909,"class Solution {
 public:
  long long maxAlternatingSum(vector<int>& nums) {
    long even = 0;  // the maximum alternating sum ending in an even index
    long odd = 0;   // the maximum alternating sum ending in an odd index

    for (const int num : nums) {
      even = max(even, odd + num);
      odd = even - num;
    }

    return even;
  }
};",1911
1910,search(movie: int),1912
1911,"class Solution {
 public:
  int maxProductDifference(vector<int>& nums) {
    int max1 = INT_MIN;
    int max2 = INT_MIN;
    int min1 = INT_MAX;
    int min2 = INT_MAX;

    for (const int num : nums) {
      if (num > max1) {
        max2 = max1;
        max1 = num;
      } else if (num > max2) {
        max2 = num;
      }
      if (num < min1) {
        min2 = min1;
        min1 = num;
      } else if (num < min2) {
        min2 = num;
      }
    }

    return max1 * max2 - min1 * min2;
  }
};",1913
1912,"class Solution {
 public:
  vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    int t = 0;      // the top
    int l = 0;      // the left
    int b = m - 1;  // the bottom
    int r = n - 1;  // the right

    while (t < b && l < r) {
      const int elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4;
      const int netRotations = k % elementInThisLayer;
      for (int rotate = 0; rotate < netRotations; ++rotate) {
        const int topLeft = grid[t][l];
        for (int j = l; j < r; ++j)
          grid[t][j] = grid[t][j + 1];
        for (int i = t; i < b; ++i)
          grid[i][r] = grid[i + 1][r];
        for (int j = r; j > l; --j)
          grid[b][j] = grid[b][j - 1];
        for (int i = b; i > t; --i)
          grid[i][l] = grid[i - 1][l];
        grid[t + 1][l] = topLeft;
      }
      ++t;
      ++l;
      --b;
      --r;
    }

    return grid;
  }
};",1914
1913,"class Solution {
 public:
  long long wonderfulSubstrings(string word) {
    long long ans = 0;
    int prefix = 0;           // the binary prefix
    vector<int> count(1024);  // the binary prefix count
    count[0] = 1;             // the empty string """"

    for (const char c : word) {
      prefix ^= 1 << c - 'a';
      // All the letters occur even number of times.
      ans += count[prefix];
      // ('a' + i) occurs odd number of times.
      for (int i = 0; i < 10; ++i)
        ans += count[prefix ^ 1 << i];
      ++count[prefix];
    }

    return ans;
  }
};",1915
1914,"class Solution:
  def waysToBuildRooms(self, prevRoom: List[int]) -> int:
    kMod = 1_000_000_007
    graph = collections.defaultdict(list)

    for i, prev in enumerate(prevRoom):
      graph[prev].append(i)

    def dfs(node: int) -> Tuple[int, int]:
      if not graph[node]:
        return 1, 1

      ans = 1
      l = 0

      for child in graph[node]:
        temp, r = dfs(child)
        ans = (ans * temp * math.comb(l + r, r)) % kMod
        l += r

      return ans, l + 1

    return dfs(0)[0]",1916
1915,"WITH
  RecommendedUserPairs AS (
    SELECT
      Listen1.user_id AS user1_id,
      Listen2.user_id AS user2_id
    FROM Listens AS Listen1
    INNER JOIN Listens AS Listen2
      USING (song_id, day)
    WHERE
      Listen1.user_id < Listen2.user_id
      AND NOT EXISTS(
        SELECT * FROM Friendship
        WHERE
          Listen1.user_id = Friendship.user1_id
          AND Listen2.user_id = Friendship.user2_id)
    GROUP BY Listen1.user_id, Listen2.user_id, Listen1.day
    HAVING COUNT(DISTINCT Listen1.song_id) >= 3
  )
SELECT
  user1_id AS user_id,
  user2_id AS recommended_id
FROM RecommendedUserPairs
UNION
SELECT
  user2_id AS user_id,
  user1_id AS recommended_id
FROM RecommendedUserPairs;",1917
1916,"class Solution {
 public:
  int kthSmallestSubarraySum(vector<int>& nums, int k) {
    int l = 0;
    int r = accumulate(nums.begin(), nums.end(), 0);

    while (l < r) {
      const int m = (l + r) / 2;
      if (numSubarrayLessThan(nums, m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int numSubarrayLessThan(const vector<int>& nums, int m) {
    int res = 0;
    int sum = 0;
    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum > m)
        sum -= nums[l++];
      res += r - l + 1;
    }
    return res;
  }
};",1918
1917,"SELECT DISTINCT
  Listen1.user_id AS user1_id,
  Listen2.user_id AS user2_id
FROM Listens AS Listen1
INNER JOIN Listens AS Listen2
  USING (song_id, day)
WHERE
  Listen1.user_id < Listen2.user_id
  AND EXISTS(
    SELECT * FROM Friendship
    WHERE
      Listen1.user_id = Friendship.user1_id
      AND Listen2.user_id = Friendship.user2_id)
GROUP BY Listen1.user_id, Listen2.user_id, Listen1.day
HAVING COUNT(DISTINCT Listen1.song_id) >= 3",1919
1918,"class Solution {
 public:
  vector<int> buildArray(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0; i < n; ++i)
      nums[i] += n * (nums[nums[i]] % n);

    for (int i = 0; i < n; ++i)
      nums[i] /= n;

    return nums;
  }
};",1920
1919,"class Solution {
 public:
  int eliminateMaximum(vector<int>& dist, vector<int>& speed) {
    const int n = dist.size();
    vector<int> arrivalTime(n);

    for (int i = 0; i < n; ++i)
      arrivalTime[i] = (dist[i] - 1) / speed[i];

    ranges::sort(arrivalTime);

    for (int i = 0; i < n; ++i)
      if (i > arrivalTime[i])
        return i;

    return n;
  }
};",1921
1920,"class Solution {
 public:
  int countGoodNumbers(long long n) {
    return modPow(4 * 5, n / 2) * (n & 1 ? 5 : 1) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x, n - 1) % kMod;
    return modPow(x * x % kMod, n / 2);
  }
};",1922
1921,"class Solution {
 public:
  int longestCommonSubpath(int n, vector<vector<int>>& paths) {
    int l = 0;
    int r = paths[0].size();

    while (l < r) {
      const int m = l + (r - l + 1) / 2;
      if (checkCommonSubpath(paths, m))
        l = m;
      else
        r = m - 1;
    }

    return l;
  }

  static constexpr long kMod = 8'417'508'174'513;
  static constexpr long kBase = 165'131;

  // Returns true if there's a common subpath of length m for all the paths.
  bool checkCommonSubpath(const vector<vector<int>>& paths, int m) {
    vector<unordered_set<long>> hashSets;

    // Calculate the hash values for subpaths of length m for every path.
    for (const vector<int>& path : paths)
      hashSets.push_back(rabinKarp(path, m));

    // Check if there is a common subpath of length m.
    for (const long subpathHash : hashSets[0])
      if (ranges::all_of(hashSets,
                         [subpathHash](const unordered_set<long>& hashSet) {
        return hashSet.count(subpathHash);
      }))
        return true;

    return false;
  }

  // Returns the hash values for subpaths of length m in the path.
  unordered_set<long> rabinKarp(const vector<int>& path, int m) {
    unordered_set<long> hashes;
    long maxPower = 1;
    long hash = 0;
    for (int i = 0; i < path.size(); ++i) {
      hash = (hash * kBase + path[i]) % kMod;
      if (i >= m)
        hash = (hash - path[i - m] * maxPower % kMod + kMod) % kMod;
      else
        maxPower = maxPower * kBase % kMod;
      if (i >= m - 1)
        hashes.insert(hash);
    }
    return hashes;
  }
};",1923
1922,"struct Point {
  double x;
  double y;
  Point(double x, double y) : x(x), y(y) {}
};

struct Disk {
  Point center;
  double radius;
  Disk(const Point& center, double radius) : center(center), radius(radius) {}
};

class Solution {
 public:
  vector<double> outerTrees(vector<vector<int>>& trees) {
    vector<Point> points;
    for (int i = 0; i < trees.size(); ++i)
      points.emplace_back(trees[i][0], trees[i][1]);
    Disk disk = welzl(points, 0, {});
    return {disk.center.x, disk.center.y, disk.radius};
  }

 private:
  // Returns the smallest disk that encloses points[i..n).
  // https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm
  Disk welzl(const vector<Point>& points, int i, vector<Point> planePoints) {
    if (i == points.size() || planePoints.size() == 3)
      return trivial(planePoints);
    Disk disk = welzl(points, i + 1, planePoints);
    if (inside(disk, points[i]))
      return disk;
    return welzl(points, i + 1, addPlanePoint(planePoints, points[i]));
  }

  vector<Point> addPlanePoint(const vector<Point>& planePoints,
                              const Point& point) {
    vector<Point> newPlanePoints(planePoints);
    newPlanePoints.push_back(point);
    return newPlanePoints;
  }
  // Returns the smallest disk that encloses `planePoints`.
  Disk trivial(const vector<Point>& planePoints) {
    if (planePoints.empty())
      return Disk(Point(0, 0), 0);
    if (planePoints.size() == 1)
      return Disk(Point(planePoints[0].x, planePoints[0].y), 0);
    if (planePoints.size() == 2)
      return getDisk(planePoints[0], planePoints[1]);

    Disk disk01 = getDisk(planePoints[0], planePoints[1]);
    if (inside(disk01, planePoints[2]))
      return disk01;

    Disk disk02 = getDisk(planePoints[0], planePoints[2]);
    if (inside(disk02, planePoints[1]))
      return disk02;

    Disk disk12 = getDisk(planePoints[1], planePoints[2]);
    if (inside(disk12, planePoints[0]))
      return disk12;

    return getDisk(planePoints[0], planePoints[1], planePoints[2]);
  }

  // Returns the smallest disk that encloses the points A and B.
  Disk getDisk(const Point& A, const Point& B) {
    const double x = (A.x + B.x) / 2;
    const double y = (A.y + B.y) / 2;
    return Disk(Point(x, y), distance(A, B) / 2);
  }

  // Returns the smallest disk that encloses the points A, B, and C.
  Disk getDisk(const Point& A, const Point& B, const Point& C) {
    // Calculate midpoints.
    Point mAB((A.x + B.x) / 2, (A.y + B.y) / 2);
    Point mBC((B.x + C.x) / 2, (B.y + C.y) / 2);

    // Calculate the slopes and the perpendicular slopes.
    const double slopeAB = (B.y - A.y) / (B.x - A.x);
    const double slopeBC = (C.y - B.y) / (C.x - B.x);
    const double perpSlopeAB = -1 / slopeAB;
    const double perpSlopeBC = -1 / slopeBC;

    // Calculate the center.
    const double x =
        (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x + mAB.y - mBC.y) /
        (perpSlopeBC - perpSlopeAB);
    const double y = perpSlopeAB * (x - mAB.x) + mAB.y;
    Point center(x, y);
    return Disk(center, distance(center, A));
  }

  // Returns true if the point is inside the disk.
  bool inside(Disk disk, Point point) {
    return disk.radius > 0 && distance(disk.center, point) <= disk.radius;
  }

  double distance(Point A, Point B) {
    const double dx = A.x - B.x;
    const double dy = A.y - B.y;
    return sqrt(dx * dx + dy * dy);
  }
};",1924
1923,"class Solution {
 public:
  int countTriples(int n) {
    int ans = 0;
    unordered_set<int> squared;

    for (int i = 1; i <= n; ++i)
      squared.insert(i * i);

    for (const int a : squared)
      for (const int b : squared)
        if (squared.count(a + b))
          ++ans;

    return ans;
  }
};",1925
1924,"class Solution {
 public:
  int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = maze.size();
    const int n = maze[0].size();
    int ans = 0;
    queue<pair<int, int>> q{{{entrance[0], entrance[1]}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[entrance[0]][entrance[1]] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || maze[x][y] == '+')
            continue;
          if (x == 0 || x == m - 1 || y == 0 || y == n - 1)
            return ans;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return -1;
  }
};",1926
1925,"class Solution {
 public:
  bool sumGame(string num) {
    const int n = num.length();
    double ans = 0.0;

    for (int i = 0; i < n / 2; ++i)
      ans += getExpectation(num[i]);

    for (int i = n / 2; i < n; ++i)
      ans -= getExpectation(num[i]);

    return ans != 0.0;
  }

 private:
  double getExpectation(char c) {
    return c == '?' ? 4.5 : c - '0';
  }
};",1927
1926,"class Solution {
 public:
  int minCost(int maxTime, vector<vector<int>>& edges,
              vector<int>& passingFees) {
    const int n = passingFees.size();
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1, maxTime, passingFees);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int maxTime, const vector<int>& passingFees) {
    // cost[i] := the minimum cost to reach the i-th city
    vector<int> cost(graph.size(), INT_MAX);
    // dist[i] := the minimum time to reach the i-th city
    vector<int> dist(graph.size(), maxTime + 1);
    using T = tuple<int, int, int>;  // (cost[u], dist[u], u)
    priority_queue<T, vector<T>, greater<>> minHeap;

    cost[src] = passingFees[src];
    dist[src] = 0;
    minHeap.emplace(cost[src], dist[src], src);

    while (!minHeap.empty()) {
      const auto [currCost, d, u] = minHeap.top();
      minHeap.pop();
      if (u == dst)
        return cost[dst];
      for (const auto& [v, w] : graph[u]) {
        if (d + w > maxTime)
          continue;
        // Go from u -> v.
        if (currCost + passingFees[v] < cost[v]) {
          cost[v] = currCost + passingFees[v];
          dist[v] = d + w;
          minHeap.emplace(cost[v], dist[v], v);
        } else if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(currCost + passingFees[v], dist[v], v);
        }
      }
    }

    return -1;
  }
};",1928
1927,"class Solution {
 public:
  vector<int> getConcatenation(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0; i < n; ++i)
      nums.push_back(nums[i]);

    return nums;
  }
};",1929
1928,"class Solution {
 public:
  int countPalindromicSubsequence(string s) {
    int ans = 0;
    vector<int> first(26, s.length());
    vector<int> last(26);

    for (int i = 0; i < s.length(); ++i) {
      const int index = s[i] - 'a';
      first[index] = min(first[index], i);
      last[index] = i;
    }

    for (int i = 0; i < 26; ++i)
      if (first[i] < last[i])
        ans += unordered_set<int>(s.begin() + first[i] + 1, s.begin() + last[i])
                   .size();

    return ans;
  }
};",1930
1929,"class Solution {
 public:
  int colorTheGrid(int m, int n) {
    this->m = m;
    this->n = n;
    return dp(0, 0, 0, 0);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int m;
  int n;
  vector<vector<int>> mem = vector<vector<int>>(1000, vector<int>(1024));

  int dp(int r, int c, int prevColMask, int currColMask) {
    if (c == n)
      return 1;
    if (mem[c][prevColMask])
      return mem[c][prevColMask];
    if (r == m)
      return dp(0, c + 1, currColMask, 0);

    int ans = 0;

    // 1 := red, 2 := green, 3 := blue
    for (int color = 1; color <= 3; ++color) {
      if (getColor(prevColMask, r) == color)
        continue;
      if (r > 0 && getColor(currColMask, r - 1) == color)
        continue;
      ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color));
      ans %= kMod;
    }

    if (r == 0)
      mem[c][prevColMask] = ans;

    return ans;
  }

  // e.g. __ __ __ __ __
  //      01 10 11 11 11
  //      R  G  B  B  B
  // getColor(0110111111, 3) -> G
  int getColor(int mask, int r) {
    return mask >> r * 2 & 3;
  }

  int setColor(int mask, int r, int color) {
    return mask | color << r * 2;
  }
};",1931
1930,"class Solution {
 public:
  TreeNode* canMerge(vector<TreeNode*>& trees) {
    unordered_map<int, TreeNode*> valToNode;  // {val: node}
    unordered_map<int, int> count;            // {val: freq}

    for (TreeNode* tree : trees) {
      valToNode[tree->val] = tree;
      ++count[tree->val];
      if (tree->left)
        ++count[tree->left->val];
      if (tree->right)
        ++count[tree->right->val];
    }

    for (TreeNode* tree : trees)
      if (count[tree->val] == 1) {
        if (isValidBST(tree, nullptr, nullptr, valToNode) &&
            valToNode.size() <= 1)
          return tree;
        return nullptr;
      }

    return nullptr;
  }

 private:
  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,
                  unordered_map<int, TreeNode*>& valToNode) {
    if (tree == nullptr)
      return true;
    if (minNode && tree->val <= minNode->val)
      return false;
    if (maxNode && tree->val >= maxNode->val)
      return false;
    if (!tree->left && !tree->right && valToNode.count(tree->val)) {
      const int val = tree->val;
      tree->left = valToNode[val]->left;
      tree->right = valToNode[val]->right;
      valToNode.erase(val);
    }

    return isValidBST(tree->left, minNode, tree, valToNode) &&
           isValidBST(tree->right, tree, maxNode, valToNode);
  }
};",1932
1931,"class Solution {
 public:
  bool isDecomposable(string s) {
    int twos = 0;
    int groupLength = 0;
    char letter = '@';  // the running letter

    for (const char c : s)
      if (c == letter) {
        ++groupLength;
      } else {
        if (groupLength % 3 == 1)
          return false;
        if (groupLength % 3 == 2 && ++twos > 1)
          return false;
        groupLength = 1;
        letter = c;
      }

    // Check the final group.
    if (groupLength % 3 == 1)
      return false;
    if (groupLength % 3 == 2 && ++twos > 1)
      return false;
    return twos == 1;
  }
};",1933
1932,"SELECT
  Signups.user_id,
  IFNULL(ROUND(AVG(Confirmations.action = 'confirmed'), 2), 0) AS confirmation_rate
FROM Signups
LEFT JOIN Confirmations
  USING (user_id)
GROUP BY 1;",1934
1933,"class Solution {
 public:
  int canBeTypedWords(string text, string brokenLetters) {
    int ans = 0;
    istringstream iss(text);
    vector<bool> broken(26);

    for (const char c : brokenLetters)
      broken[c - 'a'] = true;

    for (string word; iss >> word;)
      ans += canBeTyped(word, broken);

    return ans;
  }

 private:
  bool canBeTyped(const string& word, const vector<bool>& broken) {
    for (const char c : word)
      if (broken[c - 'a'])
        return false;
    return true;
  }
};",1935
1934,"class Solution {
 public:
  int addRungs(vector<int>& rungs, int dist) {
    int ans = 0;
    int prev = 0;

    for (const int rung : rungs) {
      ans += (rung - prev - 1) / dist;
      prev = rung;
    }

    return ans;
  }
};",1936
1935,"class Solution {
 public:
  long long maxPoints(vector<vector<int>>& points) {
    const int n = points[0].size();
    // dp[j] := the maximum number of points you can have if points[i][j] is the
    // most recent cell you picked
    vector<long long> dp(n);

    for (const vector<int>& row : points) {
      vector<long long> leftToRight(n);
      long long runningMax = 0;

      for (int j = 0; j < n; ++j) {
        runningMax = max(runningMax - 1, dp[j]);
        leftToRight[j] = runningMax;
      }

      vector<long long> rightToLeft(n);
      runningMax = 0;

      for (int j = n - 1; j >= 0; --j) {
        runningMax = max(runningMax - 1, dp[j]);
        rightToLeft[j] = runningMax;
      }

      for (int j = 0; j < n; ++j)
        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j];
    }

    return ranges::max(dp);
  }
};",1937
1936,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(2) {}
};

class Trie {
 public:
  void update(int num, int val) {
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = (num >> i) & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      node->count += val;
    }
  }

  int query(int num) {
    int ans = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = (num >> i) & 1;
      const int targetBit = bit ^ 1;
      if (node->children[targetBit] && node->children[targetBit]->count) {
        ans += 1 << i;
        node = node->children[targetBit];
      } else {
        node = node->children[targetBit ^ 1];
      }
    }
    return ans;
  }

 private:
  static constexpr int kHeight = 17;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  vector<int> maxGeneticDifference(vector<int>& parents,
                                   vector<vector<int>>& queries) {
    const int n = parents.size();
    vector<int> ans(queries.size());
    int rootVal = -1;
    vector<vector<int>> tree(n);
    // {node: (index, val)}
    unordered_map<int, vector<pair<int, int>>> nodeToQueries;
    Trie trie;

    for (int i = 0; i < parents.size(); ++i)
      if (parents[i] == -1)
        rootVal = i;
      else
        tree[parents[i]].push_back(i);

    for (int i = 0; i < queries.size(); ++i) {
      const int node = queries[i][0];
      const int val = queries[i][1];
      nodeToQueries[node].emplace_back(i, val);
    }

    dfs(rootVal, trie, tree, nodeToQueries, ans);
    return ans;
  }

 private:
  void dfs(int node, Trie& trie, const vector<vector<int>>& tree,
           const unordered_map<int, vector<pair<int, int>>>& nodeToQueries,
           vector<int>& ans) {
    trie.update(node, 1);

    if (const auto it = nodeToQueries.find(node); it != nodeToQueries.cend())
      for (const auto& [i, val] : it->second)
        ans[i] = trie.query(val);

    for (const int child : tree[node])
      dfs(child, trie, tree, nodeToQueries, ans);

    trie.update(node, -1);
  }
};",1938
1937,"WITH
  UserToTimestampDiff AS (
    SELECT user_id,
      TIMESTAMPDIFF(
        SECOND,
        time_stamp,
        LEAD(time_stamp) OVER(
          PARTITION BY user_id
          ORDER BY time_stamp
        )
      ) AS timestamp_diff
    FROM Confirmations
  )
SELECT DISTINCT user_id
FROM UserToTimestampDiff
WHERE timestamp_diff <= 24 * 60 * 60;",1939
1938,"class Solution {
 public:
  vector<int> longestCommonSubsequence(vector<vector<int>>& arrays) {
    constexpr int kMax = 100;
    vector<int> ans;
    vector<int> count(kMax + 1);

    for (const vector<int>& array : arrays)
      for (const int a : array)
        if (++count[a] == arrays.size())
          ans.push_back(a);

    return ans;
  }
};",1940
1939,"class Solution {
 public:
  bool areOccurrencesEqual(string s) {
    vector<int> count(26);
    for (const char c : s)
      ++count[c - 'a'];
    return equalFreq(count, count[s[0] - 'a']);
  }

 private:
  bool equalFreq(const vector<int>& count, int theFreq) {
    return ranges::all_of(
        count, [theFreq](int freq) { return freq == 0 || freq == theFreq; });
  }
};",1941
1940,"class Solution {
 public:
  int smallestChair(vector<vector<int>>& times, int targetFriend) {
    int nextUnsatChair = 0;
    priority_queue<int, vector<int>, greater<>> emptyChairs;
    using P = pair<int, int>;  // (leaving, chair)
    priority_queue<P, vector<P>, greater<>> occupied;

    for (int i = 0; i < times.size(); ++i)
      times[i].push_back(i);

    ranges::sort(times);

    for (const vector<int>& time : times) {
      const int arrival = time[0];
      const int leaving = time[1];
      const int i = time[2];
      while (!occupied.empty() && occupied.top().first <= arrival)
        emptyChairs.push(occupied.top().second), occupied.pop();
      if (i == targetFriend)
        return emptyChairs.empty() ? nextUnsatChair : emptyChairs.top();
      if (emptyChairs.empty())
        occupied.emplace(leaving, nextUnsatChair++);
      else
        occupied.emplace(leaving, emptyChairs.top()), emptyChairs.pop();
    }

    throw;
  }
};",1942
1941,"class Solution {
 public:
  vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
    vector<vector<long long>> ans;
    int prevIndex = 0;
    long long runningMix = 0;
    map<int, long long> timeline;

    for (const vector<int>& segment : segments) {
      const int start = segment[0];
      const int end = segment[1];
      const int color = segment[2];
      timeline[start] += color;
      timeline[end] -= color;
    }

    for (const auto& [i, mix] : timeline) {
      if (runningMix > 0)
        ans.push_back({prevIndex, i, runningMix});
      runningMix += mix;
      prevIndex = i;
    }

    return ans;
  }
};",1943
1942,"class Solution {
 public:
  vector<int> canSeePersonsCount(vector<int>& heights) {
    const int n = heights.size();
    vector<int> ans(n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && heights[stack.top()] <= heights[i])
        ++ans[stack.top()], stack.pop();
      if (!stack.empty())
        ++ans[stack.top()];
      stack.push(i);
    }

    return ans;
  }
};",1944
1943,"class Solution {
 public:
  int getLucky(string s, int k) {
    int ans = convert(s);
    for (int i = 1; i < k; ++i)
      ans = getDigitSum(ans);
    return ans;
  }

 private:
  int convert(string s) {
    int sum = 0;
    for (const char c : s) {
      const int val = c - 'a' + 1;
      // Do one transform to prevent integer overflow.
      sum += val < 10 ? val : (val % 10 + val / 10);
    }
    return sum;
  }

  int getDigitSum(int num) {
    int digitSum = 0;
    while (num > 0) {
      digitSum += num % 10;
      num /= 10;
    }
    return digitSum;
  }
};",1945
1944,"class Solution {
 public:
  string maximumNumber(string num, vector<int>& change) {
    bool mutated = false;

    for (char& c : num) {
      const int d = c - '0';
      c = '0' + max(d, change[d]);
      if (mutated && d > change[d])
        return num;
      if (d < change[d])
        mutated = true;
    }

    return num;
  }
};",1946
1945,"class Solution {
 public:
  int maxCompatibilitySum(vector<vector<int>>& students,
                          vector<vector<int>>& mentors) {
    int ans = 0;
    dfs(students, mentors, 0, /*score=*/0, vector<bool>(students.size()), ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& students,
           const vector<vector<int>>& mentors, int i, int scoreSum,
           vector<bool>&& used, int& ans) {
    if (i == students.size()) {
      ans = max(ans, scoreSum);
      return;
    }
    for (int j = 0; j < students.size(); ++j) {
      if (used[j])
        continue;
      used[j] = true;  // The `mentors[j]` is used.
      dfs(students, mentors, i + 1,
          scoreSum + getScore(students[i], mentors[j]), move(used), ans);
      used[j] = false;
    }
  }

  int getScore(const vector<int>& student, const vector<int>& mentor) {
    int score = 0;
    for (int i = 0; i < student.size(); ++i)
      if (student[i] == mentor[i])
        ++score;
    return score;
  }
};",1947
1946,"struct TrieNode {
  unordered_map<string, shared_ptr<TrieNode>> children;
  bool deleted = false;
};

class Solution {
 public:
  vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
    vector<vector<string>> ans;
    vector<string> path;
    unordered_map<string, vector<shared_ptr<TrieNode>>> subtreeToNodes;

    ranges::sort(paths);

    for (const vector<string>& path : paths) {
      shared_ptr<TrieNode> node = root;
      for (const string& s : path) {
        if (!node->children.count(s))
          node->children[s] = make_shared<TrieNode>();
        node = node->children[s];
      }
    }

    buildSubtreeToRoots(root, subtreeToNodes);

    for (const auto& [_, nodes] : subtreeToNodes)
      if (nodes.size() > 1)
        for (shared_ptr<TrieNode> node : nodes)
          node->deleted = true;

    constructPath(root, path, ans);
    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  string buildSubtreeToRoots(
      shared_ptr<TrieNode> node,
      unordered_map<string, vector<shared_ptr<TrieNode>>>& subtreeToNodes) {
    string subtree = ""("";
    for (const auto& [s, child] : node->children)
      subtree += s + buildSubtreeToRoots(child, subtreeToNodes);
    subtree += "")"";
    if (subtree != ""()"")
      subtreeToNodes[subtree].push_back(node);
    return subtree;
  }

  void constructPath(shared_ptr<TrieNode> node, vector<string>& path,
                     vector<vector<string>>& ans) {
    for (const auto& [s, child] : node->children)
      if (!child->deleted) {
        path.push_back(s);
        constructPath(child, path, ans);
        path.pop_back();
      }
    if (!path.empty())
      ans.push_back(path);
  }
};",1948
1947,"WITH
  TwoWayFriendship AS (
    SELECT user1_id AS user_id, user2_id AS friend_id FROM Friendship
    UNION ALL
    SELECT user2_id, user1_id FROM Friendship
  )
SELECT
  User1.user_id AS user1_id,
  User2.user_id AS user2_id,
  COUNT(*) AS common_friend
FROM TwoWayFriendship AS User1
INNER JOIN TwoWayFriendship AS User2
  ON (
    User1.friend_id = User2.friend_id
    AND User1.user_id < User2.user_id)
WHERE EXISTS (
  SELECT *
  FROM Friendship
  WHERE
    Friendship.user1_id = User1.user_id
    AND Friendship.user2_id = User2.user_id
)
GROUP BY 1, 2
HAVING common_friend >= 3;",1949
1948,"class Solution {
 public:
  // Similar to 1950. Maximum of Minimum Values in All Subarrays
  vector<int> findMaximums(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    // prevMin[i] := the index k s.t.
    // nums[k] is the previous minimum in nums[0..n)
    vector<int> prevMin(n, -1);
    // nextMin[i] := the index k s.t.
    // nums[k] is the next minimum innums[i + 1..n)
    vector<int> nextMin(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && nums[stack.top()] > nums[i]) {
        const int index = stack.top();
        stack.pop();
        nextMin[index] = i;
      }
      if (!stack.empty())
        prevMin[i] = stack.top();
      stack.push(i);
    }

    // For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.
    // nums[i] is the minimun in nums[l..r].
    // So, the ans[r - l + 1] will be at least nums[i].
    for (int i = 0; i < n; ++i) {
      const int sz = nextMin[i] - prevMin[i] - 1;
      ans[sz - 1] = max(ans[sz - 1], nums[i]);
    }

    // ans[i] should always >= ans[i + 1..n).
    for (int i = n - 2; i >= 0; --i)
      ans[i] = max(ans[i], ans[i + 1]);

    return ans;
  }
};",1950
1949,"WITH
  RankedRelations AS (
    SELECT
      User1.user_id AS user1_id,
      User2.user_id AS user2_id,
      RANK() OVER(ORDER BY COUNT(User1.follower_id) DESC) AS `rank`
    FROM Relations AS User1
    INNER JOIN Relations AS User2
      USING (follower_id)
    WHERE User1.user_id < User2.user_id
    GROUP BY 1, 2
  )
SELECT user1_id, user2_id
FROM RankedRelations
WHERE `rank` = 1;",1951
1950,"class Solution {
 public:
  bool isThree(int n) {
    if (n == 1)
      return false;
    // The numbers with exactly three divisors are perfect squares of a prime
    // number.
    const int root = sqrt(n);
    return root * root == n && isPrime(root);
  }

 private:
  bool isPrime(int num) {
    for (int i = 2; i <= sqrt(num); ++i)
      if (num % i == 0)
        return false;
    return true;
  }
};",1952
1951,"class Solution {
 public:
  long long numberOfWeeks(vector<int>& milestones) {
    // The best strategy is to pick ""max, nonMax, max, nonMax, ..."".
    const int max = ranges::max(milestones);
    const long long sum = accumulate(milestones.begin(), milestones.end(), 0LL);
    const long long nonMax = sum - max;
    return min(sum, 2 * nonMax + 1);
  }
};",1953
1952,"class Solution {
 public:
  long long minimumPerimeter(long long neededApples) {
    long long l = 1;
    long long r = 100'000;  // \sqrt [3] {10^{15}}

    while (l < r) {
      const long long m = (l + r) / 2;
      if (numApples(m) >= neededApples)
        r = m;
      else
        l = m + 1;
    }

    return l * 8;
  }

 private:
  // Returns the number of apples at the k-th level.
  //    k := the level making perimeter = 8k
  // p(k) := the number of apples at the k-th level on the perimeter
  // n(k) := the number of apples at the k-th level not no the perimeter
  //
  // p(1) =             1 + 2
  // p(2) =         3 + 2 + 3 + 4
  // p(3) =     5 + 4 + 3 + 4 + 5 + 6
  // p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8
  // p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k
  //      = k + 2k^2 + 2*k(k-1)/2
  //      = k + 2k^2 + k^2 - k = 3k^2
  //
  // n(k) = p(1) + p(2) + p(3) + ... + p(k)
  //      = 3*1  + 3*4  + 3*9  + ... + 3*k^2
  //      = 3 * (1 + 4 + 9 + ... + k^2)
  //      = 3 * k(k+1)(2k+1)/6 = k(k+1)(2k+1)/2
  // So, the number of apples at the k-th level should be
  //   k(k+1)(2k+1)/2 * 4 = 2k(k+1)(2k+1)
  long long numApples(long long k) {
    return 2 * k * (k + 1) * (2 * k + 1);
  }
};",1954
1953,"class Solution {
 public:
  int countSpecialSubsequences(vector<int>& nums) {
    vector<vector<int>> mem(nums.size(), vector<int>(4, -1));
    return countSpecialSubsequences(nums, 0, -1, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of increasing subsequences of the first i numbers, where
  // the previous number is `prev`.
  int countSpecialSubsequences(const vector<int>& nums, int i, int prev,
                               vector<vector<int>>& mem) {
    if (i == nums.size())
      return prev == 2;
    const int j = prev + 1;  // Map -1/0/1/2 to 0/1/2/3 respectively.
    if (mem[i][j] != -1)
      return mem[i][j];

    long res = 0;

    // Don't include `nums[i]`.
    res += countSpecialSubsequences(nums, i + 1, prev, mem);

    // Include `nums[i]`.
    if (nums[i] == prev)
      res += countSpecialSubsequences(nums, i + 1, prev, mem);
    if (prev == -1 && nums[i] == 0)
      res += countSpecialSubsequences(nums, i + 1, 0, mem);
    if (prev == 0 && nums[i] == 1)
      res += countSpecialSubsequences(nums, i + 1, 1, mem);
    if (prev == 1 && nums[i] == 2)
      res += countSpecialSubsequences(nums, i + 1, 2, mem);

    res %= kMod;
    return mem[i][j] = res;
  }
};",1955
1954,"class Solution {
 public:
  int minDayskVariants(vector<vector<int>>& points, int k) {
    constexpr int kMax = 100;
    int ans = INT_MAX;

    for (int a = 1; a <= kMax; ++a)
      for (int b = 1; b <= kMax; ++b) {
        // Stores the k minimum distances of points that can reach (a, b).
        priority_queue<int> maxHeap;
        for (const vector<int>& point : points) {
          const int x = point[0];
          const int y = point[1];
          maxHeap.push(abs(x - a) + abs(y - b));
          if (maxHeap.size() > k)
            maxHeap.pop();
        }
        ans = min(ans, maxHeap.top());
      }

    return ans;
  }
};",1956
1955,"class Solution {
 public:
  string makeFancyString(string s) {
    string ans;
    for (const char c : s)
      if (ans.length() < 2 || ans.back() != c || ans[ans.size() - 2] != c)
        ans.push_back(c);
    return ans;
  }
};",1957
1956,"class Solution {
 public:
  bool checkMove(vector<vector<char>>& board, int rMove, int cMove,
                 char color) {
    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};

    for (const auto& [dx, dy] : dirs) {
      int cellsCount = 2;
      int i = rMove + dx;
      int j = cMove + dy;
      while (0 <= i && i < 8 && 0 <= j && j < 8) {
        // There are no free cells in between.
        if (board[i][j] == '.')
          break;
        // Need >= 3 cells.
        if (cellsCount == 2 && board[i][j] == color)
          break;
        // >= 3 cells.
        if (board[i][j] == color)
          return true;
        i += dx;
        j += dy;
        ++cellsCount;
      }
    }

    return false;
  }
};",1958
1957,"class Solution {
 public:
  int minSpaceWastedKResizing(vector<int>& nums, int k) {
    vector<vector<int>> mem(nums.size(), vector<int>(k + 1, -1));
    return minSpaceWasted(nums, 0, k, mem);
  }

 private:
  static constexpr int kMax = 200'000'000;

  // Returns the minimum space wasted for nums[i..n) if you can resize k times.
  int minSpaceWasted(const vector<int>& nums, int i, int k,
                     vector<vector<int>>& mem) {
    if (i == nums.size())
      return 0;
    if (k == -1)
      return kMax;
    if (mem[i][k] != -1)
      return mem[i][k];

    int res = kMax;
    int sum = 0;
    int maxNum = nums[i];

    for (int j = i; j < nums.size(); ++j) {
      sum += nums[j];
      maxNum = max(maxNum, nums[j]);
      const int wasted = maxNum * (j - i + 1) - sum;
      res = min(res, minSpaceWasted(nums, j + 1, k - 1, mem) + wasted);
    }

    return mem[i][k] = res;
  }
};",1959
1958,"class Solution {
 public:
  long long maxProduct(string s) {
    const int n = s.length();
    long long ans = 1;
    // l[i] := the maximum length of palindromes in s[0..i)
    vector<int> l = manacher(s, n);
    // r[i] := the maximum length of palindromes in s[i..n)
    vector<int> r = manacher(string(s.rbegin(), s.rend()), n);
    reverse(r.begin(), r.end());

    for (int i = 0; i + 1 < n; ++i)
      ans = max(ans, (long long)l[i] * r[i + 1]);

    return ans;
  }

 private:
  vector<int> manacher(const string& s, int n) {
    vector<int> maxExtends(n);
    vector<int> l2r(n, 1);
    int center = 0;

    for (int i = 0; i < n; ++i) {
      const int r = center + maxExtends[center] - 1;
      const int mirrorIndex = center - (i - center);
      int extend = i > r ? 1 : min(maxExtends[mirrorIndex], r - i + 1);
      while (i - extend >= 0 && i + extend < n &&
             s[i - extend] == s[i + extend]) {
        l2r[i + extend] = 2 * extend + 1;
        ++extend;
      }
      maxExtends[i] = extend;
      if (i + maxExtends[i] >= r)
        center = i;
    }

    for (int i = 1; i < n; ++i)
      l2r[i] = max(l2r[i], l2r[i - 1]);

    return l2r;
  }
};",1960
1959,"class Solution {
 public:
  bool isPrefixString(string s, vector<string>& words) {
    string prefix;
    for (const string& word : words) {
      prefix += word;
      if (prefix == s)
        return true;
    }
    return false;
  }
};",1961
1960,"class Solution {
 public:
  int minStoneSum(vector<int>& piles, int k) {
    int ans = accumulate(piles.begin(), piles.end(), 0);
    priority_queue<int> maxHeap;

    for (const int pile : piles)
      maxHeap.push(pile);

    for (int i = 0; i < k; ++i) {
      const int maxPile = maxHeap.top();
      maxHeap.pop();
      maxHeap.push(maxPile - maxPile / 2);
      ans -= maxPile / 2;
    }

    return ans;
  }
};",1962
1961,"class Solution {
 public:
  int minSwaps(string s) {
    // Cancel out all the matched pairs, then we'll be left with ""]]]..[[["".
    // The answer is ceil(the number of unmatched pairs / 2).
    int unmatched = 0;

    for (const char c : s)
      if (c == '[')
        ++unmatched;
      else if (unmatched > 0)  // c == ']' and there's a match.
        --unmatched;

    return (unmatched + 1) / 2;
  }
};",1963
1962,"class Solution {
 public:
  vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
    vector<int> ans;
    // tail[i] := the minimum tail of all the increasing subsequences having
    // length i + 1
    // It's easy to see that tail must be an increasing array
    vector<int> tail;

    for (const int obstacle : obstacles)
      if (tail.empty() || obstacle >= tail.back()) {
        tail.push_back(obstacle);
        ans.push_back(tail.size());
      } else {
        const int index = firstGreater(tail, obstacle);
        tail[index] = obstacle;
        ans.push_back(index + 1);
      }

    return ans;
  }

 private:
  int firstGreater(const vector<int>& A, int target) {
    return ranges::upper_bound(A, target) - A.begin();
  }
};",1964
1963,"SELECT Employees.employee_id
FROM Employees
LEFT JOIN Salaries
  USING (employee_id)
WHERE Salaries.salary IS NULL
UNION ALL
SELECT Salaries.employee_id
FROM Salaries
LEFT JOIN Employees
  USING (employee_id)
WHERE Employees.name IS NULL
ORDER BY 1;",1965
1964,"class Solution {
 public:
  int binarySearchableNumbers(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // prefixMaxs[i] := max(nums[0..i))
    vector<int> prefixMaxs(n);
    // suffixMins[i] := min(nums[i + 1..n))
    vector<int> suffixMins(n);

    // Fill in `prefixMaxs`.
    prefixMaxs[0] = INT_MIN;
    for (int i = 1; i < n; ++i)
      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1]);

    // Fill in `suffixMins`.
    suffixMins[n - 1] = INT_MAX;
    for (int i = n - 2; i >= 0; --i)
      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1]);

    for (int i = 0; i < n; ++i)
      if (prefixMaxs[i] < nums[i] && nums[i] < suffixMins[i])
        ++ans;

    return ans;
  }
};",1966
1965,"class Solution {
 public:
  int numOfStrings(vector<string>& patterns, string word) {
    return ranges::count_if(patterns, [&word](const string& pattern) {
      return word.find(pattern) != word.npos;
    });
  }
};",1967
1966,"class Solution {
 public:
  vector<int> rearrangeArray(vector<int>& nums) {
    ranges::sort(nums);
    for (int i = 1; i < nums.size(); i += 2)
      swap(nums[i], nums[i - 1]);
    return nums;
  }
};",1968
1967,"class Solution {
 public:
  int minNonZeroProduct(int p) {
    // Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].
    const long n = 1L << p;
    const long halfCount = n / 2 - 1;
    return modPow(n - 2, halfCount) * ((n - 1) % kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1L;
    x %= kMod;
    if (n % 2 == 1)
      return x * modPow(x, n - 1) % kMod;
    return modPow(x * x, n / 2) % kMod;
  }
};",1969
1968,"class Solution {
 public:
  int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
    int ans = 0;
    int l = 1;
    int r = cells.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (canWalk(m, row, col, cells)) {
        ans = m;
        l = m + 1;
      } else {
        r = m - 1;
      }
    }

    return ans;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  bool canWalk(int day, int row, int col, const vector<vector<int>>& cells) {
    vector<vector<int>> matrix(row, vector<int>(col));
    for (int i = 0; i < day; ++i) {
      const int x = cells[i][0] - 1;
      const int y = cells[i][1] - 1;
      matrix[x][y] = 1;
    }

    queue<pair<int, int>> q;

    for (int j = 0; j < col; ++j)
      if (matrix[0][j] == 0) {
        q.emplace(0, j);
        matrix[0][j] = 1;
      }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == row || y < 0 || y == col)
          continue;
        if (matrix[x][y] == 1)
          continue;
        if (x == row - 1)
          return true;
        q.emplace(x, y);
        matrix[x][y] = 1;
      }
    }

    return false;
  }
};",1970
1969,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  bool validPath(int n, vector<vector<int>>& edges, int source,
                 int destination) {
    UnionFind uf(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      uf.unionByRank(u, v);
    }

    return uf.find(source) == uf.find(destination);
  }
};",1971
1970,"WITH
  TwoWayCalls AS (
    SELECT caller_id, recipient_id, call_time FROM Calls
    UNION ALL
    SELECT recipient_id, caller_id, call_time FROM Calls
  ),
  RankedCalls AS (
    SELECT
      caller_id,
      recipient_id,
      DATE(call_time) AS `date`,
      RANK() OVER(
        PARTITION BY caller_id, DATE(call_time)
        ORDER BY call_time ASC
      ) AS rank_asc
      RANK() OVER(
        PARTITION BY caller_id, DATE(call_time)
        ORDER BY call_time DESC
      ) AS rank_desc
    FROM TwoWayCalls
  )
SELECT DISTINCT caller_id AS user_id
FROM RankedCalls
WHERE rank_asc = 1 OR rank_desc = 1
GROUP BY caller_id, `date`
HAVING COUNT(DISTINCT recipient_id) = 1;",1972
1971,"struct T {
  long long sum;
  int count;
};

class Solution {
 public:
  int equalToDescendants(TreeNode* root) {
    return dfs(root).count;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return T{.sum = 0, .count = 0};
    T left = dfs(root->left);
    T right = dfs(root->right);
    return T{.sum = root->val + left.sum + right.sum,
             .count = left.count + right.count +
                      (root->val == left.sum + right.sum ? 1 : 0)};
  }
};",1973
1972,"class Solution {
 public:
  int minTimeToType(string word) {
    int moves = 0;
    char letter = 'a';

    for (const char c : word) {
      const int diff = abs(c - letter);
      moves += min(diff, 26 - diff);
      letter = c;
    }

    return moves + word.length();
  }
};",1974
1973,"class Solution {
 public:
  long long maxMatrixSum(vector<vector<int>>& matrix) {
    long long absSum = 0;
    int minAbs = INT_MAX;
    // 0 := even number of negatives
    // 1 := odd number of negatives
    int oddNeg = 0;

    for (const vector<int>& row : matrix)
      for (const int num : row) {
        absSum += abs(num);
        minAbs = min(minAbs, abs(num));
        if (num < 0)
          oddNeg ^= 1;
      }

    return absSum - oddNeg * minAbs * 2;
  }
};",1975
1974,"class Solution {
 public:
  int countPaths(int n, vector<vector<int>>& roads) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      const int w = road[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1);
  }

 private:
  // Similar to 1786. Number of Restricted Paths From First to Last Node
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    constexpr int kMod = 1'000'000'007;
    vector<long long> ways(graph.size());
    vector<long long> dist(graph.size(), LLONG_MAX);
    using P = pair<long long, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    ways[src] = 1;
    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (d > dist[u])
        continue;
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          ways[v] = ways[u];
          minHeap.emplace(dist[v], v);
        } else if (d + w == dist[v]) {
          ways[v] += ways[u];
          ways[v] %= kMod;
        }
    }

    return ways[dst];
  }
};",1976
1975,"class Solution {
 public:
  int numberOfCombinations(string num) {
    if (num[0] == '0')
      return 0;

    constexpr int kMod = 1'000'000'007;
    const int n = num.size();
    // dp[i][k] := the number of possible lists of integers ending in num[i]
    // with the length of the last number being 1..k
    vector<vector<long>> dp(n, vector<long>(n + 1));
    // lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)
    vector<vector<int>> lcs(n + 1, vector<int>(n + 1));

    for (int i = n - 1; i >= 0; --i)
      for (int j = i + 1; j < n; ++j)
        if (num[i] == num[j])
          lcs[i][j] = lcs[i + 1][j + 1] + 1;

    for (int i = 0; i < n; ++i)
      for (int k = 1; k <= i + 1; ++k) {
        dp[i][k] += dp[i][k - 1];
        dp[i][k] %= kMod;
        // The last number is num[s..i].
        const int s = i - k + 1;
        if (num[s] == '0')
          // the number of possible lists of integers ending in num[i] with the
          // length of the last number being k
          continue;
        if (s == 0) {
          // the whole string
          dp[i][k] += 1;
          continue;
        }
        if (s < k) {
          // The length k is not enough, so add the number of possible lists of
          // integers in num[0..s - 1].
          dp[i][k] += dp[s - 1][s];
          continue;
        }
        const int l = lcs[s - k][s];
        if (l >= k || num[s - k + l] <= num[s + l])
          // Have enough length k and num[s - k..s - 1] <= num[j..i].
          dp[i][k] += dp[s - 1][k];
        else
          // Have enough length k but num[s - k..s - 1] > num[j..i].
          dp[i][k] += dp[s - 1][k - 1];
      }

    return dp[n - 1][n] % kMod;
  }
};",1977
1976,"SELECT Employee.employee_id
FROM Employees AS Employee
LEFT JOIN Employees AS Manager
  ON (Employee.manager_id = Manager.employee_id)
WHERE
  Employee.salary < 30000
  AND Employee.manager_id IS NOT NULL
  AND Manager.employee_id IS NULL
ORDER BY 1;",1978
1977,"class Solution {
 public:
  int findGCD(vector<int>& nums) {
    return __gcd(ranges::min(nums), ranges::max(nums));
  }
};",1979
1978,"class Solution {
 public:
  string findDifferentBinaryString(vector<string>& nums) {
    const int bitSize = nums[0].length();
    const int maxNum = 1 << bitSize;
    unordered_set<int> numsSet;

    for (const string& num : nums)
      numsSet.insert(stoi(num, nullptr, 2));

    for (int num = 0; num < maxNum; ++num)
      if (!numsSet.count(num))
        return std::bitset<16>(num).to_string().substr(16 - bitSize);

    throw;
  }
};",1980
1979,"class Solution {
 public:
  int minimizeTheDifference(vector<vector<int>>& mat, int target) {
    const int minSum = getMinSum(mat);
    if (minSum >= target)  // No need to consider any larger combination.
      return minSum - target;

    const int maxSum = getMaxSum(mat);
    vector<vector<int>> mem(mat.size(), vector<int>(maxSum + 1, -1));
    return minimizeTheDifference(mat, 0, 0, target, mem);
  }

 private:
  int minimizeTheDifference(const vector<vector<int>>& mat, int i, int sum,
                            int target, vector<vector<int>>& mem) {
    if (i == mat.size())
      return abs(sum - target);
    if (mem[i][sum] != -1)
      return mem[i][sum];
    int res = INT_MAX;
    for (const int num : mat[i])
      res = min(res, minimizeTheDifference(mat, i + 1, sum + num, target, mem));
    return mem[i][sum] = res;
  }

  int getMinSum(const vector<vector<int>>& mat) {
    return accumulate(mat.begin(), mat.end(), 0,
                      [](int subtotal, const vector<int>& row) {
      return subtotal + ranges::min(row);
    });
  }

  int getMaxSum(const vector<vector<int>>& mat) {
    return accumulate(mat.begin(), mat.end(), 0,
                      [](int subtotal, const vector<int>& row) {
      return subtotal + ranges::max(row);
    });
  }
};",1981
1980,"class Solution {
 public:
  vector<int> recoverArray(int n, vector<int>& sums) {
    ranges::sort(sums);
    return recover(sums);
  }

 private:
  vector<int> recover(const vector<int>& sums) {
    if (sums.size() == 1)  // sums[0] must be 0.
      return {};

    // Either num or -num must be in the final array.
    //  num + sumsExcludingNum = sumsIncludingNum
    // -num + sumsIncludingNum = sumsExcludingNum
    unordered_map<int, int> count;
    for (const int sum : sums)
      ++count[sum];

    const int num = sums[1] - sums[0];
    vector<int> sumsExcludingNum;
    vector<int> sumsIncludingNum;
    bool chooseSumsIncludingNum = false;

    for (const int sum : sums) {
      if (count[sum] == 0)
        continue;
      --count[sum];
      --count[sum + num];
      sumsExcludingNum.push_back(sum);
      sumsIncludingNum.push_back(sum + num);
      if (sum + num == 0)
        chooseSumsIncludingNum = true;
    }

    // Choose `sumsExludingNum` by default since we want to gradually strip
    // `num` from each sum in `sums` to have the final array. However, we should
    // always choose the group of sums with 0 since it's a must-have.
    vector<int> recovered =
        recover(chooseSumsIncludingNum ? sumsIncludingNum : sumsExcludingNum);
    recovered.push_back(chooseSumsIncludingNum ? -num : num);
    return recovered;
  }
};",1982
1981,"class Solution {
 public:
  int widestPairOfIndices(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums1.size(); ++i) {
      prefix += nums1[i] - nums2[i];
      if (const auto it = prefixToIndex.find(prefix);
          it != prefixToIndex.cend())
        ans = max(ans, i - it->second);
      else
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};",1983
1982,"class Solution {
 public:
  int minimumDifference(vector<int>& nums, int k) {
    ranges::sort(nums);

    int ans = nums[k - 1] - nums[0];

    for (int i = k; i < nums.size(); ++i)
      ans = min(ans, nums[i] - nums[i - k + 1]);

    return ans;
  }
};",1984
1983,"class Solution {
 public:
  // Similar to 215. Kth Largest Element in an Array
  string kthLargestNumber(vector<string>& nums, int k) {
    auto compare = [](const string& a, const string& b) {
      return a.length() == b.length() ? a > b : a.length() > b.length();
    };
    priority_queue<string, vector<string>, decltype(compare)> minHeap(compare);

    for (const string& num : nums) {
      minHeap.push(num);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    return minHeap.top();
  }
};",1985
1984,"class Solution {
 public:
  int minSessions(vector<int>& tasks, int sessionTime) {
    for (int numSessions = 1; numSessions <= tasks.size(); ++numSessions)
      if (dfs(tasks, 0, vector<int>(numSessions), sessionTime))
        return numSessions;
    throw;
  }

  // Returns true if we can assign tasks[s..n) to `sessions`. Note that
  // `sessions` may be occupied by some tasks.
  bool dfs(const vector<int>& tasks, int s, vector<int>&& sessions,
           const int& sessionTime) {
    if (s == tasks.size())
      return true;

    for (int& session : sessions) {
      // Can't assign the tasks[s] to this session.
      if (session + tasks[s] > sessionTime)
        continue;
      // Assign the tasks[s] to this session.
      session += tasks[s];
      if (dfs(tasks, s + 1, move(sessions), sessionTime))
        return true;
      // Backtracking.
      session -= tasks[s];
      // If it's the first time we assign the tasks[s] to this session, then
      // future `session`s can't satisfy either.
      if (session == 0)
        return false;
    }

    return false;
  }
};",1986
1985,"class Solution {
 public:
  // Similar to 940. Distinct Subsequences II
  int numberOfUniqueGoodSubsequences(string binary) {
    constexpr int kMod = 1'000'000'007;
    // endsIn[i] := the number of subsequence that end in ('0' + i)
    vector<int> endsIn(2);

    for (const char c : binary) {
      endsIn[c - '0'] = (endsIn[0] + endsIn[1]) % kMod;
      // Don't count '0' since we want to avoid the leading zeros case.
      // However, we can always count '1'.
      if (c == '1')
        ++endsIn[1];
    }

    // Count '0' in the end.
    return (endsIn[0] + endsIn[1] +
            (binary.find('0') == string::npos ? 0 : 1)) %
           kMod;
  }
};",1987
1986,"SELECT
  Schools.school_id,
  IFNULL(MIN(Exam.score), -1) AS score
FROM Schools
LEFT JOIN Exam
  ON (capacity >= student_count)
GROUP BY 1;",1988
1987,"class Solution {
 public:
  int catchMaximumAmountofPeople(vector<int>& team, int dist) {
    int ans = 0;
    int i = 0;  // 0s index
    int j = 0;  // 1s index

    while (i < team.size() && j < team.size())
      if (i + dist < j || team[i] != 0) {
        // Find the next 0 that can be caught by 1.
        ++i;
      } else if (j + dist < i || team[j] != 1) {
        // Find the next 1 that can catch 0.
        ++j;
      } else {
        // team[j] catches team[i], so move both.
        ++ans;
        ++i;
        ++j;
      }

    return ans;
  }
};",1989
1988,"WITH
  Platforms AS (
    SELECT 'Android' AS platform
    UNION ALL
    SELECT 'IOS' AS platform
    UNION ALL
    SELECT 'Web' AS platform
  ),
  ExperimentNames AS (
    SELECT 'Reading' AS experiment_name
    UNION ALL
    SELECT 'Sports'
    UNION ALL
    SELECT 'Programming'
  )
SELECT
  Platforms.platform,
  ExperimentNames.experiment_name,
  COUNT(experiment_id) AS num_experiments
FROM Platforms
CROSS JOIN ExperimentNames
LEFT JOIN Experiments
  USING (platform, experiment_name)
GROUP BY 1, 2;",1990
1989,"class Solution {
 public:
  int findMiddleIndex(vector<int>& nums) {
    int prefix = 0;
    int suffix = accumulate(nums.begin(), nums.end(), 0);

    for (int i = 0; i < nums.size(); ++i) {
      suffix -= nums[i];
      if (prefix == suffix)
        return i;
      prefix += nums[i];
    }

    return -1;
  }
};",1991
1990,"class Solution {
 public:
  vector<vector<int>> findFarmland(vector<vector<int>>& land) {
    vector<vector<int>> ans;

    for (int i = 0; i < land.size(); ++i)
      for (int j = 0; j < land[0].size(); ++j)
        if (land[i][j] == 1) {
          int x = i;
          int y = j;
          dfs(land, i, j, x, y);
          ans.push_back({i, j, x, y});
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& land, int i, int j, int& x, int& y) {
    if (i < 0 || i == land.size() || j < 0 || j == land[0].size())
      return;
    if (land[i][j] != 1)
      return;
    land[i][j] = 2;  // Mark as visited.
    x = max(x, i);
    y = max(y, j);
    dfs(land, i + 1, j, x, y);
    dfs(land, i, j + 1, x, y);
  }
};",1992
1991,"lock(num: int, user: int)",1993
1992,"class Solution {
 public:
  int numberOfGoodSubsets(vector<int>& nums) {
    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    const int n = 1 << primes.size();
    const int maxNum = ranges::max(nums);
    vector<long> dp(n);
    vector<int> count(maxNum + 1);

    dp[0] = 1;

    for (const int num : nums)
      ++count[num];

    for (int num = 2; num <= maxNum; ++num) {
      if (count[num] == 0)
        continue;
      if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0)
        continue;
      const int numPrimesMask = getPrimesMask(num, primes);
      for (int primesMask = 0; primesMask < n; ++primesMask) {
        if ((primesMask & numPrimesMask) > 0)
          continue;
        const int nextPrimesMask = primesMask | numPrimesMask;
        dp[nextPrimesMask] += dp[primesMask] * count[num];
        dp[nextPrimesMask] %= kMod;
      }
    }

    return modPow(2, count[1]) *
           (accumulate(dp.begin() + 1, dp.end(), 0L) % kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int getPrimesMask(int num, const vector<int>& primes) {
    int primesMask = 0;
    for (int i = 0; i < primes.size(); ++i)
      if (num % primes[i] == 0)
        primesMask |= 1 << i;
    return primesMask;
  }

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",1994
1993,"class Solution {
 public:
  int countQuadruplets(std::vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;

    for (int a = 0; a < n; ++a)
      for (int b = a + 1; b < n; ++b)
        for (int c = b + 1; c < n; ++c)
          for (int d = c + 1; d < n; ++d)
            if (nums[a] + nums[b] + nums[c] == nums[d])
              ++ans;

    return ans;
  }
};",1995
1994,"class Solution {
 public:
  int numberOfWeakCharacters(vector<vector<int>>& properties) {
    // Sort properties by `attack` in descending order, then by `defense` in
    // ascending order.
    ranges::sort(properties, [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];
    });

    int ans = 0;
    int maxDefense = 0;

    for (const vector<int>& property : properties) {
      const int defense = property[1];
      if (defense < maxDefense)
        ++ans;
      maxDefense = max(maxDefense, defense);
    }

    return ans;
  }
};",1996
1995,"class Solution {
 public:
  int firstDayBeenInAllRooms(vector<int>& nextVisit) {
    constexpr int kMod = 1'000'000'007;
    const int n = nextVisit.size();
    // dp[i] := the number of days to visit room i for the first time
    vector<int> dp(n);

    // Whenever we visit i, visit times of room[0..i - 1] are all even.
    // Therefore, the rooms before i can be seen as reset and we can safely
    // reuse dp[0..i - 1] as first-time visit to get second-time visit.
    for (int i = 1; i < n; ++i)
      // The total days to visit room[i] is the sum of
      //   * dp[i - 1]: 1st-time visit room[i - 1]
      //   * 1: visit room[nextVisit[i - 1]]
      //   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]
      //   * 1: visit room[i]
      dp[i] = (2L * dp[i - 1] - dp[nextVisit[i - 1]] + 2 + kMod) % kMod;

    return dp.back();
  }
};",1997
1996,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  bool gcdSort(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    const vector<int> minPrimeFactors = sieveEratosthenes(maxNum + 1);
    UnionFind uf(maxNum + 1);

    for (const int num : nums)
      for (const int primeFactor : getPrimeFactors(num, minPrimeFactors))
        uf.unionByRank(num, primeFactor);

    vector<int> sortedNums(nums);
    ranges::sort(sortedNums);

    for (int i = 0; i < nums.size(); ++i)
      // Can't swap nums[i] with sortedNums[i].
      if (uf.find(nums[i]) != uf.find(sortedNums[i]))
        return false;

    return true;
  }

 private:
  // Gets the minimum prime factor of i, where 1 < i <= n.
  vector<int> sieveEratosthenes(int n) {
    vector<int> minPrimeFactors(n + 1);
    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);
    for (int i = 2; i * i < n; ++i)
      if (minPrimeFactors[i] == i)  // `i` is prime.
        for (int j = i * i; j < n; j += i)
          minPrimeFactors[j] = min(minPrimeFactors[j], i);
    return minPrimeFactors;
  }

  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactors) {
    vector<int> primeFactors;
    while (num > 1) {
      const int divisor = minPrimeFactors[num];
      primeFactors.push_back(divisor);
      while (num % divisor == 0)
        num /= divisor;
    }
    return primeFactors;
  }
};",1998
1997,"class Solution {
 public:
  int findInteger(int k, int digit1, int digit2) {
    const int minDigit = min(digit1, digit2);
    const int maxDigit = max(digit1, digit2);
    const vector<int> digits = minDigit == maxDigit
                                   ? vector<int>{minDigit}
                                   : vector<int>{minDigit, maxDigit};
    queue<int> q;

    for (const int digit : digits)
      q.push(digit);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      if (u > k && u % k == 0)
        return u;
      if (u == 0)
        continue;
      for (const int digit : digits) {
        const long nextNum = u * 10L + digit;
        if (nextNum > INT_MAX)
          continue;
        q.push(nextNum);
      }
    }

    return -1;
  }
};",1999
1998,"class Solution {
 public:
  string reversePrefix(string word, char ch) {
    reverse(word.begin(), word.begin() + word.find(ch) + 1);
    return word;
  }
};",2000
1999,"class Solution {
 public:
  long long interchangeableRectangles(vector<vector<int>>& rectangles) {
    long long ans = 0;
    unordered_map<double, int> ratioCount;

    for (const vector<int>& r : rectangles)
      ++ratioCount[(double)r[0] / r[1]];

    for (const auto& [_, count] : ratioCount)
      ans += static_cast<long>(count) * (count - 1) / 2;

    return ans;
  }
};",2001
2000,"class Solution {
 public:
  int maxProduct(string s) {
    size_t ans = 0;
    dfs(s, 0, """", """", ans);
    return ans;
  }

 private:
  void dfs(const string& s, int i, string&& s1, string&& s2, size_t& ans) {
    if (i == s.length()) {
      if (isPalindrome(s1) && isPalindrome(s2))
        ans = max(ans, s1.length() * s2.length());
      return;
    }

    s1.push_back(s[i]);
    dfs(s, i + 1, move(s1), move(s2), ans);
    s1.pop_back();

    s2.push_back(s[i]);
    dfs(s, i + 1, move(s1), move(s2), ans);
    s2.pop_back();

    dfs(s, i + 1, move(s1), move(s2), ans);
  }

  bool isPalindrome(const string& s) {
    int i = 0;
    int j = s.length() - 1;
    while (i < j) {
      if (s[i] != s[j])
        return false;
      ++i;
      --j;
    }
    return true;
  }
};",2002
2001,"class Solution {
 public:
  vector<int> smallestMissingValueSubtree(vector<int>& parents,
                                          vector<int>& nums) {
    const int n = parents.size();
    vector<int> ans(n, 1);
    vector<vector<int>> tree(n);
    unordered_set<int> seen;
    int minMiss = 1;

    for (int i = 1; i < n; ++i)
      tree[parents[i]].push_back(i);

    int nodeThatsOne = getNode(nums);
    if (nodeThatsOne == -1)
      return ans;

    int u = nodeThatsOne;
    int prev = -1;  // the u that just handled

    // Upward from `nodeThatsOne` to the root `u`.
    while (u != -1) {
      for (const int v : tree[u]) {
        if (v == prev)
          continue;
        dfs(v, tree, seen, nums);
      }
      seen.insert(nums[u]);
      while (seen.count(minMiss))
        ++minMiss;
      ans[u] = minMiss;
      prev = u;
      u = parents[u];
    }

    return ans;
  }

 private:
  int getNode(const vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == 1)
        return i;
    return -1;
  }

  void dfs(int u, const vector<vector<int>>& tree, unordered_set<int>& seen,
           const vector<int>& nums) {
    seen.insert(nums[u]);
    for (const int v : tree[u])
      dfs(v, tree, seen, nums);
  }
};",2003
2002,"WITH
  AccumualtedCandidates AS (
    SELECT
      employee_id,
      experience,
      ROW_NUMBER() OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS candidate_count,
      SUM(salary) OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS accumulated_salary
    FROM Candidates
  ),
  MaxHiredSeniors AS (
    SELECT
      IFNULL(MAX(candidate_count), 0) AS accepted_candidates,
      IFNULL(MAX(accumulated_salary), 0) AS accumulated_salary
    FROM AccumualtedCandidates
    WHERE
      experience = 'Senior'
      AND accumulated_salary < 70000
  )
SELECT
  'Senior' AS experience,
  accepted_candidates
FROM MaxHiredSeniors
UNION ALL
SELECT
  'Junior' AS experience,
  COUNT(*) AS accepted_candidates
FROM AccumualtedCandidates AS Juniors
WHERE
  experience = 'Junior'
  AND Juniors.accumulated_salary < (
    SELECT 70000 - MaxHiredSeniors.accumulated_salary
    FROM MaxHiredSeniors
  );",2004
2003,"class Solution {
 public:
  bool findGameWinner(int n) {
    return n % 6 != 1;
  }
};",2005
2004,"class Solution {
 public:
  int countKDifference(vector<int>& nums, int k) {
    constexpr int kMax = 100;
    int ans = 0;
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = k + 1; i <= kMax; ++i)
      ans += count[i] * count[i - k];

    return ans;
  }
};",2006
2005,"class Solution {
 public:
  vector<int> findOriginalArray(vector<int>& changed) {
    vector<int> ans;
    queue<int> q;

    ranges::sort(changed);

    for (const int num : changed)
      if (!q.empty() && num == q.front()) {
        q.pop();
      } else {
        q.push(num * 2);
        ans.push_back(num);
      }

    return q.empty() ? ans : vector<int>();
  }
};",2007
2006,start,2008
2007,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
    const int n = nums.size();
    int ans = n;

    ranges::sort(nums);
    nums.erase(unique(nums.begin(), nums.end()), nums.end());

    for (int i = 0; i < nums.size(); ++i) {
      const int start = nums[i];
      const int end = start + n - 1;
      const int index = firstGreater(nums, end);
      const int uniqueLength = index - i;
      ans = min(ans, n - uniqueLength);
    }

    return ans;
  }

 private:
  int firstGreater(const vector<int>& A, int target) {
    return ranges::upper_bound(A, target) - A.begin();
  }
};",2009
2008,"WITH
  AccumualtedCandidates AS (
    SELECT
      employee_id,
      experience,
      ROW_NUMBER() OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS candidate_count,
      SUM(salary) OVER(
        PARTITION BY experience
        ORDER BY salary, employee_id
      ) AS accumulated_salary
    FROM Candidates
  ),
  HiredSeniors AS (
    SELECT
      employee_id,
      accumulated_salary
    FROM AccumualtedCandidates
    WHERE
      experience = 'Senior'
      AND accumulated_salary < 70000
  )
SELECT HiredSeniors.employee_id
FROM HiredSeniors
UNION ALL
SELECT Juniors.employee_id
FROM AccumualtedCandidates AS Juniors
WHERE
  experience = 'Junior'
  AND Juniors.accumulated_salary < (
    SELECT 70000 - IFNULL(MAX(accumulated_salary), 0)
    FROM AccumualtedCandidates
    WHERE
      experience = 'Senior'
      AND accumulated_salary < 70000
  );",2010
2009,"class Solution {
 public:
  int finalValueAfterOperations(vector<string>& operations) {
    int ans = 0;

    for (const string& op : operations)
      ans += op[1] == '+' ? 1 : -1;

    return ans;
  }
};",2011
2010,"class Solution {
 public:
  int sumOfBeauties(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    vector<int> minOfRight(n);
    minOfRight.back() = nums.back();

    for (int i = n - 2; i >= 2; --i)
      minOfRight[i] = min(nums[i], minOfRight[i + 1]);

    int maxOfLeft = nums[0];

    for (int i = 1; i <= n - 2; ++i) {
      if (maxOfLeft < nums[i] && nums[i] < minOfRight[i + 1])
        ans += 2;
      else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1])
        ans += 1;
      maxOfLeft = max(maxOfLeft, nums[i]);
    }

    return ans;
  }
};",2012
2011,add(point: List[int]),2013
2012,"class Solution {
 public:
  string longestSubsequenceRepeatedK(string s, int k) {
    string ans;
    vector<int> count(26);
    vector<char> possibleChars;
    // Stores subsequences, where the length grows by 1 each time.
    queue<string> q{{""""}};

    for (const char c : s)
      ++count[c - 'a'];

    for (char c = 'a'; c <= 'z'; ++c)
      if (count[c - 'a'] >= k)
        possibleChars.push_back(c);

    while (!q.empty()) {
      const string currSubseq = q.front();
      q.pop();
      if (currSubseq.length() * k > s.length())
        return ans;
      for (const char c : possibleChars) {
        const string& newSubseq = currSubseq + c;
        if (isSubsequence(newSubseq, s, k)) {
          q.push(newSubseq);
          ans = newSubseq;
        }
      }
    }

    return ans;
  }

 private:
  bool isSubsequence(const string& subseq, string& s, int k) {
    int i = 0;  // subseq's index
    for (const char c : s)
      if (c == subseq[i])
        if (++i == subseq.length()) {
          if (--k == 0)
            return true;
          i = 0;
        }
    return false;
  }
};",2014
2013,"class Solution {
 public:
  vector<vector<int>> averageHeightOfBuildings(vector<vector<int>>& buildings) {
    vector<vector<int>> ans;
    vector<pair<int, int>> events;

    for (const vector<int>& b : buildings) {
      const int start = b[0];
      const int end = b[1];
      const int height = b[2];
      events.emplace_back(start, height);
      events.emplace_back(end, -height);
    }

    ranges::sort(events);

    int prev = 0;
    int count = 0;
    int sumHeight = 0;

    for (const auto& [curr, h] : events) {
      const int height = abs(h);
      if (sumHeight > 0 && curr > prev) {
        const int avgHeight = sumHeight / count;
        if (!ans.empty() && ans.back()[1] == prev && avgHeight == ans.back()[2])
          ans.back()[1] = curr;
        else
          ans.push_back({prev, curr, avgHeight});
      }
      sumHeight += h;
      count += h > 0 ? 1 : -1;
      prev = curr;
    }

    return ans;
  }
};",2015
2014,"class Solution {
 public:
  int maximumDifference(vector<int>& nums) {
    int ans = -1;
    int min = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
      if (nums[i] > min)
        ans = max(ans, nums[i] - min);
      min = std::min(min, nums[i]);
    }

    return ans;
  }
};",2016
2015,"class Solution {
 public:
  long long gridGame(vector<vector<int>>& grid) {
    const int n = grid[0].size();
    long long ans = LLONG_MAX;
    long long sumRow0 = accumulate(grid[0].begin(), grid[0].end(), 0LL);
    long long sumRow1 = 0;

    for (int i = 0; i < n; ++i) {
      sumRow0 -= grid[0][i];
      ans = min(ans, max(sumRow0, sumRow1));
      sumRow1 += grid[1][i];
    }

    return ans;
  }
};",2017
2016,"class Solution {
 public:
  bool placeWordInCrossword(vector<vector<char>>& board, string word) {
    for (const vector<vector<char>>& state : {board, getRotated(board)})
      for (const vector<char>& chars : state)
        for (const string& token : getTokens(join(chars)))
          for (const string& letters :
               {word, string(word.rbegin(), word.rend())})
            if (letters.length() == token.length())
              if (canFit(letters, token))
                return true;
    return false;
  }

 private:
  vector<vector<char>> getRotated(const vector<vector<char>>& board) {
    const int m = board.size();
    const int n = board[0].size();
    vector<vector<char>> rotated(n, vector<char>(m));
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        rotated[j][i] = board[i][j];
    return rotated;
  }

  vector<string> getTokens(const string& row) {
    vector<string> tokens;
    int start = 0;
    int end;
    string token;
    do {
      end = row.find('#', start);
      token = row.substr(start, end - start);
      if (!token.empty())
        tokens.push_back(token);
      start = end + 1;
    } while (end != string::npos);
    return tokens;
  }

  string join(const vector<char>& chars) {
    string joined;
    for (const char c : chars)
      joined += c;
    return joined;
  }

  bool canFit(const string& letters, const string& token) {
    for (int i = 0; i < letters.length(); ++i)
      if (token[i] != ' ' && token[i] != letters[i])
        return false;
    return true;
  }
};",2018
2017,"class Solution {
 public:
  int scoreOfStudents(string s, vector<int>& answers) {
    const int n = s.length() / 2 + 1;
    const unordered_map<char, function<int(int, int)>> func{
        {'+', plus<int>()}, {'*', multiplies<int>()}};
    int ans = 0;
    vector<vector<unordered_set<int>>> dp(n, vector<unordered_set<int>>(n));
    unordered_map<int, int> count;

    for (int i = 0; i < n; ++i)
      dp[i][i].insert(s[i * 2] - '0');

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        for (int k = i; k < j; ++k) {
          const char op = s[k * 2 + 1];
          for (const int a : dp[i][k])
            for (const int b : dp[k + 1][j]) {
              const int res = func.at(op)(a, b);
              if (res <= 1000)
                dp[i][j].insert(res);
            }
        }
      }

    const int correctAnswer = eval(s);

    for (const int answer : answers)
      ++count[answer];

    for (const auto& [answer, freq] : count)
      if (answer == correctAnswer)
        ans += 5 * freq;
      else if (dp[0][n - 1].count(answer))
        ans += 2 * freq;

    return ans;
  }

 private:
  int eval(const string& s) {
    int ans = 0;
    int prevNum = 0;
    int currNum = 0;
    char op = '+';

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c))
        currNum = currNum * 10 + (c - '0');
      if (!isdigit(c) || i == s.length() - 1) {
        if (op == '+') {
          ans += prevNum;
          prevNum = currNum;
        } else if (op == '*') {
          prevNum = prevNum * currNum;
        }
        op = c;
        currNum = 0;
      }
    }

    return ans + prevNum;
  }
};",2019
2018,"SELECT COUNT(Subscriptions.account_id) AS accounts_count
FROM Subscriptions
LEFT JOIN Streams
  USING (account_id)
WHERE
  2021 BETWEEN YEAR(Subscriptions.start_date) AND YEAR(Subscriptions.end_date)
  AND YEAR(Streams.stream_date) != 2021;",2020
2019,"class Solution {
 public:
  int brightestPosition(vector<vector<int>>& lights) {
    int ans = INT_MAX;
    int maxBrightness = -1;
    int currBrightness = 0;
    map<int, int> line;

    for (const vector<int>& light : lights) {
      const int position = light[0];
      const int range = light[1];
      ++line[position - range];
      --line[position + range + 1];
    }

    for (const auto& [pos, brightness] : line) {
      currBrightness += brightness;
      if (currBrightness > maxBrightness) {
        maxBrightness = currBrightness;
        ans = pos;
      }
    }

    return ans;
  }
};",2021
2020,"class Solution {
 public:
  vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
    if (original.size() != m * n)
      return {};

    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < original.size(); ++i)
      ans[i / n][i % n] = original[i];

    return ans;
  }
};",2022
2021,"class Solution {
 public:
  int numOfPairs(vector<string>& nums, string target) {
    const int n = target.length();
    int ans = 0;
    unordered_map<string, int> count;

    for (const string& num : nums) {
      const int k = num.length();
      if (k >= n)
        continue;
      if (target.substr(0, k) == num)
        ans += count[target.substr(k)];
      if (target.substr(n - k) == num)
        ans += count[target.substr(0, n - k)];
      ++count[num];
    }

    return ans;
  }
};",2023
2022,"class Solution {
 public:
  int maxConsecutiveAnswers(string answerKey, int k) {
    int ans = 0;
    int maxCount = 0;
    vector<int> count(2);

    for (int l = 0, r = 0; r < answerKey.length(); ++r) {
      maxCount = max(maxCount, ++count[answerKey[r] == 'T']);
      while (maxCount + k < r - l + 1)
        --count[answerKey[l++] == 'T'];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",2024
2023,"class Solution {
 public:
  int waysToPartition(vector<int>& nums, int k) {
    const int n = nums.size();
    const long sum = accumulate(nums.begin(), nums.end(), 0L);
    long prefix = 0;
    // count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)
    unordered_map<long, int> l;
    // count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)
    unordered_map<long, int> r;

    for (int pivot = 1; pivot < n; ++pivot) {
      prefix += nums[pivot - 1];
      const long suffix = sum - prefix;
      ++r[prefix - suffix];
    }

    int ans = r[0];
    prefix = 0;

    for (const int num : nums) {
      ans = max(ans, l[k - num] + r[num - k]);
      prefix += num;
      const long suffix = sum - prefix;
      const long diff = prefix - suffix;
      --r[diff];
      ++l[diff];
    }

    return ans;
  }
};",2025
2024,"SELECT problem_id
FROM Problems
WHERE likes / (likes + dislikes) < 0.6
ORDER BY 1;",2026
2025,"class Solution {
 public:
  int minimumMoves(string s) {
    int ans = 0;

    for (int i = 0; i < s.length();)
      if (s[i] == 'O') {
        ++i;
      } else {
        ++ans;
        i += 3;
      }

    return ans;
  }
};",2027
2026,"class Solution {
 public:
  vector<int> missingRolls(vector<int>& rolls, int mean, int n) {
    const int targetSum = (rolls.size() + n) * mean;
    int missingSum = targetSum - accumulate(rolls.begin(), rolls.end(), 0);
    if (missingSum > n * 6 || missingSum < n)
      return {};

    vector<int> ans(n, missingSum / n);
    missingSum %= n;
    for (int i = 0; i < missingSum; ++i)
      ++ans[i];

    return ans;
  }
};",2028
2027,"class Solution {
 public:
  bool stoneGameIX(vector<int>& stones) {
    vector<int> count(3);

    for (const int stone : stones)
      ++count[stone % 3];

    if (count[0] % 2 == 0)
      return min(count[1], count[2]) > 0;
    return abs(count[1] - count[2]) > 2;
  }
};",2029
2028,"class Solution {
 public:
  string smallestSubsequence(string s, int k, char letter, int repetition) {
    string ans;
    vector<char> stack;
    int required = repetition;
    int nLetters = ranges::count(s, letter);

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      while (!stack.empty() && stack.back() > c &&
             stack.size() + s.length() - i - 1 >= k &&
             (stack.back() != letter || nLetters > required)) {
        const char popped = stack.back();
        stack.pop_back();
        if (popped == letter)
          ++required;
      }
      if (stack.size() < k)
        if (c == letter) {
          stack.push_back(c);
          --required;
        } else if (k > stack.size() + required) {
          stack.push_back(c);
        }
      if (c == letter)
        --nLetters;
    }

    for (const char c : stack)
      ans += c;

    return ans;
  }
};",2030
2029,"class FenwickTree {
 public:
  FenwickTree(int n) : n(n), sums(2 * n + 1) {}

  void update(int i, int delta) {
    i += n + 1;  // re-mapping
    while (i < sums.size()) {
      sums[i] += delta;
      i += i & -i;
    }
  }

  int get(int i) {
    i += n + 1;  // re-mapping
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= i & -i;
    }
    return sum;
  }

 private:
  const int n;
  vector<int> sums;
};

class Solution {
 public:
  int subarraysWithMoreZerosThanOnes(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    int prefix = 0;
    FenwickTree tree(nums.size());
    tree.update(0, 1);

    for (const int num : nums) {
      prefix += num == 0 ? -1 : 1;
      ans += tree.get(prefix - 1);
      ans %= kMod;
      tree.update(prefix, 1);
    }

    return ans;
  }
};",2031
2030,"class Solution {
 public:
  vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2,
                            vector<int>& nums3) {
    vector<int> ans;
    vector<int> count(101);

    for (const vector<int>& nums : {nums1, nums2, nums3})
      update(count, nums);

    for (int i = 1; i <= 100; ++i)
      if (count[i] >= 2)
        ans.push_back(i);

    return ans;
  }

 private:
  void update(vector<int>& count, const vector<int>& nums) {
    for (const int num : unordered_set<int>(nums.begin(), nums.end()))
      ++count[num];
  }
};",2032
2031,"class Solution {
 public:
  int minOperations(vector<vector<int>>& grid, int x) {
    vector<int> A;
    for (const vector<int>& row : grid)
      A.insert(A.end(), row.begin(), row.end());
    if (ranges::any_of(A, [&](int a) { return (a - A[0]) % x; }))
      return -1;

    int ans = 0;

    nth_element(A.begin(), A.begin() + A.size() / 2, A.end());

    for (const int a : A)
      ans += abs(a - A[A.size() / 2]) / x;

    return ans;
  }
};",2033
2032,"update(timestamp: int, price: int)",2034
2033,"class Solution {
 public:
  int minimumDifference(vector<int>& nums) {
    const int n = nums.size() / 2;
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    const int goal = sum / 2;
    const vector<int> lNums(nums.begin(), nums.begin() + n);
    const vector<int> rNums(nums.begin() + n, nums.end());
    int ans = INT_MAX;
    vector<vector<int>> lSums(n + 1);
    vector<vector<int>> rSums(n + 1);

    dfs(lNums, 0, 0, 0, lSums);
    dfs(rNums, 0, 0, 0, rSums);

    for (int lCount = 0; lCount <= n; ++lCount) {
      auto& l = lSums[lCount];
      auto& r = rSums[n - lCount];
      ranges::sort(r);
      for (const int lSum : l) {
        const int i = firstGreaterEqual(r, goal - lSum);
        if (i < r.size()) {
          const int sumPartOne = sum - lSum - r[i];
          const int sumPartTwo = sum - sumPartOne;
          ans = min(ans, abs(sumPartOne - sumPartTwo));
        }
        if (i > 0) {
          const int sumPartOne = sum - lSum - r[i - 1];
          const int sumPartTwo = sum - sumPartOne;
          ans = min(ans, abs(sumPartOne - sumPartTwo));
        }
      }
    }

    return ans;
  }

 private:
  void dfs(const vector<int>& A, int i, int count, int path,
           vector<vector<int>>& sums) {
    if (i == A.size()) {
      sums[count].push_back(path);
      return;
    }
    dfs(A, i + 1, count + 1, path + A[i], sums);
    dfs(A, i + 1, count, path, sums);
  }

  int firstGreaterEqual(const vector<int>& A, int target) {
    return ranges::lower_bound(A, target) - A.begin();
  }
};",2035
2034,"class Solution {
 public:
  long long maximumAlternatingSubarraySum(vector<int>& nums) {
    long long ans = INT_MIN;
    long long even = 0;  // the subarray sum starting from an even index
    long long odd = 0;   // the subarray sum starting from an odd index

    for (int i = 0; i < nums.size(); ++i) {
      if ((i & 1) == 0)  // Must pick.
        even += nums[i];
      else  // Start a fresh subarray or subtract `nums[i]`.
        even = max(0LL, even - nums[i]);
      ans = max(ans, even);
    }

    for (int i = 1; i < nums.size(); ++i) {
      if ((i & 1) == 1)  // Must pick.
        odd += nums[i];
      else  // Start a fresh subarray or subtract `nums[i]`.
        odd = max(0LL, odd - nums[i]);
      ans = max(ans, odd);
    }

    return ans;
  }
};",2036
2035,"class Solution {
 public:
  int minMovesToSeat(vector<int>& seats, vector<int>& students) {
    int ans = 0;

    ranges::sort(seats);
    ranges::sort(students);

    for (int i = 0; i < seats.size(); ++i)
      ans += abs(seats[i] - students[i]);

    return ans;
  }
};",2037
2036,"class Solution {
 public:
  bool winnerOfGame(string colors) {
    int countAAA = 0;
    int countBBB = 0;

    for (int i = 1; i + 1 < colors.length(); ++i)
      if (colors[i - 1] == colors[i] && colors[i] == colors[i + 1])
        if (colors[i] == 'A')
          ++countAAA;
        else
          ++countBBB;

    return countAAA > countBBB;
  }
};",2038
2037,"class Solution {
 public:
  int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {
    const int n = patience.size();
    int ans = 0;
    vector<vector<int>> graph(n);
    queue<int> q{{0}};
    vector<int> dist(n, INT_MAX);  // dist[i] := the distance between i and 0
    dist[0] = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u])
          if (dist[v] == INT_MAX) {
            dist[v] = dist[u] + 1;
            q.push(v);
          }
      }
    }

    for (int i = 1; i < n; ++i) {
      const int numResending = (dist[i] * 2 - 1) / patience[i];
      const int lastResendingTime = patience[i] * numResending;
      const int lastArrivingTime = lastResendingTime + dist[i] * 2;
      ans = max(ans, lastArrivingTime);
    }

    return ans + 1;
  }
};",2039
2038,"class Solution {
 public:
  long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2,
                               long long k) {
    vector<int> A1;
    vector<int> A2;
    vector<int> B1;
    vector<int> B2;

    seperate(nums1, A1, A2);
    seperate(nums2, B1, B2);

    const long negCount = A1.size() * B2.size() + A2.size() * B1.size();
    int sign = 1;

    if (k > negCount) {
      k -= negCount;  //  Find (k - negCount)-th positive.
    } else {
      k = negCount - k + 1;  // Find (negCount - k + 1)-th abs(negative).
      sign = -1;
      swap(B1, B2);
    }

    long l = 0;
    long r = 1e10;

    while (l < r) {
      const long m = (l + r) / 2;
      if (numProductNoGreaterThan(A1, B1, m) +
              numProductNoGreaterThan(A2, B2, m) >=
          k)
        r = m;
      else
        l = m + 1;
    }

    return sign * l;
  }

 private:
  void seperate(const vector<int>& A, vector<int>& A1, vector<int>& A2) {
    for (const int a : A)
      if (a < 0)
        A1.push_back(-a);
      else
        A2.push_back(a);
    reverse(A1.begin(), A1.end());  // Reverse to sort ascending
  }

  long numProductNoGreaterThan(const vector<int>& A, const vector<int>& B,
                               long m) {
    long count = 0;
    int j = B.size() - 1;
    // For each a, find the first index j s.t. a * B[j] <= m
    // So numProductNoGreaterThan m for this row will be j + 1
    for (const long a : A) {
      while (j >= 0 && a * B[j] > m)
        --j;
      count += j + 1;
    }
    return count;
  }
};",2040
2039,"SELECT Candidates.candidate_id
FROM Candidates
INNER JOIN Rounds
  USING (interview_id)
WHERE Candidates.years_of_exp >= 2
GROUP BY 1
HAVING SUM(Rounds.score) > 15;",2041
2040,"class Solution {
 public:
  bool areNumbersAscending(string s) {
    int prev = 0;
    istringstream iss(s);

    for (string token; iss >> token;)
      if (isdigit(token[0])) {
        const int num = stoi(token);
        if (num <= prev)
          return false;
        prev = num;
      }

    return true;
  }
};",2042
2041,"transfer(account1: int, account2: int, money: int)",2043
2042,"class Solution {
 public:
  int countMaxOrSubsets(vector<int>& nums) {
    const int ors = accumulate(nums.begin(), nums.end(), 0, bit_or<>());
    int ans = 0;
    dfs(nums, 0, 0, ors, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int i, int path, const int& ors, int& ans) {
    if (i == nums.size()) {
      if (path == ors)
        ++ans;
      return;
    }

    dfs(nums, i + 1, path, ors, ans);
    dfs(nums, i + 1, path | nums[i], ors, ans);
  }
};",2044
2043,"class Solution {
 public:
  int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
    vector<vector<int>> graph(n + 1);
    queue<pair<int, int>> q{{{1, 0}}};
    // minTime[i][0] := the first minimum time to reach the node i
    // minTime[i][1] := the second minimum time to reach the node i
    vector<vector<int>> minTime(n + 1, vector<int>(2, INT_MAX));
    minTime[1][0] = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    while (!q.empty()) {
      const auto [i, prevTime] = q.front();
      q.pop();
      // Start from green.
      // If `numChangeSignal` is odd, now red.
      // If `numChangeSignal` is even, now green.
      const int numChangeSignal = prevTime / change;
      const int waitTime =
          numChangeSignal & 1 ? change - (prevTime % change) : 0;
      const int newTime = prevTime + waitTime + time;
      for (const int j : graph[i])
        if (newTime < minTime[j][0]) {
          minTime[j][0] = newTime;
          q.emplace(j, newTime);
        } else if (minTime[j][0] < newTime && newTime < minTime[j][1]) {
          if (j == n)
            return newTime;
          minTime[j][1] = newTime;
          q.emplace(j, newTime);
        }
    }

    throw;
  }
};",2045
2044,"class Solution {
 public:
  ListNode* sortLinkedList(ListNode* head) {
    ListNode* prev = head;
    ListNode* curr = head->next;

    while (curr)
      if (curr->val < 0) {
        prev->next = curr->next;
        curr->next = head;
        head = curr;
        curr = prev->next;
      } else {
        prev = curr;
        curr = curr->next;
      }

    return head;
  }
};",2046
2045,"class Solution {
 public:
  int countValidWords(string sentence) {
    int ans = 0;
    istringstream iss(sentence);

    for (string token; iss >> token;)
      if (isValid(token))
        ++ans;

    return ans;
  }

 private:
  bool isValid(const string& token) {
    int countHyphen = 0;
    for (int i = 0; i < token.length(); ++i) {
      const char c = token[i];
      if (isdigit(c))
        return false;
      if (c == '-') {
        if (i == 0 || !isalpha(token[i - 1]))
          return false;
        if (i + 1 == token.length() || !isalpha(token[i + 1]))
          return false;
        if (++countHyphen > 1)
          return false;
      } else if (c == '!' || c == '.' || c == ',') {
        if (i != token.length() - 1)
          return false;
      }
    }
    return true;
  }
};",2047
2046,"class Solution {
 public:
  int nextBeautifulNumber(int n) {
    while (!isBalance(++n))
      ;
    return n;
  }

 private:
  bool isBalance(int num) {
    vector<int> count(10);
    while (num) {
      if (num % 10 == 0)
        return false;
      ++count[num % 10];
      num /= 10;
    }
    for (int i = 1; i < 10; ++i)
      if (count[i] && count[i] != i)
        return false;
    return true;
  }
};",2048
2047,"class Solution {
 public:
  int countHighestScoreNodes(vector<int>& parents) {
    int ans = 0;
    vector<vector<int>> tree(parents.size());

    for (int i = 0; i < parents.size(); ++i) {
      if (parents[i] == -1)
        continue;
      tree[parents[i]].push_back(i);
    }

    dfs(tree, 0, 0, ans);
    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& tree, int u, long&& maxScore, int& ans) {
    int count = 1;
    long score = 1;
    for (const int v : tree[u]) {
      const int childCount = dfs(tree, v, move(maxScore), ans);
      count += childCount;
      score *= childCount;
    }
    const int aboveCount = tree.size() - count;
    score *= max(aboveCount, 1);
    if (score > maxScore) {
      maxScore = score;
      ans = 1;
    } else if (score == maxScore) {
      ++ans;
    }
    return count;
  }
};",2049
2048,"class Solution {
 public:
  int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {
    vector<vector<int>> graph(n);
    vector<int> inDegrees(n);
    queue<int> q;
    vector<int> dist(time);

    // Build the graph.
    for (const vector<int>& r : relations) {
      const int u = r[0] - 1;
      const int v = r[1] - 1;
      graph[u].push_back(v);
      ++inDegrees[v];
    }

    // Perform topological sorting.
    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        q.push(i);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u]) {
        dist[v] = max(dist[v], dist[u] + time[v]);
        if (--inDegrees[v] == 0)
          q.push(v);
      }
    }

    return ranges::max(dist);
  }
};",2050
2049,"SELECT
  Members.member_id,
  Members.name,
  CASE
    WHEN COUNT(Visits.visit_id) = 0 THEN 'Bronze'
    WHEN COUNT(Purchases.visit_id) / COUNT(Visits.visit_id) >= 0.8 THEN 'Diamond'
    WHEN COUNT(Purchases.visit_id) / COUNT(Visits.visit_id) >= 0.5 THEN 'Gold'
    ELSE 'Silver'
  END AS category
FROM Members
LEFT JOIN Visits
  USING (member_id)
LEFT JOIN Purchases
  USING (visit_id)
GROUP BY 1;",2051
2050,"class Solution {
 public:
  int minimumCost(string sentence, int k) {
    if (sentence.length() <= k)
      return 0;

    vector<string> words = getWords(sentence);

    // dp[i] := the minimum cost of the first i words
    vector<int> dp(words.size() + 1);

    for (int i = 1; i <= words.size(); ++i) {
      int n = words[i - 1].length();  // the length of the current row
      dp[i] = dp[i - 1] + (k - n) * (k - n);
      // Gradually add words[j - 1], words[j - 2], ....
      for (int j = i - 1; j > 0; --j) {
        n += words[j - 1].length() + 1;
        if (n > k)
          break;
        dp[i] = min(dp[i], dp[j - 1] + (k - n) * (k - n));
      }
    }

    int lastRowLen = words.back().length();
    int i = words.size() - 2;

    while (i > 0 && lastRowLen + words[i].length() + 1 <= k)
      lastRowLen += words[i--].length() + 1;

    return *min_element(dp.begin() + i + 1, dp.end());
  }

 private:
  vector<string> getWords(const string& sentence) {
    vector<string> words;
    istringstream iss(sentence);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }
};",2052
2051,"class Solution {
 public:
  string kthDistinct(vector<string>& arr, int k) {
    unordered_map<string, int> count;

    for (const string& a : arr)
      ++count[a];

    for (const string& a : arr)
      if (count[a] == 1 && --k == 0)
        return a;

    return """";
  }
};",2053
2052,"struct Event {
  int time;
  int value;
  bool isStart;
  Event(int time, int value, bool isStart)
      : time(time), value(value), isStart(isStart) {}
};

class Solution {
 public:
  int maxTwoEvents(vector<vector<int>>& events) {
    int ans = 0;
    int maxValue = 0;
    vector<Event> evts;

    for (const vector<int>& event : events) {
      const int start = event[0];
      const int end = event[1];
      const int value = event[2];
      evts.emplace_back(start, value, true);
      evts.emplace_back(end + 1, value, false);
    }

    ranges::sort(evts, [](const Event& a, const Event& b) {
      return a.time == b.time ? a.isStart < b.isStart : a.time < b.time;
    });

    for (const auto& [_, value, isStart] : evts)
      if (isStart)
        ans = max(ans, value + maxValue);
      else
        maxValue = max(maxValue, value);

    return ans;
  }
};",2054
2053,"class Solution {
 public:
  vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {
    vector<int> ans;
    vector<int> indices;  // indices of '|'

    for (int i = 0; i < s.length(); ++i)
      if (s[i] == '|')
        indices.push_back(i);

    for (const vector<int>& query : queries) {
      const int left = query[0];
      const int right = query[1];
      const int l = ranges::lower_bound(indices, left) - indices.begin();
      const int r = ranges::upper_bound(indices, right) - indices.begin() - 1;
      if (l < r) {
        const int lengthBetweenCandles = indices[r] - indices[l] + 1;
        const int numCandles = r - l + 1;
        ans.push_back(lengthBetweenCandles - numCandles);
      } else {
        ans.push_back(0);
      }
    }

    return ans;
  }
};",2055
2054,"class Solution {
 public:
  int countCombinations(vector<string>& pieces,
                        vector<vector<int>>& positions) {
    const int n = pieces.size();
    unordered_set<unsigned long long> ans;
    vector<vector<pair<int, int>>> combMoves;
    vector<pair<int, int>> board;

    getCombMoves(pieces, 0, {}, combMoves);

    for (const vector<int>& pos : positions)
      board.emplace_back(pos[0], pos[1]);

    for (const vector<pair<int, int>>& combMove : combMoves)
      dfs(board, n, combMove, (1 << n) - 1, ans);

    return ans.size();
  }

 private:
  const unordered_map<string, vector<pair<int, int>>> moves{
      {""rook"", {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}},
      {""bishop"", {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}}},
      {""queen"",
       {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}}};

  void getCombMoves(const vector<string>& pieces, int ithPiece,
                    vector<pair<int, int>>&& path,
                    vector<vector<pair<int, int>>>& combMoves) {
    if (ithPiece == pieces.size()) {
      combMoves.push_back(path);
      return;
    }

    for (const pair<int, int>& move : moves.at(pieces[ithPiece])) {
      path.push_back(move);
      getCombMoves(pieces, ithPiece + 1, std::move(path), combMoves);
      path.pop_back();
    }
  }

  void dfs(const vector<pair<int, int>>& board, int n,
           const vector<pair<int, int>>& combMove, int activeMask,
           unordered_set<unsigned long long>& ans) {
    if (activeMask == 0)
      return;
    ans.insert(getHash(board));

    for (int nextActiveMask = 1; nextActiveMask < 1 << n; ++nextActiveMask) {
      if ((activeMask & nextActiveMask) != nextActiveMask)
        continue;

      // Make sure to copy the board.
      auto nextBoard(board);

      // Move the pieces that are active in this turn.
      for (int i = 0; i < n; ++i)
        if ((nextActiveMask >> i) & 1) {
          nextBoard[i].first += combMove[i].first;
          nextBoard[i].second += combMove[i].second;
        }

      // No two or more pieces occupy the same square.
      if (getUniqueSize(nextBoard) < n)
        continue;

      // Everything needs to be in the boundary.
      if (ranges::all_of(nextBoard, [](const auto& piece) {
        const auto& [x, y] = piece;
        return 1 <= x && x <= 8 && 1 <= y && y <= 8;
      }))
        dfs(nextBoard, n, combMove, nextActiveMask, ans);
    }
  }

  unsigned long long getHash(const vector<pair<int, int>>& board) {
    unsigned long long hash;
    for (const auto& [x, y] : board)
      hash = (hash * 64) + (x - 1 << 3) + (y - 1);
    return hash;
  }

  int getUniqueSize(const vector<pair<int, int>>& board) {
    unordered_set<int> unique;
    for (const auto& [x, y] : board)
      unique.insert(x * 8 + y);
    return unique.size();
  }
};",2056
2055,"class Solution {
 public:
  int smallestEqual(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == i % 10)
        return i;
    return -1;
  }
};",2057
2056,"class Solution {
 public:
  vector<int> nodesBetweenCriticalPoints(ListNode* head) {
    int minDistance = INT_MAX;
    int firstMaIndex = -1;
    int prevMaIndex = -1;
    int index = 1;
    ListNode* prev = head;        // Point to the index 0.
    ListNode* curr = head->next;  // Point to the index 1.

    while (curr->next) {
      if (curr->val > prev->val && curr->val > curr->next->val ||
          curr->val < prev->val && curr->val < curr->next->val) {
        if (firstMaIndex == -1)  // Only assign once.
          firstMaIndex = index;
        if (prevMaIndex != -1)
          minDistance = min(minDistance, index - prevMaIndex);
        prevMaIndex = index;
      }
      prev = curr;
      curr = curr->next;
      ++index;
    }

    if (minDistance == INT_MAX)
      return {-1, -1};
    return {minDistance, prevMaIndex - firstMaIndex};
  }
};",2058
2057,"class Solution {
 public:
  int minimumOperations(vector<int>& nums, int start, int goal) {
    int ans = 0;
    queue<int> q{{start}};
    vector<bool> seen(1001);
    seen[start] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int x = q.front();
        q.pop();
        for (const int num : nums) {
          for (const int res : {x + num, x - num, x ^ num}) {
            if (res == goal)
              return ans;
            if (res < 0 || res > 1000 || seen[res])
              continue;
            seen[res] = true;
            q.push(res);
          }
        }
      }
    }

    return -1;
  }
};",2059
2058,"class Solution {
 public:
  bool possiblyEquals(string s1, string s2) {
    vector<vector<unordered_map<int, bool>>> mem(
        s1.length() + 1, vector<unordered_map<int, bool>>(s2.length() + 1));
    return f(s1, s2, 0, 0, 0, mem);
  }

 private:
  // Returns true if s1[i..n) matches s2[j..n), accounting for the padding
  // difference. Here, `paddingDiff` represents the signed padding. A positive
  // `paddingDiff` indicates that s1 has an additional number of offset bytes
  // compared to s2.
  bool f(const string& s1, const string& s2, int i, int j, int paddingDiff,
         vector<vector<unordered_map<int, bool>>>& mem) {
    if (const auto it = mem[i][j].find(paddingDiff); it != mem[i][j].cend())
      return it->second;
    if (i == s1.length() && j == s2.length())
      return paddingDiff == 0;
    if (i < s1.length() && isdigit(s1[i])) {
      // Add padding on s1.
      const int nextLetterIndex = getNextLetterIndex(s1, i);
      for (const int num : getNums(s1.substr(i, nextLetterIndex - i)))
        if (f(s1, s2, nextLetterIndex, j, paddingDiff + num, mem))
          return true;
    } else if (j < s2.length() && isdigit(s2[j])) {
      // Add padding on s2.
      const int nextLetterIndex = getNextLetterIndex(s2, j);
      for (const int num : getNums(s2.substr(j, nextLetterIndex - j)))
        if (f(s1, s2, i, nextLetterIndex, paddingDiff - num, mem))
          return true;
    } else if (paddingDiff > 0) {
      // `s1` has more padding, so j needs to catch up.
      if (j < s2.length())
        return f(s1, s2, i, j + 1, paddingDiff - 1, mem);
    } else if (paddingDiff < 0) {
      // `s2` has more padding, so i needs to catch up.
      if (i < s1.length())
        return f(s1, s2, i + 1, j, paddingDiff + 1, mem);
    } else {  // paddingDiff == 0
      // There's no padding difference, so consume the next letter.
      if (i < s1.length() && j < s2.length() && s1[i] == s2[j])
        return f(s1, s2, i + 1, j + 1, 0, mem);
    }
    return mem[i][j][paddingDiff] = false;
  }

  int getNextLetterIndex(const string& s, int i) {
    int j = i;
    while (i < s.length() && isdigit(s[j]))
      ++j;
    return j;
  }

  vector<int> getNums(const string& s) {
    vector<int> nums{stoi(s)};
    if (s.length() == 2) {
      nums.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1, 1)));
    } else if (s.length() == 3) {
      nums.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1, 2)));
      nums.push_back(stoi(s.substr(0, 2)) + stoi(s.substr(2, 1)));
      nums.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1, 1)) +
                     stoi(s.substr(2, 1)));
    }
    return nums;
  }
};",2060
2059,"class Solution {
 public:
  int numberOfCleanRooms(vector<vector<int>>& room) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = room.size();
    const int n = room[0].size();
    int ans = 1;
    int i = 0;
    int j = 0;
    int state = 0;  // 0 := right, 1 := down, 2 := left, 3 := up
    vector<vector<int>> seen(m, vector<int>(n));  // seen[i][j] := bitmask
    seen[i][j] |= 1 << state;
    room[i][j] = 2;  // 2 := cleaned

    while (true) {
      const int x = i + dirs[state][0];
      const int y = j + dirs[state][1];
      if (x < 0 || x == m || y < 0 || y == n || room[x][y] == 1) {
        // Turn 90 degrees clockwise.
        state = (state + 1) % 4;
      } else {
        // Walk to (x, y).
        if (room[x][y] == 0) {
          ++ans;
          room[x][y] = 2;
        }
        i = x;
        j = y;
      }
      if ((seen[i][j] >> state) & 1)
        return ans;
      seen[i][j] |= (1 << state);
    }
  }
};",2061
2060,"class Solution {
 public:
  int countVowelSubstrings(string word) {
    return countVowelSubstringsAtMost(word, 5) -
           countVowelSubstringsAtMost(word, 4);
  }

 private:
  int countVowelSubstringsAtMost(const string& s, int goal) {
    int ans = 0;
    int k = goal;
    vector<int> count(26);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (!isVowel(s[r])) {  // Fresh start.
        l = r + 1;
        k = goal;
        count = vector<int>(26);
        continue;
      }
      if (++count[s[r] - 'a'] == 1)
        --k;
      while (k == -1)
        if (--count[s[l++] - 'a'] == 0)
          ++k;
      ans += r - l + 1;  // s[l..r], s[l + 1..r], ..., s[r]
    }

    return ans;
  }

  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiou"";
    return kVowels.find(c) != string_view::npos;
  }
};",2062
2061,"class Solution {
 public:
  long long countVowels(string word) {
    // dp[i] := the sum of the number of vowels of word[0..i), ...,
    // word[i - 1..i)
    vector<long long> dp(word.length() + 1);

    for (int i = 1; i <= word.length(); ++i) {
      dp[i] = dp[i - 1];
      if (isVowel(word[i - 1]))
        dp[i] += i;
    }

    return accumulate(dp.begin(), dp.end(), 0LL);
  }

  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiou"";
    return kVowels.find(c) != string_view::npos;
  }
};",2063
2062,"class Solution {
 public:
  int minimizedMaximum(int n, vector<int>& quantities) {
    int l = 1;
    int r = ranges::max(quantities);

    while (l < r) {
      const int m = (l + r) / 2;
      if (numStores(quantities, m) <= n)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int numStores(const vector<int>& quantities, int m) {
    // ceil(q / m)
    return accumulate(
        quantities.begin(), quantities.end(), 0,
        [&](int subtotal, int q) { return subtotal + (q - 1) / m + 1; });
  }
};",2064
2063,"class Solution {
 public:
  int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges,
                         int maxTime) {
    const int n = values.size();
    int ans = 0;
    vector<vector<pair<int, int>>> graph(n);
    vector<int> seen(n);
    seen[0] = 1;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int time = edge[2];
      graph[u].emplace_back(v, time);
      graph[v].emplace_back(u, time);
    }

    dfs(graph, values, 0, values[0], maxTime, seen, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<pair<int, int>>>& graph,
           const vector<int>& values, int u, int quality, int remainingTime,
           vector<int>& seen, int& ans) {
    if (u == 0)
      ans = max(ans, quality);
    for (const auto& [v, time] : graph[u]) {
      if (time > remainingTime)
        continue;
      const int newQuality = quality + values[v] * (seen[v] == 0);
      ++seen[v];
      dfs(graph, values, v, newQuality, remainingTime - time, seen, ans);
      --seen[v];
    }
  }
};",2065
2064,"SELECT
  account_id,
  day,
  SUM(IF(type = 'Deposit', amount, -amount)) OVER(
    PARTITION BY account_id
    ORDER BY day
  ) AS balance
FROM Transactions
ORDER BY 1, 2;",2066
2065,"class Solution {
 public:
  int equalCountSubstrings(string s, int count) {
    const int maxUnique = unordered_set<int>(s.begin(), s.end()).size();
    int ans = 0;

    for (int unique = 1; unique <= maxUnique; ++unique) {
      const int windowSize = unique * count;
      vector<int> lettersCount(26);
      int uniqueCount = 0;
      for (int i = 0; i < s.length(); ++i) {
        if (++lettersCount[s[i] - 'a'] == count)
          ++uniqueCount;
        if (i >= windowSize &&
            --lettersCount[s[i - windowSize] - 'a'] == count - 1)
          --uniqueCount;
        ans += uniqueCount == unique;
      }
    }

    return ans;
  }
};",2067
2066,"class Solution {
 public:
  bool checkAlmostEquivalent(string word1, string word2) {
    vector<int> count(26);

    for (const char c : word1)
      ++count[c - 'a'];

    for (const char c : word2)
      --count[c - 'a'];

    return ranges::all_of(count, [](int freq) { return abs(freq) <= 3; });
  }
};",2068
2067,step(num: int),2069
2068,"class Solution {
 public:
  vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
    vector<int> ans;
    vector<int> prices;
    vector<int> maxBeautySoFar(items.size() + 1);

    ranges::sort(items);

    for (const vector<int>& item : items)
      prices.push_back(item[0]);

    for (int i = 0; i < items.size(); ++i)
      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], items[i][1]);

    for (const int query : queries) {
      const int i = ranges::upper_bound(prices, query) - prices.begin();
      ans.push_back(maxBeautySoFar[i]);
    }

    return ans;
  }
};",2070
2069,"class Solution {
 public:
  int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills,
                    int strength) {
    int ans = 0;
    int l = 0;
    int r = min(tasks.size(), workers.size());

    ranges::sort(tasks);
    ranges::sort(workers);

    // Returns true if we can finish k tasks.
    auto canComplete = [&](int k, int pillsLeft) {
      // k strongest workers
      map<int, int> sortedWorkers;
      for (int i = workers.size() - k; i < workers.size(); ++i)
        ++sortedWorkers[workers[i]];

      // Out of the k smallest tasks, start from the biggest one.
      for (int i = k - 1; i >= 0; --i) {
        // Find the first worker that has strength >= tasks[i].
        auto it = sortedWorkers.lower_bound(tasks[i]);
        if (it != sortedWorkers.end()) {
          if (--(it->second) == 0)
            sortedWorkers.erase(it);
        } else if (pillsLeft > 0) {
          // Find the first worker that has strength >= tasks[i] - strength.
          it = sortedWorkers.lower_bound(tasks[i] - strength);
          if (it != sortedWorkers.end()) {
            if (--(it->second) == 0)
              sortedWorkers.erase(it);
            --pillsLeft;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }

      return true;
    };

    while (l <= r) {
      const int m = (l + r) / 2;
      if (canComplete(m, pills)) {
        ans = m;
        l = m + 1;
      } else {
        r = m - 1;
      }
    }

    return ans;
  }
};",2071
2070,"WITH
  NY AS (
    SELECT COUNT(student_id) AS `count`
    FROM NewYork
    WHERE score >= 90
  ),
  CA AS (
    SELECT COUNT(student_id) AS `count`
    FROM California
    WHERE score >= 90
  )
SELECT
  CASE
    WHEN NY.`count` > CA.`count` THEN 'New York University'
    WHEN NY.`count` < CA.`count` THEN 'California University'
    ELSE 'No Winner'
  END AS Winner
FROM NY, CA;",2072
2071,"class Solution {
 public:
  int timeRequiredToBuy(vector<int>& tickets, int k) {
    int ans = 0;

    for (int i = 0; i < tickets.size(); ++i)
      if (i <= k)
        ans += min(tickets[i], tickets[k]);
      else
        ans += min(tickets[i], tickets[k] - 1);

    return ans;
  }
};",2073
2072,"class Solution {
 public:
  ListNode* reverseEvenLengthGroups(ListNode* head) {
    // prev -> (head -> ... -> tail) -> next -> ...
    ListNode dummy(0, head);
    ListNode* prev = &dummy;
    ListNode* tail = head;
    ListNode* next = head->next;
    int groupLength = 1;

    while (true) {
      if (groupLength % 2 == 1) {
        prev->next = head;
        prev = tail;
      } else {
        tail->next = nullptr;
        prev->next = reverse(head);
        // Prev -> (tail -> ... -> head) -> next -> ...
        head->next = next;
        prev = head;
      }
      if (next == nullptr)
        break;
      head = next;
      const auto [theTail, theLength] = getTailAndLength(head, groupLength + 1);
      tail = theTail;
      next = tail->next;
      groupLength = theLength;
    }

    return dummy.next;
  }

 private:
  pair<ListNode*, int> getTailAndLength(ListNode* head, int groupLength) {
    int length = 1;
    ListNode* tail = head;
    while (length < groupLength && tail->next) {
      tail = tail->next;
      ++length;
    }
    return {tail, length};
  }

  ListNode* reverse(ListNode* head) {
    ListNode* prev = nullptr;
    while (head) {
      ListNode* next = head->next;
      head->next = prev;
      prev = head;
      head = next;
    }
    return prev;
  }
};",2074
2073,"class Solution:
  def decodeCiphertext(self, encodedText: str, rows: int) -> str:
    n = len(encodedText)
    cols = n // rows

    ans = []
    matrix = [[' '] * cols for _ in range(rows)]

    for i in range(rows):
      for j in range(cols):
        matrix[i][j] = encodedText[i * cols + j]

    for col in range(cols):
      i = 0
      j = col
      while i < rows and j < cols:
        ans.append(matrix[i][j])
        i += 1
        j += 1

    return ''.join(ans).rstrip()",2075
2074,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<bool> friendRequests(int n, vector<vector<int>>& restrictions,
                              vector<vector<int>>& requests) {
    vector<bool> ans;
    UnionFind uf(n);

    for (const vector<int>& request : requests) {
      const int i = uf.find(request[0]);
      const int j = uf.find(request[1]);
      bool isValid = true;
      if (i != j)
        for (const vector<int>& restriction : restrictions) {
          const int x = uf.find(restriction[0]);
          const int y = uf.find(restriction[1]);
          if (i == x && j == y || i == y && j == x) {
            isValid = false;
            break;
          }
        }
      ans.push_back(isValid);
      if (isValid)
        uf.unionByRank(i, j);
    }

    return ans;
  }
};",2076
2075,"class Solution:
  def numberOfPaths(self, n: int, corridors: List[List[int]]) -> int:
    ans = 0
    graph = [[False] * 1001 for _ in range(n + 1)]

    for u, v in corridors:
      graph[u][v] = True
      graph[v][u] = True

    for u, v in corridors:
      for i in range(1, n + 1):
        if graph[u][i] and graph[i][v]:
          ans += 1

    return ans // 3",2077
2076,"class Solution {
 public:
  int maxDistance(vector<int>& colors) {
    // The maximum distance always includes either the first or the last house.
    const int n = colors.size();
    int i = 0;      // the leftmost index, where colors[i] != colors[-1]
    int j = n - 1;  // the rightmost index, where colors[j] != colors[0]
    while (colors[i] == colors.back())
      ++i;
    while (colors[j] == colors.front())
      --j;
    return max(n - 1 - i, j);
  }
};",2078
2077,"class Solution:
  def wateringPlants(self, plants: List[int], capacity: int) -> int:
    ans = 0
    currCapacity = 0

    for i, plant in enumerate(plants):
      if currCapacity + plant <= capacity:
        currCapacity += plant
      else:
        currCapacity = plant  # Reset
        ans += i * 2

    return ans + len(plants)",2079
2078,"query(left: int, right: int, value: int)",2080
2079,"class Solution:
  def kMirror(self, k: int, n: int) -> int:
    ans = 0
    A = ['0']

    def nextKMirror(A: List[chr]) -> List[chr]:
      for i in range(len(A) // 2, len(A)):
        nextNum = int(A[i]) + 1
        if nextNum < k:
          A[i] = str(nextNum)
          A[~i] = str(nextNum)
          for j in range(len(A) // 2, i):
            A[j] = '0'
            A[~j] = '0'
          return A
      return ['1'] + ['0'] * (len(A) - 1) + ['1']

    for _ in range(n):
      while True:
        A = nextKMirror(A)
        num = int(''.join(A), k)
        if str(num)[::-1] == str(num):
          break
      ans += num

    return ans",2081
2080,"SELECT COUNT(DISTINCT customer_id) AS rich_count
FROM Store
WHERE amount > 500;",2082
2081,"class Solution {
 public:
  long long numberOfSubstrings(string s) {
    long long ans = 0;
    vector<int> count(26);

    for (const char c : s)
      ans += ++count[c - 'a'];

    return ans;
  }
};",2083
2082,"WITH
  RankedOrders AS (
    SELECT
      *,
      RANK() OVER(PARTITION BY customer_id ORDER BY order_type) AS `rank`
    FROM Orders
  )
SELECT
  order_id,
  customer_id,
  order_type
FROM RankedOrders
WHERE `rank` = 1;",2084
2083,"class Solution {
 public:
  int countWords(vector<string>& words1, vector<string>& words2) {
    unordered_map<string, int> count;

    for (const string& word : words1)
      ++count[word];

    for (const string& word : words2)
      if (const auto it = count.find(word);
          it != count.cend() && it->second < 2)
        --it->second;

    return ranges::count_if(count, [](const auto& c) { return c.second == 0; });
  }
};",2085
2084,"class Solution {
 public:
  int minimumBuckets(string street) {
    for (int i = 0; i < street.length(); ++i)
      if (street[i] == 'H') {
        if (i > 0 && street[i - 1] == 'B')
          continue;
        if (i + 1 < street.length() && street[i + 1] == '.')
          // Always prefer place a bucket in (i + 1) because it enhances the
          // possibility to collect the upcoming houses.
          street[i + 1] = 'B';
        else if (i > 0 && street[i - 1] == '.')
          street[i - 1] = 'B';
        else
          return -1;
      }

    return ranges::count(street, 'B');
  }
};",2086
2085,"class Solution {
 public:
  int minCost(vector<int>& startPos, vector<int>& homePos,
              vector<int>& rowCosts, vector<int>& colCosts) {
    int ans = 0;
    int i = startPos[0];
    int j = startPos[1];
    int x = homePos[0];
    int y = homePos[1];

    while (i != x)
      ans += i < x ? rowCosts[++i] : rowCosts[--i];
    while (j != y)
      ans += j < y ? colCosts[++j] : colCosts[--j];

    return ans;
  }
};",2087
2086,"class Solution {
 public:
  int countPyramids(vector<vector<int>>& grid) {
    int ans = count(grid);
    reverse(grid.begin(), grid.end());
    ans += count(grid);
    return ans;
  }

 private:
  // dp[i][j] := the maximum height of the pyramid for which it is the apex
  int count(vector<vector<int>> dp) {
    int ans = 0;
    for (int i = dp.size() - 2; i >= 0; --i)
      for (int j = 1; j + 1 < dp[0].size(); ++j)
        if (dp[i][j] == 1) {
          dp[i][j] =
              min({dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1]}) + 1;
          ans += dp[i][j] - 1;
        }
    return ans;
  }
};",2088
2087,"class Solution {
 public:
  vector<int> targetIndices(vector<int>& nums, int target) {
    vector<int> ans;
    const int count = ranges::count(nums, target);
    int lessThan =
        ranges::count_if(nums, [&](int num) { return num < target; });

    for (int i = 0; i < count; ++i)
      ans.push_back(lessThan++);

    return ans;
  }
};",2089
2088,"class Solution {
 public:
  vector<int> getAverages(vector<int>& nums, int k) {
    const int n = nums.size();
    const int size = 2 * k + 1;
    vector<int> ans(n, -1);
    if (size > n)
      return ans;

    long sum = accumulate(nums.begin(), nums.begin() + size, 0L);

    for (int i = k; i + k < n; ++i) {
      ans[i] = sum / size;
      if (i + k + 1 < n)
        sum += nums[i + k + 1] - nums[i - k];
    }

    return ans;
  }
};",2090
2089,"class Solution {
 public:
  int minimumDeletions(vector<int>& nums) {
    const int n = nums.size();
    int a = ranges::min_element(nums) - nums.begin();
    int b = ranges::max_element(nums) - nums.begin();
    if (a > b)
      swap(a, b);
    return min({a + 1 + n - b, b + 1, n - a});
  }
};",2091
2090,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  bool connected(int u, int v) {
    return find(u) == find(v);
  }

  void reset(int u) {
    id[u] = u;
  }

 private:
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findAllPeople(int n, vector<vector<int>>& meetings,
                            int firstPerson) {
    vector<int> ans;
    UnionFind uf(n);
    map<int, vector<pair<int, int>>> timeToPairs;

    uf.unionByRank(0, firstPerson);

    for (const vector<int>& m : meetings)
      timeToPairs[m[2]].push_back({m[0], m[1]});

    for (const auto& [_, pairs] : timeToPairs) {
      unordered_set<int> peopleUnioned;
      for (const auto& [x, y] : pairs) {
        uf.unionByRank(x, y);
        peopleUnioned.insert(x);
        peopleUnioned.insert(y);
      }
      for (const int person : peopleUnioned)
        if (!uf.connected(person, 0))
          uf.reset(person);
    }

    for (int i = 0; i < n; ++i)
      if (uf.connected(i, 0))
        ans.push_back(i);

    return ans;
  }
};",2092
2091,"struct T {
  int u;
  int d;
  int leftDiscounts;
  T(int u, int d, int leftDiscounts)
      : u(u), d(d), leftDiscounts(leftDiscounts) {}
};

class Solution {
 public:
  int minimumCost(int n, vector<vector<int>>& highways, int discounts) {
    vector<vector<pair<int, int>>> graph(n);
    auto compare = [](const T& a, const T& b) { return a.d > b.d; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    unordered_map<int, int> minDiscounts;

    for (const vector<int>& h : highways) {
      const int city1 = h[0];
      const int city2 = h[1];
      const int toll = h[2];
      graph[city1].emplace_back(city2, toll);
      graph[city2].emplace_back(city1, toll);
    }

    minHeap.emplace(0, 0, discounts);

    while (!minHeap.empty()) {
      const auto [u, d, leftDiscounts] = minHeap.top();
      minHeap.pop();
      if (u == n - 1)
        return d;
      if (const auto it = minDiscounts.find(u);
          it != minDiscounts.cend() && it->second >= leftDiscounts)
        continue;
      minDiscounts[u] = leftDiscounts;
      for (const auto& [v, w] : graph[u]) {
        minHeap.emplace(v, d + w, leftDiscounts);
        if (leftDiscounts > 0)
          minHeap.emplace(v, d + w / 2, leftDiscounts - 1);
      }
    }

    return -1;
  }
};",2093
2092,"class Solution {
 public:
  vector<int> findEvenNumbers(vector<int>& digits) {
    vector<int> ans;
    vector<int> count(10);

    for (const int digit : digits)
      ++count[digit];

    // Try to construct `abc`.
    for (int a = 1; a <= 9; ++a)
      for (int b = 0; b <= 9; ++b)
        for (int c = 0; c <= 8; c += 2)
          if (count[a] > 0 && count[b] > (b == a) &&
              count[c] > (c == a) + (c == b))
            ans.push_back(a * 100 + b * 10 + c);

    return ans;
  }
};",2094
2093,"class Solution {
 public:
  ListNode* deleteMiddle(ListNode* head) {
    ListNode dummy(0, head);
    ListNode* slow = &dummy;
    ListNode* fast = &dummy;

    while (fast->next != nullptr && fast->next->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
    }

    // Delete the middle node.
    slow->next = slow->next->next;
    return dummy.next;
  }
};",2095
2094,"class Solution {
 public:
  string getDirections(TreeNode* root, int startValue, int destValue) {
    string path;
    string pathToStart;
    string pathToDest;
    // Only this subtree matters.
    dfs(lca(root, startValue, destValue), startValue, destValue, path,
        pathToStart, pathToDest);
    return string(pathToStart.length(), 'U') + pathToDest;
  }

 private:
  TreeNode* lca(TreeNode* root, int p, int q) {
    if (root == nullptr || root->val == p || root->val == q)
      return root;
    TreeNode* left = lca(root->left, p, q);
    TreeNode* right = lca(root->right, p, q);
    if (left != nullptr && right != nullptr)
      return root;
    return left == nullptr ? right : left;
  }

  void dfs(TreeNode* root, int p, int q, string& path, string& pathToStart,
           string& pathToDest) {
    if (root == nullptr)
      return;
    if (root->val == p)
      pathToStart = path;
    if (root->val == q)
      pathToDest = path;
    path.push_back('L');
    dfs(root->left, p, q, path, pathToStart, pathToDest);
    path.pop_back();
    path.push_back('R');
    dfs(root->right, p, q, path, pathToStart, pathToDest);
    path.pop_back();
  }
};",2096
2095,"class Solution {
 public:
  vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
    vector<vector<int>> ans;
    unordered_map<int, stack<int>> graph;
    unordered_map<int, int> outDegree;
    unordered_map<int, int> inDegrees;

    for (const vector<int>& pair : pairs) {
      const int start = pair[0];
      const int end = pair[1];
      graph[start].push(end);
      ++outDegree[start];
      ++inDegrees[end];
    }

    const int startNode = getStartNode(graph, outDegree, inDegrees, pairs);
    euler(graph, startNode, ans);
    reverse(ans.begin(), ans.end());
    return ans;
  }

 private:
  int getStartNode(const unordered_map<int, stack<int>>& graph,
                   unordered_map<int, int>& outDegree,
                   unordered_map<int, int>& inDegrees,
                   const vector<vector<int>>& pairs) {
    for (const auto& [u, _] : graph)
      if (outDegree[u] - inDegrees[u] == 1)
        return u;
    return pairs[0][0];  // Arbitrarily choose a node.
  }

  void euler(unordered_map<int, stack<int>>& graph, int u,
             vector<vector<int>>& ans) {
    auto& stack = graph[u];
    while (!stack.empty()) {
      const int v = stack.top();
      stack.pop();
      euler(graph, v, ans);
      ans.push_back({u, v});
    }
  }
};",2097
2096,"class Solution {
 public:
  long long largestEvenSum(vector<int>& nums, int k) {
    ranges::sort(nums);
    long long sum = accumulate(nums.end() - k, nums.end(), 0LL);
    if (sum % 2 == 0)
      return sum;

    int minOdd = -1;
    int minEven = -1;
    int maxOdd = -1;
    int maxEven = -1;

    for (int i = nums.size() - 1; i + k >= nums.size(); --i)
      if (nums[i] & 1)
        minOdd = nums[i];
      else
        minEven = nums[i];

    for (int i = 0; i + k < nums.size(); ++i)
      if (nums[i] & 1)
        maxOdd = nums[i];
      else
        maxEven = nums[i];

    long long ans = -1;

    if (maxEven >= 0 && minOdd >= 0)
      ans = max(ans, sum + maxEven - minOdd);
    if (maxOdd >= 0 && minEven >= 0)
      ans = max(ans, sum + maxOdd - minEven);
    return ans;
  }
};",2098
2097,"class Solution {
 public:
  vector<int> maxSubsequence(vector<int>& nums, int k) {
    vector<int> ans;
    vector<int> A(nums);
    nth_element(A.begin(), A.end() - k, A.end());
    const int threshold = A[A.size() - k];
    const int larger =
        ranges::count_if(nums, [&](int num) { return num > threshold; });
    int equal = k - larger;

    for (const int num : nums)
      if (num > threshold) {
        ans.push_back(num);
      } else if (num == threshold && equal) {
        ans.push_back(num);
        --equal;
      }

    return ans;
  }
};",2099
2098,"class Solution {
 public:
  vector<int> goodDaysToRobBank(vector<int>& security, int time) {
    const int n = security.size();
    vector<int> ans;
    // dec[i] := the number of continuous decreasing numbers before i
    vector<int> dec(n);
    // inc[i] := the number of continuous increasing numbers after i
    vector<int> inc(n);

    for (int i = 1; i < n; ++i)
      if (security[i - 1] >= security[i])
        dec[i] = dec[i - 1] + 1;

    for (int i = n - 2; i >= 0; --i)
      if (security[i] <= security[i + 1])
        inc[i] = inc[i + 1] + 1;

    for (int i = 0; i < n; ++i)
      if (dec[i] >= time && inc[i] >= time)
        ans.push_back(i);

    return ans;
  }
};",2100
2099,"class Solution {
 public:
  int maximumDetonation(vector<vector<int>>& bombs) {
    const int n = bombs.size();
    size_t ans = 0;
    vector<vector<int>> graph(n);

    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        if (i == j)
          continue;
        const long ri = bombs[i][2];
        if (ri * ri >= squaredDist(bombs, i, j))
          graph[i].push_back(j);
      }
    }

    for (int i = 0; i < n; ++i) {
      unordered_set<int> seen{i};
      dfs(graph, i, seen);
      ans = max(ans, seen.size());
    }

    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u]) {
      if (seen.count(v))
        continue;
      seen.insert(v);
      dfs(graph, v, seen);
    }
  }

  long squaredDist(const vector<vector<int>>& bombs, int i, int j) {
    return static_cast<long>(bombs[i][0] - bombs[j][0]) *
               (bombs[i][0] - bombs[j][0]) +
           static_cast<long>(bombs[i][1] - bombs[j][1]) *
               (bombs[i][1] - bombs[j][1]);
  }
};",2101
2100,"add(name: str, score: int)",2102
2101,"class Solution {
 public:
  int countPoints(string rings) {
    vector<int> colors(10);

    for (int i = 0; i < rings.length(); i += 2) {
      const int c = rings[i];
      const int color = c == 'R' ? 1 : c == 'G' ? 2 : 4;
      colors[rings[i + 1] - '0'] |= color;
    }

    return ranges::count(colors, 7);
  }
};",2103
2102,"class Solution {
 public:
  long long subArrayRanges(vector<int>& nums) {
    return subarraySum(nums, less<int>()) - subarraySum(nums, greater<>());
  }

 private:
  long long subarraySum(const vector<int>& A,
                        const function<int(int, int)>& op) {
    const int n = A.size();
    long long ans = 0;
    vector<int> prev(n, -1);
    vector<int> next(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && op(A[stack.top()], A[i])) {
        const int index = stack.top();
        stack.pop();
        next[index] = i;
      }
      if (!stack.empty())
        prev[i] = stack.top();
      stack.push(i);
    }

    for (int i = 0; i < n; ++i)
      ans += static_cast<long>(A[i]) * (i - prev[i]) * (next[i] - i);

    return ans;
  }
};",2104
2103,"class Solution {
 public:
  int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
    int ans = 0;
    int i = 0;
    int j = plants.size() - 1;
    int canA = capacityA;
    int canB = capacityB;

    while (i < j) {
      ans += (canA < plants[i]) + (canB < plants[j]);
      if (canA < plants[i])
        canA = capacityA;
      if (canB < plants[j])
        canB = capacityB;
      canA -= plants[i++];
      canB -= plants[j--];
    }

    return ans + (i == j && max(canA, canB) < plants[i]);
  }
};",2105
2104,"class Solution {
 public:
  int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
    const int maxRight = max(startPos, fruits.back()[0]);
    int ans = 0;
    vector<int> amounts(1 + maxRight);
    vector<int> prefix(2 + maxRight);

    for (const vector<int>& f : fruits)
      amounts[f[0]] = f[1];

    partial_sum(amounts.begin(), amounts.end(), prefix.begin() + 1);

    auto getFruits = [&](int leftSteps, int rightSteps) {
      const int l = max(0, startPos - leftSteps);
      const int r = min(maxRight, startPos + rightSteps);
      return prefix[r + 1] - prefix[l];
    };

    // Go right first.
    const int maxRightSteps = min(maxRight - startPos, k);
    for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {
      const int leftSteps = max(0, k - 2 * rightSteps);  // Turn left
      ans = max(ans, getFruits(leftSteps, rightSteps));
    }

    // Go left first.
    const int maxLeftSteps = min(startPos, k);
    for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {
      const int rightSteps = max(0, k - 2 * leftSteps);  // Turn right
      ans = max(ans, getFruits(leftSteps, rightSteps));
    }

    return ans;
  }
};",2106
2105,"class Solution {
 public:
  int shareCandies(vector<int>& candies, int k) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int candy : candies)
      ++count[candy];

    int unique = count.size();

    for (int i = 0; i < candies.size(); ++i) {
      if (--count[candies[i]] == 0) {
        count.erase(candies[i]);
        --unique;
      }
      if (i >= k && ++count[candies[i - k]] == 1)
        ++unique;
      if (i >= k - 1)
        ans = max(ans, unique);
    }

    return ans;
  }
};",2107
2106,"class Solution {
 public:
  string firstPalindrome(vector<string>& words) {
    for (const string& word : words)
      if (isPalindrome(word))
        return word;
    return """";
  }

 private:
  bool isPalindrome(const string& s) {
    int i = 0;
    int j = s.length() - 1;
    while (i < j)
      if (s[i++] != s[j--])
        return false;
    return true;
  }
};",2108
2107,"class Solution {
 public:
  string addSpaces(string s, vector<int>& spaces) {}
};",2109
2108,"class Solution {
 public:
  long long getDescentPeriods(vector<int>& prices) {
    long long ans = 1;  // prices[0]
    int dp = 1;

    for (int i = 1; i < prices.size(); ++i) {
      if (prices[i] == prices[i - 1] - 1) {
        ++dp;
      } else {
        dp = 1;
      }
      ans += dp;
    }

    return ans;
  }
};",2110
2109,"class Solution {
 public:
  int kIncreasing(vector<int>& arr, int k) {
    int ans = 0;

    for (int i = 0; i < k; ++i) {
      vector<int> A;
      for (int j = i; j < arr.size(); j += k)
        A.push_back(arr[j]);
      ans += numReplaced(A);
    }

    return ans;
  }

 private:
  int numReplaced(const vector<int>& A) {
    vector<int> tail;
    for (const int a : A)
      if (tail.empty() || tail.back() <= a)
        tail.push_back(a);
      else
        tail[firstGreater(tail, a)] = a;
    return A.size() - tail.size();
  }

  int firstGreater(const vector<int>& A, int target) {
    return ranges::upper_bound(A, target) - A.begin();
  }
};",2111
2110,"WITH
  AirportToCount AS (
    SELECT departure_airport AS airport_id, flights_count
    FROM Flights
    UNION ALL
    SELECT arrival_airport, flights_count
    FROM Flights
  ),
  RankedAirports AS (
    SELECT
      airport_id,
      RANK() OVER(ORDER BY SUM(flights_count) DESC) AS `rank`
    FROM AirportToCount
    GROUP BY 1
  )
SELECT airport_id
FROM RankedAirports
WHERE `rank` = 1;",2112
2111,"class Solution {
 public:
  vector<int> elementInNums(vector<int>& nums, vector<vector<int>>& queries) {
    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int time = query[0];
      const int index = query[1];
      ans.push_back(f(nums, time % (2 * nums.size()), index));
    }

    return ans;
  }

 private:
  int f(const vector<int>& A, int time, int index) {
    const int n = A.size();
    if (time < n) {  // [0, 1, 2] -> [1, 2] -> [2]
      index += time;
      return index >= n ? -1 : A[index];
    } else {  // [] -> [0] -> [0, 1]
      return index >= time - n ? -1 : A[index];
    }
  }
};",2113
2112,"class Solution {
 public:
  int mostWordsFound(vector<string>& sentences) {
    long maxSpaceCount = 0;

    for (const string& s : sentences)
      maxSpaceCount = max(maxSpaceCount, ranges::count(s, ' '));

    return maxSpaceCount + 1;
  }
};",2114
2113,"class Solution {
 public:
  vector<string> findAllRecipes(vector<string>& recipes,
                                vector<vector<string>>& ingredients,
                                vector<string>& supplies) {
    vector<string> ans;
    unordered_set<string> suppliesSet(supplies.begin(), supplies.end());
    unordered_map<string, vector<string>> graph;
    unordered_map<string, int> inDegrees;
    queue<string> q;

    // Build the graph.
    for (int i = 0; i < recipes.size(); ++i)
      for (const string& ingredient : ingredients[i])
        if (!suppliesSet.count(ingredient)) {
          graph[ingredient].push_back(recipes[i]);
          ++inDegrees[recipes[i]];
        }

    // Perform topological sorting.
    for (const string& recipe : recipes)
      if (!inDegrees.count(recipe))
        q.push(recipe);

    while (!q.empty()) {
      const string u = q.front();
      q.pop();
      ans.push_back(u);
      if (!graph.count(u))
        continue;
      for (const string& v : graph[u])
        if (--inDegrees[v] == 0)
          q.push(v);
    }

    return ans;
  }
};",2115
2114,"class Solution {
 public:
  bool canBeValid(string s, string locked) {
    if (s.length() & 1)
      return false;

    const bool leftToRightIsOkay = check(s, locked, true);
    reverse(s.begin(), s.end());
    reverse(locked.begin(), locked.end());
    const bool rightToLeftIsOkay = check(s, locked, false);
    return leftToRightIsOkay && rightToLeftIsOkay;
  }

 private:
  bool check(const string& s, const string& locked, bool isForward) {
    int changeable = 0;
    int l = 0;
    int r = 0;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      const char lock = locked[i];
      if (lock == '0')
        ++changeable;
      else if (c == '(')
        ++l;
      else  // c == ')'
        ++r;
      if (isForward && changeable + l - r < 0)
        return false;
      if (!isForward && changeable + r - l < 0)
        return false;
    }

    return true;
  }
};",2116
2115,"class Solution {
 public:
  string abbreviateProduct(int left, int right) {
    constexpr long long maxSuf = 1000000000000;
    double prod = 1.0;
    long long suf = 1;
    int countDigits = 0;
    int countZeros = 0;

    for (int num = left; num <= right; ++num) {
      prod *= num;
      while (prod >= 1.0) {
        prod /= 10;
        ++countDigits;
      }
      suf *= num;
      while (suf % 10 == 0) {
        suf /= 10;
        ++countZeros;
      }
      if (suf > maxSuf)
        suf %= maxSuf;
    }

    if (countDigits - countZeros <= 10) {
      const long tens = pow(10, countDigits - countZeros);
      return to_string(static_cast<long>(prod * tens + 0.5)) + 'e' +
             to_string(countZeros);
    }

    const string pre = to_string((long)(prod * pow(10, 5)));
    string sufStr = to_string(suf);
    sufStr = sufStr.substr(sufStr.length() - 5);
    return pre + ""..."" + sufStr + 'e' + to_string(countZeros);
  }
};",2117
2116,"WITH
  PowerToTerm AS (
    SELECT
      CONCAT(
        IF(factor > 0, '+', ''),
        factor,
        IF(power = 0, '', 'X'),
        IF(power IN (0, 1), '', CONCAT('^', power))
      ) AS term,
      power
    FROM Terms
    ORDER BY power DESC
  )
SELECT
  CONCAT(
    GROUP_CONCAT(
      term
      ORDER BY power DESC SEPARATOR ''
    ),
    '=0'
  ) AS equation
FROM PowerToTerm;",2118
2117,"class Solution {
 public:
  bool isSameAfterReversals(int num) {
    const int reversed1 = getReversed(num);
    const int reversed2 = getReversed(reversed1);
    return reversed2 == num;
  }

 private:
  int getReversed(int num) {
    int reversed = 0;
    while (num > 0) {
      reversed = reversed * 10 + num % 10;
      num /= 10;
    }
    return reversed;
  }
};",2119
2118,"class Solution {
 public:
  vector<int> executeInstructions(int n, vector<int>& startPos, string s) {
    const int m = s.length();
    const int uMost = startPos[0] + 1;
    const int dMost = n - startPos[0];
    const int lMost = startPos[1] + 1;
    const int rMost = n - startPos[1];
    const unordered_map<char, pair<int, int>> moves{
        {'L', {0, -1}},
        {'R', {0, 1}},
        {'U', {-1, 0}},
        {'D', {1, 0}},
    };

    vector<int> ans(m);
    unordered_map<int, int> reachX{{0, m}};
    unordered_map<int, int> reachY{{0, m}};
    int x = 0;
    int y = 0;

    for (int i = m - 1; i >= 0; --i) {
      const auto [dx, dy] = moves.at(s[i]);
      x -= dx;
      y -= dy;
      reachX[x] = i;
      reachY[y] = i;
      int out = INT_MAX;
      if (const auto it = reachX.find(x - uMost); it != reachX.cend())
        out = min(out, it->second);
      if (const auto it = reachX.find(x + dMost); it != reachX.cend())
        out = min(out, it->second);
      if (const auto it = reachY.find(y - lMost); it != reachY.cend())
        out = min(out, it->second);
      if (const auto it = reachY.find(y + rMost); it != reachY.cend())
        out = min(out, it->second);
      ans[i] = out == INT_MAX ? m - i : out - i - 1;
    }

    return ans;
  }
};",2120
2119,"class Solution {
 public:
  vector<long long> getDistances(vector<int>& arr) {
    const int n = arr.size();
    vector<long long> ans(n);
    vector<long> prefix(n);
    vector<long> suffix(n);
    unordered_map<int, vector<int>> numToIndices;

    for (int i = 0; i < n; ++i)
      numToIndices[arr[i]].push_back(i);

    for (const auto& [_, indices] : numToIndices) {
      for (int i = 1; i < indices.size(); ++i) {
        const int currIndex = indices[i];
        const int prevIndex = indices[i - 1];
        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex);
      }
      for (int i = indices.size() - 2; i >= 0; --i) {
        const int currIndex = indices[i];
        const int prevIndex = indices[i + 1];
        suffix[currIndex] += suffix[prevIndex] +
                             (indices.size() - i - 1) * (prevIndex - currIndex);
      }
    }

    for (int i = 0; i < n; ++i)
      ans[i] = prefix[i] + suffix[i];

    return ans;
  }
};",2121
2120,"class Solution {
 public:
  vector<int> recoverArray(vector<int>& nums) {
    const int n = nums.size();
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    ranges::sort(nums);

    for (int i = 1; i < n; ++i) {
      const int x = nums[i] - nums[0];  // 2 * k
      if (x <= 0 || x & 1)
        continue;
      vector<int> A = getArray(nums, x, count);
      if (!A.empty())
        return A;
    }

    throw;
  }

 private:
  vector<int> getArray(const vector<int>& nums, int x,
                       unordered_map<int, int> count) {
    vector<int> A;
    for (const int num : nums) {
      if (const auto it = count.find(num);
          it == count.cend() || it->second == 0)
        continue;
      if (const auto it = count.find(num + x);
          it == count.cend() || it->second == 0)
        return {};
      --count[num];
      --count[num + x];
      A.push_back(num + x / 2);
    }
    return A;
  }
};",2122
2121,"class Solution {
 public:
  int minimumOperations(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<vector<int>> seen(m, vector<int>(n));
    vector<vector<int>> match(m, vector<int>(n, -1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1 && match[i][j] == -1) {
          const int sessionId = i * n + j;
          seen[i][j] = sessionId;
          ans += dfs(grid, i, j, sessionId, seen, match);
        }

    return ans;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  int dfs(const vector<vector<int>>& grid, int i, int j, int sessionId,
          vector<vector<int>>& seen, vector<vector<int>>& match) {
    const int m = grid.size();
    const int n = grid[0].size();

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (grid[x][y] == 0 || seen[x][y] == sessionId)
        continue;
      seen[x][y] = sessionId;
      if (match[x][y] == -1 ||
          dfs(grid, match[x][y] / n, match[x][y] % n, sessionId, seen, match)) {
        match[x][y] = i * n + j;
        match[i][j] = x * n + y;
        return 1;
      }
    }

    return 0;
  }
};",2123
2122,"class Solution {
 public:
  bool checkString(string s) {
    return s.find(""ba"") == string::npos;
  }
};",2124
2123,"class Solution {
 public:
  int numberOfBeams(vector<string>& bank) {
    int ans = 0;
    int prevOnes = 0;

    for (const string& row : bank) {
      const int ones = ranges::count(row, '1');
      if (ones > 0) {
        ans += prevOnes * ones;
        prevOnes = ones;
      }
    }

    return ans;
  }
};",2125
2124,"class Solution {
 public:
  bool asteroidsDestroyed(int mass, vector<int>& asteroids) {
    ranges::sort(asteroids);

    long long m = mass;

    for (const int asteroid : asteroids)
      if (m >= asteroid)
        m += asteroid;
      else
        return false;

    return true;
  }
};",2126
2125,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  int maximumInvitations(vector<int>& favorite) {
    const int n = favorite.size();
    int sumComponentsLength = 0;  // the component: a -> b -> c <-> x <- y
    vector<vector<int>> graph(n);
    vector<int> inDegrees(n);
    vector<int> maxChainLength(n, 1);
    queue<int> q;

    // Build the graph.
    for (int i = 0; i < n; ++i) {
      graph[i].push_back(favorite[i]);
      ++inDegrees[favorite[i]];
    }

    // Perform topological sorting.
    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        q.push(i);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u]) {
        if (--inDegrees[v] == 0)
          q.push(v);
        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u]);
      }
    }

    for (int i = 0; i < n; ++i)
      if (favorite[favorite[i]] == i)
        // i <-> favorite[i] (the cycle's length = 2)
        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]];

    int maxCycleLength = 0;  // the cycle : a -> b -> c -> a
    vector<int> parent(n, -1);
    vector<bool> seen(n);
    vector<State> states(n);

    for (int i = 0; i < n; ++i)
      if (!seen[i])
        findCycle(graph, i, parent, seen, states, maxCycleLength);

    return max(sumComponentsLength / 2, maxCycleLength);
  }

 private:
  void findCycle(const vector<vector<int>>& graph, int u, vector<int>& parent,
                 vector<bool>& seen, vector<State>& states,
                 int& maxCycleLength) {
    seen[u] = true;
    states[u] = State::kVisiting;

    for (const int v : graph[u]) {
      if (!seen[v]) {
        parent[v] = u;
        findCycle(graph, v, parent, seen, states, maxCycleLength);
      } else if (states[v] == State::kVisiting) {
        // Find the cycle's length.
        int curr = u;
        int cycleLength = 1;
        while (curr != v) {
          curr = parent[curr];
          ++cycleLength;
        }
        maxCycleLength = max(maxCycleLength, cycleLength);
      }
    }

    states[u] = State::kVisited;
  }
};",2127
2126,"class Solution {
 public:
  bool removeOnes(vector<vector<int>>& grid) {
    const vector<int> revRow = getRevRow(grid[0]);
    return ranges::all_of(
        grid, [&](const auto& row) { return row == grid[0] || row == revRow; });
  }

 private:
  vector<int> getRevRow(vector<int>& row) {
    vector<int> revRow;
    for (const int a : row)
      revRow.push_back(a ^ 1);
    return revRow;
  }
};",2128
2127,"class Solution {
 public:
  string capitalizeTitle(string title) {
    ranges::transform(title, title.begin(), ::tolower);

    int i = 0;  // Point to the start of a word.
    int j = 0;  // Point to the end of a word.

    while (j < title.length()) {
      while (j < title.length() && title[j] != ' ')
        ++j;
      if (j - i > 2)
        title[i] = toupper(title[i]);
      i = j + 1;
      ++j;  // Skip the spaces.
    }

    return title;
  }
};",2129
2128,"class Solution {
 public:
  int pairSum(ListNode* head) {
    int ans = 0;
    ListNode* slow = head;
    ListNode* fast = head;

    // `slow` points to the start of the second half.
    while (fast != nullptr && fast->next != nullptr) {
      slow = slow->next;
      fast = fast->next->next;
    }

    // `tail` points to the end of the reversed second half.
    ListNode* tail = reverseList(slow);

    while (tail != nullptr) {
      ans = max(ans, head->val + tail->val);
      head = head->next;
      tail = tail->next;
    }

    return ans;
  }

 private:
  ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    while (head) {
      auto next = head->next;
      head->next = prev;
      prev = head;
      head = next;
    }
    return prev;
  }
};",2130
2129,"class Solution {
 public:
  int longestPalindrome(vector<string>& words) {
    int ans = 0;
    vector<vector<int>> count(26, vector<int>(26));

    for (const string& word : words) {
      const int i = word[0] - 'a';
      const int j = word[1] - 'a';
      if (count[j][i]) {
        ans += 4;
        --count[j][i];
      } else {
        ++count[i][j];
      }
    }

    for (int i = 0; i < 26; ++i)
      if (count[i][i])
        return ans + 2;

    return ans;
  }
};",2131
2130,"class Solution {
 public:
  bool possibleToStamp(vector<vector<int>>& grid, int stampHeight,
                       int stampWidth) {
    const int m = grid.size();
    const int n = grid[0].size();
    // A[i][j] := the number of 1s in grid[0..i)[0..j)
    vector<vector<int>> A(m + 1, vector<int>(n + 1));
    // B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)
    vector<vector<int>> B(m + 1, vector<int>(n + 1));
    // fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)
    vector<vector<bool>> fit(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j];
        if (i + 1 >= stampHeight && j + 1 >= stampWidth) {
          const int x = i - stampHeight + 1;
          const int y = j - stampWidth + 1;
          if (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0)
            fit[i][j] = true;
        }
      }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (!grid[i][j]) {
          const int x = min(i + stampHeight, m);
          const int y = min(j + stampWidth, n);
          if (B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0)
            return false;
        }

    return true;
  }
};",2132
2131,"class Solution {
 public:
  bool checkValid(vector<vector<int>>& matrix) {
    const int n = matrix.size();

    for (int i = 0; i < n; ++i) {
      bitset<101> row;
      bitset<101> col;
      for (int j = 0; j < n; ++j) {
        row[matrix[i][j]] = true;
        col[matrix[j][i]] = true;
      }
      if (min(row.count(), col.count()) < n)
        return false;
    }

    return true;
  }
};",2133
2132,"class Solution {
 public:
  int minSwaps(vector<int>& nums) {
    const int n = nums.size();
    const int k = ranges::count(nums, 1);
    int ones = 0;     // the number of ones in the window
    int maxOnes = 0;  // the maximum number of ones in the window

    for (int i = 0; i < n * 2; ++i) {
      if (i >= k && nums[(i - k) % n])
        --ones;
      if (nums[i % n])
        ++ones;
      maxOnes = max(maxOnes, ones);
    }

    return k - maxOnes;
  }
};",2134
2133,"class Solution {
 public:
  int wordCount(vector<string>& startWords, vector<string>& targetWords) {
    int ans = 0;
    unordered_set<int> seen;

    for (const string& w : startWords)
      seen.insert(getMask(w));

    for (const string& w : targetWords) {
      const int mask = getMask(w);
      for (const char c : w)
        // Toggle one character.
        if (seen.count(mask ^ 1 << c - 'a')) {
          ++ans;
          break;
        }
    }

    return ans;
  }

 private:
  int getMask(const string& s) {
    int mask = 0;
    for (const char c : s)
      mask ^= 1 << c - 'a';
    return mask;
  }
};",2135
2134,"struct Seed {
  int p;
  int g;
  Seed(int p, int g) : p(p), g(g) {}
};

class Solution {
 public:
  int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {
    int ans = 0;
    int time = 0;
    vector<Seed> seeds;

    for (int i = 0; i < plantTime.size(); ++i)
      seeds.emplace_back(plantTime[i], growTime[i]);

    ranges::sort(seeds, [](const Seed& a, const Seed& b) { return a.g > b.g; });

    for (const auto& [p, g] : seeds) {
      time += p;
      ans = max(ans, time + g);
    }

    return ans;
  }
};",2136
2135,"class Solution {
 public:
  double equalizeWater(vector<int>& buckets, int loss) {
    constexpr double kErr = 1e-5;
    const double kPercentage = (100 - loss) / (double)100;
    double l = 0.0;
    double r = ranges::max(buckets);

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (canFill(buckets, m, kPercentage))
        l = m;
      else
        r = m;
    }

    return l;
  }

 private:
  bool canFill(const vector<int>& buckets, double target, double kPercentage) {
    double extra = 0.0;
    double need = 0.0;
    for (const int bucket : buckets)
      if (bucket > target)
        extra += bucket - target;
      else
        need += target - bucket;
    return extra * kPercentage >= need;
  }
};",2137
2136,"class Solution {
 public:
  vector<string> divideString(string s, int k, char fill) {
    vector<string> ans;

    for (int i = 0; i < s.length(); i += k)
      ans.push_back(i + k > s.length()
                        ? s.substr(i) + string(i + k - s.length(), fill)
                        : s.substr(i, k));

    return ans;
  }
};",2138
2137,"class Solution {
 public:
  int minMoves(int target, int maxDoubles) {
    int steps = 0;

    while (target > 1 && maxDoubles) {
      if (target % 2 == 1) {
        --target;
      } else {
        target /= 2;
        --maxDoubles;
      }
      ++steps;
    }

    return steps + target - 1;
  }
};",2139
2138,"class Solution {
 public:
  long long mostPoints(vector<vector<int>>& questions) {
    const int n = questions.size();
    // dp[i] := the maximum points starting from questions[i]
    vector<long long> dp(n + 1);

    for (int i = n - 1; i >= 0; --i) {
      const int points = questions[i][0];
      const int brainpower = questions[i][1];
      const int nextIndex = i + brainpower + 1;
      const long long nextPoints = nextIndex < n ? dp[nextIndex] : 0;
      dp[i] = max(points + nextPoints, dp[i + 1]);
    }

    return dp[0];
  }
};",2140
2139,"class Solution {
 public:
  long long maxRunTime(int n, vector<int>& batteries) {
    long long sum = accumulate(batteries.begin(), batteries.end(), 0LL);

    ranges::sort(batteries);

    // The maximum battery is greater than the average, so it can last forever.
    // Reduce the problem from size n to size n - 1.
    while (batteries.back() > sum / n) {
      sum -= batteries.back(), batteries.pop_back();
      --n;
    }

    // If the maximum battery <= average running time, it won't be waste, and so
    // do smaller batteries.
    return sum / n;
  }
};",2141
2140,"WITH
  RECURSIVE BusesNeighbors AS (
    SELECT
      bus_id,
      arrival_time,
      IFNULL(LAG(arrival_time) OVER(
        ORDER BY arrival_time), 0
      ) AS prev_arrival_time
    FROM Buses
  )
SELECT
  BusesNeighbors.bus_id,
  COUNT(Passengers.passenger_id) AS passengers_cnt
FROM BusesNeighbors
LEFT JOIN Passengers
  ON (
    BusesNeighbors.prev_arrival_time < Passengers.arrival_time
    AND Passengers.arrival_time <= BusesNeighbors.arrival_time)
GROUP BY 1
ORDER BY 1;",2142
2141,"class Solution {
 public:
  int countSubranges(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    // {sum, count}, add if choose from nums1, minus if choose from nums2
    unordered_map<int, int> dp;

    for (int i = 0; i < nums1.size(); ++i) {
      // edge case: nums1[i] == nums2[i] == 0, so can't put them in the
      // initializer list.
      unordered_map<int, int> newDp;
      ++newDp[nums1[i]];
      ++newDp[-nums2[i]];

      for (const auto& [prevSum, count] : dp) {
        // Choose nums1[i].
        newDp[prevSum + nums1[i]] += count;
        newDp[prevSum + nums1[i]] %= kMod;
        // Choose nums2[i].
        newDp[prevSum - nums2[i]] += count;
        newDp[prevSum - nums2[i]] %= kMod;
      }

      dp = move(newDp);
      if (const auto it = dp.find(0); it != dp.cend()) {
        ans += it->second;
        ans %= kMod;
      }
    }

    return ans;
  }
};",2143
2142,"class Solution {
 public:
  int minimumCost(vector<int>& cost) {
    int ans = 0;

    ranges::sort(cost, [](const int a, const int b) { return a > b; });

    for (int i = 0; i < cost.size(); ++i)
      if (i % 3 != 2)
        ans += cost[i];

    return ans;
  }
};",2144
2143,"class Solution {
 public:
  int numberOfArrays(vector<int>& differences, int lower, int upper) {
    // Starts from 0, so prefix[0] = 0.
    // Changing prefix[0] to any other number doesn't affect the answer.
    vector<long> prefix(differences.size() + 1);

    for (int i = 0; i < differences.size(); ++i)
      prefix[i + 1] += prefix[i] + differences[i];

    const long maxi = ranges::max(prefix);
    const long mini = ranges::min(prefix);
    return max(0L, (upper - lower) - (maxi - mini) + 1);
  }
};",2145
2144,"class Solution {
 public:
  vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid,
                                          vector<int>& pricing,
                                          vector<int>& start, int k) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    const int low = pricing[0];
    const int high = pricing[1];
    const int row = start[0];
    const int col = start[1];
    vector<vector<int>> ans;

    if (low <= grid[row][col] && grid[row][col] <= high) {
      ans.push_back({row, col});
      if (k == 1)
        return ans;
    }

    queue<pair<int, int>> q{{{row, col}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[row][col] = true;  // Mark as visited.

    while (!q.empty()) {
      vector<vector<int>> neighbors;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (!grid[x][y] || seen[x][y])
            continue;
          if (low <= grid[x][y] && grid[x][y] <= high)
            neighbors.push_back({x, y});
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
      ranges::sort(neighbors, [&](const vector<int>& a, const vector<int>& b) {
        const int x1 = a[0];
        const int y1 = a[1];
        const int x2 = b[0];
        const int y2 = b[1];
        if (grid[x1][y1] != grid[x2][y2])
          return grid[x1][y1] < grid[x2][y2];
        return x1 == x2 ? y1 < y2 : x1 < x2;
      });
      for (const vector<int>& neighbor : neighbors) {
        if (ans.size() < k)
          ans.push_back(neighbor);
        if (ans.size() == k)
          return ans;
      }
    }

    return ans;
  }
};",2146
2145,"class Solution {
 public:
  int numberOfWays(string corridor) {
    constexpr int kMod = 1'000'000'007;
    long ans = 1;
    int prevSeat = -1;
    int numSeats = 0;

    for (int i = 0; i < corridor.length(); ++i) {
      if (corridor[i] == 'S') {
        if (++numSeats > 2 && numSeats & 1)
          ans = ans * (i - prevSeat) % kMod;
        prevSeat = i;
      }
    }

    return numSeats > 1 && numSeats % 2 == 0 ? ans : 0;
  }
};",2147
2146,"class Solution {
 public:
  int countElements(vector<int>& nums) {
    const int min = ranges::min(nums);
    const int max = ranges::max(nums);
    return ranges::count_if(
        nums, [&](const int num) { return min < num && num < max; });
  }
};",2148
2147,"class Solution {
 public:
  vector<int> rearrangeArray(vector<int>& nums) {
    vector<int> ans;
    vector<int> pos;
    vector<int> neg;

    for (const int num : nums)
      (num > 0 ? pos : neg).push_back(num);

    for (int i = 0; i < pos.size(); ++i) {
      ans.push_back(pos[i]);
      ans.push_back(neg[i]);
    }

    return ans;
  }
};",2149
2148,"class Solution {
 public:
  vector<int> findLonely(vector<int>& nums) {
    vector<int> ans;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      if (freq == 1 && !count.count(num - 1) && !count.count(num + 1))
        ans.push_back(num);

    return ans;
  }
};",2150
2149,"class Solution {
 public:
  int maximumGood(vector<vector<int>>& statements) {
    int ans = 0;
    dfs(statements, {}, 0, 0, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& statements, vector<int>&& good, int i,
           int count, int& ans) {
    if (i == statements.size()) {
      if (isValid(statements, good))
        ans = max(ans, count);
      return;
    }

    good.push_back(0);  // Assume the i-th person is bad.
    dfs(statements, move(good), i + 1, count, ans);
    good.back() = 1;  // Assume the i-th person is good.
    dfs(statements, move(good), i + 1, count + 1, ans);
    good.pop_back();
  }

  bool isValid(const vector<vector<int>>& statements, const vector<int>& good) {
    for (int i = 0; i < good.size(); ++i) {
      if (!good[i])  // The i-th person is bad, so no need to check.
        continue;
      for (int j = 0; j < statements.size(); ++j) {
        if (statements[i][j] == 2)
          continue;
        if (statements[i][j] != good[j])
          return false;
      }
    }
    return true;
  }
};",2151
2150,"class Solution {
 public:
  int minimumLines(vector<vector<int>>& points) {
    const int allCovered = (1 << points.size()) - 1;
    return dfs(points, 0, allCovered, vector<int>(allCovered, -1));
  }

 private:
  int dfs(const vector<vector<int>>& points, int covered, int allCovered,
          vector<int>&& mem) {
    if (covered == allCovered)
      return 0;
    if (mem[covered] != -1)
      return mem[covered];

    const int n = points.size();
    int ans = n / 2 + (n & 1);

    for (int i = 0; i < n; ++i) {
      if (covered >> i & 1)
        continue;
      for (int j = 0; j < n; ++j) {
        if (i == j)
          continue;
        // Connect the points[i] with the points[j].
        int newCovered = covered | 1 << i | 1 << j;
        // Mark the points covered by this line.
        const pair<int, int> slope = getSlope(points[i], points[j]);
        for (int k = 0; k < n; ++k)
          if (getSlope(points[i], points[k]) == slope)
            newCovered |= 1 << k;
        ans = min(ans, 1 + dfs(points, newCovered, allCovered, move(mem)));
      }
    }

    return mem[covered] = ans;
  }

  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {
    const int dx = p[0] - q[0];
    const int dy = p[1] - q[1];
    if (dx == 0)
      return {0, p[0]};
    if (dy == 0)
      return {p[1], 0};
    const int d = __gcd(dx, dy);
    const int x = dx / d;
    const int y = dy / d;
    if (x > 0)
      return {x, y};
    return {-x, -y};
  }
};",2152
2151,"WITH
  RECURSIVE BusesNeighbors AS (
    SELECT
      bus_id,
      arrival_time,
      capacity,
      IFNULL(LAG(arrival_time) OVER(
        ORDER BY arrival_time), 0
      ) AS prev_arrival_time
    FROM Buses
  ),
  BusesMetadata AS (
    SELECT
      BusesNeighbors.bus_id,
      BusesNeighbors.arrival_time,
      BusesNeighbors.capacity,
      BusesNeighbors.prev_arrival_time,
      COUNT(Passengers.passenger_id) AS waiting,
      ROW_NUMBER() OVER(
        ORDER BY BusesNeighbors.arrival_time
      ) AS `row_number`
    FROM BusesNeighbors
    LEFT JOIN Passengers
      ON (
        BusesNeighbors.prev_arrival_time < Passengers.arrival_time
        AND Passengers.arrival_time <= BusesNeighbors.arrival_time)
    GROUP BY 1, 2, 3
  ),
  Boarding AS (
    SELECT
      BusesMetadata.`row_number`,
      BusesMetadata.bus_id,
      LEAST(
        BusesMetadata.capacity,
        BusesMetadata.waiting
      ) AS boarded,
      GREATEST(
        0,
        BusesMetadata.waiting - BusesMetadata.capacity
      ) AS not_boarded
    FROM BusesMetadata
    WHERE `row_number` = 1
    UNION ALL
    SELECT
      BusesMetadata.`row_number`,
      BusesMetadata.bus_id,
      LEAST(
        BusesMetadata.capacity,
        Boarding.not_boarded + BusesMetadata.waiting
      ) AS boarded,
      GREATEST(
        0,
        Boarding.not_boarded + BusesMetadata.waiting - BusesMetadata.capacity
      ) AS not_boarded
    FROM BusesMetadata, Boarding
    WHERE BusesMetadata.`row_number` = Boarding.`row_number` + 1
  )
SELECT
  bus_id,
  boarded AS passengers_cnt
FROM Boarding
ORDER BY 1;",2153
2152,"class Solution {
 public:
  vector<int> maxScoreIndices(vector<int>& nums) {
    const int zeros = ranges::count(nums, 0);
    const int ones = nums.size() - zeros;
    vector<int> ans{0};  // the division at index 0
    int leftZeros = 0;
    int leftOnes = 0;
    int maxScore = ones;  // `leftZeros` + `rightOnes`

    for (int i = 0; i < nums.size(); ++i) {
      leftZeros += nums[i] == 0;
      leftOnes += nums[i] == 1;
      const int rightOnes = ones - leftOnes;
      const int score = leftZeros + rightOnes;
      if (maxScore == score) {
        ans.push_back(i + 1);
      } else if (maxScore < score) {
        maxScore = score;
        ans = {i + 1};
      }
    }

    return ans;
  }
};",2155
2153,"class Solution {
 public:
  string subStrHash(string s, int power, int modulo, int k, int hashValue) {
    long maxPower = 1;
    long hash = 0;
    int bestLeft = -1;

    auto val = [](char c) -> int { return c - 'a' + 1; };

    for (int i = s.length() - 1; i >= 0; --i) {
      hash = (hash * power + val(s[i])) % modulo;
      if (i + k < s.length())
        hash = (hash - val(s[i + k]) * maxPower % modulo + modulo) % modulo;
      else
        maxPower = maxPower * power % modulo;
      if (hash == hashValue)
        bestLeft = i;
    }

    return s.substr(bestLeft, k);
  }
};",2156
2154,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), sz(n, 1) {
    iota(id.begin(), id.end(), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
    --count;
  }

  int getCount() const {
    return count;
  }

  int getMaxSize() const {
    return ranges::max(sz);
  }

 private:
  int count;
  vector<int> id;
  vector<int> sz;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> groupStrings(vector<string>& words) {
    UnionFind uf(words.size());
    unordered_map<int, int> maskToIndex;
    unordered_map<int, int> deletedMaskToIndex;

    for (int i = 0; i < words.size(); ++i) {
      const int mask = getMask(words[i]);
      for (int j = 0; j < 26; ++j)
        if (mask >> j & 1) {
          // Going to delete this bit.
          const int m = mask ^ 1 << j;
          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())
            uf.unionBySize(i, it->second);
          if (const auto it = deletedMaskToIndex.find(m);
              it != deletedMaskToIndex.cend())
            uf.unionBySize(i, it->second);
          else
            deletedMaskToIndex[m] = i;
        } else {
          // Going to add this bit.
          const int m = mask | 1 << j;
          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())
            uf.unionBySize(i, it->second);
        }
      maskToIndex[mask] = i;
    }

    return {uf.getCount(), uf.getMaxSize()};
  }

 private:
  int getMask(const string& s) {
    int mask = 0;
    for (const char c : s)
      mask |= 1 << c - 'a';
    return mask;
  }
};",2157
2155,"enum class Type { kEntering, kLeaving };

struct Event {
  int day;
  int index;
  Type type;
  Event(int day, int index, Type type) : day(day), index(index), type(type) {}
};

class Solution {
 public:
  vector<int> amountPainted(vector<vector<int>>& paint) {
    const int n = paint.size();
    const int minDay = (*ranges::min_element(
        paint, [](const vector<int>& a, const vector<int>& b) {
      return a[0] < b[0];
    }))[0];
    const int maxDay = (*ranges::max_element(
        paint, [](const vector<int>& a, const vector<int>& b) {
      return a[1] < b[1];
    }))[1];
    vector<int> ans(n);
    vector<Event> events;
    // Stores the indices of paints that are available now.
    set<int> runningIndices;

    for (int i = 0; i < n; ++i) {
      const int start = paint[i][0];
      const int end = paint[i][1];
      events.emplace_back(start, i, Type::kEntering);  // 1 := entering
      events.emplace_back(end, i, Type::kLeaving);     // -1 := leaving
    }

    ranges::sort(events,
                 [](const auto& a, const auto& b) { return a.day < b.day; });

    int i = 0;  // events' index
    for (int day = minDay; day < maxDay; ++day) {
      while (i < events.size() && events[i].day == day) {
        if (events[i].type == Type::kEntering)
          runningIndices.insert(events[i].index);
        else
          runningIndices.erase(events[i].index);
        ++i;
      }
      if (!runningIndices.empty())
        ++ans[*runningIndices.begin()];
    }

    return ans;
  }
};",2158
2156,"WITH
  FirstCols AS(
    SELECT
      first_col,
      ROW_NUMBER() OVER() AS `row_number`
    FROM Data
    ORDER BY 1
  ),
  SecondCols AS (
    SELECT
      second_col,
      ROW_NUMBER() OVER() AS `row_number`
    FROM Data
    ORDER BY 1 DESC
  )
SELECT
  FirstCols.first_col,
  SecondCols.second_col
FROM FirstCols
INNER JOIN SecondCols
  USING (`row_number`);",2159
2157,"class Solution {
 public:
  int minimumSum(int num) {
    string s = to_string(num);
    ranges::sort(s);
    return stoi(s.substr(0, 1) + s.substr(2, 1)) +
           stoi(s.substr(1, 1) + s.substr(3, 1));
  }
};",2160
2158,"class Solution {
 public:
  vector<int> pivotArray(vector<int>& nums, int pivot) {
    vector<int> ans;

    for (const int num : nums)
      if (num < pivot)
        ans.push_back(num);

    for (const int num : nums)
      if (num == pivot)
        ans.push_back(num);

    for (const int num : nums)
      if (num > pivot)
        ans.push_back(num);

    return ans;
  }
};",2161
2159,"class Solution {
 public:
  int minCostSetTime(int startAt, int moveCost, int pushCost,
                     int targetSeconds) {
    int ans = INT_MAX;
    int mins = targetSeconds > 5999 ? 99 : targetSeconds / 60;
    int secs = targetSeconds - mins * 60;

    auto getCost = [&](int mins, int secs) -> int {
      int cost = 0;
      char curr = '0' + startAt;
      for (const char c : to_string(mins * 100 + secs))
        if (c == curr) {
          cost += pushCost;
        } else {
          cost += moveCost + pushCost;
          curr = c;
        }
      return cost;
    };

    while (secs < 100) {
      ans = min(ans, getCost(mins, secs));
      --mins;
      secs += 60;
    }

    return ans;
  }
};",2162
2160,"class Solution {
 public:
  long long minimumDifference(vector<int>& nums) {
    const int n = nums.size() / 3;
    long long ans = LLONG_MAX;
    long long leftSum = 0;
    long long rightSum = 0;
    // The left part should be as small as possible.
    priority_queue<int> maxHeap;
    // The right part should be as big as possible.
    priority_queue<int, vector<int>, greater<>> minHeap;
    // minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)
    vector<long long> minLeftSum(nums.size());

    for (int i = 0; i < 2 * n; ++i) {
      maxHeap.push(nums[i]);
      leftSum += nums[i];
      if (maxHeap.size() == n + 1)
        leftSum -= maxHeap.top(), maxHeap.pop();
      if (maxHeap.size() == n)
        minLeftSum[i] = leftSum;
    }

    for (int i = nums.size() - 1; i >= n; --i) {
      minHeap.push(nums[i]);
      rightSum += nums[i];
      if (minHeap.size() == n + 1)
        rightSum -= minHeap.top(), minHeap.pop();
      if (minHeap.size() == n)
        ans = min(ans, minLeftSum[i - 1] - rightSum);
    }

    return ans;
  }
};",2163
2161,"class Solution {
 public:
  vector<int> sortEvenOdd(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    vector<int> evenCount(101);
    vector<int> oddCount(101);

    for (int i = 0; i < n; ++i)
      if (i & 1)
        ++oddCount[nums[i]];
      else
        ++evenCount[nums[i]];

    int ansIndex = 0;
    for (int i = 1; i < 101; ++i)
      while (evenCount[i]--) {
        ans[ansIndex] = i;
        ansIndex += 2;
      }

    ansIndex = 1;
    for (int i = 100; i > 0; --i)
      while (oddCount[i]--) {
        ans[ansIndex] = i;
        ansIndex += 2;
      }

    return ans;
  }
};",2164
2162,"class Solution {
 public:
  long long smallestNumber(long long num) {
    string s = to_string(abs(num));
    ranges::sort(s, [&](int a, int b) { return num < 0 ? a > b : a < b; });
    if (num > 0)
      swap(s[0], s[s.find_first_not_of('0')]);
    return stoll(s) * (num < 0 ? -1 : 1);
  }
};",2165
2163,fix(idx: int),2166
2164,"class Solution {
 public:
  int minimumTime(string s) {
    const int n = s.length();
    // left[i] := the minimum time to remove the illegal cars of s[0..i]
    vector<int> left(n);
    left[0] = s[0] - '0';
    // dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally
    // + the time to remove the illegal cars of s[i + 1..n) consecutively
    // Note that the way to remove the illegal cars in the right part
    // doesn't need to be optimal since:
    //   `left | illegal cars | n - 1 - k` will be covered in
    //   `left' | n - 1 - i` later.
    vector<int> dp(n, n);
    dp[0] = left[0] + n - 1;

    for (int i = 1; i < n; ++i) {
      left[i] = min(left[i - 1] + (s[i] - '0') * 2, i + 1);
      dp[i] = min(dp[i], left[i] + n - 1 - i);
    }

    return ranges::min(dp);
  }
};",2167
2165,"class Solution {
 public:
  int equalDigitFrequency(string s) {
    const string_view sv(s);
    unordered_set<int> seen;

    for (int i = 0; i < s.length(); ++i)
      for (int j = i; j < s.length(); ++j)
        if (isUnique(sv.substr(i, j - i + 1)))
          seen.insert(getRollingHash(sv.substr(i, j - i + 1)));

    return seen.size();
  }

 private:
  static constexpr int power = 11;
  static constexpr int kMod = 1'000'000'007;

  bool isUnique(const string_view& sv) {
    vector<int> count(10);
    int unique = 0;
    for (const char c : sv)
      if (++count[c - '0'] == 1)
        ++unique;
    const int maxCount = ranges::max(count);
    return maxCount * unique == sv.length();
  }

  int getRollingHash(const string_view& sv) {
    long hash = 0;
    for (const char c : sv)
      hash = (hash * power + val(c)) % kMod;
    return hash;
  }

  constexpr int val(char c) {
    return c - '0' + 1;
  }
};",2168
2166,"class Solution {
 public:
  int countOperations(int num1, int num2) {
    int ans = 0;

    while (num1 && num2) {
      if (num1 < num2)
        swap(num1, num2);
      ans += num1 / num2;
      num1 %= num2;
    }

    return ans;
  }
};",2169
2167,"struct T {
  unordered_map<int, int> count;
  int max = 0;
  int secondMax = 0;
  int maxFreq = 0;
  int secondMaxFreq = 0;
};

class Solution {
 public:
  int minimumOperations(vector<int>& nums) {
    // 0 := odd indices, 1 := even indices
    vector<T> ts(2);

    for (int i = 0; i < nums.size(); ++i) {
      auto& t = ts[i & 1];
      const int freq = ++t.count[nums[i]];
      if (freq > t.maxFreq) {
        t.maxFreq = freq;
        t.max = nums[i];
      } else if (freq > t.secondMaxFreq) {
        t.secondMaxFreq = freq;
        t.secondMax = nums[i];
      }
    }

    if (ts[0].max == ts[1].max)
      return nums.size() - max(ts[0].maxFreq + ts[1].secondMaxFreq,
                               ts[1].maxFreq + ts[0].secondMaxFreq);
    return nums.size() - (ts[0].maxFreq + ts[1].maxFreq);
  }
};",2170
2168,"class Solution {
 public:
  long long minimumRemoval(vector<int>& beans) {
    const long n = beans.size();
    const long sum = accumulate(beans.begin(), beans.end(), 0L);
    long ans = LONG_MAX;

    ranges::sort(beans);

    for (int i = 0; i < n; ++i)
      ans = min(ans, sum - (n - i) * beans[i]);

    return ans;
  }
};",2171
2169,"class Solution {
 public:
  int maximumANDSum(vector<int>& nums, int numSlots) {
    const int n = 2 * numSlots;
    const int nSelected = 1 << n;
    // dp[i] := the maximum value, where i is the bitmask of the selected
    // numbers
    vector<int> dp(nSelected);

    nums.resize(n);

    for (int mask = 1; mask < nSelected; ++mask) {
      const int selected = __builtin_popcount(mask);
      const int slot = (selected + 1) / 2;  // (1, 2) -> 1, (3, 4) -> 2
      for (int i = 0; i < n; ++i)
        if (mask >> i & 1)  // Assign `nums[i]` to the `slot`-th slot.
          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & nums[i]));
    }

    return dp.back();
  }
};",2172
2170,"WITH
  MatchesWithRowNumberInEachPlayer AS (
    SELECT
      *,
      ROW_NUMBER() OVER(
        PARTITION BY player_id
        ORDER BY match_day
      ) AS `row_number`
    FROM Matches
  ),
  `Groups` AS (
    SELECT
      *,
      `row_number` - ROW_NUMBER() OVER(
        PARTITION BY player_id
        ORDER BY match_day
      ) AS group_id
    FROM MatchesWithRowNumberInEachPlayer
    WHERE result = 'Win'
  ),
  ConsecCounts AS (
    SELECT
      player_id,
      COUNT(*) AS consec_count
    FROM `Groups`
    GROUP BY player_id, group_id
  )
SELECT
  Matches.player_id,
  IFNULL(MAX(ConsecCounts.consec_count), 0) AS longest_streak
FROM Matches
LEFT JOIN ConsecCounts
  USING (player_id)
GROUP BY 1;",2173
2171,"class Solution {
 public:
  int removeOnes(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> mem(1 << m * n, INT_MAX);
    return removeOnes(encode(grid, m, n), m, n, mem);
  }

 private:
  // Returns the minimum number of operations to remove all 1s from the grid,
  // where `mask` is the bitmask of the state of the grid.
  int removeOnes(int mask, int m, int n, vector<int>& mem) {
    if (mask == 0)
      return 0;
    if (mem[mask] < INT_MAX)
      return mem[mask];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mask >> i * n + j & 1) {  // grid[i][j] == 1
          int nextMask = mask;
          // Set the cells in the same row with 0.
          for (int k = 0; k < n; ++k)
            nextMask &= ~(1 << i * n + k);
          // Set the cells in the same column with 0.
          for (int k = 0; k < m; ++k)
            nextMask &= ~(1 << k * n + j);
          mem[mask] = min(mem[mask], 1 + removeOnes(nextMask, m, n, mem));
        }

    return mem[mask];
  }

  int encode(const vector<vector<int>>& grid, int m, int n) {
    int encoded = 0;
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j])
          encoded |= 1 << i * n + j;
    return encoded;
  }
};",2174
2172,"SELECT
  TeamPoints.team_id,
  TeamPoints.name,
  CAST(
    RANK() OVER(
      ORDER BY TeamPoints.points DESC, TeamPoints.name
    ) AS SIGNED
  ) -
  CAST(
    RANK() OVER(
      ORDER BY TeamPoints.points + PointsChange.points_change DESC,
        TeamPoints.name
    ) AS SIGNED
  ) AS rank_diff
FROM TeamPoints
INNER JOIN PointsChange
  USING (team_id);",2175
2173,"class Solution {
 public:
  int countPairs(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, vector<int>> numToIndices;

    for (int i = 0; i < nums.size(); ++i)
      numToIndices[nums[i]].push_back(i);

    for (const auto& [_, indices] : numToIndices) {
      unordered_map<int, int> gcds;
      for (const int i : indices) {
        const int gcd_i = gcd(i, k);
        for (const auto& [gcd_j, count] : gcds)
          if (gcd_i * gcd_j % k == 0)
            ans += count;
        ++gcds[gcd_i];
      }
    }

    return ans;
  }
};",2176
2174,"class Solution {
 public:
  vector<long long> sumOfThree(long long num) {
    if (num % 3)
      return {};
    const long long x = num / 3;
    return {x - 1, x, x + 1};
  }
};",2177
2175,"class Solution {
 public:
  vector<long long> maximumEvenSplit(long long finalSum) {
    if (finalSum & 1)
      return {};

    vector<long long> ans;
    long long needSum = finalSum;
    long long even = 2;

    while (needSum - even >= even + 2) {
      ans.push_back(even);
      needSum -= even;
      even += 2;
    }

    ans.push_back(needSum);
    return ans;
  }
};",2178
2176,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
    const int n = nums1.size();
    long long ans = 0;
    unordered_map<int, int> numToIndex;
    vector<int> A;
    // leftSmaller[i] := the number of A[j] < A[i], where 0 <= j < i
    vector<int> leftSmaller(n);
    // rightLarger[i] := the number of A[j] > A[i], where i < j < n
    vector<int> rightLarger(n);
    FenwickTree tree1(n);  // Calculates `leftSmaller`.
    FenwickTree tree2(n);  // Calculates `rightLarger`.

    for (int i = 0; i < n; ++i)
      numToIndex[nums1[i]] = i;

    // Remap each number in `nums2` to the according index in `nums1` as `A`.
    // Rephrase the problem as finding the number of increasing tripets in `A`.
    for (const int num : nums2)
      A.push_back(numToIndex[num]);

    for (int i = 0; i < n; ++i) {
      leftSmaller[i] = tree1.get(A[i]);
      tree1.update(A[i] + 1, 1);
    }

    for (int i = n - 1; i >= 0; --i) {
      rightLarger[i] = tree2.get(n) - tree2.get(A[i]);
      tree2.update(A[i] + 1, 1);
    }

    for (int i = 0; i < n; ++i)
      ans += static_cast<long>(leftSmaller[i]) * rightLarger[i];

    return ans;
  }
};",2179
2177,"class Solution {
 public:
  int countEven(int num) {
    return (num - getDigitSum(num) % 2) / 2;
  }

 private:
  int getDigitSum(int num) {
    int digitSum = 0;
    while (num > 0) {
      digitSum += num % 10;
      num /= 10;
    }
    return digitSum;
  }
};",2180
2178,"class Solution {
 public:
  ListNode* mergeNodes(ListNode* head) {
    if (head == nullptr)
      return nullptr;
    if (!head->next->val) {
      ListNode* node = new ListNode(head->val);
      node->next = mergeNodes(head->next->next);
      return node;
    }

    ListNode* next = mergeNodes(head->next);
    next->val += head->val;
    return next;
  }
};",2181
2179,"class Solution {
 public:
  string repeatLimitedString(string s, int repeatLimit) {
    string ans;
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    while (true) {
      const bool addOne = !ans.empty() && shouldAddOne(ans, count);
      const int i = getLargestChar(ans, count);
      if (i == -1)
        break;
      const int repeats = addOne ? 1 : min(count[i], repeatLimit);
      ans += string(repeats, 'a' + i);
      count[i] -= repeats;
    }

    return ans;
  }

 private:
  bool shouldAddOne(const string& ans, const vector<int>& count) {
    for (int i = 25; i >= 0; --i)
      if (count[i])
        return ans.back() == 'a' + i;
    return false;
  }

  int getLargestChar(const string& ans, const vector<int>& count) {
    for (int i = 25; i >= 0; --i)
      if (count[i] && (ans.empty() || ans.back() != 'a' + i))
        return i;
    return -1;
  }
};",2182
2180,"class Solution {
 public:
  long long countPairs(vector<int>& nums, int k) {
    long long ans = 0;
    unordered_map<int, int> gcds;

    for (const int num : nums) {
      const long long gcd_i = gcd(num, k);
      for (const auto& [gcd_j, count] : gcds)
        if (gcd_i * gcd_j % k == 0)
          ans += count;
      ++gcds[gcd_i];
    }

    return ans;
  }
};",2183
2181,"class Solution {
 public:
  int buildWall(int height, int width, vector<int>& bricks) {
    constexpr int kMod = 1'000'000'007;
    // Stores the valid rows in bitmask.
    vector<int> rows;
    buildRows(width, bricks, 0, rows);

    const int n = rows.size();
    // dp[i] := the number of ways to build `h` height walls with rows[i] in the
    // bottom
    vector<long> dp(n, 1);
    // graph[i] := the valid neighbors of rows[i]
    vector<vector<int>> graph(n);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (!(rows[i] & rows[j]))
          graph[i].push_back(j);

    for (int h = 2; h <= height; ++h) {
      vector<long> newDp(n);
      for (int i = 0; i < n; ++i)
        for (const int v : graph[i]) {
          newDp[i] += dp[v];
          newDp[i] %= kMod;
        }
      dp = move(newDp);
    }

    return accumulate(dp.begin(), dp.end(), 0L) % kMod;
  }

 private:
  void buildRows(int width, const vector<int>& bricks, int path,
                 vector<int>& rows) {
    for (const int brick : bricks)
      if (brick == width)
        rows.push_back(path);
      else if (brick < width) {
        const int newWidth = width - brick;
        buildRows(newWidth, bricks, path | 1 << newWidth, rows);
      }
  }
};",2184
2182,"class Solution {
 public:
  int prefixCount(vector<string>& words, string pref) {
    return ranges::count_if(
        words, [&](const string& word) { return word.find(pref) == 0; });
  }
};",2185
2183,"class Solution {
 public:
  int minSteps(string s, string t) {
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (const char c : t)
      --count[c - 'a'];

    return accumulate(count.begin(), count.end(), 0,
                      [](int res, int c) { return res + abs(c); });
  }
};",2186
2184,"class Solution {
 public:
  long long minimumTime(vector<int>& time, int totalTrips) {
    long long l = 1;
    long long r = ranges::min(time) * static_cast<long>(totalTrips);

    while (l < r) {
      const long long m = (l + r) / 2;
      if (numTrips(time, m) >= totalTrips)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

  long numTrips(const vector<int>& times, long m) {
    return accumulate(times.begin(), times.end(), 0L,
                      [&](long subtotal, int t) { return subtotal + m / t; });
  }
};",2187
2185,"class Solution {
 public:
  int minimumFinishTime(vector<vector<int>>& tires, int changeTime,
                        int numLaps) {
    // singleTire[i] := the minimum time to finish i laps without changing tire
    vector<int> singleTire(numLaps + 1, INT_MAX / 2);
    // dp[i] := the minimum time to finish i laps
    vector<int> dp(numLaps + 1, INT_MAX / 2);

    for (int i = 0; i < tires.size(); ++i) {
      const int f = tires[i][0];
      const int r = tires[i][1];
      int sumSecs = 0;
      int rPower = 1;
      for (int j = 1; j <= numLaps; ++j) {
        // the time to use the same tire for the next lap >=
        // the time to change a new tire + f
        if ((long)f * rPower >= changeTime + f)
          break;
        sumSecs += f * rPower;
        rPower *= r;
        singleTire[j] = min(singleTire[j], sumSecs);
      }
    }

    dp[0] = 0;
    for (int i = 1; i <= numLaps; ++i)
      for (int j = 1; j <= i; ++j)
        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j]);

    return dp[numLaps] - changeTime;
  }
};",2188
2186,"class Solution {
 public:
  int houseOfCards(int n) {
    // dp[i] := the number of valid result for i cards
    vector<int> dp(n + 1);
    dp[0] = 1;

    for (int baseCards = 2; baseCards <= n; baseCards += 3)
      for (int i = n; i >= baseCards; --i)
        // Use `baseCards` as the base, so we're left with `i - baseCards`
        // cards.
        dp[i] += dp[i - baseCards];

    return dp[n];
  }
};",2189
2187,"class Solution {
 public:
  int mostFrequent(vector<int>& nums, int key) {
    vector<int> count(1001);

    for (int i = 0; i + 1 < nums.size(); ++i)
      if (nums[i] == key)
        ++count[nums[i + 1]];

    return ranges::max_element(count) - count.begin();
  }
};",2190
2188,"class Solution {
 public:
  vector<int> sortJumbled(vector<int>& mapping, vector<int>& nums) {
    vector<int> ans;
    vector<tuple<int, int, int>> A;  // (mapped, index, num)

    for (int i = 0; i < nums.size(); ++i)
      A.emplace_back(getMapped(nums[i], mapping), i, nums[i]);

    ranges::sort(A);

    for (const auto& [_, i, num] : A)
      ans.push_back(num);

    return ans;
  }

 private:
  int getMapped(int num, const vector<int>& mapping) {
    string mapped;
    for (const char c : to_string(num))
      mapped += to_string(mapping[c - '0']);
    return stoi(mapped);
  }
};",2191
2189,"class Solution {
 public:
  vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
    vector<vector<int>> ans(n);
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      dfs(graph, i, i, vector<bool>(n), ans);

    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, int ancestor,
           vector<bool>&& seen, vector<vector<int>>& ans) {
    seen[u] = true;
    for (const int v : graph[u]) {
      if (seen[v])
        continue;
      ans[v].push_back(ancestor);
      dfs(graph, v, ancestor, move(seen), ans);
    }
  }
};",2192
2190,"class Solution {
 public:
  int minMovesToMakePalindrome(string s) {
    int ans = 0;

    while (s.length() > 1) {
      // Greedily match the last digit.
      const int i = s.find(s.back());
      if (i == s.length() - 1) {
        // s[i] is the middle letter.
        ans += i / 2;
      } else {
        s.erase(i, 1);
        ans += i;  // Swap the matched letter to the left.
      }
      s.pop_back();
    }

    return ans;
  }
};",2193
2191,"class Solution {
 public:
  vector<string> cellsInRange(string s) {
    vector<string> ans;
    const char startCol = s[0];
    const char endCol = s[3];
    const char startRow = s[1];
    const char endRow = s[4];

    for (char col = startCol; col <= endCol; ++col)
      for (char row = startRow; row <= endRow; ++row)
        ans.push_back(string(1, col) + row);

    return ans;
  }
};",2194
2192,"class Solution {
 public:
  long long minimalKSum(vector<int>& nums, int k) {
    long long ans = 0;
    nums.push_back(0);
    ranges::sort(nums);

    for (int i = 0; i + 1 < nums.size(); ++i) {
      if (nums[i] == nums[i + 1])
        continue;
      const int l = nums[i] + 1;
      const int r = min(nums[i] + k, nums[i + 1] - 1);
      ans += static_cast<long long>(l + r) * (r - l + 1) / 2;
      k -= r - l + 1;
      if (k == 0)
        return ans;
    }

    if (k > 0) {
      const int l = nums.back() + 1;
      const int r = nums.back() + k;
      ans += static_cast<long long>(l + r) * (r - l + 1) / 2;
    }

    return ans;
  }
};",2195
2193,"class Solution {
 public:
  TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {
    unordered_map<TreeNode*, TreeNode*> childToParent;
    unordered_map<int, TreeNode*> valToNode;

    for (const vector<int>& d : descriptions) {
      const int p = d[0];
      const int c = d[1];
      const bool isLeft = d[2];
      TreeNode* parent =
          valToNode.count(p) ? valToNode[p] : (valToNode[p] = new TreeNode(p));
      TreeNode* child =
          valToNode.count(c) ? valToNode[c] : (valToNode[c] = new TreeNode(c));
      childToParent[child] = parent;
      if (isLeft)
        parent->left = child;
      else
        parent->right = child;
    }

    // Pick a random node and traverse upwardly.
    TreeNode* root = childToParent.begin()->second;
    while (childToParent.count(root))
      root = childToParent[root];
    return root;
  }
};",2196
2194,"class Solution {
 public:
  vector<int> replaceNonCoprimes(vector<int>& nums) {
    vector<int> ans;

    for (int num : nums) {
      while (!ans.empty() && std::gcd(ans.back(), num) > 1)
        num = std::lcm(ans.back(), num), ans.pop_back();
      ans.push_back(num);
    }

    return ans;
  }
};",2197
2195,"class Solution {
 public:
  long long singleDivisorTriplet(vector<int>& nums) {
    long long ans = 0;
    vector<int> count(101);

    for (const int num : nums)
      ++count[num];

    for (int a = 1; a < 101; ++a)
      for (int b = a; count[a] && b < 101; ++b)
        for (int c = b; count[b] && c < 101; ++c) {
          const int sum = a + b + c;
          if (divisible(sum, a) + divisible(sum, b) + divisible(sum, c) != 1)
            continue;
          if (a == b)
            ans += static_cast<long>(count[a]) * (count[a] - 1) / 2 * count[c];
          else if (b == c)
            ans += static_cast<long>(count[b]) * (count[b] - 1) / 2 * count[a];
          else
            ans += static_cast<long>(count[a]) * count[b] * count[c];
        }

    return ans * 6;
  }

 private:
  int divisible(int sum, int num) {
    return sum % num == 0;
  }
};",2198
2196,"SELECT
  Posts.post_id,
  IFNULL(
    GROUP_CONCAT(
      DISTINCT Keywords.topic_id
      ORDER BY Keywords.topic_id
    ),
    'Ambiguous!'
  ) AS topic
FROM Posts
LEFT JOIN Keywords
  ON (CONCAT(' ', LOWER(Posts.content), ' ') LIKE CONCAT('% ', LOWER(Keywords.word), ' %'))
GROUP BY 1;",2199
2197,"class Solution {
 public:
  vector<int> findKDistantIndices(vector<int>& nums, int key, int k) {
    const int n = nums.size();
    vector<int> ans;

    for (int i = 0, j = 0; i < n; ++i) {
      // the first index j s.t. nums[j] == key and j >= i - k
      while (j < n && (nums[j] != key || j < i - k))
        ++j;
      if (j == n)
        break;
      if (abs(i - j) <= k)
        ans.push_back(i);
    }

    return ans;
  }
};",2200
2198,"class Solution {
 public:
  int digArtifacts(int n, vector<vector<int>>& artifacts,
                   vector<vector<int>>& dig) {
    unordered_set<int> digged;

    for (const vector<int>& d : dig)
      digged.insert(hash(d[0], d[1]));

    return ranges::count_if(
        artifacts, [&](const auto& a) { return canExtract(a, digged); });
  }

 private:
  int hash(int i, int j) {
    return i << 16 | j;
  }

  bool canExtract(const vector<int>& a, const unordered_set<int>& digged) {
    for (int i = a[0]; i <= a[2]; ++i)
      for (int j = a[1]; j <= a[3]; ++j)
        if (!digged.count(hash(i, j)))
          return false;
    return true;
  }
};",2201
2199,"class Solution {
 public:
  int maximumTop(vector<int>& nums, int k) {
    const int n = nums.size();
    // After taking k elements, if there's something left, then return nums[k].
    // Otherwise, return -1.
    if (k == 0 || k == 1)
      return n == k ? -1 : nums[k];
    // Remove then add even number of times.
    if (n == 1)
      return k & 1 ? -1 : nums[0];
    // Take min(n, k - 1) elements and put the largest one back.
    const int max = *max_element(nums.begin(), nums.begin() + min(n, k - 1));
    if (k >= n)
      return max;
    return std::max(max, nums[k]);
  }
};",2202
2200,"class Solution {
 public:
  long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2,
                          int dest) {
    vector<vector<pair<int, int>>> graph(n);
    vector<vector<pair<int, int>>> reversedGraph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      reversedGraph[v].emplace_back(u, w);
    }

    const vector<long> fromSrc1 = dijkstra(graph, src1);
    const vector<long> fromSrc2 = dijkstra(graph, src2);
    const vector<long> fromDest = dijkstra(reversedGraph, dest);
    long ans = kMax;

    for (int i = 0; i < n; ++i) {
      if (fromSrc1[i] == kMax || fromSrc2[i] == kMax || fromDest[i] == kMax)
        continue;
      ans = min(ans, fromSrc1[i] + fromSrc2[i] + fromDest[i]);
    }

    return ans == kMax ? -1 : ans;
  }

 private:
  static constexpr long kMax = 1e10;

  vector<long> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {
    vector<long> dist(graph.size(), kMax);
    using P = pair<long, int>;
    priority_queue<P, vector<P>, greater<>> minHeap;  // (d, u)

    minHeap.emplace(0, src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (dist[u] != kMax)
        continue;
      dist[u] = d;
      for (const auto& [v, w] : graph[u])
        minHeap.emplace(d + w, v);
    }

    return dist;
  }
};",2203
2201,"class Solution {
 public:
  vector<int> distanceToCycle(int n, vector<vector<int>>& edges) {
    vector<int> ans(n);
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // rank[i] := the minimum node that node i can reach with forward edges
    // Initialize with NO_RANK = -2 to indicate not visited.
    vector<int> cycle;
    getRank(graph, 0, 0, vector<int>(n, NO_RANK), cycle);

    queue<int> q;
    vector<bool> seen(n);
    for (const int u : cycle) {
      q.push(u);
      seen[u] = true;
    }

    int dist = 0;
    while (!q.empty()) {
      ++dist;
      for (int sz = q.size(); sz > 0; --sz) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u]) {
          if (seen[v])
            continue;
          q.push(v);
          seen[v] = true;
          ans[v] = dist;
        }
      }
    }

    return ans;
  }

 private:
  static constexpr int NO_RANK = -2;

  // The minRank that u can reach with forward edges
  int getRank(const vector<vector<int>>& graph, int u, int currRank,
              vector<int>&& rank, vector<int>& cycle) {
    if (rank[u] != NO_RANK)  // The rank is already determined
      return rank[u];

    rank[u] = currRank;
    int minRank = currRank;

    for (const int v : graph[u]) {
      // Visited || parent (that's why NO_RANK = -2 instead of -1)
      if (rank[v] == rank.size() || rank[v] == currRank - 1)
        continue;
      const int nextRank = getRank(graph, v, currRank + 1, move(rank), cycle);
      // NextRank should > currRank if there's no cycle
      if (nextRank <= currRank)
        cycle.push_back(v);
      minRank = min(minRank, nextRank);
    }

    rank[u] = rank.size();  // Mark as visited.
    return minRank;
  }
};",2204
2202,"CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT
BEGIN
  RETURN (
    SELECT COUNT(DISTINCT user_id) AS user_cnt
    FROM Purchases
    WHERE
      time_stamp BETWEEN startDate AND endDate
      AND amount >= minAmount
  );
END",2205
2203,"class Solution {
 public:
  bool divideArray(vector<int>& nums) {
    vector<int> count(501);

    for (const int num : nums)
      ++count[num];

    return ranges::all_of(count, [](int c) { return c % 2 == 0; });
  }
};",2206
2204,"class Solution {
 public:
  long long maximumSubsequenceCount(string text, string pattern) {
    long long ans = 0;
    int count0 = 0;  // the count of the letter pattern[0]
    int count1 = 0;  // the count of the letter pattern[1]

    for (const char c : text) {
      if (c == pattern[1]) {
        ans += count0;
        ++count1;
      }
      if (c == pattern[0])
        ++count0;
    }

    // It is optimal to add pattern[0] at the beginning or add pattern[1] at the
    // end of the text.
    return ans + max(count0, count1);
  }
};",2207
2205,k = # of operations,2208
2206,"class Solution {
 public:
  int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {
    vector<vector<int>> mem(floor.length() + 1,
                            vector<int>(numCarpets + 1, kMax));
    return minimumWhiteTiles(floor, 0, numCarpets, carpetLen, mem);
  }

 private:
  static constexpr int kMax = 1000;

  // Returns the minimum number of visible white tiles of floor[i..n) after
  // covering at most j carpets.
  int minimumWhiteTiles(const string& floor, int i, int j, int carpetLen,
                        vector<vector<int>>& mem) {
    if (j < 0)
      return kMax;
    if (i >= floor.length())
      return 0;
    if (mem[i][j] != kMax)
      return mem[i][j];
    return mem[i][j] = min(
               minimumWhiteTiles(floor, i + carpetLen, j - 1, carpetLen, mem),
               minimumWhiteTiles(floor, i + 1, j, carpetLen, mem) + floor[i] -
                   '0');
  }
};",2209
2207,"class Solution {
 public:
  int countthe hillthe valley(vector<int>& nums) {
    int ans = 0;
    int left = nums[0];

    for (int i = 1; i + 1 < nums.size(); ++i)
      if (left < nums[i] && nums[i] > nums[i + 1] ||  // the hill
          left > nums[i] && nums[i] < nums[i + 1]) {  // the valley
        ++ans;
        left = nums[i];
      }

    return ans;
  }
};",2210
2208,"class Solution {
 public:
  int countCollisions(string directions) {
    int l = 0;
    int r = directions.length() - 1;

    while (l < directions.length() && directions[l] == 'L')
      ++l;

    while (r >= 0 && directions[r] == 'R')
      --r;

    return count_if(directions.begin() + l, directions.begin() + r + 1,
                    [](char c) { return c != 'S'; });
  }
};",2211
2209,"class Solution {
 public:
  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {
    constexpr int allMask = (1 << 12) - 1;
    int maxPoint = 0;
    int maxMask = 0;

    for (int mask = 0; mask < allMask; ++mask) {
      const auto& [shotable, point] =
          getShotableAndPoint(mask, numArrows, aliceArrows);
      if (shotable && point > maxPoint) {
        maxPoint = point;
        maxMask = mask;
      }
    }

    return getBobsArrows(maxMask, numArrows, aliceArrows);
  }

 private:
  pair<bool, int> getShotableAndPoint(int mask, int leftArrows,
                                      const vector<int>& aliceArrows) {
    int point = 0;
    for (int i = 0; i < 12; ++i)
      if (mask >> i & 1) {
        leftArrows -= aliceArrows[i] + 1;
        point += i;
      }
    return {leftArrows >= 0, point};
  }

  vector<int> getBobsArrows(int mask, int leftArrows,
                            const vector<int>& aliceArrows) {
    vector<int> bobsArrows(12);
    for (int i = 0; i < 12; ++i)
      if (mask >> i & 1) {
        bobsArrows[i] = aliceArrows[i] + 1;
        leftArrows -= aliceArrows[i] + 1;
      }
    bobsArrows[0] = leftArrows;
    return bobsArrows;
  }
};",2212
2210,"struct SegmentTreeNode {
  int lo;
  int hi;
  char maxLetter;
  char prefixLetter;
  char suffixLetter;
  int maxLength;
  int prefixLength;
  int suffixLength;
  SegmentTreeNode* left;
  SegmentTreeNode* right;
  SegmentTreeNode(int lo, int hi, char maxLetter, char prefixLetter,
                  char suffixLetter, int maxLength, int prefixLength,
                  int suffixLength, SegmentTreeNode* left = nullptr,
                  SegmentTreeNode* right = nullptr)
      : lo(lo),
        hi(hi),
        maxLetter(maxLetter),
        prefixLetter(prefixLetter),
        suffixLetter(suffixLetter),
        maxLength(maxLength),
        prefixLength(prefixLength),
        suffixLength(suffixLength),
        left(left),
        right(right) {}
  ~SegmentTreeNode() {
    delete left;
    delete right;
    left = nullptr;
    right = nullptr;
  }
};

class SegmentTree {
 public:
  explicit SegmentTree(const string& s) : root(build(s, 0, s.length() - 1)) {}
  ~SegmentTree() {
    delete root;
  }

  void update(int i, char val) {
    root = update(root, i, val);
  }

  int getMaxLength() {
    return root->maxLength;
  }

 private:
  SegmentTreeNode* root;

  SegmentTreeNode* build(const string& s, int lo, int hi) const {
    if (lo == hi)
      return new SegmentTreeNode(lo, hi, s[lo], s[lo], s[lo], 1, 1, 1);
    const int mid = (lo + hi) / 2;
    SegmentTreeNode* left = build(s, lo, mid);
    SegmentTreeNode* right = build(s, mid + 1, hi);
    return merge(left, right);
  }

  SegmentTreeNode* update(SegmentTreeNode* root, int i, char c) {
    if (root->lo == i && root->hi == i) {
      root->maxLetter = c;
      root->prefixLetter = c;
      root->suffixLetter = c;
      return root;
    }
    const int mid = (root->lo + root->hi) / 2;
    if (i <= mid) {
      SegmentTreeNode* updatedLeft = update(root->left, i, c);
      return root = merge(updatedLeft, root->right);
    } else {
      SegmentTreeNode* updatedRight = update(root->right, i, c);
      return root = merge(root->left, updatedRight);
    }
  }

  SegmentTreeNode* merge(SegmentTreeNode* left, SegmentTreeNode* right) const {
    // Get `maxLetter` and `maxLength`.
    char maxLetter = ' ';
    int maxLength = 0;
    if (left->maxLength > right->maxLength) {
      maxLetter = left->maxLetter;
      maxLength = left->maxLength;
    } else {
      maxLetter = right->maxLetter;
      maxLength = right->maxLength;
    }
    if (left->suffixLetter == right->prefixLetter &&
        left->suffixLength + right->prefixLength > maxLength) {
      maxLetter = left->suffixLetter;
      maxLength = left->suffixLength + right->prefixLength;
    }

    // Get `prefixLetter` and `prefixLength`.
    char prefixLetter = left->prefixLetter;
    int prefixLength = left->prefixLength;
    if (left->lo + prefixLength == right->lo &&
        left->prefixLetter == right->prefixLetter)
      prefixLength += right->prefixLength;

    // Get `suffixLetter` and `suffixLength`.
    char suffixLetter = right->suffixLetter;
    int suffixLength = right->suffixLength;
    if (right->hi - suffixLength == left->hi &&
        right->suffixLetter == left->suffixLetter)
      suffixLength += left->suffixLength;
    return new SegmentTreeNode(left->lo, right->hi, maxLetter, prefixLetter,
                               suffixLetter, maxLength, prefixLength,
                               suffixLength, left, right);
  }
};

class Solution {
 public:
  vector<int> longestRepeating(string s, string queryLetteracters,
                               vector<int>& queryIndices) {
    vector<int> ans;
    SegmentTree tree(s);

    for (int i = 0; i < queryIndices.size(); ++i) {
      tree.update(queryIndices[i], queryLetteracters[i]);
      ans.push_back(tree.getMaxLength());
    }

    return ans;
  }
};",2213
2211,"class Solution {
 public:
  long long minimumHealth(vector<int>& damage, int armor) {
    const long long sum = accumulate(damage.begin(), damage.end(), 0LL);
    const int maxDamage = ranges::max(damage);
    return 1 + sum - min(maxDamage, armor);
  }
};",2214
2212,"class Solution {
 public:
  vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
    const unordered_set<int> set1{nums1.begin(), nums1.end()};
    const unordered_set<int> set2{nums2.begin(), nums2.end()};
    vector<vector<int>> ans(2);

    for (const int num : set1)
      if (!set2.count(num))
        ans[0].push_back(num);

    for (const int num : set2)
      if (!set1.count(num))
        ans[1].push_back(num);

    return ans;
  }
};",2215
2213,"class Solution {
 public:
  int minDeletion(vector<int>& nums) {
    int ans = 0;

    for (int i = 0; i + 1 < nums.size(); ++i)
      // i - ans := the index after deletion
      if (nums[i] == nums[i + 1] && (i - ans) % 2 == 0)
        ++ans;

    return ans + ((nums.size() - ans) & 1);
  }
};",2216
2214,"class Solution {
 public:
  vector<long long> kthPalindrome(vector<int>& queries, int intLength) {
    const int start = pow(10, (intLength + 1) / 2 - 1);
    const int end = pow(10, (intLength + 1) / 2);
    const int mul = pow(10, intLength / 2);
    vector<long long> ans;

    for (const int query : queries)
      if (start + query > end)
        ans.push_back(-1);
      else
        ans.push_back(getKthPalindrome(quyer, start, mul, intLength));

    return ans;
  }

 private:
  long long getKthPalindrome(int query, int start, int mul, int intLength) {
    const long long prefix = start + query - 1;
    return prefix * mul + reverse(intLength & 1 ? prefix / 10 : prefix);
  }

  long long reverse(int num) {
    long long res = 0;
    while (num) {
      res = res * 10 + num % 10;
      num /= 10;
    }
    return res;
  }
};",2217
2215,"class Solution {
 public:
  int maxValueOfCoins(vector<vector<int>>& piles, int k) {
    vector<vector<int>> mem(piles.size(), vector<int>(k + 1));
    return maxValueOfCoins(piles, 0, k, mem);
  }

 private:
  // Returns the maximum value of picking k coins from piles[i..n)
  int maxValueOfCoins(const vector<vector<int>>& piles, int i, size_t k,
                      vector<vector<int>>& mem) {
    if (i == piles.size() || k == 0)
      return 0;
    if (mem[i][k])
      return mem[i][k];

    // Pick no coins from the current pile.
    int res = maxValueOfCoins(piles, i + 1, k, mem);
    int val = 0;  // the coins picked from the current pile

    // Try to pick 1, 2, ..., k coins from the current pile.
    for (int j = 0; j < min(piles[i].size(), k); ++j) {
      val += piles[i][j];
      res = max(res, val + maxValueOfCoins(piles, i + 1, k - j - 1, mem));
    }

    return mem[i][k] = res;
  }
};",2218
2216,"class Solution {
 public:
  long long maximumSumScore(vector<int>& nums) {
    long long ans = LLONG_MIN;
    long long prefix = 0;
    long long sum = accumulate(nums.begin(), nums.end(), 0LL);

    for (const int num : nums) {
      prefix += num;
      ans = max({ans, prefix, sum - prefix + num});
    }

    return ans;
  }
};",2219
2217,"class Solution {
 public:
  int minBitFlips(int start, int goal) {
    return __builtin_popcount(start ^ goal);
  }
};",2220
2218,"class Solution {
 public:
  int triangularSum(vector<int>& nums) {
    for (int sz = nums.size(); sz > 0; --sz)
      for (int i = 0; i + 1 < sz; ++i)
        nums[i] = (nums[i] + nums[i + 1]) % 10;
    return nums[0];
  }
};",2221
2219,"class Solution {
 public:
  long long numberOfWays(string s) {
    long long ans = 0;
    // before[i] := the number of i before the current digit
    vector<int> before(2);
    // after[i] := the number of i after the current digit
    vector<int> after(2);
    after[0] = ranges::count(s, '0');
    after[1] = s.length() - after[0];

    for (const char c : s) {
      const int num = c - '0';
      --after[num];
      if (num == 0)
        ans += before[1] * after[1];
      else
        ans += before[0] * after[0];
      ++before[num];
    }

    return ans;
  }
};",2222
2220,"class Solution {
 public:
  long long sumScores(string s) {
    const int n = s.length();
    // https://cp-algorithms.com/string/z-function.html#implementation
    vector<int> z(n);
    // [l, r] := the indices of the rightmost segment match
    int l = 0;
    int r = 0;

    for (int i = 1; i < n; ++i) {
      if (i < r)
        z[i] = min(r - i, z[i - l]);
      while (i + z[i] < n && s[z[i]] == s[i + z[i]])
        ++z[i];
      if (i + z[i] > r) {
        l = i;
        r = i + z[i];
      }
    }

    return accumulate(z.begin(), z.end(), 0LL) + n;
  }
};",2223
2221,"class Solution {
 public:
  int convertTime(string current, string correct) {
    const vector<int> ops{60, 15, 5, 1};
    int diff = getMinutes(correct) - getMinutes(current);
    int ans = 0;

    for (const int op : ops) {
      ans += diff / op;
      diff %= op;
    }

    return ans;
  }

 private:
  int getMinutes(const string& s) {
    return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));
  }
};",2224
2222,"class Solution {
 public:
  vector<vector<int>> findWinners(vector<vector<int>>& matches) {
    vector<vector<int>> ans(2);
    map<int, int> lossesCount;

    for (const vector<int>& m : matches) {
      const int winner = m[0];
      const int loser = m[1];
      if (!lossesCount.count(winner))
        lossesCount[winner] = 0;
      ++lossesCount[loser];
    }

    for (const auto& [player, nLosses] : lossesCount)
      if (nLosses < 2)
        ans[nLosses].push_back(player);

    return ans;
  }
};",2225
2223,"class Solution {
 public:
  int maximumCandies(vector<int>& candies, long long k) {
    int l = 1;
    int r = accumulate(candies.begin(), candies.end(), 0L) / k;

    while (l < r) {
      const int m = (l + r) / 2;
      if (numChildren(candies, m) < k)
        r = m;
      else
        l = m + 1;
    }

    return numChildren(candies, l) >= k ? l : l - 1;
  }

 private:
  long numChildren(const vector<int>& candies, int m) {
    return accumulate(candies.begin(), candies.end(), 0L,
                      [&](long subtotal, int c) { return subtotal + c / m; });
  };
};",2226
2224,encrypt(word1: str),2227
2225,"SELECT DISTINCT First.user_id
FROM Purchases AS First
INNER JOIN purchases AS Second
  USING (user_id)
WHERE
  First.purchase_id != Second.purchase_id
  AND First.purchase_date <= Second.purchase_date
  AND DATEDIFF(Second.purchase_date, First.purchase_date) <= 7
ORDER BY 1;",2228
2226,"class Solution {
 public:
  bool isConsecutive(vector<int>& nums) {
    const int n = nums.size();
    const int max = ranges::max(nums);
    const int min = ranges::min(nums);
    return max - min + 1 == n &&
           unordered_set<int>{nums.begin(), nums.end()}.size() == n;
  }
};",2229
2227,"CREATE PROCEDURE getUserIDs(startDate DATE, endDate DATE, minAmount INT)
BEGIN
  SELECT DISTINCT user_id
  FROM Purchases
  WHERE
    time_stamp BETWEEN startDate AND endDate
    AND amount >= minAmount
  ORDER BY 1;
END",2230
2228,"class Solution {
 public:
  int largestInteger(int num) {
    const string s = to_string(num);
    int ans = 0;
    // maxHeap[0] := the odd digits
    // maxHeap[1] := the even digits
    vector<priority_queue<int>> maxHeap(2);

    for (const char c : s) {
      const int digit = c - '0';
      maxHeap[digit & 1].push(digit);
    }

    for (const char c : s) {
      const int i = c - '0' & 1;
      ans *= 10;
      ans += maxHeap[i].top(), maxHeap[i].pop();
    }

    return ans;
  }
};",2231
2229,"class Solution {
 public:
  string minimizeResult(string expression) {
    const int plusIndex = expression.find('+');
    const string left = expression.substr(0, plusIndex);
    const string right = expression.substr(plusIndex + 1);
    string ans;
    int min = INT_MAX;

    // the expression -> a * (b + c) * d
    for (int i = 0; i < left.length(); ++i)
      for (int j = 0; j < right.length(); ++j) {
        const int a = i == 0 ? 1 : stoi(left.substr(0, i));
        const int b = stoi(left.substr(i));
        const int c = stoi(right.substr(0, j + 1));
        const int d = j == right.length() - 1 ? 1 : stoi(right.substr(j + 1));
        const int val = a * (b + c) * d;
        if (val < min) {
          min = val;
          ans = (i == 0 ? """" : to_string(a)) + '(' + to_string(b) + '+' +
                to_string(c) + ')' +
                (j == right.length() - 1 ? """" : to_string(d));
        }
      }

    return ans;
  }
};",2232
2230,"class Solution {
 public:
  int maximumProduct(vector<int>& nums, int k) {
    constexpr int kMod = 1'000'000'007;
    long ans = 1;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int num : nums)
      minHeap.push(num);

    for (int i = 0; i < k; ++i) {
      const int minNum = minHeap.top();
      minHeap.pop();
      minHeap.push(minNum + 1);
    }

    while (!minHeap.empty()) {
      ans *= minHeap.top(), minHeap.pop();
      ans %= kMod;
    }

    return ans;
  }
};",2233
2231,"class Solution {
 public:
  long long maximumBeauty(vector<int>& flowers, long long newFlowers,
                          int target, int full, int partial) {
    const long long n = flowers.size();

    // If a garden is already complete, clamp it to the target.
    for (int& flower : flowers)
      flower = min(flower, target);
    ranges::sort(flowers);

    // All gardens are complete, so nothing we can do.
    if (flowers[0] == target)
      return n * full;

    // Having many new flowers maximizes the beauty value.
    if (newFlowers >=
        n * target - accumulate(flowers.begin(), flowers.end(), 0LL))
      return max(n * full,
                 (n - 1) * full + static_cast<long long>(target - 1) * partial);

    long long ans = 0;
    long long leftFlowers = newFlowers;
    // cost[i] := the cost to make flowers[0..i] the same
    vector<long long> cost(n);

    for (long long i = 1; i < n; ++i)
      // Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].
      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1]);

    int i = n - 1;  // flowers' index (flowers[i + 1..n) are complete)
    while (flowers[i] == target)
      --i;

    for (; leftFlowers >= 0; --i) {
      // To maximize the minimum number of incomplete flowers, we find the first
      // index j that we can't make flowers[0..j] equal to flowers[j], then we
      // know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the
      // meantime, evenly increase each of them to seek a bigger minimum value.
      const int j = firstGreater(cost, i, leftFlowers);
      const long long minIncomplete =
          flowers[j - 1] + (leftFlowers - cost[j - 1]) / j;
      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial);
      leftFlowers -= max(0, target - flowers[i]);
    }

    return ans;
  }

 private:
  int firstGreater(const vector<long long>& A, int maxIndex, long long target) {
    return upper_bound(A.begin(), A.begin() + maxIndex + 1, target) - A.begin();
  }
};",2234
2232,"class Solution {
 public:
  int sum(int num1, int num2) {
    return num1 + num2;
  }
};",2235
2233,"class Solution {
 public:
  bool checkTree(TreeNode* root) {
    return root->val == root->left->val + root->right->val;
  }
};",2236
2234,"class Solution {
 public:
  int meetRequirement(int n, vector<vector<int>>& lights,
                      vector<int>& requirement) {
    int ans = 0;
    int currBrightness = 0;
    vector<int> change(n + 1);

    for (const vector<int>& light : lights) {
      const int position = light[0];
      const int range = light[1];
      ++change[max(0, position - range)];
      --change[min(n, position + range + 1)];
    }

    for (int i = 0; i < n; ++i) {
      currBrightness += change[i];
      if (currBrightness >= requirement[i])
        ++ans;
    }

    return ans;
  }
};",2237
2235,"WITH
  DriverIds AS (
    SELECT DISTINCT driver_id FROM Rides
  )
SELECT
  DriverIds.driver_id,
  COUNT(Rides.passenger_id) AS cnt
FROM DriverIds
LEFT JOIN Rides
  ON (DriverIds.driver_id = Rides.passenger_id)
GROUP BY 1;",2238
2236,"class Solution {
 public:
  int findClosestNumber(vector<int>& nums) {
    return *ranges::min_element(nums, [](const int a, const int b) {
      return abs(a) == abs(b) ? a > b : abs(a) < abs(b);
    });
  }
};",2239
2237,"class Solution {
 public:
  long long waysToBuyPensPencils(int total, int cost1, int cost2) {
    long long ans = 0;
    const int maxPen = total / cost1;

    for (int i = 0; i <= maxPen; ++i)
      ans += (total - i * cost1) / cost2 + 1;

    return ans;
  }
};",2240
2238,deposit(banknotesCount: List[int]),2241
2239,"class Solution {
 public:
  int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {
    int ans = -1;
    vector<set<pair<int, int>>> graph(scores.size());  // {(score, node)}

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace(scores[v], v);
      graph[v].emplace(scores[u], u);
      if (graph[u].size() > 3)
        graph[u].erase(graph[u].begin());
      if (graph[v].size() > 3)
        graph[v].erase(graph[v].begin());
    }

    // To find the target sequence: a - u - v - b, enumerate each edge (u, v),
    // and find a (u's child) and b (v's child). That's why we find the 3
    // children that have the highest scores because one of the 3 children is
    // guaranteed to be valid.
    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      for (const auto& [scoreA, a] : graph[u])
        for (const auto& [scoreB, b] : graph[v])
          if (a != b && a != v && b != u)
            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB);
    }

    return ans;
  }
};",2242
2240,"class Solution {
 public:
  string digitSum(string s, int k) {
    while (s.length() > k) {
      string next;
      for (int i = 0; i < s.length(); ++i)
        next += to_string(accumulate(
            s.begin() + i, s.begin() + min(static_cast<int>(s.length()), i + k),
            0, [](int subtotal, char c) { return subtotal + c - '0'; }));
      s = move(next);
    }
    return s;
  }
};",2243
2241,"class Solution {
 public:
  int minimumRounds(vector<int>& tasks) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int task : tasks)
      ++count[task];

    // freq = 1 -> it's impossible
    // freq = 2 -> needs 1 round
    // freq = 3 -> needs 1 round
    // freq = 3k                           -> needs k rounds
    // freq = 3k + 1 = 3 * (k - 1) + 2 * 2 -> needs k + 1 rounds
    // freq = 3k + 2 = 3 * k       + 2 * 1 -> needs k + 1 rounds
    for (const auto& [_, freq] : count)
      if (freq == 1)
        return -1;
      else
        ans += (freq + 2) / 3;

    return ans;
  }
};",2244
2242,"class Solution {
 public:
  int maxTrailingZeros(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // leftPrefix2[i][j] := the number of 2 in grid[i][0..j]
    // leftPrefix5[i][j] := the number of 5 in grid[i][0..j]
    // topPrefix2[i][j] := the number of 2 in grid[0..i][j]
    // topPrefix5[i][j] := the number of 5 in grid[0..i][j]
    vector<vector<int>> leftPrefix2(m, vector<int>(n));
    vector<vector<int>> leftPrefix5(m, vector<int>(n));
    vector<vector<int>> topPrefix2(m, vector<int>(n));
    vector<vector<int>> topPrefix5(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        leftPrefix2[i][j] = getCount(grid[i][j], 2);
        leftPrefix5[i][j] = getCount(grid[i][j], 5);
        if (j > 0) {
          leftPrefix2[i][j] += leftPrefix2[i][j - 1];
          leftPrefix5[i][j] += leftPrefix5[i][j - 1];
        }
      }

    for (int j = 0; j < n; ++j)
      for (int i = 0; i < m; ++i) {
        topPrefix2[i][j] = getCount(grid[i][j], 2);
        topPrefix5[i][j] = getCount(grid[i][j], 5);
        if (i > 0) {
          topPrefix2[i][j] += topPrefix2[i - 1][j];
          topPrefix5[i][j] += topPrefix5[i - 1][j];
        }
      }

    int ans = 0;
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        const int curr2 = getCount(grid[i][j], 2);
        const int curr5 = getCount(grid[i][j], 5);
        const int l2 = leftPrefix2[i][j];
        const int l5 = leftPrefix5[i][j];
        const int r2 = leftPrefix2[i][n - 1] - (j ? leftPrefix2[i][j - 1] : 0);
        const int r5 = leftPrefix5[i][n - 1] - (j ? leftPrefix5[i][j - 1] : 0);
        const int t2 = topPrefix2[i][j];
        const int t5 = topPrefix5[i][j];
        const int d2 = topPrefix2[m - 1][j] - (i ? topPrefix2[i - 1][j] : 0);
        const int d5 = topPrefix5[m - 1][j] - (i ? topPrefix5[i - 1][j] : 0);
        ans = max({ans, min(l2 + t2 - curr2, l5 + t5 - curr5),
                   min(r2 + t2 - curr2, r5 + t5 - curr5),
                   min(l2 + d2 - curr2, l5 + d5 - curr5),
                   min(r2 + d2 - curr2, r5 + d5 - curr5)});
      }

    return ans;
  }

 private:
  int getCount(int num, int factor) {
    int count = 0;
    while (num % factor == 0) {
      num /= factor;
      ++count;
    }
    return count;
  }
};",2245
2243,"class Solution {
 public:
  int longestPath(vector<int>& parent, string s) {
    const int n = parent.size();
    int ans = 1;
    vector<vector<int>> graph(n);

    for (int i = 1; i < n; ++i)
      graph[parent[i]].push_back(i);

    longestPathDownFrom(graph, 0, s, ans);
    return ans;
  }

 private:
  int longestPathDownFrom(const vector<vector<int>>& graph, int u,
                          const string& s, int& ans) {
    int max1 = 0;
    int max2 = 0;

    for (const int v : graph[u]) {
      const int res = longestPathDownFrom(graph, v, s, ans);
      if (s[u] == s[v])
        continue;
      if (res > max1) {
        max2 = max1;
        max1 = res;
      } else if (res > max2) {
        max2 = res;
      }
    }

    ans = max(ans, 1 + max1 + max2);
    return 1 + max1;
  }
};",2246
2244,"class Solution {
 public:
  int maximumCost(int n, vector<vector<int>>& highways, int k) {
    if (k + 1 > n)
      return -1;

    int ans = -1;
    vector<vector<int>> mem(n, vector<int>(1 << n, -1));
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& h : highways) {
      const int u = h[0];
      const int v = h[1];
      const int w = h[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    for (int i = 0; i < n; ++i)
      ans = max(ans, maximumCost(graph, i, 1 << i, k, mem));

    return ans;
  }

 private:
  // Returns the maximum cost of trip starting from u, where `mask` is the
  // bitmask of the visited cities.
  int maximumCost(const vector<vector<pair<int, int>>>& graph, int u, int mask,
                  int k, vector<vector<int>>& mem) {
    if (__builtin_popcount(mask) == k + 1)
      return 0;
    if (mem[u][mask] != -1)
      return mem[u][mask];

    int res = -1;
    for (const auto& [v, w] : graph[u]) {
      if (mask >> v & 1)
        continue;
      const int nextCost = maximumCost(graph, v, mask | 1 << v, k, mem);
      if (nextCost != -1)
        res = max(res, w + nextCost);
    }

    return mem[u][mask] = res;
  }
};",2247
2245,"class Solution {
 public:
  vector<int> intersection(vector<vector<int>>& nums) {
    vector<int> ans;
    vector<int> count(1001);

    for (const vector<int>& A : nums)
      for (const int a : A)
        ++count[a];

    for (int i = 1; i < 1001; ++i)
      if (count[i] == nums.size())
        ans.push_back(i);

    return ans;
  }
};",2248
2246,"class Solution {
 public:
  int countLatticePoints(vector<vector<int>>& circles) {
    int ans = 0;

    for (int x = 0; x < 201; ++x)
      for (int y = 0; y < 201; ++y)
        ans += ranges::any_of(circles, [&](const auto& c) {
          return (c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <=
                 c[2] * c[2];
        });

    return ans;
  }
};",2249
2247,"class Solution {
 public:
  vector<int> countRectangles(vector<vector<int>>& rectangles,
                              vector<vector<int>>& points) {
    vector<int> ans;
    vector<vector<int>> yToXs(101);

    for (const vector<int>& r : rectangles)
      yToXs[r[1]].push_back(r[0]);

    for (auto& xs : yToXs)
      ranges::sort(xs);

    for (const vector<int>& p : points) {
      int count = 0;
      for (int y = p[1]; y < 101; ++y) {
        const vector<int>& xs = yToXs[y];
        count += xs.end() - ranges::lower_bound(xs, p[0]);
      }
      ans.push_back(count);
    }

    return ans;
  }
};",2250
2248,"class Solution {
 public:
  vector<int> fullBloomFlowers(vector<vector<int>>& flowers,
                               vector<int>& persons) {
    vector<int> ans;
    vector<int> starts;
    vector<int> ends;

    for (const vector<int>& flower : flowers) {
      starts.push_back(flower[0]);
      ends.push_back(flower[1]);
    }

    ranges::sort(starts);
    ranges::sort(ends);

    for (const int p : persons) {
      const int started = ranges::upper_bound(starts, p) - starts.begin();
      const int ended = ranges::lower_bound(ends, p) - ends.begin();
      ans.push_back(started - ended);
    }

    return ans;
  }
};",2251
2249,"CREATE PROCEDURE PivotProducts()
BEGIN
  # Override GROUP_CONCAT length which has a default limit of 1024.
  SET SESSION group_concat_max_len = 1000000;

  SELECT GROUP_CONCAT(
      DISTINCT CONCAT(
        'SUM(IF(store = ""',
        store,
        '"", price, NULL)) AS ',
        store
      )
    ) INTO @stmt
  FROM products;

  SET @query = CONCAT(
    'SELECT product_id, ', @stmt, ' '
    'FROM Products '
    'GROUP BY 1');

  PREPARE final_query FROM @query;
  EXECUTE final_query;
  DEALLOCATE PREPARE final_query;
END",2252
2250,"CREATE PROCEDURE UnpivotProducts()
BEGIN
  # Override GROUP_CONCAT length which has a default limit of 1024.
  SET SESSION group_concat_max_len = 1000000;

  SELECT GROUP_CONCAT(
      CONCAT(
        'SELECT product_id, ""',
        `column_name`, '"" AS store, ',
        `column_name`, ' AS price ',
        'FROM products ',
        'WHERE ',
        `column_name`, ' IS NOT NULL'
      ) SEPARATOR ' UNION '
    ) INTO @stmt
  FROM `information_schema`.`columns`
  WHERE
    `table_schema` = 'test'
    AND `table_name` = 'Products'
    AND `column_name` != 'product_id';

  PREPARE final_query FROM @stmt;
  EXECUTE final_query;
  DEALLOCATE PREPARE final_query;
END",2253
2251,upload(video: str),2254
2252,"class Solution {
 public:
  int countPrefixes(vector<string>& words, string s) {
    return ranges::count_if(
        words, [&](const string& word) { return s.find(word) == 0; });
  }
};",2255
2253,"class Solution {
 public:
  int minimumAverageDifference(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    int minDiff = INT_MAX;
    long prefix = 0;
    long suffix = accumulate(nums.begin(), nums.end(), 0L);

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      suffix -= nums[i];
      const int prefixAvg = prefix / (i + 1);
      const int suffixAvg = (i == n - 1) ? 0 : suffix / (n - 1 - i);
      const int diff = abs(prefixAvg - suffixAvg);
      if (diff < minDiff) {
        ans = i;
        minDiff = diff;
      }
    }

    return ans;
  }
};",2256
2254,"class Solution {
 public:
  int countUnguarded(int m, int n, vector<vector<int>>& guards,
                     vector<vector<int>>& walls) {
    int ans = 0;
    vector<vector<char>> grid(m, vector<char>(n));
    vector<vector<char>> left(m, vector<char>(n));
    vector<vector<char>> right(m, vector<char>(n));
    vector<vector<char>> up(m, vector<char>(n));
    vector<vector<char>> down(m, vector<char>(n));

    for (const vector<int>& guard : guards)
      grid[guard[0]][guard[1]] = 'G';

    for (const vector<int>& wall : walls)
      grid[wall[0]][wall[1]] = 'W';

    for (int i = 0; i < m; ++i) {
      char lastCell = 0;
      for (int j = 0; j < n; ++j)
        recordOrFill(grid[i][j], lastCell, left[i][j]);
      lastCell = 0;
      for (int j = n - 1; j >= 0; --j)
        recordOrFill(grid[i][j], lastCell, right[i][j]);
    }

    for (int j = 0; j < n; ++j) {
      char lastCell = 0;
      for (int i = 0; i < m; ++i)
        recordOrFill(grid[i][j], lastCell, up[i][j]);
      lastCell = 0;
      for (int i = m - 1; i >= 0; --i)
        recordOrFill(grid[i][j], lastCell, down[i][j]);
    }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0 && left[i][j] != 'G' && right[i][j] != 'G' &&
            up[i][j] != 'G' && down[i][j] != 'G')
          ++ans;

    return ans;
  }

 private:
  void recordOrFill(char currCell, char& lastCell, char& infoCell) {
    if (currCell == 'G' || currCell == 'W')
      lastCell = currCell;
    else
      infoCell = lastCell;
  }
};",2257
2255,"class Solution {
 public:
  int maximumMinutes(vector<vector<int>>& grid) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int kMax = grid.size() * grid[0].size();
    vector<vector<int>> fireMinute(grid.size(),
                                   vector<int>(grid[0].size(), -1));
    buildFireGrid(grid, fireMinute, dirs);

    int ans = -1;
    int l = 0;
    int r = kMax;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (canStayFor(grid, fireMinute, m, dirs)) {
        ans = m;
        l = m + 1;
      } else {
        r = m - 1;
      }
    }

    return ans == kMax ? 1e9 : ans;
  }

 private:
  void buildFireGrid(const vector<vector<int>>& grid,
                     vector<vector<int>>& fireMinute, const vector<int>& dirs) {
    int minuteFromFire = 0;
    queue<pair<int, int>> q;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 1) {  // the fire
          q.emplace(i, j);
          fireMinute[i][j] = 0;
        }

    while (!q.empty()) {
      ++minuteFromFire;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
            continue;
          if (grid[x][y] == 2)  // the wall
            continue;
          if (fireMinute[x][y] != -1)
            continue;
          fireMinute[x][y] = minuteFromFire;
          q.emplace(x, y);
        }
      }
    }
  }

  bool canStayFor(const vector<vector<int>>& grid,
                  const vector<vector<int>>& fireMinute, int minute,
                  const vector<int>& dirs) {
    queue<pair<int, int>> q{{{0, 0}}};  // the start position
    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));
    seen[0][0] = true;

    while (!q.empty()) {
      ++minute;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
            continue;
          if (grid[x][y] == 2)  // the wall
            continue;
          if (x == grid.size() - 1 && y == grid[0].size() - 1) {
            if (fireMinute[x][y] != -1 && fireMinute[x][y] < minute)
              continue;
            return true;
          }
          if (fireMinute[x][y] != -1 && fireMinute[x][y] <= minute)
            continue;
          if (seen[x][y])
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return false;
  }
};",2258
2256,"class Solution {
 public:
  string removeDigit(string number, char digit) {
    for (int i = 0; i + 1 < number.length(); ++i)
      if (number[i] == digit && digit < number[i + 1])
        return number.erase(i, 1);
    return number.erase(number.rfind(digit), 1);
  }
};",2259
2257,"class Solution {
 public:
  int minimumCardPickup(vector<int>& cards) {
    int ans = INT_MAX;
    unordered_map<int, int> lastSeen;

    for (int i = 0; i < cards.size(); ++i) {
      if (const auto it = lastSeen.find(cards[i]); it != lastSeen.cend())
        ans = min(ans, i - it->second + 1);
      lastSeen[cards[i]] = i;
    }

    return ans == INT_MAX ? -1 : ans;
  }
};",2260
2258,"struct TrieNode {
  unordered_map<int, shared_ptr<TrieNode>> children;
  int count = 0;
};

class Solution {
 public:
  int countDistinct(vector<int>& nums, int k, int p) {
    int ans = 0;
    for (int i = 0; i < nums.size(); ++i)
      insert(root, nums, i, k, p, ans);
    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(shared_ptr<TrieNode> node, const vector<int>& nums, int i, int k,
              int p, int& ans) {
    if (i == nums.size() || k - (nums[i] % p == 0) < 0)
      return;
    if (!node->children.count(nums[i])) {
      node->children[nums[i]] = make_shared<TrieNode>();
      ++ans;
    }
    insert(node->children[nums[i]], nums, i + 1, k - (nums[i] % p == 0), p,
           ans);
  }
};",2261
2259,"class Solution {
 public:
  long long appealSum(string s) {
    long long ans = 0;
    // the total appeal of all substrings ending in the index so far
    int dp = 0;
    vector<int> lastSeen(26, -1);

    for (int i = 0; i < s.length(); ++i) {
      //   the total appeal of all substrings ending in s[i]
      // = the total appeal of all substrings ending in s[i - 1]
      // + the number of substrings ending in s[i] that contain only this s[i]
      const int c = s[i] - 'a';
      dp += i - lastSeen[c];
      ans += dp;
      lastSeen[c] = i;
    }

    return ans;
  }
};",2262
2260,"class Solution {
 public:
  int convertArray(vector<int>& nums) {
    return min(cost(nums), cost(negative(nums)));
  }

 private:
  int cost(const vector<int>& nums) {
    int ans = 0;
    priority_queue<int> maxHeap;

    // Greedily make `nums` non-decreasing.
    for (const int num : nums) {
      if (!maxHeap.empty() && maxHeap.top() > num) {
        ans += maxHeap.top() - num, maxHeap.pop();
        maxHeap.push(num);
      }
      maxHeap.push(num);
    }

    return ans;
  }

  vector<int> negative(const vector<int>& nums) {
    vector<int> A(nums);
    for (int& a : A)
      a *= -1;
    return A;
  }
};",2263
2261,"class Solution {
 public:
  string largestGoodInteger(string num) {
    string ans;

    for (int i = 2; i < num.length(); ++i)
      if (num[i - 2] == num[i - 1] && num[i - 1] == num[i])
        ans = max(ans, num.substr(i - 2, 3));

    return ans;
  }
};",2264
2262,"class Solution {
 public:
  int averageOfSubtree(TreeNode* root) {
    int ans = 0;
    dfs(root, ans);
    return ans;
  }

 private:
  pair<int, int> dfs(TreeNode* root, int& ans) {
    if (root == nullptr)
      return {0, 0};
    const auto [leftSum, leftCount] = dfs(root->left, ans);
    const auto [rightSum, rightCount] = dfs(root->right, ans);
    const int sum = root->val + leftSum + rightSum;
    const int count = 1 + leftCount + rightCount;
    if (sum / count == root->val)
      ++ans;
    return {sum, count};
  }
};",2265
2263,"class Solution {
 public:
  int countTexts(string pressedKeys) {
    constexpr int kMod = 1'000'000'007;
    const int n = pressedKeys.length();
    // dp[i] := the number of possible text messages of pressedKeys[i..n)
    vector<long> dp(n + 1);
    dp[n] = 1;  // """"

    for (int i = n - 1; i >= 0; --i) {
      dp[i] = dp[i + 1];
      if (isSame(pressedKeys, i, 2))
        dp[i] += dp[i + 2];
      if (isSame(pressedKeys, i, 3))
        dp[i] += dp[i + 3];
      if ((pressedKeys[i] == '7' || pressedKeys[i] == '9') &&
          isSame(pressedKeys, i, 4))
        dp[i] += dp[i + 4];
      dp[i] %= kMod;
    }

    return dp[0];
  }

 private:
  // Returns true if s[i..i + k) are the same digits.
  bool isSame(const string& s, int i, int k) {
    if (i + k > s.length())
      return false;
    for (int j = i + 1; j < i + k; ++j)
      if (s[j] != s[i])
        return false;
    return true;
  }
};",2266
2264,"class Solution {
 public:
  bool hasValidPath(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<vector<int>>> mem(
        m, vector<vector<int>>(n, vector<int>(m + n, -1)));
    return hasValidPath(grid, 0, 0, 0, mem);
  }

 private:
  // Returns true if there's a path from grid[i][j] to grid[m - 1][n - 1], where
  // the number of '(' - the number of ')' == k.
  bool hasValidPath(const vector<vector<char>>& grid, int i, int j, int k,
                    vector<vector<vector<int>>>& mem) {
    if (i == grid.size() || j == grid[0].size())
      return false;
    k += grid[i][j] == '(' ? 1 : -1;
    if (k < 0)
      return false;
    if (i == grid.size() - 1 && j == grid[0].size() - 1)
      return k == 0;
    if (mem[i][j][k] != -1)
      return mem[i][j][k];
    return mem[i][j][k] = hasValidPath(grid, i + 1, j, k, mem) |
                          hasValidPath(grid, i, j + 1, k, mem);
  }
};",2267
2265,"class Solution {
 public:
  int minimumKeypresses(string s) {
    int ans = 0;
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    ranges::sort(count, greater<>());

    for (int i = 0; i < 26; ++i)
      ans += count[i] * (i / 9 + 1);

    return ans;
  }
};",2268
2266,"class Solution {
 public:
  int divisorSubstrings(int num, int k) {
    const string s = to_string(num);
    int ans = 0;

    for (int i = 0; i + k <= s.length(); ++i) {
      const int x = stoi(s.substr(i, k));
      if (x != 0 && num % x == 0)
        ++ans;
    }

    return ans;
  }
};",2269
2267,"class Solution {
 public:
  int waysToSplitArray(vector<int>& nums) {
    int ans = 0;
    long prefix = 0;
    long suffix = accumulate(nums.begin(), nums.end(), 0L);

    for (int i = 0; i < nums.size() - 1; ++i) {
      prefix += nums[i];
      suffix -= nums[i];
      if (prefix >= suffix)
        ++ans;
    }

    return ans;
  }
};",2270
2268,"class Solution {
 public:
  int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {
    if (ranges::any_of(tiles, [&](const auto& tile) {
      return tile[1] - tile[0] + 1 >= carpetLen;
    }))
      return carpetLen;

    int ans = 0;
    vector<int> starts;
    vector<int> prefix(tiles.size() + 1);

    ranges::sort(tiles);

    for (const vector<int>& tile : tiles)
      starts.push_back(tile[0]);

    for (int i = 0; i < tiles.size(); ++i) {
      const int length = tiles[i][1] - tiles[i][0] + 1;
      prefix[i + 1] = prefix[i] + length;
    }

    for (int i = 0; i < tiles.size(); ++i) {
      const int s = tiles[i][0];
      const int carpetEnd = s + carpetLen - 1;
      const int endIndex =
          ranges::upper_bound(starts, carpetEnd) - starts.begin() - 1;
      const int notCover = max(0, tiles[endIndex][1] - carpetEnd);
      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover);
    }

    return ans;
  }
};",2271
2269,"class Solution {
 public:
  int largestVariance(string s) {
    int ans = 0;

    for (char a = 'a'; a <= 'z'; ++a)
      for (char b = 'a'; b <= 'z'; ++b)
        if (a != b)
          ans = max(ans, kadane(s, a, b));

    return ans;
  }

 private:
  // a := the letter with the higher frequency
  // b := the letter with the lower frequency
  int kadane(const string& s, char a, char b) {
    int ans = 0;
    int countA = 0;
    int countB = 0;
    bool canExtendPrevB = false;

    for (const char c : s) {
      if (c != a && c != b)
        continue;
      if (c == a)
        ++countA;
      else
        ++countB;
      if (countB > 0) {
        // An interval should contain at least one b.
        ans = max(ans, countA - countB);
      } else if (countB == 0 && canExtendPrevB) {
        // edge case: consider the previous b.
        ans = max(ans, countA - 1);
      }
      // Reset if the number of b > the number of a.
      if (countB > countA) {
        countA = 0;
        countB = 0;
        canExtendPrevB = true;
      }
    }

    return ans;
  }
};",2272
2270,"class Solution {
 public:
  vector<string> removeAnagrams(vector<string>& words) {
    vector<string> ans;

    for (int i = 0; i < words.size();) {
      int j = i + 1;
      while (j < words.size() && isAnagram(words[i], words[j]))
        ++j;
      ans.push_back(words[i]);
      i = j;
    }

    return ans;
  }

 private:
  bool isAnagram(const string& a, const string& b) {
    if (a.length() != b.length())
      return false;

    vector<int> count(26);

    for (const char c : a)
      ++count[c - 'a'];

    for (const char c : b)
      --count[c - 'a'];

    return ranges::all_of(count, [](const int c) { return c == 0; });
  }
};",2273
2271,"class Solution {
 public:
  int maxConsecutive(int bottom, int top, vector<int>& special) {
    int ans = 0;

    ranges::sort(special);

    for (int i = 1; i < special.size(); ++i)
      ans = max(ans, special[i] - special[i - 1] - 1);

    return max({ans, special.front() - bottom, top - special.back()});
  }
};",2274
2272,"class Solution {
 public:
  int largestCombination(vector<int>& candidates) {
    constexpr int kMaxBit = 24;
    int ans = 0;

    for (int i = 0; i < kMaxBit; ++i) {
      int count = 0;
      for (const int candidate : candidates)
        if (candidate >> i & 1)
          ++count;
      ans = max(ans, count);
    }

    return ans;
  }
};",2275
2273,"add(left: int, right: int)",2276
2274,"class Solution {
 public:
  vector<int> closestNode(int n, vector<vector<int>>& edges,
                          vector<vector<int>>& query) {
    vector<int> ans;
    vector<vector<int>> tree(n);
    vector<vector<int>> dist(n, vector<int>(n, -1));

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    for (int i = 0; i < n; ++i)
      fillDist(tree, i, i, 0, dist);

    for (const vector<int>& q : query) {
      const int start = q[0];
      const int end = q[1];
      const int node = q[2];
      ans.push_back(findClosest(tree, dist, start, end, node, start));
    }

    return ans;
  }

 private:
  void fillDist(const vector<vector<int>>& tree, int start, int u, int d,
                vector<vector<int>>& dist) {
    dist[start][u] = d;
    for (const int v : tree[u])
      if (dist[start][v] == -1)
        fillDist(tree, start, v, d + 1, dist);
  }

  int findClosest(const vector<vector<int>>& tree,
                  const vector<vector<int>>& dist, int u, int end, int node,
                  int ans) {
    for (const int v : tree[u])
      if (dist[v][end] < dist[u][end])
        return findClosest(tree, dist, v, end, node,
                           dist[ans][node] < dist[v][node] ? ans : v);
    return ans;
  }
};",2277
2275,"class Solution {
 public:
  int percentageLetter(string s, char letter) {
    return 100 * ranges::count(s, letter) / s.length();
  }
};",2278
2276,"class Solution {
 public:
  int maximumBags(vector<int>& capacity, vector<int>& rocks,
                  int additionalRocks) {
    const int n = capacity.size();
    vector<int> diff(n);

    for (int i = 0; i < n; ++i)
      diff[i] = capacity[i] - rocks[i];

    ranges::sort(diff);

    for (int i = 0; i < n; ++i) {
      if (diff[i] > additionalRocks)
        return i;
      additionalRocks -= diff[i];
    }

    return n;
  }
};",2279
2277,"class Solution {
 public:
  int minimumLines(vector<vector<int>>& stockPrices) {
    int ans = 0;

    ranges::sort(stockPrices);

    for (int i = 2; i < stockPrices.size(); ++i) {
      const pair<int, int> a = getSlope(stockPrices[i - 2], stockPrices[i - 1]);
      const pair<int, int> b = getSlope(stockPrices[i - 1], stockPrices[i]);
      if (a != b)
        ++ans;
    }

    return ans + (stockPrices.size() > 1);
  }

 private:
  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {
    const int dx = p[0] - q[0];
    const int dy = p[1] - q[1];
    if (dx == 0)
      return {0, p[0]};
    if (dy == 0)
      return {p[1], 0};
    const int d = __gcd(dx, dy);
    return {dx / d, dy / d};
  }
};",2280
2278,"class Solution {
 public:
  int totalStrength(vector<int>& strength) {
    constexpr int kMod = 1'000'000'007;
    const int n = strength.size();
    vector<long> prefix(n);
    vector<long> prefixOfPrefix(n + 1);
    // left[i] := the next index on the left (if any) s.t.
    // nums[left[i]] <= nums[i]
    vector<int> left(n, -1);
    // right[i] := the next index on the right (if any) s.t.
    // nums[right[i]] < nums[i]
    vector<int> right(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i)
      prefix[i] = i == 0 ? strength[0] : (strength[i] + prefix[i - 1]) % kMod;

    for (int i = 0; i < n; ++i)
      prefixOfPrefix[i + 1] = (prefixOfPrefix[i] + prefix[i]) % kMod;

    for (int i = n - 1; i >= 0; --i) {
      while (!stack.empty() && strength[stack.top()] >= strength[i])
        left[stack.top()] = i, stack.pop();
      stack.push(i);
    }

    stack = std::stack<int>();

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && strength[stack.top()] > strength[i])
        right[stack.top()] = i, stack.pop();
      stack.push(i);
    }

    long ans = 0;

    // For each strength[i] as minimum, calculate sum.
    for (int i = 0; i < n; ++i) {
      const int l = left[i];
      const int r = right[i];
      const long leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)];
      const long rightSum = prefixOfPrefix[r] - prefixOfPrefix[i];
      const int leftLen = i - l;
      const int rightLen = r - i;
      ans += strength[i] *
             (rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod) %
             kMod;
      ans %= kMod;
    }

    return ans;
  }
};",2281
2279,"class Solution {
 public:
  vector<vector<int>> seePeople(vector<vector<int>>& heights) {
    const int m = heights.size();
    const int n = heights[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < m; ++i) {
      stack<int> stack;
      for (int j = 0; j < n; ++j) {
        bool hasEqualHeight = false;
        while (!stack.empty() && heights[i][stack.top()] <= heights[i][j]) {
          if (heights[i][stack.top()] == heights[i][j])
            // edge case: [4, 2, 1, 1, 3]
            hasEqualHeight = true;
          ++ans[i][stack.top()], stack.pop();
        }
        if (!stack.empty() && !hasEqualHeight)
          ++ans[i][stack.top()];
        stack.push(j);
      }
    }

    for (int j = 0; j < n; ++j) {
      stack<int> stack;
      for (int i = 0; i < m; ++i) {
        bool hasEqualHeight = false;
        while (!stack.empty() && heights[stack.top()][j] <= heights[i][j]) {
          if (heights[stack.top()][j] == heights[i][j])
            hasEqualHeight = true;
          ++ans[stack.top()][j], stack.pop();
        }
        if (!stack.empty() && !hasEqualHeight)
          ++ans[stack.top()][j];
        stack.push(i);
      }
    }

    return ans;
  }
};",2282
2280,"class Solution {
 public:
  bool digitCount(string num) {
    vector<int> count(10);

    for (const char c : num)
      ++count[c - '0'];

    for (int i = 0; i < num.length(); ++i)
      if (count[i] != num[i] - '0')
        return false;

    return true;
  }
};",2283
2281,"class Solution {
 public:
  string largestWordCount(vector<string>& messages, vector<string>& senders) {
    const int n = messages.size();
    string ans;
    int maxWordsSent = 0;
    unordered_map<string, int> count;  // {sender, the number of words sent}

    for (int i = 0; i < n; ++i) {
      const string& message = messages[i];
      const string& sender = senders[i];
      const int wordsCount = ranges::count(message, ' ') + 1;
      count[sender] += wordsCount;
      const int numWordsSent = count[sender];
      if (numWordsSent > maxWordsSent) {
        ans = sender;
        maxWordsSent = numWordsSent;
      } else if (numWordsSent == maxWordsSent && sender > ans) {
        ans = sender;
      }
    }

    return ans;
  }
};",2284
2282,"class Solution {
 public:
  long long maximumImportance(int n, vector<vector<int>>& roads) {
    long long ans = 0;
    vector<long long> count(n);

    for (const vector<int>& r : roads) {
      ++count[r[0]];
      ++count[r[1]];
    }

    ranges::sort(count);

    for (int i = 0; i < n; ++i)
      ans += (i + 1) * count[i];

    return ans;
  }
};",2285
2283,"gather(k: int, maxRow: int)",2286
2284,"class Solution {
 public:
  int rearrangeCharacters(string s, string target) {
    int ans = s.length();
    vector<int> countS(128);
    vector<int> countT(128);

    for (const char c : s)
      ++countS[c];

    for (const char c : target)
      ++countT[c];

    for (const char c : target)
      ans = min(ans, countS[c] / countT[c]);

    return ans;
  }
};",2287
2285,"class Solution {
 public:
  string discountPrices(string sentence, int discount) {
    constexpr int kPrecision = 2;
    string ans;
    istringstream iss(sentence);

    for (string word; iss >> word;)
      if (word[0] == '$' && word.length() > 1) {
        const string digits = word.substr(1);
        if (ranges::all_of(digits,
                           [](const char digit) { return isdigit(digit); })) {
          const double val = stold(digits) * (100 - discount) / 100;
          const string s = to_string(val);
          const string trimmed = s.substr(0, s.find(""."") + kPrecision + 1);
          ans += ""$"" + trimmed + "" "";
        } else {
          ans += word + "" "";
        }
      } else {
        ans += word + "" "";
      }

    ans.pop_back();
    return ans;
  }
};",2288
2286,"class Solution {
 public:
  int totalSteps(vector<int>& nums) {
    // dp[i] := the number of steps to remove nums[i]
    vector<int> dp(nums.size());
    stack<int> stack;

    for (int i = 0; i < nums.size(); ++i) {
      int step = 1;
      while (!stack.empty() && nums[stack.top()] <= nums[i])
        step = max(step, dp[stack.top()] + 1), stack.pop();
      if (!stack.empty())
        dp[i] = step;
      stack.push(i);
    }

    return ranges::max(dp);
  }
};",2289
2287,"class Solution {
 public:
  int minimumObstacles(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    using T = tuple<int, int, int>;  // (d, i, j)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));

    minHeap.emplace(grid[0][0], 0, 0);
    dist[0][0] = grid[0][0];

    while (!minHeap.empty()) {
      const auto [d, i, j] = minHeap.top();
      minHeap.pop();
      if (i == m - 1 && j == n - 1)
        return d;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        const int newDist = d + grid[i][j];
        if (newDist < dist[x][y]) {
          dist[x][y] = newDist;
          minHeap.emplace(newDist, x, y);
        }
      }
    }

    return dist[m - 1][n - 1];
  }
};",2290
2288,"class Solution {
 public:
  int maximumProfit(vector<int>& present, vector<int>& future, int budget) {
    const int n = present.size();
    // dp[i][j] := the maximum profit of buying present[0..i) with j budget
    vector<vector<int>> dp(n + 1, vector<int>(budget + 1));

    for (int i = 1; i <= n; ++i) {
      const int profit = future[i - 1] - present[i - 1];
      for (int j = 0; j <= budget; ++j)
        if (j < present[i - 1])
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]]);
    }

    return dp[n][budget];
  }
};",2291
2289,"WITH
  OrdersNeighbors AS (
    SELECT
      product_id,
      YEAR(purchase_date) AS curr_year,
      LEAD(YEAR(purchase_date)) OVER(
        PARTITION BY product_id
        ORDER BY YEAR(purchase_date)
      ) AS next_year
    FROM orders
    GROUP BY 1, 2
    HAVING COUNT(order_id) >= 3
  )
SELECT DISTINCT product_id
FROM OrdersNeighbors
WHERE curr_year + 1 = next_year;",2292
2290,"class Solution {
 public:
  int minMaxGame(vector<int>& nums) {
    if (nums.size() == 1)
      return nums[0];

    vector<int> nextNums;
    for (int i = 0; i < nums.size() / 2; ++i)
      nextNums.push_back(i & 1 ? max(nums[2 * i], nums[2 * i + 1])
                               : min(nums[2 * i], nums[2 * i + 1]));
    return minMaxGame(nextNums);
  }
};",2293
2291,"class Solution {
 public:
  int partitionArray(vector<int>& nums, int k) {
    ranges::sort(nums);

    int ans = 1;
    int min = nums[0];

    for (int i = 1; i < nums.size(); ++i)
      if (min + k < nums[i]) {
        ++ans;
        min = nums[i];
      }

    return ans;
  }
};",2294
2292,"class Solution {
 public:
  vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i)
      numToIndex[nums[i]] = i;

    for (const vector<int>& o : operations) {
      const int original = o[0];
      const int replaced = o[1];
      const int index = numToIndex[original];
      nums[index] = replaced;
      numToIndex.erase(original);
      numToIndex[replaced] = index;
    }

    return nums;
  }
};",2295
2293,addText(text: str),2296
2294,"class Solution {
 public:
  long long minCost(vector<int>& nums, vector<int>& costs) {
    const int n = nums.size();
    // dp[i] := the minimum cost to jump to i
    vector<long long> dp(n, LLONG_MAX);
    stack<int> maxStack;
    stack<int> minStack;

    dp[0] = 0;

    for (int i = 0; i < n; ++i) {
      while (!maxStack.empty() && nums[i] >= nums[maxStack.top()])
        dp[i] = min(dp[i], dp[maxStack.top()] + costs[i]), maxStack.pop();
      while (!minStack.empty() && nums[i] < nums[minStack.top()])
        dp[i] = min(dp[i], dp[minStack.top()] + costs[i]), minStack.pop();
      maxStack.push(i);
      minStack.push(i);
    }

    return dp.back();
  }
};",2297
2295,"SELECT
  SUM(WEEKDAY(submit_date) >= 5) AS weekend_cnt,
  SUM(WEEKDAY(submit_date) < 5) AS working_cnt
FROM Tasks;",2298
2296,"class Solution {
 public:
  bool strongPasswordCheckerII(string password) {
    if (password.length() < 8)
      return false;

    const bool hasLowerCase =
        ranges::any_of(password, [](const char c) { return islower(c); });
    if (!hasLowerCase)
      return false;

    const bool hasUpperCase =
        ranges::any_of(password, [](const char c) { return isupper(c); });
    if (!hasUpperCase)
      return false;

    const bool hasDigit =
        ranges::any_of(password, [](const char c) { return isdigit(c); });
    if (!hasDigit)
      return false;

    const bool hasSpecial = ranges::any_of(password, [](const char c) {
      return string(""!@#$%^&*()-+"").find(c) != string::npos;
    });
    if (!hasSpecial)
      return false;

    for (int i = 1; i < password.length(); ++i)
      if (password[i] == password[i - 1])
        return false;
    return true;
  }
};",2299
2297,"class Solution {
 public:
  vector<int> successfulPairs(vector<int>& spells, vector<int>& potions,
                              long long success) {
    vector<int> ans;
    ranges::sort(potions);

    for (const int spell : spells)
      ans.push_back(potions.size() -
                    firstIndexSuccess(spell, potions, success));

    return ans;
  }

 private:
  // Returns the first index i s.t. spell * potions[i] >= success.
  int firstIndexSuccess(int spell, const vector<int>& potions,
                        long long success) {
    int l = 0;
    int r = potions.size();
    while (l < r) {
      const int m = (l + r) / 2;
      if (static_cast<long long>(spell) * potions[m] >= success)
        r = m;
      else
        l = m + 1;
    }
    return l;
  }
};",2300
2298,"class Solution {
 public:
  bool matchReplacement(string s, string sub, vector<vector<char>>& mappings) {
    vector<vector<bool>> isMapped(128, vector<bool>(128));

    for (const vector<char>& m : mappings) {
      const char old = m[0];
      const char _new = m[1];
      isMapped[old][_new] = true;
    }

    for (int i = 0; i < s.length(); ++i)
      if (canTransform(s, i, sub, isMapped))
        return true;

    return false;
  }

 private:
  bool canTransform(const string& s, int start, const string& sub,
                    const vector<vector<bool>>& isMapped) {
    if (start + sub.length() > s.length())
      return false;

    for (int i = 0; i < sub.length(); ++i) {
      const char a = sub[i];
      const char b = s[start + i];
      if (a != b && !isMapped[a][b])
        return false;
    }

    return true;
  }
};",2301
2299,"class Solution {
 public:
  long long countSubarrays(vector<int>& nums, long long k) {
    long long ans = 0;
    long long sum = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum * (r - l + 1) >= k)
        sum -= nums[l++];
      ans += r - l + 1;
    }

    return ans;
  }
};",2302
2300,"class Solution {
 public:
  double calculateTax(vector<vector<int>>& brackets, int income) {
    double ans = 0;
    int prev = 0;

    for (const vector<int>& b : brackets) {
      const int upper = b[0];
      const int percent = b[1];
      if (income < upper)
        return ans + (income - prev) * percent / 100.0;
      ans += (upper - prev) * percent / 100.0;
      prev = upper;
    }

    return ans;
  }
};",2303
2301,"class Solution {
 public:
  int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {
    const int m = grid.size();
    const int n = grid[0].size();
    // dp[i][j] := the minimum cost to reach grid[i][j]
    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
    dp[0] = grid[0];

    for (int i = 1; i < m; ++i)
      for (int j = 0; j < n; ++j)
        for (int k = 0; k < n; ++k)
          dp[i][j] = min(dp[i][j], dp[i - 1][k] + moveCost[grid[i - 1][k]][j] +
                                       grid[i][j]);

    return ranges::min(dp.back());
  }
};",2304
2302,"class Solution {
 public:
  int distributeCookies(vector<int>& cookies, int k) {
    int ans = INT_MAX;
    dfs(cookies, 0, k, vector<int>(k), ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& cookies, int s, int k, vector<int>&& children,
           int& ans) {
    if (s == cookies.size()) {
      ans = min(ans, ranges::max(children));
      return;
    }

    for (int i = 0; i < k; ++i) {
      children[i] += cookies[s];
      dfs(cookies, s + 1, k, move(children), ans);
      children[i] -= cookies[s];
    }
  }
};",2305
2303,"class Solution {
 public:
  long long distinctNames(vector<string>& ideas) {
    long long ans = 0;
    // suffixes[i] := the set of strings omitting the first letter, where the
    // first letter is ('a' + i)
    vector<unordered_set<string>> suffixes(26);

    for (const string& idea : ideas)
      suffixes[idea[0] - 'a'].insert(idea.substr(1));

    for (int i = 0; i < 25; ++i)
      for (int j = i + 1; j < 26; ++j) {
        int count = 0;
        for (const string& suffix : suffixes[i])
          if (suffixes[j].count(suffix))
            ++count;
        ans += 2 * (suffixes[i].size() - count) * (suffixes[j].size() - count);
      }

    return ans;
  }
};",2306
2304,"class Solution {
 public:
  bool checkContradictions(vector<vector<string>>& equations,
                           vector<double>& values) {
    // Convert `string` to `int` for a better perfermance.
    unordered_map<string, int> strToInt;

    for (const vector<string>& equation : equations) {
      const string& u = equation[0];
      const string& v = equation[1];
      if (!strToInt.count(u))
        strToInt[u] = strToInt.size();
      if (!strToInt.count(v))
        strToInt[v] = strToInt.size();
    }

    vector<vector<pair<int, double>>> graph(strToInt.size());
    vector<double> seen(graph.size());

    for (int i = 0; i < equations.size(); ++i) {
      const int u = strToInt.at(equations[i][0]);
      const int v = strToInt.at(equations[i][1]);
      graph[u].emplace_back(v, values[i]);
      graph[v].emplace_back(u, 1 / values[i]);
    }

    for (int i = 0; i < graph.size(); ++i)
      if (!seen[i] && dfs(graph, i, seen, 1.0))
        return true;

    return false;
  }

 private:
  bool dfs(const vector<vector<pair<int, double>>>& graph, int u,
           vector<double>& seen, double val) {
    if (seen[u])
      return abs(val / seen[u] - 1) > 1e-5;

    seen[u] = val;
    for (const auto& [v, w] : graph[u])
      if (dfs(graph, v, seen, val / w))
        return true;

    return false;
  }
};",2307
2305,"SELECT
  user_id,
  gender
FROM Genders
ORDER BY RANK() OVER(
    PARTITION by gender
    ORDER BY user_id
  ),
  LENGTH(gender) DESC;",2308
2306,"class Solution {
 public:
  string greatestLetter(string s) {
    vector<bool> seen(128);

    for (const char c : s)
      seen[c] = true;

    for (int i = 25; i >= 0; --i)
      if (seen['a' + i] && seen['A' + i])
        return string(1, 'A' + i);

    return """";
  }
};",2309
2307,"class Solution {
 public:
  int minimumNumbers(int num, int k) {
    if (num == 0)
      return 0;

    // Assume the size of the set is n, and the numbers in the set are X1, X2,
    // ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =
    // N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find
    // the n s.t. n * k % 10 = num % 10
    for (int i = 1; i <= 10 && i * k <= num; ++i)
      if (i * k % 10 == num % 10)
        return i;

    return -1;
  }
};",2310
2308,"class Solution {
 public:
  int longestSubsequence(string s, int k) {
    int oneCount = 0;
    int num = 0;
    int pow = 1;

    // Take as many 1s as possible from the right.
    for (int i = s.length() - 1; i >= 0 && num + pow <= k; --i) {
      if (s[i] == '1') {
        ++oneCount;
        num += pow;
      }
      pow *= 2;
    }

    return ranges::count(s, '0') + oneCount;
  }
};",2311
2309,"class Solution {
 public:
  long long sellingWood(int m, int n, vector<vector<int>>& prices) {
    // dp[i][j] := the maximum money of cutting i x j piece of wood
    vector<vector<long long>> dp(m + 1, vector<long long>(n + 1));

    for (const vector<int>& p : prices) {
      const int h = p[0];
      const int w = p[1];
      const int price = p[2];
    }

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j) {
        for (int h = 1; h <= i / 2; ++h)
          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j]);
        for (int w = 1; w <= j / 2; ++w)
          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w]);
      }

    return dp[m][n];
  }
};",2312
2310,"class Solution {
 public:
  int minimumFlips(TreeNode* root, bool result) {
    return dp(root, result);
  }

 private:
  struct PairHash {
    template <class T1, class T2>
    std::size_t operator()(const std::pair<T1, T2>& p) const {
      return std::hash<T1>{}(p.first) ^ std::hash<T2>{}(p.second);
    }
  };

  unordered_map<pair<TreeNode*, bool>, int, PairHash> mem;

  // Returns the minimum flips to make the subtree become the target.
  int dp(TreeNode* root, bool target) {
    const pair<TreeNode*, bool> key{root, target};
    if (const auto it = mem.find(key); it != mem.cend())
      return it->second;
    if (root->val == 0 || root->val == 1)  // the leaf
      return root->val == target ? 0 : 1;
    if (root->val == 5)  // NOT
      return dp(root->left == nullptr ? root->right : root->left, !target);

    vector<pair<int, int>> nextTargets;
    if (root->val == 2)  // OR
      nextTargets = target ? vector<pair<int, int>>{{0, 1}, {1, 0}, {1, 1}}
                           : vector<pair<int, int>>{{0, 0}};
    else if (root->val == 3)  // AND
      nextTargets = target ? vector<pair<int, int>>{{1, 1}}
                           : vector<pair<int, int>>{{0, 0}, {0, 1}, {1, 0}};
    else  // root.val == 4 (XOR)
      nextTargets = target ? vector<pair<int, int>>{{0, 1}, {1, 0}}
                           : vector<pair<int, int>>{{0, 0}, {1, 1}};

    int ans = INT_MAX;
    for (const auto& [leftTarget, rightTarget] : nextTargets)
      ans = min(ans, dp(root->left, leftTarget) + dp(root->right, rightTarget));
    return mem[key] = ans;
  }
};",2313
2311,"WITH
  RankedWeather AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION by city_id
        ORDER BY degree DESC, day
      ) AS `rank`
    FROM Weather
  )
SELECT city_id, day, degree
FROM RankedWeather
WHERE `rank` = 1;",2314
2312,"class Solution {
 public:
  int countAsterisks(string s) {
    int ans = 0;
    int bars = 0;

    for (const char c : s) {
      if (c == '|')
        ++bars;
      else if (c == '*' && bars % 2 == 0)
        ++ans;
    }

    return ans;
  }
};",2315
2313,"class Solution {
 public:
  long long countPairs(int n, vector<vector<int>>& edges) {
    long long ans = 0;
    vector<vector<int>> graph(n);
    vector<bool> seen(n);
    int unreached = n;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i) {
      const int reached = dfs(graph, i, seen);
      unreached -= reached;
      ans += static_cast<long long>(unreached) * reached;
    }
    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, vector<bool>& seen) {
    if (seen[u])
      return 0;
    seen[u] = true;
    return accumulate(
        graph[u].begin(), graph[u].end(), 1,
        [&](int subtotal, int v) { return subtotal + dfs(graph, v, seen); });
  }
};",2316
2314,"class Solution {
 public:
  int maximumXOR(vector<int>& nums) {
    // 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from
    //    nums[i] since x is arbitrary.
    // 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1
    //    for an odd number of elements.
    // 3. Therefore, the question is equivalent to: if you can convert any digit
    //    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).
    // 4. The maximum we can get is of course to make every digit of the answer
    //    to be 1 if possible
    // 5. Therefore, OR(nums[i]) is an approach.
    return reduce(nums.begin(), nums.end(), 0, bit_or());
  }
};",2317
2315,"class Solution {
 public:
  int distinctSequences(int n) {
    vector<vector<vector<int>>> mem(n + 1,
                                    vector<vector<int>>(7, vector<int>(7)));
    return distinctSequences(n, 0, 0, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of distinct sequences for n dices with `prev` and
  // `prevPrev`.
  int distinctSequences(int n, int prev, int prevPrev,
                        vector<vector<vector<int>>>& mem) {
    if (n == 0)
      return 1;
    if (mem[n][prev][prevPrev] > 0)
      return mem[n][prev][prevPrev];

    for (int dice = 1; dice <= 6; ++dice)
      if (dice != prev && dice != prevPrev &&
          (prev == 0 || gcd(dice, prev) == 1)) {
        mem[n][prev][prevPrev] += distinctSequences(n - 1, dice, prev, mem);
        mem[n][prev][prevPrev] %= kMod;
      }

    return mem[n][prev][prevPrev];
  }
};",2318
2316,"class Solution {
 public:
  bool checkXMatrix(vector<vector<int>>& grid) {
    const int n = grid.size();

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (i == j || i + j == n - 1) {  // in diagonal
          if (grid[i][j] == 0)
            return false;
        } else if (grid[i][j]) {  // not in diagonal
          return false;
        }

    return true;
  }
};",2319
2317,"class Solution {
 public:
  int countHousePlacements(int n) {
    constexpr int kMod = 1'000'000'007;
    int house = 1;  // the number of ways ending in a house
    int space = 1;  // the number of ways ending in a space
    int total = house + space;

    for (int i = 2; i <= n; ++i) {
      house = space;
      space = total;
      total = (house + space) % kMod;
    }

    return static_cast<long>(total) * total % kMod;
  }
};",2320
2318,"class Solution {
 public:
  int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {
    return max(kadane(nums1, nums2), kadane(nums2, nums1));
  }

 private:
  // Returns the maximum gain of swapping some numbers in `nums1` with some
  // numbers in `nums2`.
  int kadane(const vector<int>& nums1, const vector<int>& nums2) {
    int gain = 0;
    int maxGain = 0;

    for (int i = 0; i < nums1.size(); ++i) {
      gain = max(0, gain + nums2[i] - nums1[i]);
      maxGain = max(maxGain, gain);
    }

    return maxGain + accumulate(nums1.begin(), nums1.end(), 0);
  }
};",2321
2319,"class Solution {
 public:
  int minimumScore(vector<int>& nums, vector<vector<int>>& edges) {
    const int n = nums.size();
    const int xors = reduce(nums.begin(), nums.end(), 0, bit_xor());
    vector<int> subXors(nums);
    vector<vector<int>> tree(n);
    vector<unordered_set<int>> children(n);

    for (int i = 0; i < n; ++i)
      children[i].insert(i);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, -1, subXors, children);

    int ans = INT_MAX;

    for (int i = 0; i < edges.size(); ++i) {
      int a = edges[i][0];
      int b = edges[i][1];
      if (children[a].count(b))
        swap(a, b);
      for (int j = 0; j < i; ++j) {
        int c = edges[j][0];
        int d = edges[j][1];
        if (children[c].count(d))
          swap(c, d);
        vector<int> cands;
        if (a != c && children[a].count(c))
          cands = {subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]};
        else if (a != c && children[c].count(a))
          cands = {subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]};
        else
          cands = {subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]};
        ans = min(ans, ranges::max(cands) - ranges::min(cands));
      }
    }

    return ans;
  }

 private:
  pair<int, unordered_set<int>> dfs(const vector<vector<int>>& tree, int u,
                                    int parent, vector<int>& subXors,
                                    vector<unordered_set<int>>& children) {
    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      const auto& [vXor, vChildren] = dfs(tree, v, u, subXors, children);
      subXors[u] ^= vXor;
      children[u].insert(vChildren.begin(), vChildren.end());
    }
    return {subXors[u], children[u]};
  }
};",2322
2320,"class Solution {
 public:
  int minimumTime(vector<int>& jobs, vector<int>& workers) {
    int ans = 0;

    ranges::sort(jobs);
    ranges::sort(workers);

    for (int i = 0; i < jobs.size(); ++i)
      ans = max(ans, (jobs[i] - 1) / workers[i] + 1);

    return ans;
  }
};",2323
2321,"WITH
  RankedSpending AS (
    SELECT
      Sales.user_id,
      Sales.product_id,
      RANK() OVER(
        PARTITION by user_id
        ORDER BY SUM(Sales.quantity * Product.price) DESC
      ) AS `rank`
    FROM Sales
    INNER JOIN Product
      USING (product_id)
    GROUP BY 1, 2
  )
SELECT user_id, product_id
FROM RankedSpending
WHERE `rank` = 1;",2324
2322,"class Solution {
 public:
  string decodeMessage(string key, string message) {
    vector<char> keyToActual(128);
    keyToActual[' '] = ' ';
    char currChar = 'a';

    for (const char c : key)
      keyToActual[c] = keyToActual[c] ?: currChar++;

    transform(message.cbegin(), message.cend(), message.begin(),
              [&](char c) { return keyToActual[c]; });

    return message;
  }
};",2325
2323,"class Solution {
 public:
  vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    vector<vector<int>> ans(m, vector<int>(n, -1));
    int x = 0;  // the current x position
    int y = 0;  // the current y position
    int d = 0;

    for (ListNode* curr = head; curr; curr = curr->next) {
      ans[x][y] = curr->val;
      if (x + dirs[d] < 0 || x + dirs[d] == m || y + dirs[d + 1] < 0 ||
          y + dirs[d + 1] == n || ans[x + dirs[d]][y + dirs[d + 1]] != -1)
        d = (d + 1) % 4;
      x += dirs[d];
      y += dirs[d + 1];
    }

    return ans;
  }
};",2326
2324,"class Solution {
 public:
  int peopleAwareOfSecret(int n, int delay, int forget) {
    constexpr int kMod = 1'000'000'007;
    long share = 0;
    // dp[i] := the number of people know the secret at day i
    vector<int> dp(n);  // Maps day i to i + 1.
    dp[0] = 1;

    for (int i = 1; i < n; ++i) {
      if (i - delay >= 0)
        share += dp[i - delay];
      if (i - forget >= 0)
        share -= dp[i - forget];
      share += kMod;
      share %= kMod;
      dp[i] = share;
    }

    // People before day `n - forget - 1` already forget the secret.
    return accumulate(dp.end() - forget, dp.end(), 0, [&](int subtotal, int d) {
      return (subtotal + d) % kMod;
    });
  }
};",2327
2325,"class Solution {
 public:
  int countPaths(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<vector<int>> mem(m, vector<int>(n, -1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        ans += countPaths(grid, i, j, mem);
        ans %= kMod;
      }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  // Returns the number of increasing paths starting from (i, j).
  int countPaths(const vector<vector<int>>& grid, int i, int j,
                 vector<vector<int>>& mem) {
    if (mem[i][j] != -1)
      return mem[i][j];

    mem[i][j] = 1;  // The current cell contributes 1 length.

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
        continue;
      if (grid[x][y] <= grid[i][j])
        continue;
      mem[i][j] += countPaths(grid, x, y, mem);
      mem[i][j] %= kMod;
    }

    return mem[i][j];
  }
};",2328
2326,"SELECT
  Sales.user_id,
  SUM(Sales.quantity * Product.price) AS spending
FROM Sales
INNER JOIN Product
  USING (product_id)
GROUP BY user_id
ORDER BY spending DESC;",2329
2327,"class Solution {
 public:
  bool makePalindrome(string s) {
    int change = 0;
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      if (s[l] != s[r] && ++change > 2)
        return false;
      ++l;
      --r;
    }

    return true;
  }
};",2330
2328,"class Solution {
 public:
  bool evaluateTree(TreeNode* root) {
    if (root->val < 2)
      return root->val;
    if (root->val == 2)  // OR
      return evaluateTree(root->left) || evaluateTree(root->right);
    // AND
    return evaluateTree(root->left) && evaluateTree(root->right);
  }
};",2331
2329,"class Solution {
 public:
  int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers,
                            int capacity) {
    ranges::sort(buses);
    ranges::sort(passengers);

    if (passengers.front() > buses.back())
      return buses.back();

    int ans = passengers[0] - 1;
    int i = 0;  // buses' index
    int j = 0;  // passengers' index

    while (i < buses.size()) {
      // Greedily make passengers catch `buses[i]`.
      int arrived = 0;
      while (arrived < capacity && j < passengers.size() &&
             passengers[j] <= buses[i]) {
        if (j > 0 && passengers[j] != passengers[j - 1] + 1)
          ans = passengers[j] - 1;
        ++j;
        ++arrived;
      }
      // There's room for `buses[i]` to carry a passenger arriving at
      // `buses[i]`.
      if (arrived < capacity && j > 0 && passengers[j - 1] != buses[i])
        ans = buses[i];
      ++i;
    }

    return ans;
  }
};",2332
2330,"class Solution {
 public:
  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1,
                             int k2) {
    const vector<int> diff = getDiff(nums1, nums2);
    int k = k1 + k2;
    if (accumulate(diff.begin(), diff.end(), 0LL) <= k)
      return 0;

    unordered_map<int, int> count;
    priority_queue<pair<int, int>> maxHeap;  // (num, freq)

    for (const int d : diff)
      if (d != 0)
        ++count[d];

    for (const auto& [num, freq] : count)
      maxHeap.emplace(num, freq);

    while (k > 0) {
      const auto [maxNum, maxNumFreq] = maxHeap.top();
      maxHeap.pop();
      // Buck decrease in this turn
      const int numDecreased = min(k, maxNumFreq);
      k -= numDecreased;
      if (maxNumFreq > numDecreased)
        maxHeap.emplace(maxNum, maxNumFreq - numDecreased);
      if (!maxHeap.empty() && maxHeap.top().first + 1 == maxNum) {
        const auto [secondMaxNum, secondMaxNumFreq] = maxHeap.top();
        maxHeap.pop();
        maxHeap.emplace(secondMaxNum, secondMaxNumFreq + numDecreased);
      } else if (maxNum > 1) {
        maxHeap.emplace(maxNum - 1, numDecreased);
      }
    }

    long long ans = 0;
    while (!maxHeap.empty()) {
      const auto [num, freq] = maxHeap.top();
      maxHeap.pop();
      ans += static_cast<long long>(num) * num * freq;
    }

    return ans;
  }

 private:
  vector<int> getDiff(const vector<int>& nums1, const vector<int>& nums2) {
    vector<int> diff;
    for (int i = 0; i < nums1.size(); ++i)
      diff.push_back(abs(nums1[i] - nums2[i]));
    return diff;
  }
};",2333
2331,"class Solution {
 public:
  // Similar to 907. Sum of Subarray Minimums
  int validSubarraySize(vector<int>& nums, int threshold) {
    const int n = nums.size();
    // prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)
    vector<int> prev(n, -1);
    // next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)
    vector<int> next(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && nums[stack.top()] > nums[i]) {
        const int index = stack.top();
        stack.pop();
        next[index] = i;
      }
      if (!stack.empty())
        prev[i] = stack.top();
      stack.push(i);
    }

    for (int i = 0; i < n; ++i) {
      // the number of `nums` in subarray containing nums[i] >= nums[i]
      const int k = (i - prev[i]) + (next[i] - i) - 1;
      if (nums[i] > threshold / static_cast<double>(k))
        return k;
    }

    return -1;
  }
};",2334
2332,"class Solution {
 public:
  int fillCups(vector<int>& amount) {
    const int max = ranges::max(amount);
    const int sum = accumulate(amount.begin(), amount.end(), 0);
    return std::max(max, (sum + 1) / 2);
  }
};",2335
2333,popSmallest(),2336
2334,"class Solution {
 public:
  bool canChange(string start, string target) {
    const int n = start.length();
    int i = 0;  // start's index
    int j = 0;  // target's index

    while (i <= n && j <= n) {
      while (i < n && start[i] == '_')
        ++i;
      while (j < n && target[j] == '_')
        ++j;
      if (i == n || j == n)
        return i == n && j == n;
      if (start[i] != target[j])
        return false;
      if (start[i] == 'R' && i > j)
        return false;
      if (start[i] == 'L' && i < j)
        return false;
      ++i;
      ++j;
    }

    return true;
  }
};",2337
2335,"class Solution {
 public:
  int idealArrays(int n, int maxValue) {
    constexpr int kMod = 1'000'000'007;
    // Since 2^14 > 10^4, the longest strictly increasing array is [1, 2, 4,
    // ..., 2^13]
    const int maxLength = min(14, n);
    const vector<vector<int>> factors = getFactors(maxValue);
    // dp[i][j] := the number of strictly increasing ideal arrays of length i
    // ending in j
    // dp[i][j] := sum(dp[i - 1][k]), where j % k == 0
    // dp[i][0] := sum(dp[i][j]) where 1 <= j <= maxValue
    vector<vector<unsigned long long>> dp(
        maxLength + 1, vector<unsigned long long>(maxValue + 1));
    mem.resize(n, vector<unsigned long long>(maxLength, -1));
    unsigned long long ans = 0;

    for (int j = 1; j <= maxValue; ++j)
      dp[1][j] = 1;

    for (int i = 2; i <= maxLength; ++i)
      for (int j = 1; j <= maxValue; ++j)
        for (const int k : factors[j]) {
          dp[i][j] += dp[i - 1][k];
          dp[i][j] %= kMod;
        }

    for (int i = 1; i <= maxLength; ++i)
      for (int j = 1; j <= maxValue; ++j) {
        dp[i][0] += dp[i][j];
        dp[i][0] %= kMod;
      }

    for (int i = 1; i <= maxLength; ++i) {
      // nCk(n - 1, i - 1) := the number of ways to create an ideal array of
      // length n from a strictly increasing array of length i
      ans += dp[i][0] * nCk(n - 1, i - 1);
      ans %= kMod;
    }

    return ans;
  }

 private:
  vector<vector<unsigned long long>> mem;

  vector<vector<int>> getFactors(int maxValue) {
    vector<vector<int>> factors(maxValue + 1);
    for (int i = 1; i <= maxValue; ++i)
      // Start from i * 2 because of strictly increasing.
      for (int j = i * 2; j <= maxValue; j += i)
        factors[j].push_back(i);
    return factors;
  }

  unsigned long long nCk(int n, int k, int kMod = 1e9 + 7) {
    if (k == 0)
      return 1;
    if (n == k)
      return 1;
    if (mem[n][k] != -1)
      return mem[n][k];
    return mem[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % kMod;
  }
};",2338
2336,"SELECT
  Home.team_name AS home_team,
  Away.team_name AS away_team
FROM Teams AS Home
INNER JOIN Teams AS Away
WHERE Home.team_name != Away.team_name;",2339
2337,"class Solution {
 public:
  int minimumSwaps(vector<int>& nums) {
    const int minIndex = getLeftmostMinIndex(nums);
    const int maxIndex = getRightmostMaxIndex(nums);
    const int swaps = minIndex + (nums.size() - 1 - maxIndex);
    return minIndex <= maxIndex ? swaps : swaps - 1;
  }

 private:
  int getLeftmostMinIndex(const vector<int>& nums) {
    int min = nums.front();
    int minIndex = 0;
    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < min) {
        min = nums[i];
        minIndex = i;
      }
    return minIndex;
  }

  int getRightmostMaxIndex(const vector<int>& nums) {
    int max = nums.back();
    int maxIndex = nums.size() - 1;
    for (int i = nums.size() - 2; i >= 0; --i)
      if (nums[i] > max) {
        max = nums[i];
        maxIndex = i;
      }
    return maxIndex;
  }
};",2340
2338,"class Solution {
 public:
  vector<int> numberOfPairs(vector<int>& nums) {
    constexpr int kMax = 100;
    vector<int> ans(2);
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = 0; i <= kMax; ++i) {
      ans[0] += count[i] / 2;
      ans[1] += count[i] & 1;
    }

    return ans;
  }
};",2341
2339,"class Solution {
 public:
  int maximumSum(vector<int>& nums) {
    constexpr int kMax = 9 * 9;  // 999,999,999
    int ans = -1;
    vector<vector<int>> count(kMax + 1);

    for (const int num : nums)
      count[getDigitSum(num)].push_back(num);

    for (vector<int>& groupNums : count) {
      if (groupNums.size() < 2)
        continue;
      ranges::sort(groupNums, greater<>());
      ans = max(ans, groupNums[0] + groupNums[1]);
    }

    return ans;
  }

 private:
  int getDigitSum(int num) {
    int digitSum = 0;
    while (num > 0) {
      digitSum += num % 10;
      num /= 10;
    }
    return digitSum;
  }
};",2342
2340,"class Solution {
 public:
  vector<int> smallestTrimmedNumbers(vector<string>& nums,
                                     vector<vector<int>>& queries) {
    vector<int> ans;
    for (const vector<int>& query : queries)
      ans.push_back(getKSmallestIndex(nums, query[0], query[1]));
    return ans;
  }

 private:
  int getKSmallestIndex(const vector<string>& nums, int k, int trim) {
    const int startIndex = nums[0].length() - trim;
    vector<pair<string, int>> trimmed;  // (num, index)

    for (int i = 0; i < nums.size(); ++i) {
      const string& num = nums[i];
      trimmed.push_back({num.substr(startIndex), i});
    }

    ranges::sort(trimmed);
    return trimmed[k - 1].second;
  }
};",2343
2341,"class Solution {
 public:
  int minOperations(vector<int>& nums, vector<int>& numsDivide) {
    const int gcd = getGCD(numsDivide);

    ranges::sort(nums);

    for (int i = 0; i < nums.size(); ++i)
      if (gcd % nums[i] == 0)
        return i;

    return -1;
  }

 private:
  int getGCD(const vector<int>& nums) {
    int gcd = nums[0];
    for (const int num : nums)
      gcd = __gcd(gcd, num);
    return gcd;
  }
};",2344
2342,"class Solution {
 public:
  int visibleMountains(vector<vector<int>>& peaks) {
    const vector<pair<int, int>> A = deDuplicates(peaks);
    stack<int> stack;

    for (int i = 0; i < A.size(); ++i) {
      while (!stack.empty() && isHidden(A[stack.top()], A[i]))
        stack.pop();
      if (!stack.empty() && isHidden(A[i], A[stack.top()]))
        continue;
      stack.push(i);
    }

    return stack.size();
  }

 private:
  vector<pair<int, int>> deDuplicates(const vector<vector<int>>& peaks) {
    vector<pair<int, int>> A;
    unordered_map<pair<int, int>, int, PairHash> count;

    for (const vector<int>& peak : peaks)
      ++count[{peak[0], peak[1]}];

    for (const auto& [k, v] : count)
      if (v == 1)
        A.push_back(k);

    ranges::sort(A);
    return A;
  }

  bool isHidden(const pair<int, int>& peak1, const pair<int, int>& peak2) {
    const auto& [x1, y1] = peak1;
    const auto& [x2, y2] = peak2;
    return x1 - y1 >= x2 - y2 && x1 + y1 <= x2 + y2;
  }

  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",2345
2343,"SELECT
  student_id,
  department_id,
  ROUND(
    100 * PERCENT_RANK() OVER(
      PARTITION BY department_id
      ORDER BY mark DESC
    ),
    2
  ) AS percentage
FROM Students;",2346
2344,"class Solution {
 public:
  string bestHand(vector<int>& ranks, vector<char>& suits) {
    if (ranges::all_of(suits,
                       [&suits](const char suit) { return suit == suits[0]; }))
      return ""Flush"";

    constexpr int kMax = 13;
    vector<int> count(kMax + 1);

    for (const int rank : ranks)
      ++count[rank];

    const int max = ranges::max(count);
    if (max > 2)
      return ""Three of a Kind"";
    if (max == 2)
      return ""Pair"";
    return ""High Card"";
  }
};",2347
2345,"class Solution {
 public:
  long long zeroFilledSubarray(vector<int>& nums) {
    long long ans = 0;
    int indexBeforeZero = -1;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i])
        indexBeforeZero = i;
      else
        ans += i - indexBeforeZero;

    return ans;
  }
};",2348
2346,"change(index: int, number: int)",2349
2347,"class Solution {
 public:
  int shortestSequence(vector<int>& rolls, int k) {
    int ans = 1;  // the the next target length
    unordered_set<int> seen;

    for (const int roll : rolls) {
      seen.insert(roll);
      if (seen.size() == k) {
        // Have all combinations that form `ans` length, and we are going to
        // extend the sequence to `ans + 1` length.
        ++ans;
        seen.clear();
      }
    }

    return ans;
  }
};",2350
2348,"class Solution {
 public:
  char repeatedCharacter(string s) {
    vector<bool> seen(26);

    for (const char c : s) {
      if (seen[c - 'a'])
        return c;
      seen[c - 'a'] = true;
    }

    throw;
  }
};",2351
2349,"class Solution {
 public:
  int equalPairs(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        int k = 0;
        for (; k < n; ++k)
          if (grid[i][k] != grid[k][j])
            break;
        if (k == n)  // R[i] == C[j]
          ++ans;
      }

    return ans;
  }
};",2352
2350,"changeRating(food: str, newRating: int)",2353
2351,"class Solution {
 public:
  long long countExcellentPairs(vector<int>& nums, int k) {
    constexpr int kMaxBit = 30;
    // bits(num1 | num2) + bits(num1 & num2) = bits(num1) + bits(num2)
    long long ans = 0;
    vector<long long> count(kMaxBit);

    for (const int num : unordered_set<int>(nums.begin(), nums.end()))
      ++count[__builtin_popcount(num)];

    for (int i = 0; i < kMaxBit; ++i)
      for (int j = 0; j < kMaxBit; ++j)
        if (i + j >= k)
          ans += count[i] * count[j];

    return ans;
  }
};",2354
2352,"class Solution {
 public:
  long long maximumBooks(vector<int>& books) {
    // dp[i] := the maximum number of books we can take from books[0..i] with
    // taking all of books[i]
    vector<long long> dp(books.size());
    stack<int> stack;  // the possible indices we can reach

    for (int i = 0; i < books.size(); ++i) {
      // We may take all of books[j], where books[j] < books[i] - (i - j).
      while (!stack.empty() &&
             books[stack.top()] >= books[i] - (i - stack.top()))
        stack.pop();
      // We can now take books[j + 1..i].
      const int j = stack.empty() ? -1 : stack.top();
      const int lastTook = books[i] - (i - j) + 1;
      if (lastTook > 1)
        // books[i] + (books[i] - 1) + ... + (books[i] - (i - j) + 1)
        dp[i] = static_cast<long long>(books[i] + lastTook) * (i - j) / 2;
      else
        // 1 + 2 + ... + books[i]
        dp[i] = static_cast<long long>(books[i]) * (books[i] + 1) / 2;
      if (j >= 0)
        dp[i] += dp[j];
      stack.push(i);
    }

    return ranges::max(dp);
  }
};",2355
2353,"SELECT
  teacher_id,
  COUNT(DISTINCT subject_id) AS cnt
FROM Teacher
GROUP BY 1;",2356
2354,"class Solution {
 public:
  int minimumOperations(vector<int>& nums) {
    unordered_set<int> seen(nums.begin(), nums.end());
    return seen.size() - seen.count(0);
  }
};",2357
2355,"class Solution {
 public:
  int maximumGroups(vector<int>& grades) {
    // Sort grades, then we can seperate the students into groups of sizes 1, 2,
    // 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and
    // size. So, we can rephrase the problem into:
    //   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n

    //  1 + 2 + 3 + ... + k <= n
    //         k(k + 1) / 2 <= n
    //              k^2 + k <= 2n
    //   (k + 0.5)^2 - 0.25 <= 2n
    //          (k + 0.5)^2 <= 2n + 0.25
    //                    k <= sqrt(2n + 0.25) - 0.5
    return sqrt(grades.size() * 2 + 0.25) - 0.5;
  }
};",2358
2356,"class Solution {
 public:
  int closestMeetingNode(vector<int>& edges, int node1, int node2) {
    constexpr int kMax = 10000;
    const vector<int> dist1 = getDist(edges, node1);
    const vector<int> dist2 = getDist(edges, node2);
    int minDist = kMax;
    int ans = -1;

    for (int i = 0; i < edges.size(); ++i)
      if (min(dist1[i], dist2[i]) >= 0) {
        const int maxDist = max(dist1[i], dist2[i]);
        if (maxDist < minDist) {
          minDist = maxDist;
          ans = i;
        }
      }

    return ans;
  }

 private:
  vector<int> getDist(const vector<int>& edges, int u) {
    vector<int> dist(edges.size(), -1);
    int d = 0;
    while (u != -1 && dist[u] == -1) {
      dist[u] = d++;
      u = edges[u];
    }
    return dist;
  }
};",2359
2357,"class Solution {
 public:
  int longestCycle(vector<int>& edges) {
    int ans = -1;
    int time = 1;
    vector<int> timeVisited(edges.size());

    for (int i = 0; i < edges.size(); ++i) {
      if (timeVisited[i])
        continue;
      const int startTime = time;
      int u = i;
      while (u != -1 && !timeVisited[u]) {
        timeVisited[u] = time++;
        u = edges[u];  // Move to the next node.
      }
      if (u != -1 && timeVisited[u] >= startTime)
        ans = max(ans, time - timeVisited[u]);
    }

    return ans;
  }
};",2360
2358,"class Solution {
 public:
  vector<long long> minimumCosts(vector<int>& regular, vector<int>& express,
                                 int expressCost) {
    const int n = regular.size();
    vector<long long> ans(n);
    // the minimum cost to reach the current stop in a regular route
    long long dpReg = 0;
    // the minimum cost to reach the current stop in an express route
    long long dpExp = expressCost;

    for (int i = 0; i < n; ++i) {
      const long long prevReg = dpReg;
      const long long prevExp = dpExp;
      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i]);
      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i]);
      ans[i] = min(dpReg, dpExp);
    }

    return ans;
  }
};",2361
2359,"WITH
  HighestPriceInvoice AS (
    SELECT
      Purchases.invoice_id,
      SUM(Purchases.quantity * Products.price) AS price
    FROM Purchases
    INNER JOIN Products
      USING (product_id)
    GROUP BY 1
    ORDER BY 2 DESC, 1
    LIMIT 1
  )
SELECT
  Products.product_id,
  Purchases.quantity,
  Purchases.quantity * Products.price AS price
FROM HighestPriceInvoice
INNER JOIN Purchases
  USING (invoice_id)
INNER JOIN Products
  USING (product_id);",2362
2360,"class Solution {
 public:
  vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1,
                                        vector<vector<int>>& items2) {
    constexpr int kMax = 1000;
    vector<vector<int>> ans;
    vector<int> count(kMax + 1);

    for (const vector<int>& item : items1)
      count[item[0]] += item[1];

    for (const vector<int>& item : items2)
      count[item[0]] += item[1];

    for (int i = 1; i <= kMax; ++i)
      if (count[i])
        ans.push_back({i, count[i]});

    return ans;
  }
};",2363
2361,"class Solution {
 public:
  long long countBadPairs(vector<int>& nums) {
    long long ans = 0;
    unordered_map<int, int> count;  // (nums[i] - i)

    for (int i = 0; i < nums.size(); ++i)
      //     count[nums[i] - i] := the number of good pairs
      // i - count[nums[i] - i] := the number of bad pairs
      ans += i - count[nums[i] - i]++;

    return ans;
  }
};",2364
2362,"class Solution {
 public:
  long long taskSchedulerII(vector<int>& tasks, int space) {
    unordered_map<int, long long> taskToNextAvailable;
    long long ans = 0;

    for (const int task : tasks) {
      ans = max(ans + 1, taskToNextAvailable[task]);
      taskToNextAvailable[task] = ans + space + 1;
    }

    return ans;
  }
};",2365
2363,"class Solution {
 public:
  long long minimumReplacement(vector<int>& nums) {
    long long ans = 0;

    int max = nums.back();
    for (int i = nums.size() - 2; i >= 0; --i) {
      const int ops = (nums[i] - 1) / max;
      ans += ops;
      max = nums[i] / (ops + 1);
    }

    return ans;
  }
};",2366
2364,"class Solution {
 public:
  int arithmeticTriplets(vector<int>& nums, int diff) {
    constexpr int kMax = 200;
    int ans = 0;
    vector<bool> count(kMax + 1);

    for (const int num : nums) {
      if (num >= 2 * diff && count[num - diff] && count[num - 2 * diff])
        ++ans;
      count[num] = true;
    }

    return ans;
  }
};",2367
2365,"class Solution {
 public:
  int reachableNodes(int n, vector<vector<int>>& edges,
                     vector<int>& restricted) {
    vector<vector<int>> tree(n);
    vector<bool> seen(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    for (const int r : restricted)
      seen[r] = true;

    return dfs(tree, 0, seen);
  }

 private:
  int dfs(const vector<vector<int>>& tree, int u, vector<bool>& seen) {
    if (seen[u])
      return 0;

    seen[u] = true;
    int ans = 1;

    for (const int v : tree[u])
      ans += dfs(tree, v, seen);

    return ans;
  }
};",2368
2366,"class Solution {
 public:
  bool validPartition(vector<int>& nums) {
    const int n = nums.size();
    // dp[i] := true if there's a valid partition for the first i numbers
    vector<bool> dp(n + 1);
    dp[0] = true;
    dp[2] = nums[0] == nums[1];

    for (int i = 3; i <= n; ++i)
      dp[i] = (dp[i - 2] && nums[i - 2] == nums[i - 1]) ||
              (dp[i - 3] &&
               ((nums[i - 3] == nums[i - 2] && nums[i - 2] == nums[i - 1]) ||
                (nums[i - 3] + 1 == nums[i - 2] &&
                 nums[i - 2] + 1 == nums[i - 1])));

    return dp[n];
  }
};",2369
2367,"class Solution {
 public:
  int longestIdealString(string s, int k) {
    // dp[i] := the longest subsequence that ends in ('a' + i)
    vector<int> dp(26);

    for (const char c : s) {
      const int i = c - 'a';
      dp[i] = 1 + getMaxReachable(dp, i, k);
    }

    return ranges::max(dp);
  }

 private:
  int getMaxReachable(const vector<int>& dp, int i, int k) {
    const int first = max(0, i - k);
    const int last = min(25, i + k);
    int maxReachable = 0;
    for (int j = first; j <= last; ++j)
      maxReachable = max(maxReachable, dp[j]);
    return maxReachable;
  }
};",2370
2368,"class Solution {
 public:
  vector<vector<int>> minScore(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    vector<array<int, 3>> valAndIndices;
    vector<int> rows(m);  // rows[i] := the maximum used number so far
    vector<int> cols(n);  // cols[j] := the maximum used number so far

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        valAndIndices.push_back({grid[i][j], i, j});

    ranges::sort(valAndIndices);

    for (const auto& [_, i, j] : valAndIndices) {
      const int nextAvailable = max(rows[i], cols[j]) + 1;
      ans[i][j] = nextAvailable;
      rows[i] = nextAvailable;
      cols[j] = nextAvailable;
    }

    return ans;
  }
};",2371
2369,"SELECT
  Salesperson.salesperson_id,
  Salesperson.name,
  SUM(IFNULL(Sales.price, 0)) AS total
FROM Salesperson
LEFT JOIN Customer
  USING (salesperson_id)
LEFT JOIN Sales
  USING (customer_id)
GROUP BY 1;",2372
2370,"class Solution {
 public:
  vector<vector<int>> largestLocal(vector<vector<int>>& grid) {
    const int n = grid.size();
    vector<vector<int>> ans(n - 2, vector<int>(n - 2));

    for (int i = 0; i < n - 2; ++i)
      for (int j = 0; j < n - 2; ++j)
        for (int x = i; x < i + 3; ++x)
          for (int y = j; y < j + 3; ++y)
            ans[i][j] = max(ans[i][j], grid[x][y]);

    return ans;
  }
};",2373
2371,"class Solution {
 public:
  int edgeScore(vector<int>& edges) {
    vector<long long> scores(edges.size());
    for (int i = 0; i < edges.size(); ++i)
      scores[edges[i]] += i;
    return ranges::max_element(scores) - scores.begin();
  }
};",2374
2372,"class Solution {
 public:
  string smallestNumber(string pattern) {
    string ans;
    stack<char> stack{{'1'}};

    for (const char c : pattern) {
      char maxSorFar = stack.top();
      if (c == 'I')
        while (!stack.empty()) {
          maxSorFar = max(maxSorFar, stack.top());
          ans += stack.top(), stack.pop();
        }
      stack.push(maxSorFar + 1);
    }

    while (!stack.empty())
      ans += stack.top(), stack.pop();

    return ans;
  }
};",2375
2373,"class Solution {
 public:
  // Same as 1012. Numbers With Repeated Digits
  int countSpecialNumbers(int n) {
    const int digitSize = log10(n) + 1;
    vector<vector<vector<int>>> mem(
        digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));
    return count(to_string(n), 0, 0, true, mem) - 1;  // - 0;
  }

 private:
  // Returns the number of special integers, considering the i-th digit, where
  // `used` is the bitmask of the used digits, and `isTight` indicates if the
  // current digit is tightly bound.
  int count(const string& s, int i, int used, bool isTight,
            vector<vector<vector<int>>>& mem) {
    if (i == s.length())
      return 1;
    if (mem[i][used][isTight] != -1)
      return mem[i][used][isTight];

    int res = 0;

    const int maxDigit = isTight ? s[i] - '0' : 9;
    for (int d = 0; d <= maxDigit; ++d) {
      // `d` is used.
      if (used >> d & 1)
        continue;
      // Use `d` now.
      const bool nextIsTight = isTight && (d == maxDigit);
      if (used == 0 && d == 0)  // Don't count leading 0s as used.
        res += count(s, i + 1, used, nextIsTight, mem);
      else
        res += count(s, i + 1, used | 1 << d, nextIsTight, mem);
    }

    return mem[i][used][isTight] = res;
  }
};",2376
2374,"SELECT
  country,
  gold_medals,
  silver_medals,
  bronze_medals
FROM Olympic
ORDER BY
  gold_medals DESC,
  silver_medals DESC,
  bronze_medals DESC,
  country;",2377
2375,"class Solution {
 public:
  long long maxScore(vector<vector<int>>& edges) {
    const int n = edges.size();
    vector<vector<pair<int, int>>> graph(n);

    for (int i = 0; i < n; ++i) {
      const int parent = edges[i][0];
      const int weight = edges[i][1];
      if (parent != -1)
        graph[parent].emplace_back(i, weight);
    }

    const auto [takeRoot, notTakeRoot] = dfs(graph, 0);
    return max(takeRoot, notTakeRoot);
  }

 private:
  // Returns (the maximum sum at u if we take one u->v edge,
  //          the maximum sum at u if we don't take any child edge).
  pair<long long, long long> dfs(const vector<vector<pair<int, int>>>& graph,
                                 int u) {
    long long bestEdge = 0;
    long long notTakeU = 0;

    for (const auto& [v, w] : graph[u]) {
      const auto [takeV, notTakeV] = dfs(graph, v);
      bestEdge = max(bestEdge, w + notTakeV - takeV);
      notTakeU += takeV;
    }

    return {bestEdge + notTakeU, notTakeU};
  }
};",2378
2376,"class Solution {
 public:
  int minimumRecolors(string blocks, int k) {
    int countB = 0;
    int maxCountB = 0;

    for (int i = 0; i < blocks.length(); ++i) {
      if (blocks[i] == 'B')
        ++countB;
      if (i >= k && blocks[i - k] == 'B')
        --countB;
      maxCountB = max(maxCountB, countB);
    }

    return k - maxCountB;
  }
};",2379
2377,"class Solution {
 public:
  int secondsToRemoveOccurrences(string s) {
    int ans = 0;
    int zeros = 0;

    for (const char c : s)
      if (c == '0')
        ++zeros;
      else if (zeros > 0)  // c == '1'
        ans = max(ans + 1, zeros);

    return ans;
  }
};",2380
2378,"class Solution {
 public:
  string shiftingLetters(string s, vector<vector<int>>& shifts) {
    int currShift = 0;
    vector<int> timeline(s.length() + 1);

    for (const vector<int>& shift : shifts) {
      const int start = shift[0];
      const int end = shift[1];
      const int direction = shift[2];
      const int diff = direction ? 1 : -1;
      timeline[start] += diff;
      timeline[end + 1] -= diff;
    }

    for (int i = 0; i < s.length(); ++i) {
      currShift = (currShift + timeline[i]) % 26;
      const int num = (s[i] - 'a' + currShift + 26) % 26;
      s[i] = 'a' + num;
    }

    return s;
  }
};",2381
2379,"class Solution {
 public:
  vector<long long> maximumSegmentSum(vector<int>& nums,
                                      vector<int>& removeQueries) {
    const int n = nums.size();
    long long maxSum = 0;
    vector<long long> ans(n);
    // For the segment [l, r], record its sum in sum[l] and sum[r]
    vector<long long> sum(n);
    // For the segment [l, r], record its count in count[l] and count[r]
    vector<int> count(n);

    for (int i = n - 1; i >= 0; --i) {
      ans[i] = maxSum;
      const int j = removeQueries[i];

      // Calculate `segmentSum`.
      const long long leftSum = j > 0 ? sum[j - 1] : 0;
      const long long rightSum = j + 1 < n ? sum[j + 1] : 0;
      const long long segmentSum = nums[j] + leftSum + rightSum;

      // Calculate `segmentCount`.
      const int leftCount = j > 0 ? count[j - 1] : 0;
      const int rightCount = j + 1 < n ? count[j + 1] : 0;
      const int segmentCount = 1 + leftCount + rightCount;

      // Update the sum and count of the segment [l, r].
      const int l = j - leftCount;
      const int r = j + rightCount;
      sum[l] = segmentSum;
      sum[r] = segmentSum;
      count[l] = segmentCount;
      count[r] = segmentCount;
      maxSum = max(maxSum, segmentSum);
    }

    return ans;
  }
};",2382
2380,"class Solution {
 public:
  int minNumberOfHours(int initialEnergy, int initialExperience,
                       vector<int>& energy, vector<int>& experience) {
    return getRequiredEnergy(initialEnergy, energy) +
           getRequiredExperience(initialExperience, experience);
  }

 private:
  int getRequiredEnergy(int initialEnergy, const vector<int>& energy) {
    return max(0,
               accumulate(energy.begin(), energy.end(), 0) + 1 - initialEnergy);
  }

  int getRequiredExperience(int currentExperience,
                            const vector<int>& experience) {
    int requiredExperience = 0;
    for (const int e : experience) {
      if (e >= currentExperience) {
        requiredExperience += e + 1 - currentExperience;
        currentExperience += e + 1 - currentExperience;
      }
      currentExperience += e;
    }
    return requiredExperience;
  }
};",2383
2381,"class Solution {
 public:
  string largestPalindromic(string num) {
    unordered_map<char, int> count;

    for (const char c : num)
      ++count[c];

    const string firstHalf = getFirstHalf(count);
    const string mid = getMid(count);
    const string ans = firstHalf + mid + reversed(firstHalf);
    return ans.empty() ? ""0"" : ans;
  }

 private:
  string getFirstHalf(const unordered_map<char, int>& count) {
    string firstHalf;
    for (char c = '9'; c >= '0'; --c) {
      const auto it = count.find(c);
      if (it == count.cend())
        continue;
      const int freq = it->second;
      firstHalf += string(freq / 2, c);
    }
    const int index = firstHalf.find_first_not_of('0');
    return index == string::npos ? """" : firstHalf.substr(index);
  }

  string getMid(const unordered_map<char, int>& count) {
    for (char c = '9'; c >= '0'; --c) {
      const auto it = count.find(c);
      if (it == count.cend())
        continue;
      const int freq = it->second;
      if (freq & 1)
        return string(1, c);
    }
    return """";
  }

  string reversed(const string& s) {
    return {s.rbegin(), s.rend()};
  }
};",2384
2382,"class Solution {
 public:
  int amountOfTime(TreeNode* root, int start) {
    int ans = -1;
    const unordered_map<int, vector<int>> graph = getGraph(root);
    queue<int> q{{start}};
    unordered_set<int> seen{start};

    for (; !q.empty(); ++ans) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int u = q.front();
        q.pop();
        if (!graph.count(u))
          continue;
        for (const int v : graph.at(u)) {
          if (seen.count(v))
            continue;
          q.push(v);
          seen.insert(v);
        }
      }
    }

    return ans;
  }

 private:
  unordered_map<int, vector<int>> getGraph(TreeNode* root) {
    unordered_map<int, vector<int>> graph;
    queue<pair<TreeNode*, int>> q{{{root, -1}}};  // (node, parent)

    while (!q.empty()) {
      const auto [node, parent] = q.front();
      q.pop();
      if (parent != -1) {
        graph[parent].push_back(node->val);
        graph[node->val].push_back(parent);
      }
      if (node->left)
        q.emplace(node->left, node->val);
      if (node->right)
        q.emplace(node->right, node->val);
    }

    return graph;
  }
};",2385
2383,"class Solution {
 public:
  long long kSum(vector<int>& nums, int k) {
    const long long maxSum = getMaxSum(nums);
    const vector<int> absNums = getAbsNums(nums);
    long long ans = maxSum;
    // (the next maximum sum, the next index i)
    using P = pair<long long, int>;
    priority_queue<P> maxHeap;
    maxHeap.emplace(maxSum - absNums[0], 0);

    for (int j = 0; j < k - 1; ++j) {
      const auto [nextMaxSum, i] = maxHeap.top();
      maxHeap.pop();
      ans = nextMaxSum;
      if (i + 1 < absNums.size()) {
        maxHeap.emplace(nextMaxSum - absNums[i + 1], i + 1);
        maxHeap.emplace(nextMaxSum - absNums[i + 1] + absNums[i], i + 1);
      }
    }

    return ans;
  }

 private:
  long long getMaxSum(const vector<int>& nums) {
    long long maxSum = 0;
    for (const int num : nums)
      if (num > 0)
        maxSum += num;
    return maxSum;
  }

  vector<int> getAbsNums(const vector<int>& nums) {
    vector<int> absNums;
    for (const int num : nums)
      absNums.push_back(abs(num));
    ranges::sort(absNums);
    return absNums;
  }
};",2386
2384,"class Solution {
 public:
  int matrixMedian(vector<vector<int>>& grid) {
    const int noGreaterThanMedianCount = grid.size() * grid[0].size() / 2 + 1;
    int l = 1;
    int r = 1e6;

    while (l < r) {
      const int m = (l + r) / 2;
      if (numsNoGreaterThan(grid, m) >= noGreaterThanMedianCount)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int numsNoGreaterThan(const vector<vector<int>>& grid, int m) {
    int count = 0;
    for (const vector<int>& row : grid)
      count += ranges::upper_bound(row, m) - row.begin();
    return count;
  }
};",2387
2385,"WITH
  CoffeeShoptWithRowNumber AS (
    SELECT *, ROW_NUMBER() OVER() AS `row_number`
    FROM CoffeeShop
  ),
  CoffeeShoptWithRowNumberAndGroupId AS (
    SELECT
      *,
      SUM(drink IS NOT NULL) OVER(
        ORDER BY `row_number`
      ) AS group_id
    FROM CoffeeShoptWithRowNumber
  )
SELECT
  id,
  FIRST_VALUE(drink) OVER(
    PARTITION by group_id
    ORDER BY `row_number`
  ) AS drink
FROM CoffeeShoptWithRowNumberAndGroupId;",2388
2386,"class Solution {
 public:
  vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {
    vector<int> ans;

    ranges::sort(nums);

    for (const int query : queries)
      ans.push_back(numOfElementsLessThan(nums, query));

    return ans;
  }

 private:
  int numOfElementsLessThan(const vector<int>& nums, int query) {
    int sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
      sum += nums[i];
      if (sum > query)
        return i;
    }
    return nums.size();
  }
};",2389
2387,"class Solution {
 public:
  string removeStars(string s) {
    string ans;
    for (const char c : s)
      if (c == '*')
        ans.pop_back();
      else
        ans.push_back(c);
    return ans;
  }
};",2390
2388,"class Solution {
 public:
  int garbageCollection(vector<string>& garbage, vector<int>& travel) {
    vector<int> prefix(travel.size());
    partial_sum(travel.begin(), travel.end(), prefix.begin());
    const int timeM = getTime(garbage, prefix, 'M');
    const int timeP = getTime(garbage, prefix, 'P');
    const int timeG = getTime(garbage, prefix, 'G');
    return timeM + timeP + timeG;
  }

 private:
  int getTime(const vector<string>& garbage, const vector<int>& prefix,
              char c) {
    int characterCount = 0;
    int lastIndex = -1;
    for (int i = 0; i < garbage.size(); ++i) {
      const string& s = garbage[i];
      if (ranges::any_of(s, [c](const char g) { return g == c; }))
        lastIndex = i;
      characterCount += std::ranges::count(s, c);
    }
    return characterCount + (lastIndex <= 0 ? 0 : prefix[lastIndex - 1]);
  }
};",2391
2389,"class Solution {
 public:
  vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions,
                                  vector<vector<int>>& colConditions) {
    const vector<int> rowOrder = topologicalSort(rowConditions, k);
    if (rowOrder.empty())
      return {};

    const vector<int> colOrder = topologicalSort(colConditions, k);
    if (colOrder.empty())
      return {};

    vector<vector<int>> ans(k, vector<int>(k));
    vector<int> nodeToRowIndex(k + 1);

    for (int i = 0; i < k; ++i)
      nodeToRowIndex[rowOrder[i]] = i;

    for (int j = 0; j < k; ++j) {
      const int node = colOrder[j];
      const int i = nodeToRowIndex[node];
      ans[i][j] = node;
    }

    return ans;
  }

 private:
  vector<int> topologicalSort(const vector<vector<int>>& conditions, int n) {
    vector<int> order;
    vector<vector<int>> graph(n + 1);
    vector<int> inDegrees(n + 1);
    queue<int> q;

    // Build the graph.
    for (const vector<int>& condition : conditions) {
      const int u = condition[0];
      const int v = condition[1];
      graph[u].push_back(v);
      ++inDegrees[v];
    }

    // Perform topological sorting.
    for (int i = 1; i <= n; ++i)
      if (inDegrees[i] == 0)
        q.push(i);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      order.push_back(u);
      for (const int v : graph[u])
        if (--inDegrees[v] == 0)
          q.push(v);
    }

    return order.size() == n ? order : vector<int>();
  }
};",2392
2390,"class Solution {
 public:
  long long countSubarrays(vector<int>& nums) {
    long long ans = 0;

    for (int i = 0, j = -1; i < nums.size(); ++i) {
      if (i > 0 && nums[i] <= nums[i - 1])
        j = i - 1;
      ans += i - j;
    }

    return ans;
  }
};",2393
2391,"SELECT Employees.employee_id
FROM Employees
LEFT JOIN Logs
  USING (employee_id)
GROUP BY Employees.employee_id, Employees.needed_hours
HAVING (
    SUM(
      CEIL(
        IFNULL(
          TIMESTAMPDIFF(SECOND, LOGS.in_time, LOGS.out_time),
          0
        ) / 60
      )
    ) / 60
  ) < Employees.needed_hours;",2394
2392,"class Solution {
 public:
  bool findSubarrays(vector<int>& nums) {
    unordered_set<int> seen;

    for (int i = 1; i < nums.size(); ++i)
      if (!seen.insert(nums[i - 1] + nums[i]).second)
        return true;

    return false;
  }
};",2395
2393,"class Solution {
 public:
  bool isStrictlyPalindromic(int n) {
    return false;
  }
};",2396
2394,"class Solution {
 public:
  int maximumRows(vector<vector<int>>& matrix, int numSelect) {
    int ans = 0;
    dfs(matrix, /*colIndex=*/0, numSelect, /*mask=*/0, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& matrix, int colIndex, int leftColsCount,
           int mask, int& ans) {
    if (leftColsCount == 0) {
      ans = max(ans, getAllZerosRowCount(matrix, mask));
      return;
    }
    if (colIndex == matrix[0].size())
      return;

    // Choose this column.
    dfs(matrix, colIndex + 1, leftColsCount - 1, mask | 1 << colIndex, ans);
    // Don't choose this column.
    dfs(matrix, colIndex + 1, leftColsCount, mask, ans);
  }

  int getAllZerosRowCount(const vector<vector<int>>& matrix, int mask) {
    int count = 0;
    for (const vector<int>& row : matrix) {
      bool isAllZeros = true;
      for (int i = 0; i < row.size(); ++i) {
        if (row[i] == 1 && (mask >> i & 1) == 0) {
          isAllZeros = false;
          break;
        }
      }
      if (isAllZeros)
        ++count;
    }
    return count;
  }
};",2397
2395,"class Solution {
 public:
  int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts,
                    long long budget) {
    long long cost = 0;
    deque<int> maxQ;  // Stores `chargeTimes[i]`.

    int j = 0;  // window's range := [i..j], so k = i - j + 1
    for (int i = 0; i < chargeTimes.size(); ++i) {
      cost += runningCosts[i];
      while (!maxQ.empty() && maxQ.back() < chargeTimes[i])
        maxQ.pop_back();
      maxQ.push_back(chargeTimes[i]);
      if (maxQ.front() + (i - j + 1) * cost > budget) {
        if (maxQ.front() == chargeTimes[j])
          maxQ.pop_front();
        cost -= runningCosts[j++];
      }
    }

    return chargeTimes.size() - j;
  }
};",2398
2396,"class Solution {
 public:
  bool checkDistances(string s, vector<int>& distance) {
    vector<int> firstSeenIndex(26, -1);

    for (int i = 0; i < s.length(); ++i) {
      const int j = s[i] - 'a';
      int& prevIndex = firstSeenIndex[j];
      if (prevIndex != -1 && i - prevIndex - 1 != distance[j])
        return false;
      prevIndex = i;
    }

    return true;
  }
};",2399
2397,"class Solution {
 public:
  int numberOfWays(int startPos, int endPos, int k) {
    // leftStep + rightStep = k
    // rightStep - leftStep = endPos - startPos
    //        2 * rightStep = k + endPos - startPos
    //            rightStep = (k + endPos - startPos) / 2
    const int val = k + endPos - startPos;
    if (val < 0 || val & 1)
      return 0;
    const int rightStep = val / 2;
    const int leftStep = k - rightStep;
    if (leftStep < 0)
      return 0;
    return nCk(leftStep + rightStep, min(leftStep, rightStep));
  }

 private:
  // C(n, k) = C(n - 1, k) + C(n - 1, k - 1)
  int nCk(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := C(n so far, i)
    vector<int> dp(k + 1);
    dp[0] = 1;

    while (n-- > 0)  // Calculate n times.
      for (int j = k; j > 0; --j) {
        dp[j] += dp[j - 1];
        dp[j] %= kMod;
      }

    return dp[k];
  }
};",2400
2398,"class Solution {
 public:
  int longestNiceSubarray(vector<int>& nums) {
    int ans = 0;
    int used = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (used & nums[r])
        used ^= nums[l++];
      used |= nums[r];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",2401
2399,"struct T {
  long endTime;
  int roomId;
};

class Solution {
 public:
  int mostBooked(int n, vector<vector<int>>& meetings) {
    vector<int> count(n);

    ranges::sort(meetings);

    auto compare = [](const T& a, const T& b) {
      return a.endTime == b.endTime ? a.roomId > b.roomId
                                    : a.endTime > b.endTime;
    };
    priority_queue<T, vector<T>, decltype(compare)> occupied(compare);
    priority_queue<int, vector<int>, greater<>> availableRoomIds;

    for (int i = 0; i < n; ++i)
      availableRoomIds.push(i);

    for (const vector<int>& meeting : meetings) {
      const int start = meeting[0];
      const int end = meeting[1];
      // Push meetings ending before this `meeting` in occupied to the
      // `availableRoomsIds`.
      while (!occupied.empty() && occupied.top().endTime <= start)
        availableRoomIds.push(occupied.top().roomId), occupied.pop();
      if (availableRoomIds.empty()) {
        const auto [newStart, roomId] = occupied.top();
        occupied.pop();
        ++count[roomId];
        occupied.push({newStart + (end - start), roomId});
      } else {
        const int roomId = availableRoomIds.top();
        availableRoomIds.pop();
        ++count[roomId];
        occupied.push({end, roomId});
      }
    }

    return ranges::max_element(count) - count.begin();
  }
};",2402
2400,"class Solution {
 public:
  long long minimumTime(vector<int>& power) {
    const int n = power.size();
    const int maxMask = 1 << n;
    // dp[i] := the minimum number of days needed to defeat the monsters, where
    // i is the bitmask of the monsters
    vector<long> dp(maxMask, LONG_MAX);
    dp[0] = 0;

    for (int mask = 1; mask < maxMask; ++mask) {
      const int currentGain = __builtin_popcount(mask);
      for (int i = 0; i < n; ++i)
        if (mask >> i & 1)
          dp[mask] =
              min(dp[mask],
                  dp[mask & ~(1 << i)] +
                      static_cast<int>(ceil(power[i] * 1.0 / currentGain)));
    }

    return dp.back();
  }
};",2403
2401,"class Solution {
 public:
  int mostFrequentEven(vector<int>& nums) {
    int ans = -1;
    unordered_map<int, int> count;

    for (const int num : nums) {
      if (num & 1)
        continue;
      const int newCount = ++count[num];
      const int maxCount = count[ans];
      if (newCount > maxCount || newCount == maxCount && num < ans)
        ans = num;
    }

    return ans;
  }
};",2404
2402,"class Solution {
 public:
  int partitionString(string s) {
    int ans = 1;
    int used = 0;

    for (const char c : s) {
      const int i = c - 'a';
      if (used >> i & 1) {
        used = 1 << i;
        ++ans;
      } else {
        used |= 1 << i;
      }
    }

    return ans;
  }
};",2405
2403,"class Solution {
 public:
  // Similar to 253. Meeting Rooms II
  int minGroups(vector<vector<int>>& intervals) {
    // Stores `right`s.
    priority_queue<int, vector<int>, greater<>> minHeap;

    ranges::sort(intervals);

    for (const vector<int>& interval : intervals) {
      if (!minHeap.empty() && interval[0] > minHeap.top())
        minHeap.pop();  // There is no overlaps, so we can reuse the same group.
      minHeap.push(interval[1]);
    }

    return minHeap.size();
  }
};",2406
2404,"struct SegmentTreeNode {
  int lo;
  int hi;
  int maxLength;
  unique_ptr<SegmentTreeNode> left;
  unique_ptr<SegmentTreeNode> right;
  // maxLength := the maximum length of LIS ending in [lo..hi]
  SegmentTreeNode(int lo, int hi, int maxLength,
                  unique_ptr<SegmentTreeNode> left = nullptr,
                  unique_ptr<SegmentTreeNode> right = nullptr)
      : lo(lo),
        hi(hi),
        maxLength(maxLength),
        left(move(left)),
        right(move(right)) {}
};

class SegmentTree {
 public:
  explicit SegmentTree() : root(make_unique<SegmentTreeNode>(0, 1e5 + 1, 0)) {}

  void updateRange(int i, int j, int maxLength) {
    update(root, i, j, maxLength);
  }

  // queryRange(i, j) := the maximum length of LIS ending in [i..j]
  int queryRange(int i, int j) {
    return query(root, i, j);
  }

 private:
  std::unique_ptr<SegmentTreeNode> root;

  void update(unique_ptr<SegmentTreeNode>& root, int i, int j, int maxLength) {
    if (root->lo == i && root->hi == j) {
      root->maxLength = maxLength;
      root->left = nullptr;
      root->right = nullptr;
      return;
    }
    const int mid = root->lo + (root->hi - root->lo) / 2;
    if (root->left == nullptr) {
      root->left = make_unique<SegmentTreeNode>(root->lo, mid, root->maxLength);
      root->right =
          make_unique<SegmentTreeNode>(mid + 1, root->hi, root->maxLength);
    }
    if (j <= mid)
      update(root->left, i, j, maxLength);
    else if (i > mid)
      update(root->right, i, j, maxLength);
    else {
      update(root->left, i, mid, maxLength);
      update(root->right, mid + 1, j, maxLength);
    }
    root->maxLength = max(root->left->maxLength, root->right->maxLength);
  }

  int query(unique_ptr<SegmentTreeNode>& root, int i, int j) {
    if (root->left == nullptr)
      return root->maxLength;
    if (root->lo == i && root->hi == j)
      return root->maxLength;
    const int mid = root->lo + (root->hi - root->lo) / 2;
    if (j <= mid)
      return query(root->left, i, j);
    if (i > mid)
      return query(root->right, i, j);
    return max(query(root->left, i, mid), query(root->right, mid + 1, j));
  }
};

class Solution {
 public:
  int lengthOfLIS(vector<int>& nums, int k) {
    int ans = 1;
    SegmentTree tree;

    for (const int num : nums) {
      const int left = max(1, num - k);
      const int right = num - 1;
      // the maximum length of LIS ending in [left..right] + the current number
      const int maxLength = tree.queryRange(left, right) + 1;
      ans = std::max(ans, maxLength);
      tree.updateRange(num, num, maxLength);
    }

    return ans;
  }
};",2407
2405,"insertRow(name: str, row: List[str])",2408
2406,"class Solution {
 public:
  int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob,
                        string leaveBob) {
    const int arriveA = toDays(arriveAlice);
    const int leaveA = toDays(leaveAlice);
    const int arriveB = toDays(arriveBob);
    const int leaveB = toDays(leaveBob);
    int ans = 0;

    for (int day = 1; day <= 365; ++day)
      if (arriveA <= day && day <= leaveA && arriveB <= day && day <= leaveB)
        ++ans;

    return ans;
  }

 private:
  const vector<int> days{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

  int toDays(const string& s) {
    const int month = (s[0] - '0') * 10 + (s[1] - '0');
    const int day = (s[3] - '0') * 10 + (s[4] - '0');
    int prevDays = 0;
    for (int m = 1; m < month; ++m)
      prevDays += days[m];
    return prevDays + day;
  }
};",2409
2407,"class Solution {
 public:
  int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {
    int ans = 0;

    ranges::sort(players);
    ranges::sort(trainers);

    for (int i = 0; i < trainers.size(); ++i)
      if (players[ans] <= trainers[i] && ++ans == players.size())
        return ans;

    return ans;
  }
};",2410
2408,"class Solution {
 public:
  vector<int> smallestSubarrays(vector<int>& nums) {
    constexpr int kMaxBit = 30;
    vector<int> ans(nums.size(), 1);
    // closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1
    vector<int> closest(kMaxBit);

    for (int i = nums.size() - 1; i >= 0; --i)
      for (int j = 0; j < kMaxBit; ++j) {
        if (nums[i] >> j & 1)
          closest[j] = i;
        ans[i] = max(ans[i], closest[j] - i + 1);
      }

    return ans;
  }
};",2411
2409,"class Solution {
 public:
  long long minimumMoney(vector<vector<int>>& transactions) {
    long long ans = 0;
    long long losses = 0;

    // Before picking the final transaction, perform any transaction that raises
    // the required money.
    for (const vector<int>& t : transactions) {
      const int cost = t[0];
      const int cashback = t[1];
      losses += max(0, cost - cashback);
    }

    // Now, pick a transaction to be the final one.
    for (const vector<int>& t : transactions) {
      const int cost = t[0];
      const int cashback = t[1];
      if (cost > cashback)
        // The losses except this transaction: losses - (cost - cashback), so
        // add the cost of this transaction = losses - (cost - cashback) + cost.
        ans = max(ans, losses + cashback);
      else
        // The losses except this transaction: losses, so add the cost of this
        // transaction = losses + cost.
        ans = max(ans, losses + cost);
    }

    return ans;
  }
};",2412
2410,"class Solution {
 public:
  int smallestEvenMultiple(int n) {
    return n * (n % 2 + 1);
  }
};",2413
2411,"class Solution {
 public:
  int longestContinuousSubstring(string s) {
    int ans = 1;
    int runningLen = 1;

    for (int i = 1; i < s.length(); ++i)
      if (s[i] == s[i - 1] + 1)
        ans = max(ans, ++runningLen);
      else
        runningLen = 1;

    return ans;
  }
};",2414
2412,"class Solution {
 public:
  TreeNode* reverseOddLevels(TreeNode* root) {
    dfs(root->left, root->right, true);
    return root;
  }

 private:
  void dfs(TreeNode* left, TreeNode* right, bool isOddLevel) {
    if (left == nullptr)
      return;
    if (isOddLevel)
      swap(left->val, right->val);
    dfs(left->left, right->right, !isOddLevel);
    dfs(left->right, right->left, !isOddLevel);
  }
};",2415
2413,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<int> sumPrefixScores(vector<string>& words) {
    vector<int> ans;

    for (const string& word : words)
      insert(word);

    for (const string& word : words)
      ans.push_back(getScore(word));

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      ++node->count;
    }
  }

  int getScore(const string& word) {
    shared_ptr<TrieNode> node = root;
    int score = 0;
    for (const char c : word) {
      node = node->children[c - 'a'];
      score += node->count;
    }
    return score;
  }
};",2416
2414,"class Solution {
 public:
  int closestFair(int n) {
    const int digitsCount = to_string(n).length();
    return (digitsCount & 1) ? getOddDigits(digitsCount) : getEvenDigits(n);
  }

 private:
  long getOddDigits(int digitsCount) {
    const int zeros = (digitsCount + 1) / 2;
    const int ones = (digitsCount - 1) / 2;
    return stoi('1' + string(zeros, '0') + string(ones, '1'));
  }

  int getEvenDigits(int n) {
    const int digitsCount = to_string(n).length();
    const long maxNum = stol('1' + string(digitsCount, '0'));
    for (long num = n; num < maxNum; ++num)
      if (isValidNum(num))
        return num;
    return getOddDigits(digitsCount + 1);
  }

  bool isValidNum(long num) {
    int count = 0;
    for (const char c : to_string(num))
      count += (c - '0' & 1) ? -1 : 1;
    return count == 0;
  }
};",2417
2415,"class Solution {
 public:
  vector<string> sortPeople(vector<string>& names, vector<int>& heights) {
    vector<string> ans;
    vector<pair<int, string>> heightAndNames;

    for (int i = 0; i < names.size(); ++i)
      heightAndNames.emplace_back(heights[i], names[i]);

    ranges::sort(heightAndNames, greater<>());

    for (const auto& [_, name] : heightAndNames)
      ans.push_back(name);

    return ans;
  }
};",2418
2416,"class Solution {
 public:
  int longestSubarray(vector<int>& nums) {
    int ans = 0;
    int maxIndex = 0;
    int sameNumLength = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == nums[maxIndex]) {
        ans = max(ans, ++sameNumLength);
      } else if (nums[i] > nums[maxIndex]) {
        maxIndex = i;
        sameNumLength = 1;
        ans = 1;
      } else {
        sameNumLength = 0;
      }

    return ans;
  }
};",2419
2417,"class Solution {
 public:
  // Same as 2100. Find Good Days to Rob the Bank
  vector<int> goodIndices(vector<int>& nums, int k) {
    const int n = nums.size();
    vector<int> ans;
    // dec[i] := 1 + the number of continuous decreasing numbers before i
    vector<int> dec(n, 1);
    // inc[i] := 1 + the number of continuous increasing numbers after i
    vector<int> inc(n, 1);

    for (int i = 1; i < n; ++i)
      if (nums[i - 1] >= nums[i])
        dec[i] = dec[i - 1] + 1;

    for (int i = n - 2; i >= 0; --i)
      if (nums[i] <= nums[i + 1])
        inc[i] = inc[i + 1] + 1;

    for (int i = k; i < n - k; ++i)
      if (dec[i - 1] >= k && inc[i + 1] >= k)
        ans.push_back(i);

    return ans;
  }
};",2420
2418,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
    const int n = vals.size();
    int ans = n;
    UnionFind uf(n);
    vector<vector<int>> tree(n);
    map<int, vector<int>> valToNodes;

    for (int i = 0; i < vals.size(); ++i)
      valToNodes[vals[i]].push_back(i);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      if (vals[v] <= vals[u])
        tree[u].push_back(v);
      if (vals[u] <= vals[v])
        tree[v].push_back(u);
    }

    for (const auto& [val, nodes] : valToNodes) {
      for (const int u : nodes)
        for (const int v : tree[u])
          uf.unionByRank(u, v);
      unordered_map<int, int> rootCount;
      for (const int u : nodes)
        ++rootCount[uf.find(u)];
      // For each group, C(count, 2) := count * (count - 1) / 2
      for (const auto& [_, count] : rootCount)
        ans += count * (count - 1) / 2;
    }

    return ans;
  }
};",2421
2419,"class Solution {
 public:
  int minimumOperations(vector<int>& nums) {
    int ans = 0;
    int l = 0;
    int r = nums.size() - 1;
    long leftSum = nums.front();
    long rightSum = nums.back();

    while (l < r)
      if (leftSum < rightSum) {
        leftSum += nums[++l];
        ++ans;
      } else if (leftSum > rightSum) {
        rightSum += nums[--r];
        ++ans;
      } else {  // leftSum == rightSum
        leftSum = nums[++l];
        rightSum = nums[--r];
      }

    return ans;
  }
};",2422
2420,"class Solution {
 public:
  bool equalFrequency(string word) {
    vector<int> count(26);

    for (const char c : word)
      ++count[c - 'a'];

    // Try to remove each letter, then check if the frequency of all the letters
    // in `word` are equal.
    for (const char c : word) {
      --count[c - 'a'];
      if (equalFreq(count))
        return true;
      ++count[c - 'a'];
    }

    return false;
  }

 private:
  bool equalFreq(const vector<int>& count) {
    int theFreq = -1;
    for (const int freq : count) {
      if (freq == 0 || freq == theFreq)
        continue;
      if (theFreq == -1)
        theFreq = freq;
      else
        return false;
    }
    return true;
  }
};",2423
2421,upload(video: int),2424
2422,"class Solution {
 public:
  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {
    // If the size of nums1 is m and the size of nums2 is n, then each number in
    // nums1 is repeated n times and each number in nums2 is repeated m times.
    const int xors1 = accumulate(nums1.begin(), nums1.end(), 0, bit_xor<>());
    const int xors2 = accumulate(nums2.begin(), nums2.end(), 0, bit_xor<>());
    return (nums1.size() % 2 * xors2) ^ (nums2.size() % 2 * xors1);
  }
};",2425
2423,"class Solution {
 public:
  long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {
    // nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff
    // nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff
    // Define A[i] := nums1[i] - nums2[i] -> A[i] <= A[j] + diff
    vector<int> A;

    for (int i = 0; i < nums1.size(); ++i)
      A.push_back(nums1[i] - nums2[i]);

    long long ans = 0;
    mergeSort(A, 0, A.size() - 1, diff, ans);
    return ans;
  }

 private:
  void mergeSort(vector<int>& A, int l, int r, int diff, long long& ans) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(A, l, m, diff, ans);
    mergeSort(A, m + 1, r, diff, ans);
    merge(A, l, m, r, diff, ans);
  }

  void merge(vector<int>& A, int l, int m, int r, int diff, long long& ans) {
    const int lo = m + 1;
    int hi = m + 1;  // the first index s.t. A[i] <= A[hi] + diff

    // For each index i in the range [l, m], add `r - hi + 1` to `ans`.
    for (int i = l; i <= m; ++i) {
      while (hi <= r && A[i] > A[hi] + diff)
        ++hi;
      ans += r - hi + 1;
    }

    vector<int> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (A[i] < A[j])
        sorted[k++] = A[i++];
      else
        sorted[k++] = A[j++];

    // Put the possible remaining left part into the sorted array.
    while (i <= m)
      sorted[k++] = A[i++];

    // Put the possible remaining right part into the sorted array.
    while (j <= r)
      sorted[k++] = A[j++];

    copy(sorted.begin(), sorted.end(), A.begin() + l);
  }
};",2426
2424,"class Solution {
 public:
  int commonFactors(int a, int b) {
    int ans = 1;
    const int gcd = __gcd(a, b);
    for (int i = 2; i <= gcd; ++i)
      if (a % i == 0 && b % i == 0)
        ++ans;
    return ans;
  }
};",2427
2425,"class Solution {
 public:
  int maxSum(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 1; i + 1 < grid.size(); ++i)
      for (int j = 1; j + 1 < grid[0].size(); ++j)
        ans =
            max(ans, grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] +
                         grid[i][j] + grid[i + 1][j - 1] + grid[i + 1][j] +
                         grid[i + 1][j + 1]);

    return ans;
  }
};",2428
2426,"class Solution {
 public:
  int minimizeXor(int num1, int num2) {
    constexpr int kMaxBit = 30;
    int bits = __builtin_popcount(num2);
    // Can turn off all the bits in `num1`.
    if (__builtin_popcount(num1) == bits)
      return num1;

    int ans = 0;

    // Turn off the MSB if we have `bits` quota.
    for (int i = kMaxBit; i >= 0; --i)
      if (num1 >> i & 1) {
        ans |= 1 << i;
        if (--bits == 0)
          return ans;
      }

    // Turn on the LSB if we still have `bits`.
    for (int i = 0; i < kMaxBit; ++i)
      if ((num1 >> i & 1) == 0) {
        ans |= 1 << i;
        if (--bits == 0)
          return ans;
      }

    return ans;
  }
};",2429
2427,"class Solution {
 public:
  int deleteString(string s) {
    const int n = s.length();
    // lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)
    vector<vector<int>> lcs(n + 1, vector<int>(n + 1));
    // dp[i] := the maximum number of operations needed to delete s[i..n)
    vector<int> dp(n, 1);

    for (int i = n - 1; i >= 0; --i)
      for (int j = i + 1; j < n; ++j) {
        if (s[i] == s[j])
          lcs[i][j] = lcs[i + 1][j + 1] + 1;
        if (lcs[i][j] >= j - i)
          dp[i] = max(dp[i], dp[j] + 1);
      }

    return dp[0];
  }
};",2430
2428,"class Solution {
 public:
  int maxTastiness(vector<int>& price, vector<int>& tastiness, int maxAmount,
                   int maxCoupons) {
    const int n = price.size();
    // dp[i][j][k] := the maximum tastiness of first i price with j amount of
    // money and k coupons
    vector<vector<vector<int>>> dp(
        n + 1, vector<vector<int>>(maxAmount + 1, vector<int>(maxCoupons + 1)));

    for (int i = 1; i <= n; ++i) {
      // 1-indexed
      const int currPrice = price[i - 1];
      const int currTastiness = tastiness[i - 1];
      for (int amount = 0; amount <= maxAmount; ++amount) {
        for (int coupon = 0; coupon <= maxCoupons; ++coupon) {
          // Case 1: Don't buy, the tastiness will be the same as the first i -
          // 1 price.
          dp[i][amount][coupon] = dp[i - 1][amount][coupon];

          // Case 2: Buy without coupon if have enough money.
          if (amount >= currPrice)
            dp[i][amount][coupon] =
                max(dp[i][amount][coupon],
                    dp[i - 1][amount - currPrice][coupon] + currTastiness);

          // Case 3: Buy with coupon if have coupon and enough money.
          if (coupon > 0 && amount >= currPrice / 2)
            dp[i][amount][coupon] = max(
                dp[i][amount][coupon],
                dp[i - 1][amount - currPrice / 2][coupon - 1] + currTastiness);
        }
      }
    }

    return dp[n][maxAmount][maxCoupons];
  }
};",2431
2429,"class Solution {
 public:
  int hardestWorker(int n, vector<vector<int>>& logs) {
    int ans = logs[0][0];
    int maxWorkingTime = logs[0][1];

    for (int i = 1; i < logs.size(); ++i) {
      const int id = logs[i][0];
      const int workingTime = logs[i][1] - logs[i - 1][1];
      if (workingTime > maxWorkingTime) {
        ans = id;
        maxWorkingTime = workingTime;
      } else if (workingTime == maxWorkingTime) {
        ans = min(ans, id);
      }
    }

    return ans;
  }
};",2432
2430,"class Solution {
 public:
  vector<int> findArray(vector<int>& pref) {
    vector<int> ans(pref.size());

    ans[0] = pref[0];
    for (int i = 1; i < ans.size(); ++i)
      ans[i] = pref[i] ^ pref[i - 1];

    return ans;
  }
};",2433
2431,"class Solution {
 public:
  string robotWithString(string s) {
    string ans;
    vector<int> count(26);
    stack<char> stack;

    for (const char c : s)
      ++count[c - 'a'];

    for (const char c : s) {
      stack.push(c);
      --count[c - 'a'];
      const char minChar = getMinChar(count);
      while (!stack.empty() && stack.top() <= minChar)
        ans += stack.top(), stack.pop();
    }

    while (!stack.empty())
      ans += stack.top(), stack.pop();

    return ans;
  }

 private:
  char getMinChar(const vector<int>& count) {
    for (int i = 0; i < 26; ++i)
      if (count[i])
        return 'a' + i;
    return 'a';
  }
};",2434
2432,"class Solution {
 public:
  int numberOfPaths(vector<vector<int>>& grid, int k) {
    vector<vector<vector<int>>> mem(
        grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k, -1)));
    return numberOfPaths(grid, 0, 0, 0, k, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of paths to (i, j), where the sum / k == `sum`.
  int numberOfPaths(const vector<vector<int>>& grid, int i, int j, int sum,
                    int k, vector<vector<vector<int>>>& mem) {
    if (i == grid.size() || j == grid[0].size())
      return 0;
    if (i == grid.size() - 1 && j == grid[0].size() - 1)
      return (sum + grid[i][j]) % k == 0;
    if (mem[i][j][sum] != -1)
      return mem[i][j][sum];
    const int newSum = (sum + grid[i][j]) % k;
    return mem[i][j][sum] = (numberOfPaths(grid, i + 1, j, newSum, k, mem) +
                             numberOfPaths(grid, i, j + 1, newSum, k, mem)) %
                            kMod;
  }
};",2435
2433,"class Solution {
 public:
  int minimumSplits(vector<int>& nums) {
    int ans = 1;
    int gcd = nums[0];

    for (const int num : nums) {
      const int newGcd = __gcd(gcd, num);
      if (newGcd > 1) {
        gcd = newGcd;
      } else {
        gcd = num;
        ++ans;
      }
    }

    return ans;
  }
};",2436
2434,"class Solution {
 public:
  int countTime(string time) {
    int ans = 1;
    if (time[3] == '?')
      ans *= 6;
    if (time[4] == '?')
      ans *= 10;

    if (time[0] == '?' && time[1] == '?')
      return ans * 24;
    if (time[0] == '?')
      return time[1] < '4' ? ans * 3 : ans * 2;
    if (time[1] == '?')
      return time[0] == '2' ? ans * 4 : ans * 10;
    return ans;
  }
};",2437
2435,"class Solution {
 public:
  vector<int> productQueries(int n, vector<vector<int>>& queries) {
    constexpr int kMod = 1'000'000'007;
    constexpr int kMaxBit = 30;
    vector<int> ans;
    vector<int> powers;

    for (int i = 0; i < kMaxBit; ++i)
      if (n >> i & 1)
        powers.push_back(1 << i);

    for (const vector<int>& query : queries) {
      const int left = query[0];
      const int right = query[1];
      long prod = 1;
      for (int i = left; i <= right; ++i) {
        prod *= powers[i];
        prod %= kMod;
      }
      ans.push_back(prod);
    }

    return ans;
  }
};",2438
2436,"class Solution {
 public:
  int minimizeArrayValue(vector<int>& nums) {
    long ans = 0;
    long prefix = 0;

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      const long prefixAvg = ceil(prefix / static_cast<double>(i + 1));
      ans = max(ans, prefixAvg);
    }

    return ans;
  }
};",2439
2437,"class Solution {
 public:
  int componentValue(vector<int>& nums, vector<vector<int>>& edges) {
    const int n = nums.size();
    const int sum = accumulate(nums.begin(), nums.end(), 0);
    vector<vector<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    for (int i = n; i > 1; --i)
      // Split the tree into i parts, i.e. delete (i - 1) edges.
      if (sum % i == 0 && dfs(nums, tree, 0, sum / i, vector<bool>(n)) == 0)
        return i - 1;

    return 0;
  }

 private:
  static constexpr int kMax = 1'000'000'000;

  // Returns the sum of the subtree rooted at u substracting the sum of the
  // deleted subtrees.
  int dfs(const vector<int>& nums, const vector<vector<int>>& tree, int u,
          int target, vector<bool>&& seen) {
    int sum = nums[u];
    seen[u] = true;

    for (const int v : tree[u]) {
      if (seen[v])
        continue;
      sum += dfs(nums, tree, v, target, move(seen));
      if (sum > target)
        return kMax;
    }

    // Delete the tree that has sum == target.
    if (sum == target)
      return 0;
    return sum;
  }
};",2440
2438,"class Solution {
 public:
  int findMaxK(vector<int>& nums) {
    int ans = -1;
    unordered_set<int> seen;

    for (const int num : nums)
      if (seen.count(-num))
        ans = max(ans, abs(num));
      else
        seen.insert(num);

    return ans;
  }
};",2441
2439,"class Solution {
 public:
  int countDistinctIntegers(vector<int>& nums) {
    unordered_set<int> numsSet{nums.begin(), nums.end()};

    for (const int num : nums)
      numsSet.insert(reversed(num));

    return numsSet.size();
  }

 private:
  int reversed(int num) {
    int ans = 0;
    while (num > 0) {
      ans = ans * 10 + num % 10;
      num /= 10;
    }
    return ans;
  }
};",2442
2440,"class Solution {
 public:
  bool sumOfNumberAndReverse(int num) {
    for (int i = num / 2; i <= num; ++i)
      if (num == i + reversed(i))
        return true;
    return false;
  }

 private:
  int reversed(int num) {
    int ans = 0;
    while (num > 0) {
      ans = ans * 10 + num % 10;
      num /= 10;
    }
    return ans;
  }
};",2443
2441,"class Solution {
 public:
  long long countSubarrays(vector<int>& nums, int minK, int maxK) {
    long long ans = 0;
    int j = -1;
    int prevMinKIndex = -1;
    int prevMaxKIndex = -1;

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] < minK || nums[i] > maxK)
        j = i;
      if (nums[i] == minK)
        prevMinKIndex = i;
      if (nums[i] == maxK)
        prevMaxKIndex = i;
      // Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the
      // start of the subarray s.t. nums[k..i] satisfies the conditions.
      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j);
    }

    return ans;
  }
};",2444
2442,"class Solution {
 public:
  int numberOfNodes(int n, vector<int>& queries) {
    // flipped[i] := true if we should flip all the values in the subtree rooted
    // at i
    vector<bool> flipped(n + 1);

    for (const int query : queries)
      flipped[query] = flipped[query] ^ true;

    return dfs(1, 0, n, flipped);
  }

 private:
  int dfs(int label, int value, int n, const vector<bool>& flipped) {
    if (label > n)
      return 0;
    value ^= flipped[label];
    return value +  //
           dfs(label * 2, value, n, flipped) +
           dfs(label * 2 + 1, value, n, flipped);
  }
};",2445
2443,"class Solution {
 public:
  bool haveConflict(vector<string>& event1, vector<string>& event2) {
    return event1[0] <= event2[1] && event2[0] <= event1[1];
  }
};",2446
2444,"class Solution {
 public:
  int subarrayGCD(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> gcds;

    for (const int num : nums)
      if (num % k == 0) {
        unordered_map<int, int> nextGcds{{num, 1}};
        for (const auto& [prevGcd, count] : gcds)
          nextGcds[gcd(prevGcd, num)] += count;
        ans += nextGcds[k];
        gcds = move(nextGcds);
      } else {
        // The GCD streak stops, so fresh start from the next number.
        gcds.clear();
      }

    return ans;
  }
};",2447
2445,"class Solution {
 public:
  long long minCost(vector<int>& nums, vector<int>& cost) {
    long long ans = 0;
    int l = ranges::min(nums);
    int r = ranges::max(nums);

    while (l < r) {
      const int m = (l + r) / 2;
      const long long cost1 = getCost(nums, cost, m);
      const long long cost2 = getCost(nums, cost, m + 1);
      ans = min(cost1, cost2);
      if (cost1 < cost2)
        r = m;
      else
        l = m + 1;
    }

    return ans;
  }

 private:
  long long getCost(const vector<int>& nums, const vector<int>& cost,
                    int target) {
    long long res = 0;
    for (int i = 0; i < nums.size(); ++i)
      res += abs(nums[i] - target) * static_cast<long long>(cost[i]);
    return res;
  }
};",2448
2446,"class Solution {
 public:
  long long makeSimilar(vector<int>& nums, vector<int>& target) {
    long long ans = 0;
    vector<vector<int>> A(2);  // A[0] := even nums, A[1] := odd nums
    vector<vector<int>> B(2);  // B[0] := even target, B[1] := odd nums

    for (const int num : nums)
      A[num % 2].push_back(num);

    for (const int num : target)
      B[num % 2].push_back(num);

    ranges::sort(A[0]);
    ranges::sort(A[1]);
    ranges::sort(B[0]);
    ranges::sort(B[1]);

    for (int i = 0; i < 2; ++i)
      for (int j = 0; j < A[i].size(); ++j)
        ans += abs(A[i][j] - B[i][j]) / 2;

    return ans / 2;
  }
};",2449
2447,"class Solution {
 public:
  int countDistinctStrings(string s, int k) {
    // Since the content of `s` doesn't matter, for each i in [0, n - k], we can
    // flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.
    return modPow(2, s.length() - k + 1);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2450
2448,"class Solution {
 public:
  string oddString(vector<string>& words) {
    const vector<pair<string, string>> wordAndDiffStrs =
        getWordAndDiffStrs(words);
    unordered_map<string, int> diffStrCount;

    for (const auto& [_, diffStr] : wordAndDiffStrs)
      ++diffStrCount[diffStr];

    for (const auto& [word, diffStr] : wordAndDiffStrs)
      if (diffStrCount[diffStr] == 1)
        return word;

    throw;
  }

 private:
  // Returns the pairs of the word and its corresponding difference string.
  // e.g. [(""adc"", ""3#-1#""), (""wzy"", ""3#-1#""), (""abc"", ""1#1#"")]
  vector<pair<string, string>> getWordAndDiffStrs(const vector<string>& words) {
    vector<pair<string, string>> wordAndDiffStrs;
    for (const string& word : words)
      wordAndDiffStrs.emplace_back(word, getDiffStr(word));
    return wordAndDiffStrs;
  }

  // Returns the difference string of `s`.
  // e.g. getDiffStr(""adc"") -> ""3#-1#""
  string getDiffStr(const string& s) {
    string diffStr;
    for (int i = 1; i < s.length(); ++i)
      diffStr += to_string(s[i] - s[i - 1]) + ""#"";
    return diffStr;
  }
};",2451
2449,"class Solution {
 public:
  vector<string> twoEditWords(vector<string>& queries,
                              vector<string>& dictionary) {
    vector<string> ans;

    for (const string& query : queries)
      for (const string& word : dictionary)
        if (inner_product(query.begin(), query.end(), word.begin(), 0, plus<>(),
                          not_equal_to<char>()) < 3) {
          ans.push_back(q);
          break;
        }

    return ans;
  }
};",2452
2450,"class Solution {
 public:
  int destroyTargets(vector<int>& nums, int space) {
    int ans = INT_MAX;
    int maxCount = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      maxCount = max(maxCount, ++count[num % space]);

    for (const int num : nums)
      if (count[num % space] == maxCount)
        ans = min(ans, num);

    return ans;
  }
};",2453
2451,"class Solution {
 public:
  vector<int> secondGreaterElement(vector<int>& nums) {
    vector<int> ans(nums.size(), -1);
    // a decreasing stack that stores indices that met the first greater number
    stack<int> prevStack;
    // a decreasing stack that stores indices
    stack<int> currStack;

    for (int i = 0; i < nums.size(); ++i) {
      // Indices in `prevStack` meet the second greater number.
      while (!prevStack.empty() && nums[prevStack.top()] < nums[i])
        ans[prevStack.top()] = nums[i], prevStack.pop();
      // Push indices that meet the first greater number from `currStack` to
      // `prevStack`. We need a temporary array to make the indices in the
      // `prevStack` increasing.
      stack<int> decreasingIndices;
      while (!currStack.empty() && nums[currStack.top()] < nums[i])
        decreasingIndices.push(currStack.top()), currStack.pop();
      while (!decreasingIndices.empty())
        prevStack.push(decreasingIndices.top()), decreasingIndices.pop();
      currStack.push(i);
    }

    return ans;
  }
};",2454
2452,"class Solution {
 public:
  int averageValue(vector<int>& nums) {
    int sum = 0;
    int count = 0;

    for (const int num : nums)
      if (num % 6 == 0) {
        sum += num;
        ++count;
      }

    return count == 0 ? 0 : sum / count;
  }
};",2455
2453,"struct Creator {
  long popularity;  // the popularity sum
  string videoId;   // the video id that has the maximum view
  int maxView;      // the maximum view of the creator
};

class Solution {
 public:
  vector<vector<string>> mostPopularCreator(vector<string>& creators,
                                            vector<string>& ids,
                                            vector<int>& views) {
    vector<vector<string>> ans;
    unordered_map<string, Creator> nameToCreator;
    long maxPopularity = 0;

    for (int i = 0; i < creators.size(); ++i) {
      if (!nameToCreator.count(creators[i])) {
        nameToCreator[creators[i]] = Creator{
            .popularity = views[i],
            .videoId = ids[i],
            .maxView = views[i],
        };
        maxPopularity = max(maxPopularity, static_cast<long>(views[i]));
        continue;
      }
      Creator& creator = nameToCreator[creators[i]];
      creator.popularity += views[i];
      maxPopularity = max(maxPopularity, static_cast<long>(creator.popularity));
      if (creator.maxView < views[i] ||
          creator.maxView == views[i] && creator.videoId > ids[i]) {
        creator.videoId = ids[i];
        creator.maxView = views[i];
      }
    }

    for (const auto& [name, creator] : nameToCreator)
      if (creator.popularity == maxPopularity)
        ans.push_back({name, creator.videoId});

    return ans;
  }
};",2456
2454,"class Solution {
 public:
  long long makeIntegerBeautiful(long long n, int target) {
    long long ans = 0;
    long power = 1;

    // e.g. n = 123. After tunning off the last bit by adding 7, n = 130.
    // Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.
    while (sum(n) > target) {
      // the cost to turn off the last digit
      ans += power * (10 - n % 10);
      n = n / 10 + 1;
      power *= 10;
    }

    return ans;
  }

 private:
  int sum(long long n) {
    int res = 0;
    while (n > 0) {
      res += n % 10;
      n /= 10;
    }
    return res;
  }
};",2457
2455,"class Solution {
 public:
  vector<int> treeQueries(TreeNode* root, vector<int>& queries) {
    vector<int> ans;

    dfs(root, 0, 0);

    for (const int query : queries)
      ans.push_back(valToMaxHeight[query]);

    return ans;
  }

 private:
  // valToMaxHeight[val] := the maximum height without the node with `val`
  unordered_map<int, int> valToMaxHeight;
  // valToHeight[val] := the height of the node with `val`
  unordered_map<int, int> valToHeight;

  int height(TreeNode* root) {
    if (root == nullptr)
      return 0;
    if (const auto it = valToHeight.find(root->val); it != valToHeight.cend())
      return it->second;
    return valToHeight[root->val] =
               (1 + max(height(root->left), height(root->right)));
  }

  // maxHeight := the maximum height without the current node `root`
  void dfs(TreeNode* root, int depth, int maxHeight) {
    if (root == nullptr)
      return;
    valToMaxHeight[root->val] = maxHeight;
    dfs(root->left, depth + 1, max(maxHeight, depth + height(root->right)));
    dfs(root->right, depth + 1, max(maxHeight, depth + height(root->left)));
  }
};",2458
2456,"class Solution:
  def sortArray(self, nums: List[int]) -> int:
    n = len(nums)
    numToIndex = [0] * n

    for i, num in enumerate(nums):
      numToIndex[num] = i

    def minOps(numToIndex: List[int], zeroInBeginning: bool) -> int:
      ops = 0
      num = 1
      # If zeroInBeginning, the correct index of each num is num.
      # If not zeroInBeginning, the correct index of each num is num - 1.
      offset = 0 if zeroInBeginning else 1
      while num < n:
        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.
        if zeroInBeginning and numToIndex[0] == 0 or \
                not zeroInBeginning and numToIndex[0] == n - 1:
          while numToIndex[num] == num - offset:  # num is in correct position
            num += 1
            if num == n:
              return ops
          numInWrongIndex = num
        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not
        # in nums[2] because nums[2] == 0.
        else:
          numInWrongIndex = numToIndex[0] + offset
        numToIndex[0], numToIndex[numInWrongIndex] = \
            numToIndex[numInWrongIndex], numToIndex[0]
        ops += 1

    return min(minOps(numToIndex.copy(), True),
               minOps(numToIndex.copy(), False))",2459
2457,"class Solution {
 public:
  vector<int> applyOperations(vector<int>& nums) {
    vector<int> ans(nums.size());

    for (int i = 0; i + 1 < nums.size(); ++i)
      if (nums[i] == nums[i + 1]) {
        nums[i] *= 2;
        nums[i + 1] = 0;
      }

    int i = 0;
    for (const int num : nums)
      if (num > 0)
        ans[i++] = num;

    return ans;
  }
};",2460
2458,"class Solution {
 public:
  long long maximumSubarraySum(vector<int>& nums, int k) {
    long long ans = 0;
    long long sum = 0;
    int distinct = 0;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i) {
      sum += nums[i];
      if (++count[nums[i]] == 1)
        ++distinct;
      if (i >= k) {
        if (--count[nums[i - k]] == 0)
          --distinct;
        sum -= nums[i - k];
      }
      if (i >= k - 1 && distinct == k)
        ans = max(ans, sum);
    }

    return ans;
  }
};",2461
2459,"class Solution {
 public:
  long long totalCost(vector<int>& costs, int k, int candidates) {
    long long ans = 0;
    int i = 0;
    int j = costs.size() - 1;
    priority_queue<int, vector<int>, greater<>> minHeapL;
    priority_queue<int, vector<int>, greater<>> minHeapR;

    for (int hired = 0; hired < k; ++hired) {
      while (minHeapL.size() < candidates && i <= j)
        minHeapL.push(costs[i++]);
      while (minHeapR.size() < candidates && i <= j)
        minHeapR.push(costs[j--]);
      if (minHeapL.empty())
        ans += minHeapR.top(), minHeapR.pop();
      else if (minHeapR.empty())
        ans += minHeapL.top(), minHeapL.pop();
      // Both `minHeapL` and `minHeapR` are not empty.
      else if (minHeapL.top() <= minHeapR.top())
        ans += minHeapL.top(), minHeapL.pop();
      else
        ans += minHeapR.top(), minHeapR.pop();
    }

    return ans;
  }
};",2462
2460,"class Solution {
 public:
  long long minimumTotalDistance(vector<int>& robot,
                                 vector<vector<int>>& factory) {
    ranges::sort(robot);
    ranges::sort(factory);
    vector<vector<vector<long long>>> mem(
        robot.size(), vector<vector<long long>>(
                          factory.size(), vector<long long>(robot.size())));
    return minimumTotalDistance(robot, factory, 0, 0, 0, mem);
  }

 private:
  // Returns the minimum distance to fix robot[i..n) with factory[j..n), where
  // factory[j] already fixed k robots.
  long long minimumTotalDistance(const vector<int>& robot,
                                 const vector<vector<int>>& factory, int i,
                                 int j, int k,
                                 vector<vector<vector<long long>>>& mem) {
    if (i == robot.size())
      return 0;
    if (j == factory.size())
      return LLONG_MAX;
    if (mem[i][j][k] > 0)
      return mem[i][j][k];
    const long long skipFactory =
        minimumTotalDistance(robot, factory, i, j + 1, 0, mem);
    const int position = factory[j][0];
    const int limit = factory[j][1];
    const long long useFactory =
        limit > k ? minimumTotalDistance(robot, factory, i + 1, j, k + 1, mem) +
                        abs(robot[i] - position)
                  : LLONG_MAX / 2;
    return mem[i][j][k] = min(skipFactory, useFactory);
  }
};",2463
2461,"class Solution {
 public:
  int validSubarraySplit(vector<int>& nums) {
    constexpr int kMax = INT_MAX / 2;
    // dp[i] := the minimum number of subarrays to validly split nums[0..i]
    vector<int> dp(nums.size(), kMax);

    for (int i = 0; i < nums.size(); ++i)
      for (int j = 0; j <= i; ++j)
        if (__gcd(nums[j], nums[i]) > 1)
          dp[i] = min(dp[i], j == 0 ? 1 : dp[j - 1] + 1);

    return dp.back() == kMax ? -1 : dp.back();
  }
};",2464
2462,"class Solution {
 public:
  int distinctAverages(vector<int>& nums) {
    const int n = nums.size();
    unordered_set<int> sums;

    ranges::sort(nums);

    for (int i = 0; i < n / 2; ++i)
      sums.insert(nums[i] + nums[n - 1 - i]);

    return sums.size();
  }
};",2465
2463,"class Solution {
 public:
  int countGoodStrings(int low, int high, int zero, int one) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    // dp[i] := the number of good strings with length i
    vector<int> dp(high + 1);
    dp[0] = 1;

    for (int i = 1; i <= high; ++i) {
      if (i >= zero)
        dp[i] = (dp[i] + dp[i - zero]) % kMod;
      if (i >= one)
        dp[i] = (dp[i] + dp[i - one]) % kMod;
      if (i >= low)
        ans = (ans + dp[i]) % kMod;
    }

    return ans;
  }
};",2466
2464,"class Solution {
 public:
  int mostProfitablePath(vector<vector<int>>& edges, int bob,
                         vector<int>& amount) {
    const int n = amount.size();
    vector<vector<int>> tree(n);
    vector<int> parent(n);
    vector<int> aliceDist(n, -1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, -1, 0, parent, aliceDist);

    // Modify the amount along the path from node Bob to node 0.
    // For each node,
    //   1. If Bob reaches earlier than Alice does, change the amount to 0.
    //   2. If Bob and Alice reach simultaneously, devide the amount by 2.
    for (int u = bob, bobDist = 0; u != 0; u = parent[u], ++bobDist)
      if (bobDist < aliceDist[u])
        amount[u] = 0;
      else if (bobDist == aliceDist[u])
        amount[u] /= 2;

    return getMoney(tree, 0, -1, amount);
  }

 private:
  // Fills `parent` and `dist`.
  void dfs(const vector<vector<int>>& tree, int u, int prev, int d,
           vector<int>& parent, vector<int>& dist) {
    parent[u] = prev;
    dist[u] = d;
    for (const int v : tree[u]) {
      if (dist[v] == -1)
        dfs(tree, v, u, d + 1, parent, dist);
    }
  }

  int getMoney(const vector<vector<int>>& tree, int u, int prev,
               const vector<int>& amount) {
    // a leaf node
    if (tree[u].size() == 1 && tree[u][0] == prev)
      return amount[u];

    int maxPath = INT_MIN;
    for (const int v : tree[u])
      if (v != prev)
        maxPath = max(maxPath, getMoney(tree, v, u, amount));

    return amount[u] + maxPath;
  }
};",2467
2465,"class Solution {
 public:
  vector<string> splitMessage(string message, int limit) {
    const int kMessageLength = message.length();
    int b = 1;
    // the total length of a: initialized with the length of ""1""
    int aLength = sz(1);

    // the total length of b := b * sz(b)
    // The total length of ""</>"" := b * 3
    while (b * limit < b * (sz(b) + 3) + aLength + kMessageLength) {
      // If the length of the last suffix ""<b/b>"" := sz(b) * 2 + 3 >= limit,
      // then it's impossible that the length of ""*<b/b>"" <= limit.
      if (sz(b) * 2 + 3 >= limit)
        return {};
      aLength += sz(++b);
    }

    vector<string> ans;

    for (int i = 0, a = 1; a <= b; ++a) {
      // the length of ""<a/b>"" := sz(a) + sz(b) + 3
      const int j = limit - (sz(a) + sz(b) + 3);
      ans.push_back(message.substr(i, j) + ""<"" + to_string(a) + ""/"" +
                    to_string(b) + "">"");
      i += j;
    }

    return ans;
  }

 private:
  int sz(int num) {
    return to_string(num).length();
  }
};",2468
2466,"class Solution {
 public:
  vector<double> convertTemperature(double celsius) {
    return {celsius + 273.15, celsius * 1.8 + 32};
  }
};",2469
2467,"class Solution {
 public:
  int subarrayLCM(vector<int>& nums, int k) {
    int ans = 0;

    for (int i = 0; i < nums.size(); ++i) {
      int runningLcm = nums[i];
      for (int j = i; j < nums.size(); ++j) {
        runningLcm = std::lcm(runningLcm, nums[j]);
        if (runningLcm > k)
          break;
        if (runningLcm == k)
          ++ans;
      }
    }

    return ans;
  }
};",2470
2468,"class Solution {
 public:
  int minimumOperations(TreeNode* root) {
    int ans = 0;
    queue<TreeNode*> q{{root}};

    // e.g. vals = [7, 6, 8, 5]
    // [2, 1, 3, 0]: Initialize the ids based on the order of vals.
    // [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).
    // [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.
    while (!q.empty()) {
      vector<int> vals;
      vector<int> ids(q.size());
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        vals.push_back(node->val);
        if (node->left != nullptr)
          q.push(node->left);
        if (node->right != nullptr)
          q.push(node->right);
      }
      iota(ids.begin(), ids.end(), 0);
      ranges::sort(ids, [&vals](int i, int j) { return vals[i] < vals[j]; });
      for (int i = 0; i < ids.size(); ++i)
        for (; ids[i] != i; ++ans)
          swap(ids[i], ids[ids[i]]);
    }

    return ans;
  }
};",2471
2469,"class Solution {
 public:
  int maxPalindromes(string s, int k) {
    const int n = s.length();
    // dp[i] := the maximum number of substrings in the first i chars of s
    vector<int> dp(n + 1);

    // If a palindrome is a substring of another palindrome, then considering
    // the longer palindrome won't increase the number of non-overlapping
    // palindromes. So, we only need to consider the shorter one. Also,
    // considering palindromes with both k length and k + 1 length ensures that
    // we look for both even and odd length palindromes.
    for (int i = k; i <= n; ++i) {
      dp[i] = dp[i - 1];
      // Consider palindrome with length k.
      if (isPalindrome(s, i - k, i - 1))
        dp[i] = max(dp[i], 1 + dp[i - k]);
      // Consider palindrome with length k + 1.
      if (isPalindrome(s, i - k - 1, i - 1))
        dp[i] = max(dp[i], 1 + dp[i - k - 1]);
    }

    return dp[n];
  }

 private:
  // Returns true is s[i..j) is a palindrome.
  bool isPalindrome(const string& s, int l, int r) {
    if (l < 0)
      return false;
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};",2472
2470,"class Solution {
 public:
  vector<long long> minCost(int n, vector<vector<int>>& roads,
                            vector<int>& appleCost, int k) {
    vector<long long> ans;
    vector<vector<pair<int, long long>>> graph(n);

    for (const vector<int>& road : roads) {
      const int u = road[0] - 1;
      const int v = road[1] - 1;
      const int w = road[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    for (int i = 0; i < n; ++i)
      ans.push_back(dijkstra(graph, i, appleCost, k));

    return ans;
  }

 private:
  long long dijkstra(const vector<vector<pair<int, long long>>>& graph, int i,
                     const vector<int>& appleCost, int k) {
    vector<long long> forwardCost(graph.size(), LLONG_MAX);
    vector<long long> totalCost(graph.size(), LLONG_MAX);
    forwardCost[i] = 0;
    queue<int> q{{i}};

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const auto& [v, w] : graph[u]) {
        const long long nextCost = forwardCost[u] + w;
        if (nextCost >= forwardCost[v])
          continue;
        forwardCost[v] = nextCost;
        // Take apple at city v and return back to city i.
        totalCost[v] = (k + 1) * nextCost + appleCost[v];
        q.push(v);
      }
    }

    return min(static_cast<long long>(appleCost[i]), ranges::min(totalCost));
  }
};",2473
2471,"WITH
  YearlyOrders AS (
    SELECT
      customer_id,
      YEAR(order_date) AS year,
      SUM(price) AS price
    FROM Orders
    GROUP BY 1, 2
  )
SELECT CurrYear.customer_id
FROM YearlyOrders AS CurrYear
LEFT JOIN YearlyOrders AS NextYear
  ON (
    CurrYear.customer_id = NextYear.customer_id
    AND CurrYear.year + 1 = NextYear.year
    AND CurrYear.price < NextYear.price)
GROUP BY 1
HAVING COUNT(*) - COUNT(NextYear.customer_id) = 1;",2474
2472,"// Assume that we have 4 kinds of numbers a, b, c, and d in the count map.
//
// What we want is:
//   cnt[a] * cnt[b] * cnt[c]
//   cnt[a] * cnt[b] * cnt[d]
//   cnt[a] * cnt[c] * cnt[d]
//   cnt[b] * cnt[c] * cnt[d]
//
// The above combinations can be reduced as:
//
// prev                       | curr   | next
// ----------------------------------------------------------------
// (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])
// (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])
// (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])
// (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)

class Solution {
 public:
  int unequalTriplets(vector<int>& nums) {
    int ans = 0;
    int prev = 0;
    int next = nums.size();
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [_, freq] : count) {
      next -= freq;
      ans += prev * freq * next;
      prev += freq;
    }

    return ans;
  }
};",2475
2473,"class Solution {
 public:
  vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
    vector<vector<int>> ans;
    vector<int> sortedVals;

    inorder(root, sortedVals);

    for (const int query : queries) {
      const auto it = ranges::lower_bound(sortedVals, query);
      // query is presented in the tree, so just use {query, query}.
      if (it != sortedVals.cend() && *it == query)
        ans.push_back({query, query});
      // query isn't presented in the tree, so find the cloest one if possible.
      else
        ans.push_back({it == sortedVals.cbegin() ? -1 : *prev(it),
                       it == sortedVals.cend() ? -1 : *it});
    }

    return ans;
  }

 private:
  // Walks the BST to collect the sorted numbers.
  void inorder(TreeNode* root, vector<int>& sortedVals) {
    if (root == nullptr)
      return;
    inorder(root->left, sortedVals);
    sortedVals.push_back(root->val);
    inorder(root->right, sortedVals);
  }
};",2476
2474,"class Solution {
 public:
  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
    long long ans = 0;
    vector<vector<int>> tree(roads.size() + 1);

    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, -1, seats, ans);
    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& tree, int u, int prev, int seats,
          long long& ans) {
    int people = 1;
    for (const int v : tree[u]) {
      if (v == prev)
        continue;
      people += dfs(tree, v, u, seats, ans);
    }
    if (u > 0)
      // the number of cars needed = ceil(people / seats)
      ans += (people + seats - 1) / seats;
    return people;
  }
};",2477
2475,"class Solution {
 public:
  int beautifulPartitions(string s, int k, int minLength) {
    if (!isPrime(s.front()) || isPrime(s.back()))
      return 0;
    vector<vector<int>> mem(s.length(), vector<int>(k, -1));
    return beautifulPartitions(s, minLength, k - 1, minLength, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of beautiful partitions of s[i..n) with k bars (|) left.
  int beautifulPartitions(const string& s, int i, int k, int minLength,
                          vector<vector<int>>& mem) {
    if (i <= s.length() && k == 0)
      return 1;
    if (i >= s.length())
      return 0;
    if (mem[i][k] != -1)
      return mem[i][k];

    // Don't split between s[i - 1] and s[i].
    int res = beautifulPartitions(s, i + 1, k, minLength, mem) % kMod;

    // Split between s[i - 1] and s[i].
    if (isPrime(s[i]) && !isPrime(s[i - 1]))
      res += beautifulPartitions(s, i + minLength, k - 1, minLength, mem);

    return mem[i][k] = res % kMod;
  }

  bool isPrime(char c) {
    return c == '2' || c == '3' || c == '5' || c == '7';
  }
};",2478
2476,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  TrieNode() : children(2) {}
};

class BitTrie {
 public:
  BitTrie(int maxBit) : maxBit(maxBit) {}

  void insert(long long num) {
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
    }
  }

  long long getMaxXor(long long num) {
    long long maxXor = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = num >> i & 1;
      const int toggleBit = bit ^ 1;
      if (node->children[toggleBit] != nullptr) {
        maxXor = maxXor | 1LL << i;
        node = node->children[toggleBit];
      } else if (node->children[bit] != nullptr) {
        node = node->children[bit];
      } else {  // There's nothing in the Bit Trie.
        return 0;
      }
    }
    return maxXor;
  }

 private:
  const int maxBit;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  long long maxXor(int n, vector<vector<int>>& edges, vector<int>& values) {
    long long ans = 0;
    vector<vector<int>> tree(n);
    vector<long long> treeSums(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    getTreeSum(tree, 0, -1, treeSums, values);
    const long long maxSubTreeSum =
        *max_element(treeSums.begin() + 1, treeSums.end());
    const int maxBit = static_cast<int>(log2(maxSubTreeSum));
    // Similar to 421. Maximum XOR of Two Numbers in an Array
    dfs(tree, 0, -1, treeSums, BitTrie(maxBit), ans);
    return ans;
  }

 private:
  // Gets the tree sum rooted at node u.
  long long getTreeSum(const vector<vector<int>>& tree, int u, int prev,
                       vector<long long>& treeSums, const vector<int>& values) {
    long long treeSum = values[u];
    for (const int v : tree[u]) {
      if (v == prev)
        continue;
      treeSum += getTreeSum(tree, v, u, treeSums, values);
    }
    treeSums[u] = treeSum;
    return treeSum;
  }

  void dfs(const vector<vector<int>>& tree, int u, int prev,
           const vector<long long>& treeSums, BitTrie&& bitTrie,
           long long& ans) {
    for (const int v : tree[u]) {
      if (v == prev)
        continue;
      // Preorder to get the ans.
      ans = max(ans, bitTrie.getMaxXor(treeSums[v]));
      // Recursively call on the subtree rooted at node v.
      dfs(tree, v, u, treeSums, move(bitTrie), ans);
      // Postorder insert the tree sum rooted at node v.
      bitTrie.insert(treeSums[v]);
    }
  }
};",2479
2477,"SELECT
  A.symbol AS metal,
  B.symbol AS nonmetal
FROM Elements AS A, Elements AS B
WHERE
  A.type = 'Metal'
  AND B.type = 'Nonmetal'",2480
2478,"class Solution {
 public:
  int numberOfCuts(int n) {
    if (n == 1)
      return 0;
    return n & 1 ? n : n / 2;
  }
};",2481
2479,"class Solution {
 public:
  vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    vector<int> onesRow;
    vector<int> onesCol;

    for (const vector<int>& row : grid)
      onesRow.push_back(ranges::count(row, 1));

    for (int j = 0; j < n; ++j) {
      int ones = 0;
      for (int i = 0; i < m; ++i)
        ones += grid[i][j];
      onesCol.push_back(ones);
    }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans[i][j] =
            onesRow[i] + onesCol[j] - (n - onesRow[i]) - (m - onesCol[j]);

    return ans;
  }
};",2482
2480,"class Solution {
 public:
  int bestClosingTime(string customers) {
    // Instead of computing the minimum penalty, we can compute the maximum
    // profit.
    int ans = 0;
    int profit = 0;
    int maxProfit = 0;

    for (int i = 0; i < customers.length(); ++i) {
      profit += customers[i] == 'Y' ? 1 : -1;
      if (profit > maxProfit) {
        maxProfit = profit;
        ans = i + 1;
      }
    }

    return ans;
  }
};",2483
2481,"class Solution {
 public:
  int countPalindromes(string s) {
    constexpr int kMod = 1'000'000'007;
    constexpr int kPatternSize = 5;
    long ans = 0;

    for (char a = '0'; a <= '9'; ++a)
      for (char b = '0'; b <= '9'; ++b) {
        const vector<char> pattern{a, b, '.', b, a};
        // dp[i] := the number of subsequences of pattern[i..n) in s, where
        // pattern[2] can be any character
        vector<long> dp(kPatternSize + 1);
        dp.back() = 1;
        for (const char c : s)
          for (int i = 0; i < kPatternSize; ++i)
            if (pattern[i] == '.' || pattern[i] == c)
              dp[i] += dp[i + 1];
        ans += dp[0];
        ans %= kMod;
      }

    return ans;
  }
};",2484
2482,"class Solution {
 public:
  int pivotInteger(int n) {
    // 1 + 2 + ... + x = x + ... + n
    // (1 + x) * x / 2 = (x + n) * (n - x + 1) / 2
    //         x + x^2 = nx - x^2 + x + n^2 - nx + n
    //         2 * x^2 = n^2 + n
    //               x = sqrt((n^2 + n) / 2)
    const int y = (n * n + n) / 2;
    const int x = sqrt(y);
    return x * x == y ? x : -1;
  }
};",2485
2483,"class Solution {
 public:
  int appendCharacters(string s, string t) {
    int i = 0;  // t's index

    for (const char c : s)
      if (c == t[i])
        if (++i == t.length())
          return 0;

    return t.length() - i;
  }
};",2486
2484,"class Solution {
 public:
  ListNode* removeNodes(ListNode* head) {
    if (head == nullptr)
      return nullptr;
    head->next = removeNodes(head->next);
    return head->next != nullptr && head->val < head->next->val ? head->next
                                                                : head;
  }
};",2487
2485,"class Solution {
 public:
  int countSubarrays(vector<int>& nums, int k) {
    const int kIndex = find(nums.begin(), nums.end(), k) - nums.begin();
    int ans = 0;
    unordered_map<int, int> count;

    for (int i = kIndex, balance = 0; i >= 0; --i) {
      if (nums[i] < k)
        --balance;
      else if (nums[i] > k)
        ++balance;
      ++count[balance];
    }

    for (int i = kIndex, balance = 0; i < nums.size(); ++i) {
      if (nums[i] < k)
        --balance;
      else if (nums[i] > k)
        ++balance;
      // The subarray that has balance == 0 or 1 having median equal to k.
      // So, add count[0 - balance] and count[1 - balance] to `ans`.
      ans += count[-balance] + count[1 - balance];
    }

    return ans;
  }
};",2488
2486,"class Solution {
 public:
  long long fixedRatio(string s, int num1, int num2) {
    // Let x := the number of 0s and y := the number of 1s in the subarray.
    // We want x : y = num1 : num2, so our goal is to find number of subarrays
    // with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count
    // map to record the count of the running x * num2 - y * num1. If the
    // running x * num2 - y * num1 = prefix, then add count[prefix] to the
    // `ans`.
    long long ans = 0;
    long long prefix = 0;
    unordered_map<long long, int> prefixCount{{0, 1}};

    for (const char c : s) {
      if (c == '0')
        prefix += num2;
      else  // c == '1'
        prefix -= num1;
      ans += prefixCount[prefix];
      ++prefixCount[prefix];
    }

    return ans;
  }
};",2489
2487,"class Solution {
 public:
  bool isCircularSentence(string sentence) {
    for (int i = 0; i < sentence.length(); ++i)
      if (sentence[i] == ' ' && sentence[i - 1] != sentence[i + 1])
        return false;
    return sentence.front() == sentence.back();
  }
};",2490
2488,"class Solution {
 public:
  long long dividePlayers(vector<int>& skill) {
    const int n = skill.size();
    const int teamSkill = accumulate(skill.begin(), skill.end(), 0) / (n / 2);
    long long ans = 0;
    unordered_map<int, int> count;

    for (const int s : skill)
      ++count[s];

    for (const auto& [s, freq] : count) {
      const int requiredSkill = teamSkill - s;
      if (const auto it = count.find(requiredSkill);
          it == count.cend() || it->second != freq)
        return -1;
      ans += static_cast<long long>(s) * requiredSkill * freq;
    }

    return ans / 2;
  }
};",2491
2489,"class Solution {
 public:
  int minScore(int n, vector<vector<int>>& roads) {
    int ans = INT_MAX;
    vector<vector<pair<int, int>>> graph(n);  // graph[u] := [(v, distance)]
    queue<int> q{{0}};
    vector<bool> seen(n);
    seen[0] = true;

    for (const vector<int>& r : roads) {
      const int u = r[0] - 1;
      const int v = r[1] - 1;
      const int distance = r[2];
      graph[u].emplace_back(v, distance);
      graph[v].emplace_back(u, distance);
    }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const auto& [v, d] : graph[u]) {
        ans = min(ans, d);
        if (seen[v])
          continue;
        q.push(v);
        seen[v] = true;
      }
    }

    return ans;
  }
};",2492
2490,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
    } else if (rank[i] > rank[j]) {
      id[j] = i;
    } else {
      id[i] = j;
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int magnificentSets(int n, vector<vector<int>>& edges) {
    vector<vector<int>> graph(n);
    UnionFind uf(n);
    unordered_map<int, int> rootToGroupSize;

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      graph[u].push_back(v);
      graph[v].push_back(u);
      uf.unionByRank(u, v);
    }

    for (int i = 0; i < n; ++i) {
      const int newGroupSize = bfs(graph, i);
      if (newGroupSize == -1)
        return -1;
      const int root = uf.find(i);
      auto& groupSize = rootToGroupSize[root];
      groupSize = max(groupSize, newGroupSize);
    }

    int ans = 0;
    for (const auto& [_, groupSize] : rootToGroupSize)
      ans += groupSize;

    return ans;
  }

 private:
  int bfs(const vector<vector<int>>& graph, int u) {
    int step = 0;
    queue<int> q{{u}};
    unordered_map<int, int> nodeToStep{{u, 1}};

    while (!q.empty()) {
      ++step;
      for (int sz = q.size(); sz > 0; --sz) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u]) {
          if (!nodeToStep.count(v)) {
            q.push(v);
            nodeToStep[v] = step + 1;
          } else if (nodeToStep[v] == step) {
            // There is an odd number of edges in the cycle.
            return -1;
          }
        }
      }
    }

    return step;
  }
};",2493
2491,"WITH
  HallEventsWithIsNewEvent AS (
    SELECT
      hall_id,
      start_day,
      end_day,
      IFNULL(
        start_day > MAX(end_day) OVER(
          PARTITION BY hall_id
          ORDER BY start_day,
            end_day DESC ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ),
        1
      ) AS is_new_event
    FROM HallEvents
  ),
  HallEventsWithGroupId AS (
    SELECT
      hall_id,
      start_day,
      end_day,
      SUM(is_new_event) OVER(
        PARTITION BY hall_id
        ORDER BY start_day, end_day DESC
      ) AS group_id
    FROM HallEventsWithIsNewEvent
  )
SELECT
  hall_id,
  MIN(start_day) AS start_day,
  MAX(end_day) AS end_day
FROM HallEventsWithGroupId
GROUP BY hall_id, group_id;",2494
2492,"class Solution {
 public:
  long long evenProduct(vector<int>& nums) {
    long long ans = 0;
    int numsBeforeEven = 0;  // inclusively

    // e.g. nums = [1, 0, 1, 1, 0].
    // After meeting the first 0, set `numsBeforeEven` to 2. So, the number
    // between index 1 to index 3 (the one before next 0) will contribute 2 to
    // `ans`.
    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] % 2 == 0)
        numsBeforeEven = i + 1;
      ans += numsBeforeEven;
    }

    return ans;
  }
};",2495
2493,"class Solution {
 public:
  int maximumValue(vector<string>& strs) {
    int ans = 0;
    for (const string& s : strs)
      ans = max(ans, ranges::any_of(s, [](char c) { return isalpha(c); })
                         ? static_cast<int>(s.length())
                         : stoi(s));
    return ans;
  }
};",2496
2494,"class Solution {
 public:
  int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {
    const int n = vals.size();
    int ans = INT_MIN;
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, vals[v]);
      graph[v].emplace_back(u, vals[u]);
    }

    for (int i = 0; i < n; ++i) {
      priority_queue<int> maxHeap;
      for (const auto& [_, val] : graph[i])
        if (val > 0)
          maxHeap.push(val);
      int starSum = vals[i];
      for (int j = 0; j < k && !maxHeap.empty(); ++j)
        starSum += maxHeap.top(), maxHeap.pop();
      ans = max(ans, starSum);
    }

    return ans;
  }
};",2497
2495,"class Solution {
 public:
  int maxJump(vector<int>& stones) {
    // Let's denote the forwarding path as F and the backwarding path as B.
    // ""F1 B2 B1 F2"" is no better than ""F1 B2 F2 B1"" since the distance between
    // F1 and F2 increase, resulting a larger `ans`.
    int ans = stones[1] - stones[0];  // If there're only two stones.
    for (int i = 2; i < stones.size(); ++i)
      ans = max(ans, stones[i] - stones[i - 2]);
    return ans;
  }
};",2498
2496,"class Solution {
 public:
  long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
    const int n = nums1.size();
    long long ans = 0;
    int maxFreq = 0;
    int maxFreqNum = 0;
    int shouldBeSwapped = 0;
    vector<int> conflictedNumCount(n + 1);

    // Collect the indices i s.t. nums1[i] == nums2[i] and record their
    // `maxFreq` and `maxFreqNum`.
    for (int i = 0; i < n; ++i)
      if (nums1[i] == nums2[i]) {
        const int conflictedNum = nums1[i];
        if (++conflictedNumCount[conflictedNum] > maxFreq) {
          maxFreq = conflictedNumCount[conflictedNum];
          maxFreqNum = conflictedNum;
        }
        ++shouldBeSwapped;
        ans += i;
      }

    // Collect the indices with nums1[i] != nums2[i] that contribute less cost.
    // This can be greedily achieved by iterating from 0 to n - 1.
    for (int i = 0; i < n; ++i) {
      // Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be
      // successfully distributed, so no need to collectextra spaces.
      if (maxFreq * 2 <= shouldBeSwapped)
        break;
      if (nums1[i] == nums2[i])
        continue;
      // The numbers == `maxFreqNum` worsen the result since they increase the
      // `maxFreq`.
      if (nums1[i] == maxFreqNum || nums2[i] == maxFreqNum)
        continue;
      ++shouldBeSwapped;
      ans += i;
    }

    return maxFreq * 2 > shouldBeSwapped ? -1 : ans;
  }
};",2499
2497,"class Solution {
 public:
  int deleteGreatestValue(vector<vector<int>>& grid) {
    int ans = 0;

    for (vector<int>& row : grid)
      ranges::sort(row);

    for (int j = 0; j < grid[0].size(); ++j) {
      int maxOfColumn = 0;
      for (int i = 0; i < grid.size(); ++i)
        maxOfColumn = max(maxOfColumn, grid[i][j]);
      ans += maxOfColumn;
    }

    return ans;
  }
};",2500
2498,"class Solution {
 public:
  int longestSquareStreak(vector<int>& nums) {
    nums.erase(std::unique(nums.begin(), nums.end()), nums.end());
    ranges::sort(nums, greater<>());

    const int maxNum = ranges::max(nums);
    // dp[i] := the longest square streak starts with i
    vector<int> dp(maxNum + 1);

    for (const int num : nums) {
      dp[num] = 1;
      const long squaredNum = static_cast<long>(num) * num;
      if (squaredNum <= maxNum)
        dp[num] += dp[squaredNum];
    }

    const int ans = ranges::max(dp);
    return ans < 2 ? -1 : ans;
  }
};",2501
2499,"allocate(size: int, mID: int)",2502
2500,"struct IndexedQuery {
  int queryIndex;
  int query;
};

struct T {
  int i;
  int j;
  int val;  // grid[i][j]
  T(int i, int j, int val) : i(i), j(j), val(val) {}
};

class Solution {
 public:
  vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {
    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> ans(queries.size());
    auto compare = [](const T& a, const T& b) { return a.val > b.val; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<bool>> seen(m, vector<bool>(n));

    minHeap.emplace(0, 0, grid[0][0]);
    seen[0][0] = true;
    int accumulate = 0;

    for (const auto& [queryIndex, query] : getIndexedQueries(queries)) {
      while (!minHeap.empty()) {
        const auto [i, j, val] = minHeap.top();
        minHeap.pop();
        if (val >= query) {
          // The smallest neighbor is still larger than `query`, so no need to
          // keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.
          minHeap.emplace(i, j, val);
          break;
        }
        ++accumulate;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y])
            continue;
          minHeap.emplace(x, y, grid[x][y]);
          seen[x][y] = true;
        }
      }
      ans[queryIndex] = accumulate;
    }

    return ans;
  }

 private:
  vector<IndexedQuery> getIndexedQueries(const vector<int>& queries) {
    vector<IndexedQuery> indexedQueries;
    for (int i = 0; i < queries.size(); ++i)
      indexedQueries.push_back({i, queries[i]});
    ranges::sort(indexedQueries,
                 [](const IndexedQuery& a, const IndexedQuery& b) {
      return a.query < b.query;
    });
    return indexedQueries;
  }
};",2503
2501,"SELECT
  person_id,
  CONCAT(name, '(', LEFT(profession, 1), ')') name
FROM Person
ORDER BY 1 DESC;",2504
2502,"class Solution {
 public:
  long long subsequenceSumOr(vector<int>& nums) {
    long long ans = 0;
    long long prefix = 0;

    for (const int num : nums) {
      prefix += num;
      ans |= num | prefix;
    }

    return ans;
  }
};",2505
2503,"class Solution {
 public:
  int similarPairs(vector<string>& words) {
    int ans = 0;
    vector<int> masks;

    for (const string& word : words)
      masks.push_back(getMask(word));

    for (int i = 0; i < masks.size(); ++i)
      for (int j = i + 1; j < masks.size(); ++j)
        if (masks[i] == masks[j])
          ++ans;

    return ans;
  }

 private:
  int getMask(const string& word) {
    int mask = 0;
    for (const char c : word)
      mask |= 1 << c - 'a';
    return mask;
  }
};",2506
2504,"class Solution {
 public:
  int smallestValue(int n) {
    int primeSum = getPrimeSum(n);
    while (n != primeSum) {
      n = primeSum;
      primeSum = getPrimeSum(n);
    }
    return n;
  }

 private:
  int getPrimeSum(int n) {
    int primeSum = 0;
    for (int i = 2; i <= n; ++i)
      while (n % i == 0) {
        n /= i;
        primeSum += i;
      }
    return primeSum;
  }
};",2507
2505,"class Solution {
 public:
  bool isPossible(int n, vector<vector<int>>& edges) {
    vector<unordered_set<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      graph[u].insert(v);
      graph[v].insert(u);
    }

    const vector<int> oddNodes = getOddNodes(graph);
    if (oddNodes.empty())
      return true;
    if (oddNodes.size() == 2) {
      const int a = oddNodes[0];
      const int b = oddNodes[1];
      for (int i = 0; i < n; ++i)
        // Can connect i with a and i with b.
        if (!graph[i].count(a) && !graph[i].count(b))
          return true;
    }
    if (oddNodes.size() == 4) {
      const int a = oddNodes[0];
      const int b = oddNodes[1];
      const int c = oddNodes[2];
      const int d = oddNodes[3];
      return (!graph[a].count(b) && !graph[c].count(d)) ||
             (!graph[a].count(c) && !graph[b].count(d)) ||
             (!graph[a].count(d) && !graph[b].count(c));
    }
    return false;
  }

 private:
  vector<int> getOddNodes(const vector<unordered_set<int>>& graph) {
    vector<int> oddNodes;
    for (int i = 0; i < graph.size(); ++i)
      if (graph[i].size() & 1)
        oddNodes.push_back(i);
    return oddNodes;
  }
};",2508
2506,"class Solution {
 public:
  vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {
    vector<int> ans;

    for (const vector<int>& query : queries) {
      ans.push_back(1);
      int a = query[0];
      int b = query[1];
      while (a != b) {
        if (a > b)
          a /= 2;
        else
          b /= 2;
        ++ans.back();
      }
    }

    return ans;
  }
};",2509
2507,"class Solution {
 public:
  bool isThereAPath(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // Map negative (the number of 0s - the number of 1s) to non-negative one.
    const int cells = m + n - 1;
    if (cells % 2 == 1)
      return false;
    vector<vector<vector<int>>> mem(
        m, vector<vector<int>>(n, vector<int>(cells * 2 + 1, -1)));
    return isThereAPath(grid, 0, 0, 0, cells, mem);
  }

 private:
  // Returns 1 if there's a path to grid[i][j]
  // s.t. `sum` = (the number of 0s - the number of 1s).
  bool isThereAPath(const vector<vector<int>>& grid, int i, int j, int sum,
                    const int& cells, vector<vector<vector<int>>>& mem) {
    if (i == grid.size() || j == grid[0].size())
      return false;
    sum += grid[i][j] == 0 ? 1 : -1;
    if (i == grid.size() - 1 && j == grid[0].size() - 1)
      return sum == 0;
    const int k = cells + sum;
    if (mem[i][j][k] != -1)
      return mem[i][j][k];
    return mem[i][j][k] = isThereAPath(grid, i + 1, j, sum, cells, mem) ||
                          isThereAPath(grid, i, j + 1, sum, cells, mem);
  }
};",2510
2508,"class Solution {
 public:
  int captureForts(vector<int>& forts) {
    int ans = 0;

    for (int i = 0, j = 0; i < forts.size(); ++i)
      if (forts[i] != 0) {  // -1 or 1
        if (forts[i] == -forts[j])
          ans = max(ans, i - j - 1);
        j = i;
      }

    return ans;
  }
};",2511
2509,"class Solution {
 public:
  vector<int> topStudents(vector<string>& positive_feedback,
                          vector<string>& negative_feedback,
                          vector<string>& report, vector<int>& student_id,
                          int k) {
    vector<int> ans;
    vector<pair<int, int>> scoreAndIds;
    unordered_set<string> pos{positive_feedback.begin(),
                              positive_feedback.end()};
    unordered_set<string> neg{negative_feedback.begin(),
                              negative_feedback.end()};

    for (int i = 0; i < report.size(); ++i) {
      int score = 0;
      istringstream iss(report[i]);
      for (string word; iss >> word;) {
        if (pos.count(word))
          score += 3;
        if (neg.count(word))
          score -= 1;
      }
      scoreAndIds.emplace_back(-score, student_id[i]);
    }

    partial_sort(scoreAndIds.begin(), scoreAndIds.begin() + k,
                 scoreAndIds.end());
    transform(
        scoreAndIds.begin(), scoreAndIds.begin() + k, back_inserter(ans),
        [](const pair<int, int>& scoreAndId) { return scoreAndId.second; });
    return ans;
  }
};",2512
2510,"class Solution {
 public:
  int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {
    const long divisorLcm = std::lcm(static_cast<long>(divisor1), divisor2);
    long l = 0;
    long r = INT_MAX;

    while (l < r) {
      const long m = (l + r) / 2;
      if (isPossible(m, divisorLcm, divisor1, divisor2, uniqueCnt1, uniqueCnt2))
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns true if we can take uniqueCnt1 integers from [1..m] to arr1 and
  // take uniqueCnt2 integers from [1..m] to arr2.
  bool isPossible(long m, long divisorLcm, int divisor1, int divisor2,
                  int uniqueCnt1, int uniqueCnt2) {
    const long cnt1 = m - m / divisor1;
    const long cnt2 = m - m / divisor2;
    const long totalCnt = m - m / divisorLcm;
    return cnt1 >= uniqueCnt1 && cnt2 >= uniqueCnt2 &&
           totalCnt >= uniqueCnt1 + uniqueCnt2;
  }
};",2513
2511,"class Solution {
 public:
  int countAnagrams(string s) {
    const int n = s.length();
    const auto [fact, invFact] = getFactAndInvFact(n);
    int ans = 1;
    istringstream iss(s);

    for (string word; iss >> word;) {
      ans = ans * fact[word.length()] % kMod;
      vector<int> count(26);
      for (const char c : word)
        ++count[c - 'a'];
      for (const int freq : count)
        ans = ans * invFact[freq] % kMod;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {
    vector<long> fact(n + 1);
    vector<long> invFact(n + 1);
    vector<long> inv(n + 1);
    fact[0] = invFact[0] = 1;
    inv[0] = inv[1] = 1;
    for (int i = 1; i <= n; ++i) {
      if (i >= 2)
        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;
      fact[i] = fact[i - 1] * i % kMod;
      invFact[i] = invFact[i - 1] * inv[i] % kMod;
    }
    return {fact, invFact};
  }
};",2514
2512,"class Solution {
 public:
  int closetTarget(vector<string>& words, string target, int startIndex) {
    const int n = words.size();

    for (int i = 0; i < n; ++i) {
      if (words[(startIndex + i + n) % n] == target)
        return i;
      if (words[(startIndex - i + n) % n] == target)
        return i;
    }

    return -1;
  }
};",2515
2513,"class Solution {
 public:
  int takeCharacters(string s, int k) {
    const int n = s.length();
    int ans = n;
    vector<int> count(3);

    for (const char c : s)
      ++count[c - 'a'];

    if (count[0] < k || count[1] < k || count[2] < k)
      return -1;

    for (int l = 0, r = 0; r < n; ++r) {
      --count[s[r] - 'a'];
      while (count[s[r] - 'a'] < k)
        ++count[s[l++] - 'a'];
      ans = min(ans, n - (r - l + 1));
    }

    return ans;
  }
};",2516
2514,"class Solution {
 public:
  int maximumTastiness(vector<int>& price, int k) {
    ranges::sort(price);

    int l = 0;
    int r = ranges::max(price) - ranges::min(price) + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (numBaskets(price, m) >= k)
        l = m + 1;
      else
        r = m;
    }

    return l - 1;
  }

 private:
  // Returns the number of baskets we can pick for m tastiness.
  int numBaskets(const vector<int>& price, int m) {
    int baskets = 0;
    int prevPrice = -m;
    for (const int p : price)
      if (p >= prevPrice + m) {
        prevPrice = p;
        ++baskets;
      }
    return baskets;
  }
};",2517
2515,"class Solution {
 public:
  int countPartitions(vector<int>& nums, int k) {
    const long sum = accumulate(nums.begin(), nums.end(), 0L);
    long ans = modPow(2, nums.size());
    vector<long> dp(k + 1);
    dp[0] = 1;

    for (const int num : nums)
      for (int i = k; i >= num; --i) {
        dp[i] += dp[i - num];
        dp[i] %= kMod;
      }

    // Substract the cases that're not satisfied.
    for (int i = 0; i < k; ++i)
      if (sum - i < k)  // Both group1 and group2 < k.
        ans -= dp[i];
      else
        ans -= dp[i] * 2;

    return (ans % kMod + kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2518
2516,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int kBigIndices(vector<int>& nums, int k) {
    const int n = nums.size();
    int ans = 0;
    FenwickTree leftTree(n);
    FenwickTree rightTree(n);
    // left[i] := the number of `nums` < nums[i] with index < i
    vector<int> left(n);
    // right[i] := the number of `nums` < nums[i] with index > i
    vector<int> right(n);

    for (int i = 0; i < n; ++i) {
      left[i] = leftTree.get(nums[i] - 1);
      leftTree.update(nums[i], 1);
    }

    for (int i = n - 1; i >= 0; --i) {
      right[i] = rightTree.get(nums[i] - 1);
      rightTree.update(nums[i], 1);
    }

    for (int i = 0; i < n; ++i)
      if (left[i] >= k && right[i] >= k)
        ++ans;

    return ans;
  }
};",2519
2517,"class Solution {
 public:
  int countDigits(int num) {
    int ans = 0;

    for (int n = num; n > 0; n /= 10)
      if (num % (n % 10) == 0)
        ++ans;

    return ans;
  }
};",2520
2518,"class Solution {
 public:
  int distinctPrimeFactors(vector<int>& nums) {
    unordered_set<int> primes;

    for (const int num : nums)
      addPrimeFactors(primes, num);

    return primes.size();
  }

 private:
  void addPrimeFactors(unordered_set<int>& primes, int num) {
    for (int divisor = 2; divisor <= num; ++divisor)
      if (num % divisor == 0) {
        primes.insert(divisor);
        while (num % divisor == 0)
          num /= divisor;
      }
  }
};",2521
2519,"class Solution {
 public:
  int minimumPartition(string s, int k) {
    int ans = 1;
    long curr = 0;

    for (const char c : s) {
      curr = curr * 10 + c - '0';
      if (curr > k) {
        curr = c - '0';
        ++ans;
      }
      if (curr > k)
        return -1;
    }

    return ans;
  }
};",2522
2520,"class Solution {
 public:
  vector<int> closestPrimes(int left, int right) {
    const vector<bool> isPrime = sieveEratosthenes(right + 1);
    vector<int> primes;

    for (int i = left; i <= right; ++i)
      if (isPrime[i])
        primes.push_back(i);

    if (primes.size() < 2)
      return {-1, -1};

    int minDiff = INT_MAX;
    int num1 = -1;
    int num2 = -1;

    for (int i = 1; i < primes.size(); ++i) {
      const int diff = primes[i] - primes[i - 1];
      if (diff < minDiff) {
        minDiff = diff;
        num1 = primes[i - 1];
        num2 = primes[i];
      }
    }

    return {num1, num2};
  }

 private:
  vector<bool> sieveEratosthenes(int n) {
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    return isPrime;
  }
};",2523
2521,"class Solution {
 public:
  int maxFrequencyScore(vector<int>& nums, int k) {
    unordered_map<int, int> count;

    for (int i = 0; i < k; ++i)
      ++count[nums[i]];

    int sum = getInitialSum(count);
    int ans = sum;

    for (int i = k; i < nums.size(); ++i) {
      // Remove the leftmost number that's out-of-window.
      const int leftNum = nums[i - k];
      sum = (sum - modPow(leftNum, count[leftNum]) + kMod) % kMod;
      // After decreasing its frequency, if it's still > 0, then add it back.
      if (--count[leftNum] > 0)
        sum = (sum + modPow(leftNum, count[leftNum])) % kMod;
      // Otherwise, remove it from the count map.
      else
        count.erase(leftNum);
      // Add the current number. Similarly, remove the current score like above.
      const int rightNum = nums[i];
      if (count[rightNum] > 0)
        sum = (sum - modPow(rightNum, count[rightNum]) + kMod) % kMod;
      sum = (sum + modPow(rightNum, ++count[rightNum])) % kMod;
      ans = max(ans, sum);
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int getInitialSum(const unordered_map<int, int>& count) {
    long sum = 0;
    for (const auto& [num, freq] : count)
      sum = (sum + modPow(num, freq)) % kMod;
    return sum;
  }

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2524
2522,"class Solution {
 public:
  string categorizeBox(int length, int width, int height, int mass) {
    const bool isBulky =
        length >= 10000 || width >= 10000 || height >= 10000 ||
        static_cast<long>(length) * width * height >= 1'000'000'000;
    const bool isHeavy = mass >= 100;
    if (isBulky && isHeavy)
      return ""Both"";
    if (isBulky)
      return ""Bulky"";
    if (isHeavy)
      return ""Heavy"";
    return ""Neither"";
  }
};",2525
2523,consec(num: int),2526
2524,"class Solution {
 public:
  int xorBeauty(vector<int>& nums) {
    return accumulate(nums.begin(), nums.end(), 0, bit_xor<>());
  }
};",2527
2525,"class Solution {
 public:
  long long maxPower(vector<int>& stations, int r, int k) {
    long long left = ranges::min(stations);
    long long right = accumulate(stations.begin(), stations.end(), 0LL) + k + 1;

    while (left < right) {
      const long long mid = (left + right) / 2;
      if (check(stations, r, k, mid))
        left = mid + 1;
      else
        right = mid;
    }

    return left - 1;
  }

 private:
  // Returns true if each city can have at least `minPower`.
  bool check(vector<int> stations, int r, int additionalStations,
             long long minPower) {
    const int n = stations.size();
    // Initilaize `power` as the 0-th city's power - stations[r].
    long long power = accumulate(stations.begin(), stations.begin() + r, 0LL);

    for (int i = 0; i < n; ++i) {
      if (i + r < n)
        power += stations[i + r];  // `power` = sum(stations[i - r..i + r]).
      if (power < minPower) {
        const long long requiredPower = minPower - power;
        // There're not enough stations to plant.
        if (requiredPower > additionalStations)
          return false;
        // Greedily plant `requiredPower` power stations in the farthest place
        // to cover as many cities as possible.
        stations[min(n - 1, i + r)] += requiredPower;
        additionalStations -= requiredPower;
        power += requiredPower;
      }
      if (i - r >= 0)
        power -= stations[i - r];
    }

    return true;
  }
};",2528
2526,"class Solution {
 public:
  int maximumCount(vector<int>& nums) {
    return max(ranges::count_if(nums, [](int num) { return num > 0; }),
               ranges::count_if(nums, [](int num) { return num < 0; }));
  }
};",2529
2527,"class Solution {
 public:
  long long maxKelements(vector<int>& nums, int k) {
    long long ans = 0;
    priority_queue<int> maxHeap;

    for (const int num : nums)
      maxHeap.push(num);

    for (int i = 0; i < k; ++i) {
      const int num = maxHeap.top();
      maxHeap.pop();
      ans += num;
      maxHeap.push((num + 2) / 3);
    }

    return ans;
  }
};",2530
2528,"class Solution {
 public:
  bool isItPossible(string word1, string word2) {
    const vector<int> count1 = getCount(word1);
    const vector<int> count2 = getCount(word2);
    const int distinct1 = getDistinct(count1);
    const int distinct2 = getDistinct(count2);

    for (int i = 0; i < 26; ++i)
      for (int j = 0; j < 26; ++j) {
        if (count1[i] == 0 || count2[j] == 0)
          continue;
        if (i == j) {
          // Swapping the same letters won't change the number of distinct
          // letters in each string, so just check if `distinct1 == distinct2`.
          if (distinct1 == distinct2)
            return true;
          continue;
        }
        // The calculation is meaningful only when i != j.
        // Swap ('a' + i) in word1 with ('a' + j) in word2.
        const int distinctAfterSwap1 =
            distinct1 - (count1[i] == 1) + (count1[j] == 0);
        const int distinctAfterSwap2 =
            distinct2 - (count2[j] == 1) + (count2[i] == 0);
        if (distinctAfterSwap1 == distinctAfterSwap2)
          return true;
      }

    return false;
  }

 private:
  vector<int> getCount(const string& s) {
    vector<int> count(26);
    for (const char c : s)
      ++count[c - 'a'];
    return count;
  }

  int getDistinct(const vector<int>& count) {
    return ranges::count_if(count, [](const int c) { return c > 0; });
  }
};",2531
2529,"class Solution {
 public:
  int findCrossingTime(int n, int k, vector<vector<int>>& time) {
    int ans = 0;
    using P = pair<int, int>;
    // (leftToRight + rightToLeft, i)
    priority_queue<P> leftBridgeQueue;
    priority_queue<P> rightBridgeQueue;
    // (time to be idle, i)
    priority_queue<P, vector<P>, greater<>> leftWorkers;
    priority_queue<P, vector<P>, greater<>> rightWorkers;

    for (int i = 0; i < k; ++i)
      leftBridgeQueue.emplace(
          /*leftToRight*/ time[i][0] + /*rightToLeft*/ time[i][2], i);

    while (n > 0 || !rightBridgeQueue.empty() || !rightWorkers.empty()) {
      // Idle left workers get on the left bridge.
      while (!leftWorkers.empty() && leftWorkers.top().first <= ans) {
        const int i = leftWorkers.top().second;
        leftWorkers.pop();
        leftBridgeQueue.emplace(
            /*leftToRight*/ time[i][0] + /*rightToLeft*/ time[i][2], i);
      }
      // Idle right workers get on the right bridge.
      while (!rightWorkers.empty() && rightWorkers.top().first <= ans) {
        const int i = rightWorkers.top().second;
        rightWorkers.pop();
        rightBridgeQueue.emplace(
            /*leftToRight*/ time[i][0] + /*rightToLeft*/ time[i][2], i);
      }

      if (!rightBridgeQueue.empty()) {
        // If the bridge is free, the worker waiting on the right side of the
        // bridge gets to cross the bridge. If more than one worker is waiting
        // on the right side, the one with the lowest efficiency crosses first.
        const int i = rightBridgeQueue.top().second;
        rightBridgeQueue.pop();
        ans += /*rightToLeft*/ time[i][2];
        leftWorkers.emplace(ans + /*putNew*/ time[i][3], i);
      } else if (!leftBridgeQueue.empty() && n > 0) {
        // If the bridge is free and no worker is waiting on the right side, and
        // at least one box remains at the old warehouse, the worker on the left
        // side of the river gets to cross the bridge. If more than one worker
        // is waiting on the left side, the one with the lowest efficiency
        // crosses first.
        const int i = leftBridgeQueue.top().second;
        leftBridgeQueue.pop();
        ans += /*leftToRight*/ time[i][0];
        rightWorkers.emplace(ans + /*pickOld*/ time[i][1], i);
        --n;
      } else {
        // Advance the time of the last crossing worker.
        ans = min(
            !leftWorkers.empty() && n > 0 ? leftWorkers.top().first : INT_MAX,
            !rightWorkers.empty() ? rightWorkers.top().first : INT_MAX);
      }
    }

    return ans;
  }
};",2532
2530,"class Solution {
 public:
  int goodBinaryStrings(int minLength, int maxLength, int oneGroup,
                        int zeroGroup) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := the number of good binary strings with length i
    vector<int> dp(maxLength + 1);
    dp[0] = 1;  // """"

    for (int i = 0; i <= maxLength; ++i)
      // There are good binary strings with length i, so we can append
      // consecutive 0s or 1s after it.
      if (dp[i] > 0) {
        const int appendZeros = i + zeroGroup;
        if (appendZeros <= maxLength) {
          dp[appendZeros] += dp[i];
          dp[appendZeros] %= kMod;
        }
        const int appendOnes = i + oneGroup;
        if (appendOnes <= maxLength) {
          dp[appendOnes] += dp[i];
          dp[appendOnes] %= kMod;
        }
      }

    return accumulate(dp.begin() + minLength, dp.end(), 0L) % kMod;
  }
};",2533
2531,"class Solution {
 public:
  vector<int> timeTaken(vector<int>& arrival, vector<int>& state) {
    const int n = arrival.size();
    vector<int> ans(n);
    // qs[0] := enter, qs[1] := exit
    vector<queue<int>> qs(2);
    int time = 0;
    int d = 1;

    for (int i = 0; i < n; ++i) {
      popQueues(time, d, arrival[i], qs, ans);
      // If the door was not used in the previous second, then the person who
      // wants to exit goes first.
      if (arrival[i] > time) {
        time = arrival[i];  // Forward `time` to now.
        d = 1;
      }
      qs[state[i]].push(i);
    }

    popQueues(time, d, 200'000, qs, ans);
    return ans;
  }

 private:
  void popQueues(int& time, int& d, int arrivalTime, vector<queue<int>>& qs,
                 vector<int>& ans) {
    while (arrivalTime > time && (!qs[0].empty() || !qs[1].empty())) {
      if (qs[d].empty())
        d ^= 1;
      ans[qs[d].front()] = time, qs[d].pop();
      ++time;
    }
  }
};",2534
2532,"class Solution {
 public:
  int differenceOfSum(vector<int>& nums) {
    const int elementSum = accumulate(nums.begin(), nums.end(), 0);
    const int allDigitSum = getAllDigitSum(nums);
    return abs(elementSum - allDigitSum);
  }

 private:
  int getAllDigitSum(const vector<int>& nums) {
    int allDigitSum = 0;
    for (const int num : nums)
      allDigitSum += getDigitSum(num);
    return allDigitSum;
  }

  int getDigitSum(int num) {
    int digitSum = 0;
    while (num > 0) {
      digitSum += num % 10;
      num /= 10;
    }
    return digitSum;
  }
};",2535
2533,"class Solution {
 public:
  vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {
    vector<vector<int>> ans(n, vector<int>(n));
    vector<vector<int>> prefix(n, vector<int>(n + 1));

    for (const vector<int>& query : queries) {
      const int row1 = query[0];
      const int col1 = query[1];
      const int row2 = query[2];
      const int col2 = query[3];
      for (int i = row1; i <= row2; ++i) {
        ++prefix[i][col1];
        --prefix[i][col2 + 1];
      }
    }

    for (int i = 0; i < n; ++i) {
      int sum = 0;
      for (int j = 0; j < n; ++j) {
        sum += prefix[i][j];
        ans[i][j] = sum;
      }
    }

    return ans;
  }
};",2536
2534,"class Solution {
 public:
  long long countGood(vector<int>& nums, int k) {
    long long ans = 0;
    int pairs = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      // Since there're count[r] nums[r]s, including nums[r] to the window will
      // increase the number of good subarrays by count[r].
      pairs += count[nums[r]]++;
      while (pairs >= k)
        pairs -= --count[nums[l++]];
      // nums[0..r], nums[1..r], ..., nums[l - 1..r] are good subarrays, so add
      // l to `ans`.
      ans += l;
    }

    return ans;
  }
};",2537
2535,"class Solution {
 public:
  long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {
    int ans = 0;
    vector<vector<int>> tree(n);
    // maxSums[i] := the maximum the sum of path rooted at i
    vector<int> maxSums(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    // Precalculate `maxSums`.
    maxSum(tree, 0, /*prev=*/-1, maxSums, price);
    reroot(tree, 0, /*prev=*/-1, /*parentSum=*/0, maxSums, price, ans);
    return ans;
  }

 private:
  int maxSum(const vector<vector<int>>& tree, int u, int prev,
             vector<int>& maxSums, const vector<int>& price) {
    int maxChildSum = 0;
    for (const int v : tree[u])
      if (prev != v)
        maxChildSum = max(maxChildSum, maxSum(tree, v, u, maxSums, price));
    return maxSums[u] = price[u] + maxChildSum;
  }

  void reroot(const vector<vector<int>>& tree, int u, int prev, int parentSum,
              const vector<int>& maxSums, const vector<int>& price, int& ans) {
    // Get the top two subtree sums and the top one node index.
    int maxSubtreeSum1 = 0;
    int maxSubtreeSum2 = 0;
    int maxNode = -1;
    for (const int v : tree[u]) {
      if (v == prev)
        continue;
      if (maxSums[v] > maxSubtreeSum1) {
        maxSubtreeSum2 = maxSubtreeSum1;
        maxSubtreeSum1 = maxSums[v];
        maxNode = v;
      } else if (maxSums[v] > maxSubtreeSum2) {
        maxSubtreeSum2 = maxSums[v];
      }
    }

    if (tree[u].size() == 1)
      ans = max({ans, parentSum, maxSubtreeSum1});

    for (const int v : tree[u]) {
      if (v == prev)
        continue;
      const int nextParentSum =
          (v == maxNode ? price[u] + max(parentSum, maxSubtreeSum2)
                        : price[u] + max(parentSum, maxSubtreeSum1));
      reroot(tree, v, u, nextParentSum, maxSums, price, ans);
    }
  }
};",2538
2536,"class Solution {
 public:
  int countGoodSubsequences(string s) {
    // For each frequency f in [1, max(freq)], start with """" and calculate how
    // many subsequences can be constructed with each letter's frequency = f.
    //
    // e.g. s = ""abb"", so f = max(freq) = 2.
    //
    // For f = 1, with 1 way to build """", choose any 'a' to construct a good
    // subseq, so # of good subsequences = 1 + 1 * (1, 1) = 2 ("""", ""a""). Next,
    // add 'b' and # of good subsequences = 2 + 2 * (2, 1) = 6 ("""", ""a"", ""b1"",
    // ""b2"", ""ab1"", ""ab2""). So, the number of good subsequences for f = 1 is 5
    // since we need to exclude """".
    //
    // For f = 2, with 1 way to build """", choose any two 'b's to construct a
    // good subseq, so # of good subsequences = 1 + 1 * (2, 2) is 2 ("""", ""bb"").
    // So, the number of good subsequences for f = 2 = 1 since we need to
    // exclude """".
    //
    // Therefore, the number of good subsequences for ""aab"" = 5 + 1 = 6.
    int ans = 0;
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    const int maxFreq = ranges::max(count);
    const auto [fact, invFact] = getFactAndInvFact(maxFreq);

    for (int freq = 1; freq <= maxFreq; ++freq) {
      long numSubseqs = 1;  // """"
      for (const int charFreq : count)
        if (charFreq >= freq)
          numSubseqs = (numSubseqs +  //
                        numSubseqs * nCk(charFreq, freq, fact, invFact)) %
                       kMod;
      ans += numSubseqs - 1;  // Minus """".
      ans %= kMod;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {
    vector<long> fact(n + 1);
    vector<long> invFact(n + 1);
    vector<long> inv(n + 1);
    fact[0] = invFact[0] = 1;
    inv[0] = inv[1] = 1;
    for (int i = 1; i <= n; ++i) {
      if (i >= 2)
        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;
      fact[i] = fact[i - 1] * i % kMod;
      invFact[i] = invFact[i - 1] * inv[i] % kMod;
    }
    return {fact, invFact};
  }

  int nCk(int n, int k, const vector<long>& fact, const vector<long>& invFact) {
    return fact[n] * invFact[k] % kMod * invFact[n - k] % kMod;
  }
};",2539
2537,"class Solution {
 public:
  int getCommon(vector<int>& nums1, vector<int>& nums2) {
    int i = 0;  // nums1's index
    int j = 0;  // nums2's index

    while (i < nums1.size() && j < nums2.size()) {
      if (nums1[i] == nums2[j])
        return nums1[i];
      if (nums1[i] < nums2[j])
        ++i;
      else
        ++j;
    }

    return -1;
  }
};",2540
2538,"class Solution {
 public:
  long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {
    if (k == 0)
      return nums1 == nums2 ? 0 : -1;

    long long ans = 0;
    // the number of increments - the number of decrements
    long long opsDiff = 0;

    for (int i = 0; i < nums1.size(); ++i) {
      const int diff = nums1[i] - nums2[i];
      if (diff == 0)
        continue;
      if (diff % k != 0)
        return -1;
      const int ops = diff / k;
      opsDiff += ops;
      ans += abs(ops);
    }

    return opsDiff == 0 ? ans / 2 : -1;
  }
};",2541
2539,"class Solution {
 public:
  // Same as 1383. Maximum Performance of a Team
  long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {
    long long ans = 0;
    long long sum = 0;
    // (nums2[i], nums1[i]) sorted by nums2[i] in descending order.
    vector<pair<int, int>> A;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 0; i < nums1.size(); ++i)
      A.emplace_back(nums2[i], nums1[i]);

    ranges::sort(A, greater<>());

    for (const auto& [num2, num1] : A) {
      minHeap.push(num1);
      sum += num1;
      if (minHeap.size() > k)
        sum -= minHeap.top(), minHeap.pop();
      if (minHeap.size() == k)
        ans = max(ans, sum * num2);
    }

    return ans;
  }
};",2542
2540,"class Solution {
 public:
  bool isReachable(int targetX, int targetY) {
    return __builtin_popcount(gcd(targetX, targetY)) == 1;
  }
};",2543
2541,"class Solution {
 public:
  int alternateDigitSum(int n) {
    int ans = 0;
    int sign = 1;

    for (; n > 0; n /= 10) {
      sign *= -1;
      ans += sign * n % 10;
    }

    return sign * ans;
  }
};",2544
2542,"class Solution {
 public:
  vector<vector<int>> sortTheStudents(vector<vector<int>>& score, int k) {
    ranges::sort(score, [k](const vector<int>& a, const vector<int>& b) {
      return a[k] > b[k];
    });
    return score;
  }
};",2545
2543,"class Solution {
 public:
  bool makeStringsEqual(string s, string target) {
    return (s.find('1') != string::npos) == (target.find('1') != string::npos);
  }
};",2546
2544,"class Solution {
 public:
  int minCost(vector<int>& nums, int k) {
    constexpr int kMax = 1001;
    const int n = nums.size();
    // trimmedLength[i][j] := trimmed(nums[i..j]).length
    vector<vector<int>> trimmedLength(n, vector<int>(n));
    // dp[i] := the minimum cost to split nums[i..n)
    vector<int> dp(n + 1, INT_MAX / 2);

    for (int i = 0; i < n; ++i) {
      int length = 0;
      vector<int> count(kMax);
      for (int j = i; j < n; ++j) {
        if (++count[nums[j]] == 2)
          length += 2;
        else if (count[nums[j]] > 2)
          ++length;
        trimmedLength[i][j] = length;
      }
    }

    dp[n] = 0;

    for (int i = n - 1; i >= 0; --i)
      for (int j = i; j < n; ++j)
        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1]);

    return dp[0];
  }
};",2547
2545,"class Solution {
 public:
  double maxPrice(vector<vector<int>>& items, int capacity) {
    double ans = 0;

    // Sort items based on price/weight.
    ranges::sort(items, [](const vector<int>& a, const vector<int>& b) {
      return static_cast<double>(a[0]) / a[1] >
             static_cast<double>(b[0]) / b[1];
    });

    for (const vector<int>& item : items) {
      const int price = item[0];
      const int weight = item[1];
      // The bag is filled.
      if (capacity <= weight)
        return ans + price * capacity / static_cast<double>(weight);
      ans += price;
      capacity -= weight;
    }

    return -1;
  }
};",2548
2546,"class Solution {
 public:
  int distinctIntegers(int n) {
    return max(n - 1, 1);
  }
};",2549
2547,"class Solution {
 public:
  int monkeyMove(int n) {
    const int res = modPow(2, n) - 2;
    return res < 0 ? res + kMod : res;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2550
2548,"class Solution {
 public:
  long long putMarbles(vector<int>& weights, int k) {
    // To distribute marbles into k bags, there will be k - 1 cuts. If there's a
    // cut after weights[i], then weights[i] and weights[i + 1] will be added to
    // the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will
    // be counted. So, the goal is to find the max/min k - 1 weights[i] +
    // weights[i + 1].
    vector<int> A;  // weights[i] + weights[i + 1]
    long long min = 0;
    long long max = 0;

    for (int i = 0; i + 1 < weights.size(); ++i)
      A.push_back(weights[i] + weights[i + 1]);

    ranges::sort(A);

    for (int i = 0; i < k - 1; ++i) {
      min += A[i];
      max += A[A.size() - 1 - i];
    }

    return max - min;
  }
};",2551
2549,"class Solution {
 public:
  long long countQuadruplets(vector<int>& nums) {
    long long ans = 0;
    // dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] <
    // nums[k] < nums[j]. Keep this information for l to use later.
    vector<int> dp(nums.size());

    // k can be treated as l.
    for (int k = 2; k < nums.size(); ++k)
      // j can be treated as i.
      for (int j = 0, numLessThanK = 0; j < k; ++j)
        if (nums[j] < nums[k]) {
          ++numLessThanK;  // nums[i] < nums[k]
          // nums[j] < nums[l], so we should add dp[j] since we find a new
          // quadruplets for (i, j, k, l).
          ans += dp[j];

        } else if (nums[j] > nums[k]) {
          dp[j] += numLessThanK;
        }

    return ans;
  }
};",2552
2550,"class Solution {
 public:
  vector<int> separateDigits(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums)
      for (const char c : to_string(num))
        ans.push_back(c - '0');

    return ans;
  }
};",2553
2551,"class Solution {
 public:
  int maxCount(vector<int>& banned, int n, int maxSum) {
    int ans = 0;
    int sum = 0;
    const unordered_set<int> bannedSet{banned.begin(), banned.end()};

    for (int i = 1; i <= n; ++i)
      if (!bannedSet.count(i) && sum + i <= maxSum) {
        ++ans;
        sum += i;
      }

    return ans;
  }
};",2554
2552,"class Solution {
 public:
  int maximizeWin(vector<int>& prizePositions, int k) {
    int ans = 0;
    // dp[i] := the maximum number of prizes to choose the first i
    // `prizePositions`
    vector<int> dp(prizePositions.size() + 1);

    for (int i = 0, j = 0; i < prizePositions.size(); ++i) {
      while (prizePositions[i] - prizePositions[j] > k)
        ++j;
      const int covered = i - j + 1;
      dp[i + 1] = max(dp[i], covered);
      ans = max(ans, dp[j] + covered);
    }

    return ans;
  }
};",2555
2553,"class Solution {
 public:
  bool isPossibleToCutPath(vector<vector<int>>& grid) {
    if (!hasPath(grid, 0, 0))
      return true;
    // Reassign (0, 0) as 1.
    grid[0][0] = 1;
    return !hasPath(grid, 0, 0);
  }

 private:
  // Returns true is there's a path from (0, 0) to (m - 1, n - 1).
  // Also marks the visited path as 0 except (m - 1, n - 1).
  bool hasPath(vector<vector<int>>& grid, int i, int j) {
    if (i == grid.size() || j == grid[0].size())
      return false;
    if (i == grid.size() - 1 && j == grid[0].size() - 1)
      return true;
    if (grid[i][j] == 0)
      return false;

    grid[i][j] = 0;
    // Go down first. Since we use OR logic, we'll only mark one path.
    return hasPath(grid, i + 1, j) || hasPath(grid, i, j + 1);
  }
};",2556
2554,"class Solution {
 public:
  int maxCount(vector<int>& banned, int n, long long maxSum) {
    const unordered_set<int> bannedSet{banned.begin(), banned.end()};
    int l = 1;
    int r = n;

    while (l < r) {
      const int m = (l + r + 1) / 2;
      if (getSum(bannedSet, m) > maxSum)
        r = m - 1;
      else
        l = m;
    }

    return l - ranges::count_if(bannedSet, [l](const int b) { return b <= l; });
  }

 private:
  // Returns sum([1..m]) - sum(bannedSet).
  long long getSum(const unordered_set<int>& bannedSet, long m) {
    long long sum = m * (m + 1) / 2;  // sum([1..m])
    for (const int b : bannedSet)
      if (b <= m)
        sum -= b;
    return sum;
  }
};",2557
2555,"class Solution {
 public:
  long long pickGifts(vector<int>& gifts, int k) {
    long long ans = 0;
    priority_queue<int> maxHeap;

    for (const int gift : gifts)
      maxHeap.push(gift);

    for (int i = 0; i < k; ++i) {
      const int squaredMax = sqrt(maxHeap.top());
      maxHeap.pop();
      maxHeap.push(squaredMax);
    }

    while (!maxHeap.empty())
      ans += maxHeap.top(), maxHeap.pop();

    return ans;
  }
};",2558
2556,"class Solution {
 public:
  vector<int> vowelStrings(vector<string>& words,
                           vector<vector<int>>& queries) {
    vector<int> ans;
    // prefix[i] := the number of the first i words that start with and end in a
    // vowel
    vector<int> prefix(words.size() + 1);

    for (int i = 0; i < words.size(); ++i)
      prefix[i + 1] += prefix[i] + startsAndEndsWithVowel(words[i]);

    for (const vector<int>& query : queries) {
      const int l = query[0];
      const int r = query[1];
      ans.push_back(prefix[r + 1] - prefix[l]);
    }

    return ans;
  }

 private:
  bool startsAndEndsWithVowel(const string& word) {
    return isVowel(word.front()) && isVowel(word.back());
  }

  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiou"";
    return kVowels.find(c) != string_view::npos;
  }
};",2559
2557,"class Solution {
 public:
  int minCapability(vector<int>& nums, int k) {
    int l = ranges::min(nums);
    int r = ranges::max(nums);

    while (l < r) {
      const int m = (l + r) / 2;
      if (numStolenHouses(nums, m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int numStolenHouses(const vector<int>& nums, int capacity) {
    int stolenHouses = 0;
    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] <= capacity) {
        ++stolenHouses;
        ++i;
      }
    return stolenHouses;
  }
};",2560
2558,"class Solution {
 public:
  long long minCost(vector<int>& basket1, vector<int>& basket2) {
    vector<int> swapped;
    unordered_map<int, int> count;

    for (const int b : basket1)
      ++count[b];

    for (const int b : basket2)
      --count[b];

    for (const auto& [num, freq] : count) {
      if (freq % 2 != 0)
        return -1;
      for (int i = 0; i < abs(freq) / 2; ++i)
        swapped.push_back(num);
    }

    const int minNum = min(ranges::min(basket1), ranges::min(basket2));
    const auto midIt = swapped.begin() + swapped.size() / 2;
    nth_element(swapped.begin(), midIt, swapped.end());
    return accumulate(swapped.begin(), midIt, 0LL,
                      [minNum](long long subtotal, int num) {
      return subtotal + min(2 * minNum, num);
    });
  }
};",2561
2559,"class Solution {
 public:
  long long findTheArrayConcVal(vector<int>& nums) {
    long long ans = 0;

    for (int i = 0, j = nums.size() - 1; i <= j; ++i, --j) {
      ans += nums[j];
      if (i < j)
        ans += nums[i] * pow(10, static_cast<int>(log10(nums[j])) + 1);
    }

    return ans;
  }
};",2562
2560,"class Solution {
 public:
  long long countFairPairs(vector<int>& nums, int lower, int upper) {
    // nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j
    // degrades to i != j and we can sort the array.
    ranges::sort(nums);
    return countLess(nums, upper) - countLess(nums, lower - 1);
  }

 private:
  long long countLess(const vector<int>& nums, int sum) {
    long long res = 0;
    for (int i = 0, j = nums.size() - 1; i < j; ++i) {
      while (i < j && nums[i] + nums[j] > sum)
        --j;
      res += j - i;
    }
    return res;
  }
};",2563
2561,"class Solution {
 public:
  vector<vector<int>> substringXorQueries(string s,
                                          vector<vector<int>>& queries) {
    constexpr int kMaxBit = 30;
    vector<vector<int>> ans;
    // {val: (left, right)} := s[left..right]'s decimal value = val
    unordered_map<int, pair<int, int>> valToLeftAndRight;

    for (int left = 0; left < s.length(); ++left) {
      int val = 0;
      if (s[left] == '0') {
        // edge case: Save the index of the first 0.
        if (!valToLeftAndRight.count(0))
          valToLeftAndRight[0] = {left, left};
        continue;
      }
      const int maxRight = min(static_cast<int>(s.length()), left + kMaxBit);
      for (int right = left; right < maxRight; ++right) {
        val = val * 2 + s[right] - '0';
        if (!valToLeftAndRight.count(val))
          valToLeftAndRight[val] = {left, right};
      }
    }

    for (const vector<int>& query : queries) {
      const int first = query[0];
      const int second = query[1];
      const int val = first ^ second;
      const auto it = valToLeftAndRight.find(val);
      if (it == valToLeftAndRight.cend()) {
        ans.push_back({-1, -1});
      } else {
        const auto [left, right] = it->second;
        ans.push_back({left, right});
      }
    }

    return ans;
  }
};",2564
2562,"class Solution:
  def minimumScore(self, s: str, t: str) -> int:
    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].
    #          -1 := impossible
    leftmost = [-1] * len(t)
    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).
    #           -1 := impossible
    rightmost = [-1] * len(t)

    j = 0  # t's index
    for i in range(len(s)):
      if s[i] == t[j]:
        leftmost[j] = i
        j += 1
        if j == len(t):
          break

    j = len(t) - 1  # t's index
    for i in reversed(range(len(s))):
      if s[i] == t[j]:
        rightmost[j] = i
        j -= 1
        if j == -1:
          break

    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced
    # from the above loop).
    ans = j + 1

    j = 0
    for i in range(len(t)):
      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since
      # no need to consider any larger i.
      if leftmost[i] == -1:
        break
      # While t[0..i] + t[j:] is not a subsequence of s, increase j.
      while j < len(t) and leftmost[i] >= rightmost[j]:
        j += 1
      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.
      # If i == j that means t is a subsequence of s, so just return 0.
      if i == j:
        return 0
      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.
      ans = min(ans, j - i - 1)

    return ans",2565
2563,"class Solution {
 public:
  int minMaxDifference(int num) {
    const string s = to_string(num);
    const char to9 = s[firstNotNineIndex(s)];
    const char to0 = s[0];
    return getMax(s, to9) - getMin(s, to0);
  }

 private:
  int firstNotNineIndex(const string& s) {
    for (int i = 0; i < s.length(); ++i)
      if (s[i] != '9')
        return i;
    return 0;
  }

  int getMax(string s, char to9) {
    for (char& c : s)
      if (c == to9)
        c = '9';
    return stoi(s);
  }

  int getMin(string s, char to0) {
    for (char& c : s)
      if (c == to0)
        c = '0';
    return stoi(s);
  }
};",2566
2564,"class Solution {
 public:
  int minimizeSum(vector<int>& nums) {
    ranges::sort(nums);
    // Can always change the number to any other number in `nums`, so `low`
    // becomes 0. Thus, rephrase the problem as finding the minimum `high`.
    const int n = nums.size();
    const int highOfChangingTwoMins = nums.back() - nums[2];
    const int highOfChangingTwoMaxs = nums[n - 3] - nums[0];
    const int highOfChangingMinAndMax = nums[n - 2] - nums[1];
    return min({highOfChangingTwoMins, highOfChangingTwoMaxs,
                highOfChangingMinAndMax});
  }
};",2567
2565,"class Solution {
 public:
  int minImpossibleOR(vector<int>& nums) {
    int ans = 1;
    const unordered_set<int> numsSet{nums.begin(), nums.end()};

    while (numsSet.count(ans))
      ans <<= 1;

    return ans;
  }
};",2568
2566,"class LazySegmentTree {
 public:
  explicit LazySegmentTree(const vector<int>& nums) {
    const int n = nums.size();
    tree.resize(4 * n);
    lazy.resize(4 * n);
    build(nums, 0, 0, n - 1);
  }

  //            i := index of the current node
  // [start, end] := range of the current node
  //       [l, r] := range of the query
  void updateRange(int i, int start, int end, int l, int r) {
    if (lazy[i])
      propogate(i, start, end);
    if (start > r || end < l)
      return;
    if (start >= l && end <= r) {
      flip(i, start, end);
      return;
    }
    const int mid = (start + end) / 2;
    updateRange(i * 2 + 1, start, mid, l, r);
    updateRange(i * 2 + 2, mid + 1, end, l, r);
    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];
  }

  int getTreeSum() const {
    return tree[0];
  }

 private:
  vector<int> tree;
  vector<bool> lazy;

  void build(const vector<int>& nums, int i, int start, int end) {
    if (start == end) {
      tree[i] = nums[start];
      return;
    }
    const int mid = (start + end) / 2;
    build(nums, 2 * i + 1, start, mid);
    build(nums, 2 * i + 2, mid + 1, end);
    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];
  }

  void propogate(int i, int start, int end) {
    flip(i, start, end);
    lazy[i] = false;
  }

  void flip(int i, int start, int end) {
    tree[i] = (end - start + 1) - tree[i];  // Flip 0/1.
    if (start < end) {
      lazy[2 * i + 1] = !lazy[2 * i + 1];
      lazy[2 * i + 2] = !lazy[2 * i + 2];
    }
  }
};

class Solution {
 public:
  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,
                                vector<vector<int>>& queries) {
    vector<long long> ans;
    LazySegmentTree tree(nums1);
    long long sumNums2 = accumulate(nums2.begin(), nums2.end(), 0LL);

    for (const vector<int>& query : queries) {
      const int type = query[0];
      const int l = query[1];
      const int r = query[2];
      if (type == 1) {
        tree.updateRange(0, 0, nums1.size() - 1, l, r);
      } else if (type == 2) {
        sumNums2 += static_cast<long long>(l) * tree.getTreeSum();
      } else {  // type == 3
        ans.push_back(sumNums2);
      }
    }

    return ans;
  }
};",2569
2567,"class Solution {
 public:
  vector<vector<int>> mergeArrays(vector<vector<int>>& nums1,
                                  vector<vector<int>>& nums2) {
    constexpr int kMax = 1000;
    vector<vector<int>> ans;
    vector<int> count(kMax + 1);

    addCount(nums1, count);
    addCount(nums2, count);

    for (int i = 1; i <= kMax; ++i)
      if (count[i] > 0)
        ans.push_back({i, count[i]});

    return ans;
  }

 private:
  void addCount(const vector<vector<int>>& nums, vector<int>& count) {
    for (const vector<int>& idAndVal : nums) {
      const int id = idAndVal[0];
      const int val = idAndVal[1];
      count[id] += val;
    }
  }
};",2570
2568,"class Solution {
 public:
  int minOperations(int n) {
    // The strategy is that when the end of n is
    //   1. consecutive 1s, add 1 (2^0).
    //   2. single 1, substract 1 (2^0).
    //   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.
    //
    // e.g.
    //
    //         n = 0b101
    // n -= 2^0 -> 0b100
    // n -= 2^2 -> 0b0
    //         n = 0b1011
    // n += 2^0 -> 0b1100
    // n -= 2^2 -> 0b1000
    // n -= 2^3 -> 0b0
    int ans = 0;

    while (n > 0)
      if ((n & 3) == 3) {
        ++n;
        ++ans;
      } else if ((n & 1) == 1) {
        --n;
        ++ans;
      } else {
        n >>= 1;
      }

    return ans;
  }
};",2571
2569,"class Solution {
 public:
  int squareFreeSubsets(vector<int>& nums) {
    vector<vector<int>> mem(nums.size(),
                            vector<int>(1 << (kPrimesCount + 1), -1));
    vector<int> masks;

    for (const int num : nums)
      masks.push_back(getMask(num));

    // -1 means that we take no number.
    // `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.
    return (squareFreeSubsets(masks, 0, /*used=*/1, mem) - 1 + kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  static constexpr int kPrimesCount = 10;
  static constexpr int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

  int squareFreeSubsets(const vector<int>& masks, int i, int used,
                        vector<vector<int>>& mem) {
    if (i == masks.size())
      return 1;
    if (mem[i][used] != -1)
      return mem[i][used];
    const int pick = (masks[i] & used) == 0
                         ? squareFreeSubsets(masks, i + 1, used | masks[i], mem)
                         : 0;
    const int skip = squareFreeSubsets(masks, i + 1, used, mem);
    return mem[i][used] = (pick + skip) % kMod;
  }

  // e.g. num = 10 = 2 * 5, so mask = 0b101 -> 0b1010 (append a 0)
  //      num = 15 = 3 * 5, so mask = 0b110 -> 0b1100 (append a 0)
  //      num = 25 = 5 * 5, so mask =  0b-1 -> 0b1..1 (invalid)
  int getMask(int num) {
    int mask = 0;
    for (int i = 0; i < sizeof(primes) / sizeof(int); ++i) {
      int rootCount = 0;
      while (num % primes[i] == 0) {
        num /= primes[i];
        ++rootCount;
      }
      if (rootCount >= 2)
        return -1;
      if (rootCount == 1)
        mask |= 1 << i;
    }
    return mask << 1;
  }
};",2572
2570,"class Solution {
 public:
  string findTheString(vector<vector<int>>& lcp) {
    const int n = lcp.size();
    constexpr char nonLetter = 'a' - 1;
    char c = nonLetter;
    vector<char> word(n, nonLetter);

    for (int i = 0; i < n; ++i) {
      if (word[i] != nonLetter)  // There's a candidate already.
        continue;
      if (++c > 'z')  // Run out of letters, so return """".
        return """";
      // No need to consider [0..i - 1] since they were considered.
      for (int j = i; j < n; ++j)
        if (lcp[i][j] > 0)
          word[j] = c;
    }

    // Check if `word` is valid.
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        const int nextLcp = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;
        const int currLcp = word[i] == word[j] ? 1 + nextLcp : 0;
        if (lcp[i][j] != currLcp)
          return """";
      }

    string ans;
    for (const char c : word)
      ans += c;
    return ans;
  }
};",2573
2571,"class Solution {
 public:
  vector<int> leftRigthDifference(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    vector<int> leftSum(n);
    vector<int> rightSum(n);
    int prefix = 0;
    int suffix = 0;

    for (int i = 0; i < n; ++i) {
      if (i > 0)
        prefix += nums[i - 1];
      leftSum[i] = prefix;
    }

    for (int i = n - 1; i >= 0; --i) {
      if (i + 1 < n)
        suffix += nums[i + 1];
      rightSum[i] = suffix;
    }

    for (int i = 0; i < n; ++i)
      ans[i] = abs(leftSum[i] - rightSum[i]);

    return ans;
  }
};",2574
2572,"class Solution {
 public:
  vector<int> divisibilityArray(string word, int m) {
    vector<int> ans;
    long long prevRemainder = 0;

    for (const char c : word) {
      const long long remainder = (prevRemainder * 10 + (c - '0')) % m;
      ans.push_back(remainder == 0 ? 1 : 0);
      prevRemainder = remainder;
    }

    return ans;
  }
};",2575
2573,"class Solution {
 public:
  int maxNumOfMarkedIndices(vector<int>& nums) {
    ranges::sort(nums);

    int l = 0;
    int r = nums.size() / 2 + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (isPossible(nums, m))
        l = m + 1;
      else
        r = m;
    }

    return (l - 1) * 2;
  }

 private:
  bool isPossible(const vector<int>& nums, int m) {
    for (int i = 0; i < m; ++i)
      if (2 * nums[i] > nums[nums.size() - m + i])
        return false;
    return true;
  }
};",2576
2574,"class Solution {
 public:
  int minimumTime(vector<vector<int>>& grid) {
    if (grid[0][1] > 1 && grid[1][0] > 1)
      return -1;

    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    const int m = grid.size();
    const int n = grid[0].size();
    using T = tuple<int, int, int>;  // (time, i, j)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<bool>> seen(m, vector<bool>(n));

    minHeap.emplace(0, 0, 0);
    seen[0][0] = true;

    while (!minHeap.empty()) {
      const auto [time, i, j] = minHeap.top();
      minHeap.pop();
      if (i == m - 1 && j == n - 1)
        return time;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        const int extraWait = (grid[x][y] - time) % 2 == 0 ? 1 : 0;
        const int nextTime = max(time + 1, grid[x][y] + extraWait);
        minHeap.emplace(nextTime, x, y);
        seen[x][y] = true;
      }
    }

    throw;
  }
};",2577
2575,"class Solution {
 public:
  int splitNum(int num) {
    string num1;
    string num2;
    string s = to_string(num);

    ranges::sort(s);

    for (int i = 0; i < s.length(); ++i)
      if (i % 2 == 0)
        num1 += s[i];
      else
        num2 += s[i];

    return stoi(num1) + stoi(num2);
  }
};",2578
2576,"class Solution {
 public:
  long long coloredCells(int n) {
    return 1LL * n * n + 1LL * (n - 1) * (n - 1);
  }
};",2579
2577,"class Solution {
 public:
  int countWays(vector<vector<int>>& ranges) {
    constexpr int kMod = 1'000'000'007;
    int ans = 1;
    int prevEnd = -1;

    ranges::sort(ranges);

    for (const vector<int>& range : ranges) {
      const int start = range[0];
      const int end = range[1];
      if (start > prevEnd)
        ans = ans * 2 % kMod;
      prevEnd = max(prevEnd, end);
    }

    return ans;
  }
};",2580
2578,"class Solution {
 public:
  int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses,
                int k) {
    int ans = 0;
    const int n = edges.size() + 1;
    vector<vector<int>> graph(n);
    vector<unordered_set<int>> guessGraph(n);
    vector<int> parent(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (const vector<int>& guess : guesses) {
      const int u = guess[0];
      const int v = guess[1];
      guessGraph[u].insert(v);
    }

    // Precalculate `parent`.
    dfs(graph, 0, /*prev=*/-1, parent);

    // Calculate `correctGuess` for tree rooted at 0.
    int correctGuess = 0;
    for (int i = 1; i < n; ++i)
      if (guessGraph[parent[i]].count(i))
        ++correctGuess;

    reroot(graph, 0, /*prev=*/-1, correctGuess, guessGraph, k, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, int prev,
           vector<int>& parent) {
    parent[u] = prev;
    for (const int v : graph[u])
      if (v != prev)
        dfs(graph, v, u, parent);
  }

  void reroot(const vector<vector<int>>& graph, int u, int prev,
              int correctGuess, const vector<unordered_set<int>>& guessGraph,
              const int& k, int& ans) {
    if (u != 0) {
      // The tree is rooted at u, so a guess edge (u, prev) will match the new
      // `parent` relationship.
      if (guessGraph[u].count(prev))
        ++correctGuess;
      // A guess edge (prev, u) matching the old `parent` relationship will no
      // longer be true.
      if (guessGraph[prev].count(u))
        --correctGuess;
    }
    if (correctGuess >= k)
      ++ans;
    for (const int v : graph[u])
      if (v != prev)
        reroot(graph, v, u, correctGuess, guessGraph, k, ans);
  }
};",2581
2579,"class Solution {
 public:
  int passThePillow(int n, int time) {
    // Repeat every (n - 1) * 2 seconds.
    time %= (n - 1) * 2;
    if (time < n)  // Go forward from 1.
      return 1 + time;
    return n - (time - (n - 1));  // Go backward from n.
  }
};",2582
2580,"class Solution {
 public:
  long long kthLargestLevelSum(TreeNode* root, int k) {
    vector<long long> levelSums;
    dfs(root, 0, levelSums);
    if (levelSums.size() < k)
      return -1;

    nth_element(levelSums.begin(), levelSums.begin() + k - 1, levelSums.end(),
                greater<>());
    return levelSums[k - 1];
  }

 private:
  void dfs(TreeNode* root, int level, vector<long long>& levelSums) {
    if (root == nullptr)
      return;
    if (levelSums.size() == level)
      levelSums.push_back(0);
    levelSums[level] += root->val;
    dfs(root->left, level + 1, levelSums);
    dfs(root->right, level + 1, levelSums);
  }
};",2583
2581,"class Solution {
 public:
  int findValidSplit(vector<int>& nums) {
    unordered_map<int, int> leftPrimeFactors;
    unordered_map<int, int> rightPrimeFactors;

    for (const int num : nums)
      for (const int primeFactor : getPrimeFactors(num))
        ++rightPrimeFactors[primeFactor];

    for (int i = 0; i < nums.size() - 1; ++i) {
      for (const int primeFactor : getPrimeFactors(nums[i])) {
        if (--rightPrimeFactors[primeFactor] == 0) {
          // rightPrimeFactors[primeFactor] == 0, so no need to track
          // leftPrimeFactors[primeFactor].
          rightPrimeFactors.erase(primeFactor);
          leftPrimeFactors.erase(primeFactor);
        } else {
          // Otherwise, need to track leftPrimeFactors[primeFactor].
          ++leftPrimeFactors[primeFactor];
        }
      }
      if (leftPrimeFactors.empty())
        return i;
    }

    return -1;
  }

 private:
  // Gets the prime factors under sqrt(10^6).
  vector<int> getPrimeFactors(int num) {
    vector<int> primeFactors;
    for (int divisor = 2; divisor <= min(1000, num); ++divisor)
      if (num % divisor == 0) {
        primeFactors.push_back(divisor);
        while (num % divisor == 0)
          num /= divisor;
      }
    // Handle the case that `num` contains a prime factor > 1000.
    if (num > 1)
      primeFactors.push_back(num);
    return primeFactors;
  }
};",2584
2582,"class Solution {
 public:
  int waysToReachTarget(int target, vector<vector<int>>& types) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := the number of ways to earn j points with the first i types
    vector<vector<int>> dp(types.size() + 1, vector<int>(target + 1));
    dp[0][0] = 1;

    for (int i = 1; i <= types.size(); ++i) {
      const int count = types[i - 1][0];
      const int mark = types[i - 1][1];
      for (int j = 0; j <= target; ++j)
        for (int solved = 0; solved <= count; ++solved)
          if (j - solved * mark >= 0) {
            dp[i][j] += dp[i - 1][j - solved * mark];
            dp[i][j] %= kMod;
          }
    }

    return dp[types.size()][target];
  }
};",2585
2583,"class Solution {
 public:
  int vowelStrings(vector<string>& words, int left, int right) {
    return count_if(words.begin() + left, words.begin() + right + 1,
                    [=](const string& word) {
      return isVowel(word.front()) && isVowel(word.back());
    });
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiou"";
    return kVowels.find(c) != string_view::npos;
  }
};",2586
2584,"class Solution {
 public:
  int maxScore(vector<int>& nums) {
    long long prefix = 0;

    ranges::sort(nums, greater<>());

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      if (prefix <= 0)
        return i;
    }

    return nums.size();
  }
};",2587
2585,"class Solution {
 public:
  long long beautifulSubarrays(vector<int>& nums) {
    // A subarray is beautiful if xor(subarray) = 0.
    long long ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixCount{{0, 1}};

    for (const int num : nums) {
      prefix ^= num;
      ans += prefixCount[prefix]++;
    }

    return ans;
  }
};",2588
2586,"class Solution {
 public:
  int findMinimumTime(vector<vector<int>>& tasks) {
    constexpr int kMax = 2000;
    vector<bool> running(kMax + 1);

    // Sort tasks by end.
    sort(
        tasks.begin(), tasks.end(),
        [](const vector<int>& a, const vector<int>& b) { return a[1] < b[1]; });

    for (const vector<int>& task : tasks) {
      const int start = task[0];
      const int end = task[1];
      const int duration = task[2];
      int neededDuration = duration - count(running.begin() + start,
                                            running.begin() + end + 1, true);
      // Greedily run the task as late as possible so that later tasks can run
      // simultaneously.
      for (int i = end; neededDuration > 0; --i) {
        if (!running[i]) {
          running[i] = true;
          --neededDuration;
        }
      }
    }

    return ranges::count(running, true);
  }
};",2589
2587,"addTask(userId: int, taskDescription, str, dueDate: int, tags: List[str])",2590
2588,"class Solution {
 public:
  int distMoney(int money, int children) {
    // Everyone must receive at least 1 dollar.
    money -= children;
    if (money < 0)
      return -1;

    const int count7 = money / 7;
    const int remaining = money % 7;

    // Distribute 8 dollars to every child.
    if (count7 == children && remaining == 0)
      return count7;

    // Need to move 1 dollar from the last child with 4 dollars to one of other
    // children. That's why we need to substract 1.
    if (count7 == children - 1 && remaining == 3)
      return count7 - 1;

    // Though there might be child with 4 dollars, since count7 < children - 1,
    // we have ""extra"" spot to move money to if needed.
    return min(children - 1, count7);
  }
};",2591
2589,"class Solution {
 public:
  int maximizeGreatness(vector<int>& nums) {
    int ans = 0;

    ranges::sort(nums);

    for (const int num : nums)
      if (num > nums[ans])
        ++ans;

    return ans;
  }
};",2592
2590,"class Solution {
 public:
  long long findScore(vector<int>& nums) {
    long long ans = 0;
    set<pair<int, int>> numAndIndices;
    vector<bool> seen(nums.size());

    for (int i = 0; i < nums.size(); ++i)
      numAndIndices.insert({nums[i], i});

    for (const auto& [num, i] : numAndIndices) {
      if (seen[i])
        continue;
      if (i > 0)
        seen[i - 1] = true;
      if (i + 1 < nums.size())
        seen[i + 1] = true;
      seen[i] = true;
      ans += num;
    }

    return ans;
  }
};",2593
2591,"class Solution {
 public:
  long long repairCars(vector<int>& ranks, int cars) {
    long long l = 0;
    long long r = 1LL * ranges::min(ranks) * cars * cars;

    while (l < r) {
      const long long m = (l + r) / 2;
      if (numCarsFixed(ranks, m) >= cars)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  long long numCarsFixed(const vector<int>& ranks, long long minutes) {
    long long carsFixed = 0;
    //    r * n^2 = minutes
    // -> n = sqrt(minutes / r)
    for (const int rank : ranks)
      carsFixed += sqrt(minutes / rank);
    return carsFixed;
  }
};",2594
2592,"class Solution {
 public:
  vector<int> evenOddBit(int n) {
    vector<int> ans(2);
    int i = 0;  // 0 := even, 1 := odd

    while (n > 0) {
      ans[i] += n & 1;
      n >>= 1;
      i ^= 1;
    }

    return ans;
  }
};",2595
2593,"class Solution {
 public:
  bool checkValidGrid(vector<vector<int>>& grid) {
    const int n = grid.size();
    int i = 0;
    int j = 0;

    for (int target = 1; target < n * n; ++target) {
      const auto [x, y] = nextGrid(grid, i, j, target);
      if (x == -1 && y == -1)
        return false;
      // Move (x, y) to (i, j).
      i = x;
      j = y;
    }

    return true;
  }

 private:
  const vector<pair<int, int>> dirs{{-2, 1}, {-1, 2}, {1, 2},   {2, 1},
                                    {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};

  // Returns (x, y), where grid[x][y] == target if (i, j) can reach target.
  pair<int, int> nextGrid(const vector<vector<int>>& grid, int i, int j,
                          int target) {
    const int n = grid.size();
    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x >= n || y < 0 || y >= n)
        continue;
      if (grid[x][y] == target)
        return {x, y};
    }
    return {-1, -1};
  }
};",2596
2594,"// e.g. nums = [2, 3, 4, 4], k = 2
//
// subset[0] = [2, 4, 4']
// subset[1] = [1]
// count = {2: 1, 4: 2, 1: 1}
//
// Initially, skip = len([]) = 0, pick = len([]) = 0
//
// * For values in subset[0]:
//   After 2:
//     skip = skip + pick = len([]) = 0
//     pick = (2^count[2] - 1) * (1 + skip + pick)
//          = len([[2]]) * len([[]])
//          = len([[2]]) = 1
//   After 4:
//     skip = skip + pick = len([[2]]) = 1
//     pick = (2^count[4] - 1) * (1 + skip)
//          = len([[4], [4'], [4, 4']]) * len([[]])
//          = len([[4], [4'], [4, 4']]) = 3
//
// * For values in subset[1]:
//   After 1:
//     skip = skip + pick
//          = len([[2], [4], [4'], [4, 4']]) = 4
//     pick = (2^count[1] - 1) * (1 + skip + pick)
//          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])
//          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5
//
// So, ans = skip + pick = 9

class Solution {
 public:
  int beautifulSubsets(vector<int>& nums, int k) {
    constexpr int kMaxNum = 1000;
    vector<int> count(kMaxNum + 1);
    unordered_map<int, set<int>> modToSubset;

    for (const int num : nums) {
      ++count[num];
      modToSubset[num % k].insert(num);
    }

    int prevNum = -k;
    int skip = 0;
    int pick = 0;

    for (const auto& [_, subset] : modToSubset)
      for (const int num : subset) {
        const int nonEmptyCount = pow(2, count[num]) - 1;
        const int cacheSkip = skip;
        skip += pick;
        pick =
            nonEmptyCount * (1 + cacheSkip + (num - prevNum == k ? 0 : pick));
        prevNum = num;
      }

    return skip + pick;
  }
};",2597
2595,"class Solution {
 public:
  int findSmallestInteger(vector<int>& nums, int value) {
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[(num % value + value) % value];

    for (int i = 0; i < nums.size(); ++i)
      if (--count[i % value] < 0)
        return i;

    return nums.size();
  }
};",2598
2596,"class Solution {
 public:
  int makePrefSumNonNegative(vector<int>& nums) {
    int ans = 0;
    long long prefix = 0;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int num : nums) {
      prefix += num;
      if (num < 0)
        minHeap.push(num);
      while (prefix < 0) {
        prefix -= minHeap.top(), minHeap.pop();
        ++ans;
      }
    }

    return ans;
  }
};",2599
2597,"class Solution {
 public:
  int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
    if (k <= numOnes)
      return k;
    if (k <= numOnes + numZeros)
      return numOnes;
    return numOnes - (k - numOnes - numZeros);
  }
};",2600
2598,"class Solution {
 public:
  bool primeSubOperation(vector<int>& nums) {
    constexpr int kMax = 1000;
    const vector<int> primes = sieveEratosthenes(kMax);

    int prevNum = 0;
    for (int num : nums) {
      // Make nums[i] the smallest as possible and still > nums[i - 1].
      const auto it = ranges::lower_bound(primes, num - prevNum);
      if (it != primes.begin())
        num -= *prev(it);
      if (num <= prevNum)
        return false;
      prevNum = num;
    }

    return true;
  }

  vector<int> sieveEratosthenes(int n) {
    vector<int> primes;
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    for (int i = 2; i < n; ++i)
      if (isPrime[i])
        primes.push_back(i);
    return primes;
  }
};",2601
2599,"class Solution {
 public:
  vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {
    const int n = nums.size();
    vector<long long> ans;
    vector<long long> prefix{0};

    ranges::sort(nums);

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    for (const long long query : queries) {
      const int i = ranges::upper_bound(nums, query) - nums.begin();
      // Since nums[0..i) <= query, nums[i..n) > `query`, we should
      // - increase each num in nums[0..i) to `query` and
      // - decrease each num in nums[i..n) to `query`.
      const long long inc = query * i - prefix[i];
      const long long dec = prefix[n] - prefix[i] - query * (n - i);
      ans.push_back(inc + dec);
    }

    return ans;
  }
};",2602
2600,"class Solution {
 public:
  int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {
    const int n = coins.size();
    vector<unordered_set<int>> tree(n);
    queue<int> leavesToBeRemoved;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].insert(v);
      tree[v].insert(u);
    }

    for (int i = 0; i < n; ++i) {
      int u = i;
      // Remove the leaves that don't have coins.
      while (tree[u].size() == 1 && coins[u] == 0) {
        const int v = *tree[u].begin();
        tree[u].clear();
        tree[v].erase(u);
        u = v;  // Walk up to its parent.
      }
      // After trimming leaves without coins, leaves with coins may satisfy
      // `leavesToBeRemoved`.
      if (tree[u].size() == 1)
        leavesToBeRemoved.push(u);
    }

    // Remove each remaining leaf node and its parent. The remaining nodes are
    // the ones that must be visited.
    for (int i = 0; i < 2; ++i)
      for (int sz = leavesToBeRemoved.size(); sz > 0; --sz) {
        const int u = leavesToBeRemoved.front();
        leavesToBeRemoved.pop();
        if (!tree[u].empty()) {
          const int v = *tree[u].begin();
          tree[u].clear();
          tree[v].erase(u);
          if (tree[v].size() == 1)
            leavesToBeRemoved.push(v);
        }
      }

    return accumulate(tree.begin(), tree.end(), 0,
                      [](int subtotal, const unordered_set<int>& children) {
      return subtotal + children.size();
    });
  }
};",2603
2601,"class Solution {
 public:
  int minimumTime(vector<int>& hens, vector<int>& grains) {
    ranges::sort(hens);
    ranges::sort(grains);

    const int maxPosition = max(ranges::max(hens), ranges::max(grains));
    const int minPosition = min(ranges::min(hens), ranges::min(grains));
    int l = 0;
    int r = 1.5 * (maxPosition - minPosition);

    while (l < r) {
      const int m = (l + static_cast<long>(r)) / 2;
      if (canEat(hens, grains, m))
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns true if `hens` can eat all `grains` within `time`.
  bool canEat(const vector<int>& hens, const vector<int>& grains, int time) {
    int i = 0;  // grains[i] := next grain to be ate
    for (const int hen : hens) {
      int moves = time;
      if (grains[i] < hen) {
        // `hen` needs go back to eat `grains[i]`.
        const int leftMoves = hen - grains[i];
        if (leftMoves > time)
          return false;
        const int leftThenRight = time - 2 * leftMoves;
        const int rightThenLeft = (time - leftMoves) / 2;
        moves = max({0, leftThenRight, rightThenLeft});
      }
      i = ranges::upper_bound(grains, hen + moves) - grains.begin();
      if (i == grains.size())
        return true;
    }
    return false;
  }
};",2604
2602,"class Solution {
 public:
  int minNumber(vector<int>& nums1, vector<int>& nums2) {
    int ans = 89;  // the largest num we can have
    for (const int a : nums1)
      for (const int b : nums2)
        ans = min(ans, a == b ? a : min(a, b) * 10 + max(a, b));
    return ans;
  }
};",2605
2603,"class Solution {
 public:
  int maximumCostSubstring(string s, string chars, vector<int>& vals) {
    int ans = 0;
    int cost = 0;
    vector<int> costs(26);  // costs[i] := the cost of 'a' + i

    iota(costs.begin(), costs.end(), 1);

    for (int i = 0; i < chars.size(); ++i)
      costs[chars[i] - 'a'] = vals[i];

    for (const char c : s) {
      cost = max(0, cost + costs[c - 'a']);
      ans = max(ans, cost);
    }

    return ans;
  }
};",2606
2604,"class Solution {
 public:
  long long makeSubKSumEqual(vector<int>& arr, int k) {
    // If the sum of each subarray of length k is equal, then `arr` must have a
    // repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have
    // sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==
    // arr[(i + k) % n] for every i.
    const int n = arr.size();
    long long ans = 0;
    vector<bool> seen(n);

    for (int i = 0; i < n; ++i) {
      vector<int> groups;
      int j = i;
      while (!seen[j]) {
        groups.push_back(arr[j]);
        seen[j] = true;
        j = (j + k) % n;
      }
      nth_element(groups.begin(), groups.begin() + groups.size() / 2,
                  groups.end());
      for (const int num : groups)
        ans += abs(num - groups[groups.size() / 2]);
    }

    return ans;
  }
};",2607
2605,"class Solution {
 public:
  int findShortestCycle(int n, vector<vector<int>>& edges) {
    int ans = kInf;
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i)
      ans = min(ans, bfs(graph, i));

    return ans == kInf ? -1 : ans;
  }

 private:
  static constexpr int kInf = 1001;

  // Returns the length of the minimum cycle by starting BFS from node `i`.
  // Returns `kInf` if there's no cycle.
  int bfs(const vector<vector<int>>& graph, int i) {
    vector<int> dist(graph.size(), kInf);
    queue<int> q{{i}};
    dist[i] = 0;
    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u]) {
        if (dist[v] == kInf) {
          dist[v] = dist[u] + 1;
          q.push(v);
        } else if (dist[v] + 1 != dist[u]) {  // v is not a parent u.
          return dist[v] + dist[u] + 1;
        }
      }
    }
    return kInf;
  }
};",2608
2606,while,2609
2607,"class Solution {
 public:
  vector<vector<int>> findMatrix(vector<int>& nums) {
    // The number of rows we need equals the maximum frequency.
    vector<vector<int>> ans;
    vector<int> count(nums.size() + 1);

    for (const int num : nums) {
      // Construct `ans` on demand.
      if (++count[num] > ans.size())
        ans.push_back({});
      ans[count[num] - 1].push_back(num);
    }

    return ans;
  }
};",2610
2608,"class Solution {
 public:
  int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {
    // diffs[i] := reward1[i] - reward2[i].
    vector<int> diffs;

    for (int i = 0; i < reward1.size(); ++i)
      diffs.push_back(reward1[i] - reward2[i]);

    nth_element(diffs.begin(), diffs.begin() + k, diffs.end(), greater<>());
    return accumulate(reward2.begin(), reward2.end(), 0) +
           accumulate(diffs.begin(), diffs.begin() + k, 0);
  }
};",2611
2609,"class Solution {
 public:
  vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
    const unordered_set<int> bannedSet{banned.begin(), banned.end()};
    vector<int> ans(n, -1);
    // unseen[i] := the unseen numbers that % 2 == i
    vector<set<int>> unseen(2);

    for (int num = 0; num < n; ++num)
      if (num != p && !bannedSet.count(num))
        unseen[num & 1].insert(num);

    // Perform BFS from `p`.
    queue<int> q{{p}};
    ans[p] = 0;

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      const int lo = max(u - k + 1, k - 1 - u);
      const int hi = min(u + k - 1, n - 1 - (u - (n - k)));
      // Choose the correct set of numbers.
      set<int>& nums = unseen[lo & 1];
      for (auto it = nums.lower_bound(lo); it != nums.end() && *it <= hi;) {
        ans[*it] = ans[u] + 1;
        q.push(*it);
        it = nums.erase(it);
      }
    }

    return ans;
  }
};",2612
2610,"template <typename T>
class RangeQuery {
 public:
  virtual void update(int index, int val);
  virtual T query(int i, int j);

 private:
  virtual T merge(T a, T b);

 protected:
  int left(int treeIndex) {
    return 2 * treeIndex + 1;
  }

  int right(int treeIndex) {
    return 2 * treeIndex + 2;
  }
};

class SegmentTree : RangeQuery<int> {
 public:
  explicit SegmentTree(const vector<int>& nums)
      : n(nums.size()), nums(nums), tree(4 * n, -1) {}

  // Updates the value of the node to be the index of the smaller number
  // between the old value stored at the node and the new value `index`, where
  // `i` is the index of the element in the array that needs to be updated.
  void update(int i, int index) override {
    update(0, 0, n, i, index);
  }

  // Returns the index k s.t. `nums[k]` is the smallest number in nums[i..j].
  int query(int i, int j) override {
    return query(0, 0, n, i, j);
  }

 private:
  const int n;
  const vector<int> nums;  // nums2 + nums1 or nums2 - nums1
  vector<int> tree;        // tree[i] := the maximum index stored in this node

  void update(int treeIndex, int lo, int hi, int i, int index) {
    if (lo == i && hi == i) {
      tree[treeIndex] = merge(tree[treeIndex], index);
      return;
    }
    const int mid = (lo + hi) / 2;
    const int leftTreeIndex = left(treeIndex);
    const int rightTreeIndex = right(treeIndex);
    if (i <= mid)
      update(leftTreeIndex, lo, mid, i, index);
    else
      update(rightTreeIndex, mid + 1, hi, i, index);
    tree[treeIndex] = merge(tree[leftTreeIndex], tree[rightTreeIndex]);
  }

  int query(int treeIndex, int lo, int hi, int i, int j) {
    // [lo, hi] lies completely inside [i, j].
    if (i <= lo && hi <= j)
      return tree[treeIndex];
    // [lo, hi] lies completely outside [i, j].
    if (j < lo || hi < i)
      return -1;
    const int mid = (lo + hi) / 2;
    return merge(query(left(treeIndex), lo, mid, i, j),
                 query(right(treeIndex), mid + 1, hi, i, j));
  }

  // Returns the better index. Index i is better than index j if
  // (nums[i] > nums[j]) or (nums[i] == nums[j] && i < j).
  int merge(int i, int j) override {
    if (i == -1)
      return j;
    if (j == -1)
      return i;
    if (nums[i] > nums[j])
      return i;
    if (nums[j] > nums[i])
      return j;
    return min(i, j);
  }
};

class Solution {
 public:
  vector<int> beautifulPair(vector<int>& nums1, vector<int>& nums2) {
    // The goal is to find the lexicographically smallest beautiful pair (i, j)
    // s.t. |nums1[i] + nums1[j]| + |nums2[i] - nums2[j]| is the smallest.
    //
    // Sort `nums2` and store the order in `indices`.
    // To minimize |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]|, since we
    // already have sorted `nums2`, we can always have nums2[i] > nums2[j] while
    // iterating the array. So we only need to consider the following 2 cases:
    //
    // * nums1[i] >= nums1[j]:
    //   The value will be nums1[i] - nums1[j] + nums2[i] - nums2[j]
    //                   = (nums2[i] + nums1[i]) - (nums2[j] + nums1[j])
    //   Just find max (nums2[j] + nums1[j]) s.t. 0 <= nums1[j] <= nums1[i].
    //
    // * nums1[i] <= nums1[j]:
    //   The value will be nums1[j] - nums1[i] + nums2[i] - nums2[j]
    //                   = (nums2[i] - nums1[i]) - (nums2[j] + nums1[j])
    //   Just find max (nums2[j] - nums1[j]) s.t. nums1[i] <= nums1[j] <= n.
    const int n = nums1.size();
    vector<int> ans(2, n);
    vector<int> nums2PlusNums1;
    vector<int> nums2MinusNums1;
    vector<int> indices;
    int minBeauty = INT_MAX;

    for (int i = 0; i < n; ++i) {
      nums2PlusNums1.push_back(nums2[i] + nums1[i]);
      nums2MinusNums1.push_back(nums2[i] - nums1[i]);
      indices.push_back(i);
    }

    ranges::sort(indices,
                 [&nums2](int i, int j) { return nums2[i] < nums2[j]; });

    SegmentTree tree1(nums2PlusNums1);
    SegmentTree tree2(nums2MinusNums1);

    for (const int i : indices) {
      const int num = nums1[i];
      // For case nums1[i] >= nums1[j], find index j s.t. (nums2[j] + nums1[j])
      // is the maximum in the range [0, nums1[i]].
      int j = tree1.query(0, num);
      if (j >= 0)
        updateAns(nums2PlusNums1, i, j, minBeauty, ans);
      tree1.update(num, i);
      // For case nums1[i] <= nums1[j], find index j s.t. (nums2[j] - nums1[j])
      // is the maximum in the range [nums1[i], n].
      j = tree2.query(num, n);
      if (j >= 0)
        updateAns(nums2MinusNums1, i, j, minBeauty, ans);
      tree2.update(num, i);
    }

    return ans;
  }

 private:
  void updateAns(const vector<int>& nums, int i, int j, int& minBeauty,
                 vector<int>& ans) {
    // beauty := |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]|
    const int beauty = nums[i] - nums[j];
    const vector<int> nextAns = {min(i, j), max(i, j)};
    if (beauty < minBeauty) {
      minBeauty = beauty;
      ans = nextAns;
    } else if (beauty == minBeauty) {
      ans = min(ans, nextAns);
    }
  }
};",2613
2611,"class Solution {
 public:
  int diagonalPrime(vector<vector<int>>& nums) {
    int ans = 0;
    for (int i = 0; i < nums.size(); ++i) {
      const int a = nums[i][i];
      const int b = nums[i][nums.size() - i - 1];
      if (isPrime(a))
        ans = max(ans, a);
      if (isPrime(b))
        ans = max(ans, b);
    }
    return ans;
  }

 private:
  bool isPrime(int n) {
    if (n <= 1)
      return false;
    for (int i = 2; i * i <= n; ++i)
      if (n % i == 0)
        return false;
    return true;
  }
};",2614
2612,"class Solution {
 public:
  vector<long long> distance(vector<int>& nums) {
    vector<long long> ans(nums.size());
    unordered_map<int, vector<int>> numToIndices;

    for (int i = 0; i < nums.size(); ++i)
      numToIndices[nums[i]].push_back(i);

    for (const auto& [_, indices] : numToIndices) {
      const int n = indices.size();
      if (n == 1)
        continue;
      long long sumSoFar = accumulate(indices.begin(), indices.end(), 0LL);
      int prevIndex = 0;
      for (int i = 0; i < n; ++i) {
        sumSoFar += (i - 1) * (indices[i] - prevIndex);
        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex);
        ans[indices[i]] = sumSoFar;
        prevIndex = indices[i];
      }
    }

    return ans;
  }
};",2615
2613,"class Solution {
 public:
  int minimizeMax(vector<int>& nums, int p) {
    ranges::sort(nums);

    int l = 0;
    int r = nums.back() - nums.front();

    while (l < r) {
      const int m = (l + r) / 2;
      if (numPairs(nums, m) >= p)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns the number of pairs that can be obtained if the difference between
  // each pair <= `maxDiff`.
  int numPairs(const vector<int>& nums, int maxDiff) {
    int pairs = 0;
    for (int i = 1; i < nums.size(); ++i)
      // Greedily pair nums[i] with nums[i - 1].
      if (nums[i] - nums[i - 1] <= maxDiff) {
        ++pairs;
        ++i;
      }
    return pairs;
  }
};",2616
2614,"template <typename T>
class RangeQuery {
 public:
  virtual void update(int index, int val);
  virtual T query(int i, int j);

 private:
  virtual T merge(T a, T b);

 protected:
  int left(int treeIndex) {
    return 2 * treeIndex + 1;
  }

  int right(int treeIndex) {
    return 2 * treeIndex + 2;
  }
};

class SegmentTree : RangeQuery<int> {
 public:
  explicit SegmentTree(int n, int kInf) : n(n), kInf(kInf), tree(4 * n, kInf) {}

  // Updates nums[i] to val equivalently.
  void update(int i, int val) override {
    update(0, 0, n - 1, i, val);
  }

  // Returns min(nums[i..j]).
  int query(int i, int j) override {
    return query(0, 0, n - 1, i, j);
  }

 private:
  const int n;       // the size of the input array
  const int kInf;    // the invalid value
  vector<int> tree;  // the segment tree

  void update(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == i && hi == i) {
      tree[treeIndex] = val;
      return;
    }
    const int mid = (lo + hi) / 2;
    const int leftTreeIndex = left(treeIndex);
    const int rightTreeIndex = right(treeIndex);
    if (i <= mid)
      update(leftTreeIndex, lo, mid, i, val);
    else
      update(rightTreeIndex, mid + 1, hi, i, val);
    tree[treeIndex] = merge(tree[leftTreeIndex], tree[rightTreeIndex]);
  }

  int query(int treeIndex, int lo, int hi, int i, int j) {
    // [lo, hi] lies completely inside [i, j].
    if (i <= lo && hi <= j)
      return tree[treeIndex];
    // [lo, hi] lies completely outside [i, j].
    if (j < lo || hi < i)
      return kInf;
    const int mid = (lo + hi) / 2;
    return merge(query(left(treeIndex), lo, mid, i, j),
                 query(right(treeIndex), mid + 1, hi, i, j));
  }

  // Merges the result of the left node and the right node.
  int merge(int a, int b) override {
    return min(a, b);
  }
};

class Solution {
 public:
  int minimumVisitedCells(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const int kInf = (m + n) * 2 - 1;
    vector<SegmentTree> rows(m, SegmentTree(n, kInf));
    vector<SegmentTree> cols(n, SegmentTree(m, kInf));

    // The min # cells to visit (m - 1, n - 1) from (m - 1, n - 1) is 1.
    rows[m - 1].update(n - 1, 1);
    cols[n - 1].update(m - 1, 1);

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        // There's no k s.t. j < k <= 0 + j.
        // There's no k s.t. i < k <= 0 + i.
        if (grid[i][j] == 0)
          continue;
        const int moveRight = rows[i].query(j + 1, grid[i][j] + j);
        const int moveDown = cols[j].query(i + 1, grid[i][j] + i);
        const int minMove = min(kInf, min(moveRight, moveDown) + 1);
        rows[i].update(j, minMove);
        cols[j].update(i, minMove);
      }

    const int res = rows[0].query(0, 0);
    return res == kInf ? -1 : res;
  }
};",2617
2615,"function checkIfInstanceOf(obj: any, classFunction: any): boolean {
  while (obj != null) {
    if (obj.constructor === classFunction) {
      return true;
    }
    obj = Object.getPrototypeOf(obj);
  }
  return false;
}",2618
2616,"declare global {
  interface Array<T> {
    last(): T | -1;
  }
}

Array.prototype.last = function () {
  return this.length === 0 ? -1 : this[this.length - 1];
};

export {};",2619
2617,"function createCounter(n: number): () => number {
  return function () {
    return n++;
  };
}",2620
2618,"async function sleep(millis: number): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(resolve, millis);
  });
}",2621
2619,"interface Value {
  value: number;
  expiredAt: number;
}

class TimeLimitedCache {
  private cache = new Map<number, Value>();

  set(key: number, value: number, duration: number): boolean {
    const now = Date.now();
    const exists = this.getValue(now, key) !== undefined;
    this.cache.set(key, { value, expiredAt: now + duration });
    return exists;
  }

  get(key: number): number {
    const val = this.getValue(Date.now(), key);
    return val === undefined ? -1 : val.value;
  }

  count(): number {
    const now = Date.now();
    for (const key of this.cache.keys())
      if (this.getValue(now, key) === undefined) {
        this.cache.delete(key);
      }
    return this.cache.size;
  }

  private getValue(now: number, key: number): Value | undefined {
    const val = this.cache.get(key);
    return val && now <= val.expiredAt ? val : undefined;
  }
}",2622
2620,"type Fn = (...params: number[]) => number;

function memoize(fn: Fn): Fn {
  const cache: Record<string, number> = {};
  return function (...args) {
    const key = args.join(' ');
    return cache[key] === undefined ? (cache[key] = fn(...args)) : cache[key];
  };
}",2623
2621,"declare global {
  interface Array<T> {
    snail(rowsCount: number, colsCount: number): number[][];
  }
}

Array.prototype.snail = function (
  rowsCount: number,
  colsCount: number
): number[][] {
  if (rowsCount * colsCount != this.length) {
    return [];
  }
  const ans: number[][] = [];
  for (let i = 0; i < rowsCount; ++i) {
    ans.push([]);
  }
  for (let i = 0; i < rowsCount; ++i)
    for (let j = 0; j < colsCount; ++j) {
      const k = j * rowsCount + (j % 2 == 0 ? i : rowsCount - 1 - i);
      ans[i][j] = this[k];
    }
  return ans;
};",2624
2622,"type MultiDimensionalArray = (number | MultiDimensionalArray)[];

var flat = function (
  arr: MultiDimensionalArray,
  n: number
): MultiDimensionalArray {
  function dfs(arr: number | MultiDimensionalArray, n: number) {
    if (typeof arr === 'number') {
      ans.push(arr);
    } else if (n === 0) {
      for (const element of arr) {
        ans.push(element);
      }
    } else {
      for (const element of arr) {
        dfs(element, n - 1);
      }
    }
  }
  const ans: MultiDimensionalArray = [];
  dfs(arr, n);
  return ans;
};",2625
2623,"type Fn = (accum: number, curr: number) => number;

function reduce(nums: number[], fn: Fn, init: number): number {
  let ans = init;
  for (const num of nums) {
    ans = fn(ans, num);
  }
  return ans;
}",2626
2624,"type F = (...args: number[]) => void;

function debounce(fn: F, t: number): F {
  let timeout: ReturnType<typeof setTimeout> | undefined;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), t);
  };
}",2627
2625,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function areDeeplyEqual(o1: JSONValue, o2: JSONValue): boolean {
  if (o1 === o2) {
    return true;
  }
  if (o1 === null || o1 === undefined || o2 === null || o2 === undefined) {
    return false;
  }
  if (typeof o1 !== 'object' || typeof o2 !== 'object') {
    return false;
  }
  if (Array.isArray(o1) !== Array.isArray(o2)) {
    return false;
  }
  if (Object.keys(o1).length != Object.keys(o2).length) {
    return false;
  }
  for (const key in o1) {
    if (!areDeeplyEqual(o1[key], o2[key])) {
      return false;
    }
  }
  return true;
}",2628
2626,"type F = (x: number) => number;

function compose(functions: F[]): F {
  return function (x) {
    return functions.reduceRight((val, f) => f(val), x);
  };
}",2629
2627,"type Fn = (...params: any) => any;

function memoize(fn: Fn): Fn {
  const root = new Map(); // trie
  const ansKey = {};
  return function (...params) {
    let node = root;
    for (const param of params) {
      let next = node.get(param);
      if (next === undefined) {
        next = new Map();
        node.set(param, next);
      }
      node = next;
    }

    // Check if `ansKey` has been set.
    if (node.has(ansKey)) return node.get(ansKey);
    const ans = fn(...params);
    node.set(ansKey, ans);
    return ans;
  };
}",2630
2628,"declare global {
  interface Array<T> {
    groupBy(fn: (item: T) => string): Record<string, T[]>;
  }
}

Array.prototype.groupBy = function (fn) {
  const ans: Record<string, any[]> = {};
  for (const item of this) {
    const key = fn(item);
    if (ans[key] === undefined) {
      ans[key] = [];
    }
    ans[key].push(item);
  }
  return ans;
};",2631
2629,"function curry(fn: Function): Function {
  return function curried(...args: any[]): any {
    return args.length >= fn.length
      ? fn.apply(this, args)
      : curried.bind(this, ...args);
  };
}",2632
2630,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function jsonStringify(object: JSONValue): string {
  if (object === null) {
    return 'null';
  }
  if (typeof object === 'boolean' || typeof object === 'number') {
    return String(object);
  }
  if (typeof object === 'string') {
    return `""${object}""`;
  }
  if (Array.isArray(object)) {
    const elems = object.map((elem) => jsonStringify(elem));
    return `[${elems.join(',')}]`;
  }
  // typeof object === 'object'
  const pairs = Object.keys(object).map(
    (key) => `""${key}"":${jsonStringify(object[key])}`
  );
  return `{${pairs.join(',')}}`;
}",2633
2631,"type Fn = (n: number, i: number) => any;

function filter(arr: number[], fn: Fn): number[] {
  const ans: number[] = [];
  arr.forEach((a, index) => {
    if (fn(a, index)) {
      ans.push(a);
    }
  });
  return ans;
}",2634
2632,"function map(arr: number[], fn: (n: number, i: number) => number): number[] {
  const ans: number[] = [];
  arr.forEach((a, index) => {
    ans.push(fn(a, index));
  });
  return ans;
}",2635
2633,"type F = () => Promise<any>;

function promisePool(functions: F[], n: number): Promise<any> {
  const next = () => functions[n++]?.().then(next);
  return Promise.all(functions.slice(0, n).map((f) => f().then(next)));
}",2636
2634,"type Fn = (...params: any[]) => Promise<any>;

function timeLimit(fn: Fn, t: number): Fn {
  return async function (...args) {
    const p1 = new Promise((_, reject) => {
      setTimeout(() => reject('Time Limit Exceeded'), t);
    });
    const p2 = fn(...args);
    return Promise.race([p1, p2]);
  };
}",2637
2635,"class Solution {
 public:
  // Similar to 2597. The Number of Beautiful Subsets
  long long countTheNumOfKFreeSubsets(vector<int>& nums, int k) {
    unordered_map<int, set<int>> modToSubset;

    for (const int num : nums)
      modToSubset[num % k].insert(num);

    int prevNum = -k;
    long long skip = 0;
    long long pick = 0;

    for (const auto& [_, subset] : modToSubset)
      for (const int num : subset) {
        const long long cacheSkip = skip;
        skip += pick;
        pick = 1 + cacheSkip + (num - prevNum == k ? 0 : pick);
        prevNum = num;
      }

    return 1 + skip + pick;
  }
};",2638
2636,"class Solution {
 public:
  vector<int> findColumnWidth(vector<vector<int>>& grid) {
    vector<int> ans;

    for (int j = 0; j < grid[0].size(); ++j) {
      ans.push_back(0);
      for (int i = 0; i < grid.size(); ++i)
        ans[j] = max(ans[j], static_cast<int>(to_string(grid[i][j]).length()));
    }

    return ans;
  }
};",2639
2637,"class Solution {
 public:
  vector<long long> findPrefixScore(vector<int>& nums) {
    vector<long long> ans;
    long long prefix = 0;
    int maxi = 0;

    for (const int num : nums) {
      maxi = max(maxi, num);
      prefix += num + maxi;
      ans.push_back(prefix);
    }

    return ans;
  }
};",2640
2638,"class Solution {
 public:
  TreeNode* replaceValueInTree(TreeNode* root) {
    vector<int> levelSums;
    dfs(root, 0, levelSums);
    return replace(root, 0, new TreeNode(0), levelSums);
  }

 private:
  void dfs(TreeNode* root, int level, vector<int>& levelSums) {
    if (root == nullptr)
      return;
    if (levelSums.size() == level)
      levelSums.push_back(0);
    levelSums[level] += root->val;
    dfs(root->left, level + 1, levelSums);
    dfs(root->right, level + 1, levelSums);
  }

  TreeNode* replace(TreeNode* root, int level, TreeNode* curr,
                    const vector<int>& levelSums) {
    const int nextLevel = level + 1;
    const int nextLevelCousinsSum =
        nextLevel >= levelSums.size()
            ? 0
            : levelSums[nextLevel] -
                  (root->left == nullptr ? 0 : root->left->val) -
                  (root->right == nullptr ? 0 : root->right->val);
    if (root->left != nullptr) {
      curr->left = new TreeNode(nextLevelCousinsSum);
      replace(root->left, level + 1, curr->left, levelSums);
    }
    if (root->right != nullptr) {
      curr->right = new TreeNode(nextLevelCousinsSum);
      replace(root->right, level + 1, curr->right, levelSums);
    }
    return curr;
  }
};",2641
2639,addEdge(self: List[int]),2642
2640,"class Solution {
 public:
  vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {
    vector<int> ans{0, 0};

    for (int i = 0; i < mat.size(); ++i) {
      const int ones = ranges::count(mat[i], 1);
      if (ones > ans[1]) {
        ans[0] = i;
        ans[1] = ones;
      }
    }

    return ans;
  }
};",2643
2641,"class Solution {
 public:
  int maxDivScore(vector<int>& nums, vector<int>& divisors) {
    int ans = -1;
    int maxScore = -1;

    for (const int divisor : divisors) {
      const int score = ranges::count_if(
          nums, [divisor](const int num) { return num % divisor == 0; });
      if (score > maxScore) {
        ans = divisor;
        maxScore = score;
      } else if (score == maxScore) {
        ans = min(ans, divisor);
      }
    }

    return ans;
  }
};",2644
2642,"class Solution {
 public:
  int addMinimum(string word) {
    const string letters = ""abc"";
    int ans = 0;
    int i = 0;

    while (i < word.length())
      for (const char c : letters) {
        if (i < word.length() && word[i] == c)
          ++i;
        else
          ++ans;
      }

    return ans;
  }
};",2645
2643,"class Solution {
 public:
  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price,
                        vector<vector<int>>& trips) {
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // count[i] := the number of times node i is traversed
    vector<int> count(n);

    for (const vector<int>& trip : trips) {
      const int start = trip[0];
      const int end = trip[1];
      vector<int> path;
      dfsCount(graph, start, /*prev=*/-1, end, count, path);
    }

    vector<vector<int>> mem(n, vector<int>(2, -1));
    return dfs(graph, 0, -1, price, count, false, mem);
  }

 private:
  void dfsCount(const vector<vector<int>>& graph, int u, int prev, int end,
                vector<int>& count, vector<int>& path) {
    path.push_back(u);
    if (u == end) {
      for (const int i : path)
        ++count[i];
      return;
    }
    for (const int v : graph[u])
      if (v != prev)
        dfsCount(graph, v, u, end, count, path);
    path.pop_back();
  }

  // Returns the minimum price sum for the i-th node, where its parent is
  // halved parent or not halved not.
  int dfs(const vector<vector<int>>& graph, int u, int prev,
          const vector<int>& price, const vector<int>& count, int parentHalved,
          vector<vector<int>>& mem) {
    if (mem[u][parentHalved] != -1)
      return mem[u][parentHalved];

    int sumWithFullNode = price[u] * count[u];
    for (const int v : graph[u])
      if (v != prev)
        sumWithFullNode += dfs(graph, v, u, price, count, false, mem);

    if (parentHalved)  // Can't halve this node if its parent was halved.
      return mem[u][parentHalved] = sumWithFullNode;

    int sumWithHalvedNode = (price[u] / 2) * count[u];
    for (const int v : graph[u])
      if (v != prev)
        sumWithHalvedNode += dfs(graph, v, u, price, count, true, mem);

    return mem[u][parentHalved] = min(sumWithFullNode, sumWithHalvedNode);
  }
};",2646
2644,"class Solution {
 public:
  vector<vector<int>> colorRed(int n) {
    vector<vector<int>> ans;
    const int tipSize = n % 4;

    // The tip of the triangle is always painted red.
    if (tipSize >= 1)
      ans.push_back({1, 1});

    // Paint the rightmost and the leftmost elements at the following rows.
    for (int i = 2; i <= tipSize; ++i) {
      ans.push_back({i, 1});
      ans.push_back({i, 2 * i - 1});
    }

    // Paint the 4-row chunks.
    for (int i = tipSize + 1; i < n; i += 4) {
      // Fill the first row of the chunk.
      ans.push_back({i, 1});
      // Fill the second row.
      for (int j = 1; j <= i; ++j)
        ans.push_back({i + 1, 2 * j + 1});
      // Fill the third row.
      ans.push_back({i + 2, 2});
      // Fill the fourth row.
      for (int j = 0; j <= i + 2; ++j)
        ans.push_back({i + 3, 2 * j + 1});
    }

    return ans;
  }
};",2647
2645,"function* fibGenerator(): Generator<number, any, number> {
  const arr = [0, 0, 1];
  while (true) {
    yield arr[1];
    arr[0] = arr[1];
    arr[1] = arr[2];
    arr[2] = arr[0] + arr[1];
  }
}",2648
2646,"type MultidimensionalArray = (MultidimensionalArray | number)[];

function* inorderTraversal(
  arr: MultidimensionalArray
): Generator<number, void, unknown> {
  for (const item of arr) {
    if (typeof item === 'number') {
      yield item;
    } else {
      yield* inorderTraversal(item);
    }
  }
}",2649
2647,"function cancellable<T>(
  generator: Generator<Promise<any>, T, unknown>
): [() => void, Promise<T>] {
  let cancel = () => {};
  const cancelPromise = new Promise<never>((_, reject) => {
    cancel = () => reject('Cancelled');
  });

  const promise = (async (): Promise<T> => {
    let next = generator.next();
    while (!next.done) {
      try {
        next = generator.next(await Promise.race([next.value, cancelPromise]));
      } catch (e) {
        next = generator.throw(e);
      }
    }
    return next.value;
  })();

  return [cancel, promise];
}",2650
2648,"class Solution {
 public:
  int findDelayedArrivalTime(int arrivalTime, int delayedTime) {
    return (arrivalTime + delayedTime) % 24;
  }
};",2651
2649,"class Solution {
 public:
  int sumOfMultiples(int n) {
    int ans = 0;
    for (int i = 1; i <= n; ++i)
      if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0)
        ans += i;
    return ans;
  }
};",2652
2650,"class Solution {
 public:
  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {
    vector<int> ans;
    vector<int> count(50);  // count[i] := the frequency of (i + 50)

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] < 0)
        ++count[nums[i] + 50];
      if (i - k >= 0 && nums[i - k] < 0)
        --count[nums[i - k] + 50];
      if (i + 1 >= k)
        ans.push_back(getXthSmallestNum(count, x));
    }

    return ans;
  }

 private:
  int getXthSmallestNum(const vector<int>& count, int x) {
    int prefix = 0;
    for (int i = 0; i < 50; ++i) {
      prefix += count[i];
      if (prefix >= x)
        return i - 50;
    }
    return 0;
  }
};",2653
2651,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
    const int n = nums.size();
    const int ones = ranges::count(nums, 1);
    if (ones > 0)
      return n - ones;

    // the minimum operations to make the shortest subarray with a gcd == 1
    int minOps = INT_MAX;

    for (int i = 0; i < n; ++i) {
      int g = nums[i];
      for (int j = i + 1; j < n; ++j) {
        g = __gcd(g, nums[j]);
        if (g == 1) {  // gcd(nums[i..j]) == 1
          minOps = min(minOps, j - i);
          break;
        }
      }
    }

    // After making the shortest subarray with `minOps`, need additional n - 1
    // operations to make the other numbers to 1.
    return minOps == INT_MAX ? -1 : minOps + n - 1;
  }
};",2654
2652,"class Solution {
 public:
  vector<vector<int>> findMaximalUncoveredRanges(int n,
                                                 vector<vector<int>>& ranges) {
    vector<vector<int>> ans;
    int start = 0;

    ranges::sort(ranges);

    for (const vector<int>& range : ranges) {
      const int l = range[0];
      const int r = range[1];
      if (start < l)
        ans.push_back({start, l - 1});
      if (start <= r)
        start = r + 1;
    }

    if (start < n)
      ans.push_back({start, n - 1});

    return ans;
  }
};",2655
2653,"class Solution {
 public:
  int maximizeSum(vector<int>& nums, int k) {
    // If x = max(nums), ans = x + (x + 1) + .. + (x + k - 1).
    const int x = ranges::max(nums);
    return x * k + k * (k - 1) / 2;
  }
};",2656
2654,"class Solution {
 public:
  vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {
    const int n = A.size();
    int prefixCommon = 0;
    vector<int> ans;
    vector<int> count(n + 1);

    for (int i = 0; i < A.size(); ++i) {
      if (++count[A[i]] == 2)
        ++prefixCommon;
      if (++count[B[i]] == 2)
        ++prefixCommon;
      ans.push_back(prefixCommon);
    }

    return ans;
  }
};",2657
2655,"class Solution {
 public:
  int findMaxFish(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] > 0)
          ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] == 0)
      return 0;
    int caughtFish = grid[i][j];
    grid[i][j] = 0;                                     // Mark 0 as visited
    return caughtFish +                                 //
           dfs(grid, i + 1, j) + dfs(grid, i - 1, j) +  //
           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);
  }
};",2658
2656,"class Solution {
 public:
  long long countOperationsToEmptyArray(vector<int>& nums) {
    const int n = nums.size();
    long long ans = n;
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < n; ++i)
      numToIndex[nums[i]] = i;

    ranges::sort(nums);

    for (int i = 1; i < n; ++i)
      // On the i-th step we've already removed the i - 1 smallest numbers and
      // can ignore them. If an element nums[i] has smaller index in origin
      // array than nums[i - 1], we should rotate the whole left array n - i
      // times to set nums[i] element on the first position.
      if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])
        ans += n - i;

    return ans;
  }
};",2659
2657,"class Solution {
 public:
  int isWinner(vector<int>& player1, vector<int>& player2) {
    const int score1 = getScore(player1);
    const int score2 = getScore(player2);
    if (score1 > score2)
      return 1;
    if (score2 > score1)
      return 2;
    return 0;
  }

 private:
  int getScore(const vector<int>& player) {
    constexpr int kInvalid = -3;
    int score = 0;
    int last10 = kInvalid;
    for (int i = 0; i < player.size(); ++i) {
      score += i - last10 > 2 ? player[i] : player[i] * 2;
      if (player[i] == 10)
        last10 = i;
    }
    return score;
  }
};",2660
2658,"class Solution {
 public:
  int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    // rows[i] := the number of painted grid in the i-th row
    vector<int> rows(m);
    // cols[j] := the number of painted grid in the j-th column
    vector<int> cols(n);
    // numToRow[num] := the i-th row of `num` in `mat`
    vector<int> numToRow(m * n + 1);
    // numToCol[num] := the j-th column of `num` in `mat`
    vector<int> numToCol(m * n + 1);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        numToRow[mat[i][j]] = i;
        numToCol[mat[i][j]] = j;
      }

    for (int i = 0; i < arr.size(); ++i) {
      if (++rows[numToRow[arr[i]]] == n)
        return i;
      if (++cols[numToCol[arr[i]]] == m)
        return i;
    }

    throw;
  }
};",2661
2659,"class Solution {
 public:
  int minimumCost(vector<int>& start, vector<int>& target,
                  vector<vector<int>>& specialRoads) {
    return dijkstra(specialRoads, start[0], start[1], target[0], target[1]);
  }

 private:
  int dijkstra(const vector<vector<int>>& specialRoads, int srcX, int srcY,
               int dstX, int dstY) {
    const int n = specialRoads.size();
    // dist[i] := the minimum distance of (srcX, srcY) to
    // specialRoads[i](x2, y2)
    vector<int> dist(specialRoads.size(), INT_MAX);
    using P = pair<int, int>;  // (d, u), where u := the i-th specialRoads
    priority_queue<P, vector<P>, greater<>> minHeap;

    // (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)
    for (int u = 0; u < n; ++u) {
      const int x1 = specialRoads[u][0];
      const int y1 = specialRoads[u][1];
      const int cost = specialRoads[u][4];
      const int d = abs(x1 - srcX) + abs(y1 - srcY) + cost;
      dist[u] = d;
      minHeap.emplace(dist[u], u);
    }

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      const int ux2 = specialRoads[u][2];
      const int uy2 = specialRoads[u][3];
      for (int v = 0; v < n; ++v) {
        if (v == u)
          continue;
        const int vx1 = specialRoads[v][0];
        const int vy1 = specialRoads[v][1];
        const int vcost = specialRoads[v][4];
        // (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)
        const int newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost;
        if (newDist < dist[v]) {
          dist[v] = newDist;
          minHeap.emplace(dist[v], v);
        }
      }
    }

    int ans = abs(dstX - srcX) + abs(dstY - srcY);
    for (int u = 0; u < n; ++u) {
      const int x2 = specialRoads[u][2];
      const int y2 = specialRoads[u][3];
      // (srcX, srcY) -> (x2, y2) -> (dstX, dstY).
      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2));
    }
    return ans;
  }
};",2662
2660,"class Solution {
 public:
  string smallestBeautifulString(string s, int k) {
    for (int i = s.length() - 1; i >= 0; --i) {
      do {
        ++s[i];
      } while (containsPalindrome(s, i));
      if (s[i] < 'a' + k)
        // If s[i] is among the first k letters, then change the letters after
        // s[i] to the smallest ones that don't form any palindrome substring.
        return changeSuffix(s, i + 1);
    }

    return """";
  }

 private:
  // Returns true if s[0..i] contains any palindrome.
  bool containsPalindrome(const string& s, int i) {
    return (i > 0 && s[i] == s[i - 1]) || (i > 1 && s[i] == s[i - 2]);
  }

  // Returns a string, where replacing s[i..n) with the smallest possible
  // letters don't form any palindrome substring.
  string changeSuffix(string& s, int i) {
    for (int j = i; j < s.length(); ++j)
      for (s[j] = 'a'; containsPalindrome(s, j); ++s[j])
        ;
    return s;
  }
};",2663
2661,"class Solution {
 public:
  vector<vector<int>> tourOfKnight(int m, int n, int r, int c) {
    vector<vector<int>> ans(m, vector<int>(n, -1));
    dfs(m, n, r, c, 0, ans);
    return ans;
  }

 private:
  static constexpr int dirs[8][2] = {{1, 2},   {2, 1},   {2, -1}, {1, -2},
                                     {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};

  bool dfs(int m, int n, int i, int j, int step, vector<vector<int>>& ans) {
    if (step == m * n)
      return true;
    if (i < 0 || i >= m || j < 0 || j >= n)
      return false;
    if (ans[i][j] != -1)
      return false;
    ans[i][j] = step;
    for (const auto& [dx, dy] : dirs)
      if (dfs(m, n, i + dx, j + dy, step + 1, ans))
        return true;
    ans[i][j] = -1;
    return false;
  }
};",2664
2662,"type ReturnObj = {
  increment: () => number;
  decrement: () => number;
  reset: () => number;
};

function createCounter(init: number): ReturnObj {
  let cur = init;
  return {
    increment: () => ++cur,
    decrement: () => --cur,
    reset: () => (cur = init),
  };
}",2665
2663,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type OnceFn = (...args: JSONValue[]) => JSONValue | undefined;

function once(fn: Function): OnceFn {
  let isCalled = false;
  return function (...args) {
    if (isCalled) {
      return;
    }
    isCalled = true;
    return fn(...args);
  };
}",2666
2664,"function createHelloWorld() {
  return function (..._): string {
    return 'Hello World';
  };
}",2667
2665,"SELECT
  emp_id,
  firstname,
  lastname,
  MAX(salary) AS salary,
  department_id
FROM Salary
GROUP BY 1
ORDER BY 1;",2668
2666,"SELECT
  artist,
  COUNT(id) AS occurrences
FROM Spotify
GROUP BY 1
ORDER BY 2 DESC, 1;",2669
2667,"class Solution {
 public:
  vector<int> distinctDifferenceArray(vector<int>& nums) {
    constexpr int kMax = 50;
    vector<int> ans;
    vector<int> prefixCount(kMax + 1);
    vector<int> suffixCount(kMax + 1);
    int distinctPrefix = 0;
    int distinctSuffix = 0;

    for (const int num : nums)
      if (++suffixCount[num] == 1)
        ++distinctSuffix;

    for (const int num : nums) {
      if (++prefixCount[num] == 1)
        ++distinctPrefix;
      if (--suffixCount[num] == 0)
        --distinctSuffix;
      ans.push_back(distinctPrefix - distinctSuffix);
    }

    return ans;
  }
};",2670
2668,add(number: int),2671
2669,"class Solution {
 public:
  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {
    vector<int> ans;
    vector<int> arr(n);
    int sameColors = 0;

    for (const vector<int>& query : queries) {
      const int i = query[0];
      const int color = query[1];
      if (i + 1 < n) {
        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])
          --sameColors;
        if (arr[i + 1] == color)
          ++sameColors;
      }
      if (i > 0) {
        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])
          --sameColors;
        if (arr[i - 1] == color)
          ++sameColors;
      }
      arr[i] = color;
      ans.push_back(sameColors);
    }

    return ans;
  }
};",2672
2670,"class Solution {
 public:
  int minIncrements(int n, vector<int>& cost) {
    int ans = 0;

    for (int i = n / 2 - 1; i >= 0; --i) {
      const int l = i * 2 + 1;
      const int r = i * 2 + 2;
      ans += abs(cost[l] - cost[r]);
      // Record the information in the parent from the children. So, there's
      // need to actually update the values in the children.
      cost[i] += max(cost[l], cost[r]);
    }

    return ans;
  }
};",2673
2671,"class Solution {
 public:
  vector<ListNode*> splitCircularLinkedList(ListNode* list) {
    ListNode* slow = list;
    ListNode* fast = list;

    // Point `slow` to the last node in the first half.
    while (fast->next != list && fast->next->next != list) {
      slow = slow->next;
      fast = fast->next->next;
    }

    // Circle back the second half.
    ListNode* secondHead = slow->next;
    if (fast->next == list)
      fast->next = secondHead;
    else
      fast->next->next = secondHead;

    // Circle back the first half.
    slow->next = list;

    return {list, secondHead};
  }
};",2674
2672,"function jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {
  const isObject = (o: any) => o !== null && typeof o === 'object';

  // Returns the keys of a JSON-like object by recursively unwrapping the nests.
  const getKeys = (json: any): string[] => {
    if (!isObject(json)) {
      return [''];
    }
    return Object.keys(json).reduce((acc: string[], currKey: string) => {
      return (
        acc.push(
          ...getKeys(json[currKey]).map((nextKey: string) =>
            nextKey === '' ? currKey : `${currKey}.${nextKey}`
          )
        ),
        acc
      );
    }, []);
  };

  const sortedKeys: string[] = [
    ...arr.reduce((acc: Set<string>, curr: any) => {
      getKeys(curr).forEach((key: string) => acc.add(key));
      return acc;
    }, new Set<string>()),
  ].sort();

  // Returns the value of `obj` keyed by `nestedKey`.
  const getValue = (
    obj: any,
    nestedKey: string
  ): string | number | boolean | null => {
    let value: any = obj;
    for (const key of nestedKey.split('.')) {
      if (!isObject(value) || !(key in value)) {
        return '';
      }
      value = value[key];
    }
    return isObject(value) ? '' : value;
  };

  const matrix: (string | number | boolean | null)[][] = [sortedKeys];
  arr.forEach((obj: any) => {
    matrix.push(
      sortedKeys.map((nestedKey: string) => getValue(obj, nestedKey))
    );
  });

  return matrix;
}",2675
2673,"type F = (...args: any[]) => void;

function throttle(fn: F, t: number): F {
  let timeout: ReturnType<typeof setTimeout> | undefined;
  let nextTimeToCallFn = 0;
  return function (...args) {
    const delay = Math.max(0, nextTimeToCallFn - Date.now());
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn(...args);
      nextTimeToCallFn = Date.now() + t;
    }, delay);
  };
}",2676
2674,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function chunk(arr: Obj[], size: number): Obj[][] {
  const ans: Obj[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    ans.push(arr.slice(i, i + size));
  }
  return ans;
}",2677
2675,"class Solution {
 public:
  int countSeniors(vector<string>& details) {
    return ranges::count_if(details, [](const string& detail) {
      return stoi(detail.substr(11, 2)) > 60;
    });
  }
};",2678
2676,"class Solution {
 public:
  int matrixSum(vector<vector<int>>& nums) {
    int ans = 0;

    for (vector<int>& row : nums)
      ranges::sort(row);

    for (int j = 0; j < nums[0].size(); ++j) {
      int maxi = 0;
      for (int i = 0; i < nums.size(); ++i)
        maxi = max(maxi, nums[i][j]);
      ans += maxi;
    }

    return ans;
  }
};",2679
2677,"class Solution {
 public:
  long long maximumOr(vector<int>& nums, int k) {
    const int n = nums.size();
    long long ans = 0;
    // prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]
    vector<long long> prefix(n);
    // suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]
    vector<long long> suffix(n);

    for (int i = 1; i < n; ++i)
      prefix[i] = prefix[i - 1] | nums[i - 1];

    for (int i = n - 2; i >= 0; --i)
      suffix[i] = suffix[i + 1] | nums[i + 1];

    // For each num, greedily shift it left by k bits.
    for (int i = 0; i < n; ++i)
      ans = max(ans,
                prefix[i] | static_cast<long long>(nums[i]) << k | suffix[i]);

    return ans;
  }
};",2680
2678,"class Solution {
 public:
  int sumOfPower(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long long ans = 0;
    long long sum = 0;

    ranges::sort(nums);

    for (const int num : nums) {
      ans = (ans + (num + sum) * num % kMod * num % kMod) % kMod;
      sum = (sum * 2 + num) % kMod;
    }

    return ans;
  }
};",2681
2679,"class Solution {
 public:
  vector<int> circularGameLosers(int n, int k) {
    vector<int> ans;
    vector<bool> seen(n);

    for (int friendIndex = 0, turn = 1; !seen[friendIndex];) {
      seen[friendIndex] = true;
      friendIndex += turn++ * k;
      friendIndex %= n;
    }

    for (int friendIndex = 0; friendIndex < n; ++friendIndex)
      if (!seen[friendIndex])
        ans.push_back(friendIndex + 1);

    return ans;
  }
};",2682
2680,"class Solution {
 public:
  bool doesValidArrayExist(vector<int>& derived) {
    //      original = [O[0], O[1], ..., O[n - 1]]
    //       derived = [O[0]^O[1], O[1]^O[2], ..., O[n - 1]^O[0]]
    // XOR(derivedd) = 0
    return accumulate(derived.begin(), derived.end(), 0, bit_xor<>()) == 0;
  }
};",2683
2681,"class Solution {
 public:
  int maxMoves(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    // dp[i][j] := the maximum number of moves you can perform from (i, j)
    vector<vector<int>> dp(m, vector<int>(n));

    for (int j = n - 2; j >= 0; --j)
      for (int i = 0; i < m; ++i) {
        if (grid[i][j + 1] > grid[i][j])
          dp[i][j] = 1 + dp[i][j + 1];
        if (i > 0 && grid[i - 1][j + 1] > grid[i][j])
          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1]);
        if (i + 1 < m && grid[i + 1][j + 1] > grid[i][j])
          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1]);
      }

    for (int i = 0; i < m; ++i)
      ans = max(ans, dp[i][0]);

    return ans;
  }
};",2684
2682,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n), nodeCount(n, 1), edgeCount(n) {
    iota(id.begin(), id.end(), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    ++edgeCount[i];
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = j;
      edgeCount[j] += edgeCount[i];
      nodeCount[j] += nodeCount[i];
    } else if (rank[i] > rank[j]) {
      id[j] = i;
      edgeCount[i] += edgeCount[j];
      nodeCount[i] += nodeCount[j];
    } else {
      id[i] = j;
      edgeCount[j] += edgeCount[i];
      nodeCount[j] += nodeCount[i];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

  bool isComplete(int u) {
    return nodeCount[u] * (nodeCount[u] - 1) / 2 == edgeCount[u];
  }

 private:
  vector<int> id;
  vector<int> rank;
  vector<int> nodeCount;
  vector<int> edgeCount;
};

class Solution {
 public:
  int countCompleteComponents(int n, vector<vector<int>>& edges) {
    int ans = 0;
    UnionFind uf(n);
    unordered_set<int> parents;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      uf.unionByRank(u, v);
    }

    for (int i = 0; i < n; ++i) {
      const int parent = uf.find(i);
      if (parents.insert(parent).second && uf.isComplete(parent))
        ++ans;
    }

    return ans;
  }
};",2685
2683,"SELECT
  order_date,
  ROUND(
    AVG(order_date = customer_pref_delivery_date) * 100,
    2
  ) AS immediate_percentage
FROM Delivery
GROUP BY 1
ORDER BY 1;",2686
2684,"SELECT bike_number, MAX(end_time) AS end_time
FROM Bikes
GROUP BY 1;",2687
2685,"WITH
  UsersWithRowNumber AS (
    SELECT
      *,
      ROW_NUMBER() OVER(ORDER BY created_at) AS `row_number`
    FROM Users
  )
SELECT DISTINCT(First.user_id)
FROM UsersWithRowNumber AS First
INNER JOIN UsersWithRowNumber AS Second
  USING (user_id)
WHERE
  First.`row_number` < Second.`row_number`
  AND DATEDIFF(Second.created_at, First.created_at) <= 7",2688
2686,"class Solution {
 public:
  char getKthCharacter(RopeTreeNode* root, int k) {
    if (root->len == 0)
      return root->val[k - 1];
    const int leftLen =
        root->left == nullptr
            ? 0
            : max(root->left->len, static_cast<int>(root->left->val.length()));
    return leftLen >= k ? getKthCharacter(root->left, k)
                        : getKthCharacter(root->right, k - leftLen);
  }
};",2689
2687,"function createInfiniteObject(): Record<string, () => string> {
  return new Proxy(
    {},
    {
      get: (_, prop: string) => () => prop,
    }
  );
}",2690
2688,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type InputObj = Record<string, JSONValue> | Array<JSONValue>;

type RecursiveHandler = {
  set: (target: any, prop: string, value: any) => boolean;
  get: (target: any, prop: string) => unknown;
};

const isObject = (o: any) => o !== null && typeof o === 'object';

// Access history of properties
class AccessHistory {
  value: JSONValue | null = null;
  props: Map<string, AccessHistory> = new Map();
}

class ImmutableHelper {
  private obj: InputObj;

  constructor(obj: InputObj) {
    this.obj = obj;
  }

  produce(mutator: (obj: InputObj) => void): InputObj {
    // Creates a proxied object to track property access history.
    function createProxiedObj(
      obj: InputObj,
      accessHistory: AccessHistory
    ): InputObj {
      const handler: RecursiveHandler = {
        // 'set' trap intercepts property assignment.
        set(_, prop, value) {
          if (!accessHistory.props.has(prop)) {
            accessHistory.props.set(prop, new AccessHistory());
          }
          accessHistory.props.get(prop)!.value = value;
          return true;
        },
        // 'get' trap intercepts property access.
        get(_, prop) {
          if (accessHistory.value !== null) {
            return accessHistory.value;
          }
          if (!accessHistory.props.has(prop)) {
            accessHistory.props.set(prop, new AccessHistory());
          }
          if (accessHistory.props.get(prop)!.value !== null) {
            return accessHistory.props.get(prop)!.value;
          }
          if (isObject(obj[prop])) {
            // Recursively create a proxed object for object property.
            return createProxiedObj(
              obj[prop] as InputObj,
              accessHistory.props.get(prop)! as AccessHistory
            );
          }
          return obj[prop];
        },
      };
      return new Proxy(obj, handler);
    }

    // Returns true if there are mutated properties in the access history;
    // otherwise, returns false and deletes the unnecessary properties.
    function deleteUnmutatedProps(accessHistory: AccessHistory): boolean {
      if (accessHistory.value !== null) {
        return true;
      }
      let hasMutation = false;
      for (const [prop, childAccessHistory] of [...accessHistory.props]) {
        if (deleteUnmutatedProps(childAccessHistory)) {
          hasMutation = true;
        } else {
          accessHistory.props.delete(prop);
        }
      }
      return hasMutation;
    }

    // Function to transform the original object based on the access history
    function transform(obj: InputObj, accessHistory: AccessHistory): InputObj {
      if (accessHistory.value !== null) {
        return accessHistory.value as InputObj;
      }
      if (accessHistory.props.size === 0) {
        return obj;
      }
      if (!isObject(obj)) {
        return obj;
      }
      let clone = Array.isArray(obj) ? [...obj] : { ...obj };
      for (const [prop, childAccessHistory] of [...accessHistory.props]) {
        clone[prop] = transform(obj[prop] as InputObj, childAccessHistory);
      }
      return clone;
    }

    const accessHistory = new AccessHistory();
    const proxiedObj = createProxiedObj(this.obj, accessHistory);
    // Apply the mutator function on the proxied object. This will also record
    // the property access history in `accessHistory`.
    mutator(proxiedObj);
    // Simplify the access history.
    deleteUnmutatedProps(accessHistory);
    // Transform the original object based on the simplified access history.
    return transform(this.obj, accessHistory);
  }
}",2691
2689,"type RecursiveHandler = {
  set: <T extends object>(target: T, prop: string, value: any) => boolean;
  get: <T extends object>(target: T, prop: string) => any;
  apply: <T extends Function>(target: T, thisArg: any, argArray?: any) => any;
};

function makeImmutable<T extends object | Function>(obj: T): T {
  // a set of mutating array methods
  const methods = new Set([
    'pop',
    'push',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse',
  ]);

  const handler: RecursiveHandler = {
    // 'set' trap prevents modifications of the object properties.
    set(target, prop, _) {
      throw Array.isArray(target)
        ? `Error Modifying Index: ${String(prop)}`
        : `Error Modifying: ${String(prop)}`;
    },
    // 'get' trap returns object properties or creates new proxies for nested
    // objects or functions
    get(target, prop) {
      // If the property is 'prototype', null, or not an object/function, return
      // it directly. We exclude 'prototype' to avoid potential issues with
      // inheritance Objects and functions are wrapped in a new proxy to
      // preserve immutability at all depths.
      const key = prop as keyof typeof target;
      return prop === 'prototype' ||
        target[key] === null ||
        (typeof target[key] !== 'object' && typeof target[key] !== 'function')
        ? target[key]
        : new Proxy(target[key], this);
    },
    // 'apply' trap prevents call of mutating methods and apply function calls.
    apply(target, thisArg, argumentsList) {
      if (methods.has((target as any).name))
        throw `Error Calling Method: ${(target as any).name}`;
      return target.apply(thisArg, argumentsList);
    },
  };

  return new Proxy(obj, handler) as T;
}",2692
2690,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

declare global {
  interface Function {
    callPolyfill(
      context: Record<string, JSONValue>,
      ...args: JSONValue[]
    ): JSONValue;
  }
}

Function.prototype.callPolyfill = function (context, ...args): JSONValue {
  const fn = this;
  Object.defineProperty(context, '__fn__', {
    value: fn,
    enumerable: false,
  });
  const ans = (context.__fn__ as any)(...args);
  delete context.__fn__;
  return typeof ans !== 'undefined' ? ans : undefined;
};",2693
2691,"type Callback = (...args: any[]) => any;
type Subscription = {
  unsubscribe: () => void;
};

class EventEmitter {
  private eventToCallbacks: Map<string, Callback[]>;

  constructor() {
    this.eventToCallbacks = new Map();
  }

  subscribe(eventName: string, callback: Callback): Subscription {
    if (!this.eventToCallbacks.has(eventName))
      this.eventToCallbacks.set(eventName, []);

    const callbacks = this.eventToCallbacks.get(eventName);
    callbacks?.push(callback);

    return {
      unsubscribe: () => {
        const index = callbacks?.indexOf(callback);
        if (index !== undefined && index !== -1) {
          callbacks?.splice(index, 1);
        }
      },
    };
  }

  emit(eventName: string, args: any[] = []): any[] {
    const callbacks = this.eventToCallbacks.get(eventName);
    if (callbacks === undefined) {
      return [];
    }
    return callbacks.map((callback) => callback(...args));
  }
}",2694
2692,"class ArrayWrapper {
  private nums: number[];

  constructor(nums: number[]) {
    this.nums = nums;
  }

  valueOf(): number {
    return this.nums.reduce((sum, num) => sum + num, 0);
  }

  toString(): string {
    return '[' + this.nums.join(',') + ']';
  }
}",2695
2693,"class Solution {
 public:
  int minLength(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == 'B' && match(stack, 'A'))
        stack.pop();
      else if (c == 'D' && match(stack, 'C'))
        stack.pop();
      else
        stack.push(c);

    return stack.size();
  }

 private:
  bool match(const stack<char>& stack, int c) {
    return !stack.empty() && stack.top() == c;
  }
};",2696
2694,"class Solution {
 public:
  string makeSmallestPalindrome(string s) {
    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {
      const int minChar = min(s[i], s[j]);
      s[i] = minChar;
      s[j] = minChar;
    }
    return s;
  }
};",2697
2695,"class Solution {
 public:
  int punishmentNumber(int n) {
    int ans = 0;
    for (int i = 1; i <= n; ++i)
      if (isPossible(0, 0, to_string(i * i), 0, i))
        ans += i * i;
    return ans;
  }

 private:
  // Returns true if the sum of any split of `numChars` equals to the target.
  bool isPossible(int accumulate, int running, const string& numChars, int s,
                  int target) {
    if (s == numChars.length())
      return target == accumulate + running;
    const int d = numChars[s] - '0';
    return isPossible(accumulate, running * 10 + d, numChars, s + 1, target) ||
           isPossible(accumulate + running, d, numChars, s + 1, target);
  }
};",2698
2696,"class Solution {
 public:
  vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges,
                                         int source, int destination,
                                         int target) {
    constexpr int kMax = 2'000'000'000;
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      if (w == -1)
        continue;
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    int distToDestination = dijkstra(graph, source, destination);
    if (distToDestination < target)
      return {};
    if (distToDestination == target) {
      // Change the weights of negative edges to an impossible value.
      for (vector<int>& edge : edges)
        if (edge[2] == -1)
          edge[2] = kMax;
      return edges;
    }

    for (int i = 0; i < edges.size(); ++i) {
      const int u = edges[i][0];
      const int v = edges[i][1];
      int& w = edges[i][2];
      if (w != -1)
        continue;
      w = 1;
      graph[u].emplace_back(v, 1);
      graph[v].emplace_back(u, 1);
      distToDestination = dijkstra(graph, source, destination);
      if (distToDestination <= target) {
        w += target - distToDestination;
        // Change the weights of negative edges to an impossible value.
        for (int j = i + 1; j < edges.size(); ++j)
          if (edges[j][2] == -1)
            edges[j][2] = kMax;
        return edges;
      }
    }

    return {};
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    vector<int> dist(graph.size(), INT_MAX);
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
    }

    return dist[dst];
  }
};",2699
2697,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function objDiff(obj1: Obj, obj2: Obj): Obj {
  if (obj1 === obj2) {
    return {};
  }
  if (obj1 === null || obj2 === null) {
    return [obj1, obj2];
  }
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return [obj1, obj2];
  }
  if (Array.isArray(obj1) !== Array.isArray(obj2)) {
    return [obj1, obj2];
  }
  const ans = {};
  for (const key in obj1) {
    if (key in obj2) {
      const subDiff = objDiff(obj1[key], obj2[key]);
      if (Object.keys(subDiff).length > 0) {
        ans[key] = subDiff;
      }
    }
  }
  return ans;
}",2700
2698,"WITH
  IncreasingTransactions AS (
    SELECT
      Curr.customer_id,
      Curr.transaction_date
    FROM Transactions AS Curr
    LEFT JOIN Transactions AS Next
      USING (customer_id)
    WHERE
      Curr.amount < Next.amount
      AND DATEDIFF(Next.transaction_date, Curr.transaction_date) = 1
  ),
  IncreasingTransactionsWithGroupId AS (
    SELECT
      *,
      TO_DAYS(transaction_date) - ROW_NUMBER() OVER(
        PARTITION BY customer_id
        ORDER BY transaction_date
      ) AS group_id
    FROM IncreasingTransactions
  ),
  IncreasingTransactionsWithCountDays AS (
    SELECT
      customer_id,
      MIN(transaction_date) AS consecutive_start,
      COUNT(*) AS count_days
    FROM IncreasingTransactionsWithGroupId
    GROUP BY customer_id, group_id
  )
SELECT
  customer_id,
  consecutive_start,
  DATE_ADD(consecutive_start, INTERVAL count_days DAY) AS consecutive_end
FROM IncreasingTransactionsWithCountDays
WHERE count_days >= 2
ORDER BY 1;",2701
2699,"class Solution {
 public:
  int minOperations(vector<int>& nums, int x, int y) {
    int l = 0;
    int r = ranges::max(nums);

    while (l < r) {
      const int m = (l + r) / 2;
      if (isPossible(nums, x, y, m))
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns true if it's possible to make all `nums` <= 0 using m operations.
  bool isPossible(const vector<int>& nums, int x, int y, int m) {
    long long additionalOps = 0;
    // If we want m operations, first decrease all the numbers by y * m. Then,
    // we have m operations to select indices to decrease them by x - y.
    for (const int num : nums)
      additionalOps += max(0LL, (num - 1LL * y * m + x - y - 1) / (x - y));
    return additionalOps <= m;
  }
};",2702
2700,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function argumentsLength(...args: JSONValue[]): number {
  return args.length;
}",2703
2701,"type ToBeOrNotToBe = {
  toBe: (val: any) => boolean;
  notToBe: (val: any) => boolean;
};

function expect(val: any): ToBeOrNotToBe {
  return {
    toBe: function (val2: any) {
      if (val === val2) {
        return true;
      }
      throw 'Not Equal';
    },
    notToBe: function (val2: any) {
      if (val !== val2) {
        return true;
      }
      throw 'Equal';
    },
  };
}",2704
2702,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function compactObject(obj: Obj): Obj {
  return dfs(obj) as Obj;
}

function dfs(value: JSONValue): JSONValue {
  if (value === null) {
    return null;
  }
  if (Array.isArray(value)) {
    return value.filter(Boolean).map(dfs);
  }
  if (typeof value === 'object') {
    for (const key of Object.keys(value)) {
      if (Boolean(value[key])) {
        value[key] = dfs(value[key]);
      } else {
        delete value[key];
      }
    }
  }
  return value;
}",2705
2703,"class Solution {
 public:
  int buyChoco(vector<int>& prices, int money) {
    int min1 = INT_MAX;
    int min2 = INT_MAX;

    for (const int price : prices)
      if (price <= min1) {
        min2 = min1;
        min1 = price;
      } else if (price < min2) {
        min2 = price;
      }

    const int minCost = min1 + min2;
    return minCost > money ? money : money - minCost;
  }
};",2706
2704,"class Solution {
 public:
  // Similar to 139. Word Break
  int minExtraChar(string s, vector<string>& dictionary) {
    const int n = s.length();
    const unordered_set<string> dictionarySet{dictionary.begin(),
                                              dictionary.end()};
    // dp[i] := the minimum extra letters if breaking up s[0..i) optimally
    vector<int> dp(n + 1, n);
    dp[0] = 0;

    for (int i = 1; i <= n; ++i)
      for (int j = 0; j < i; ++j)
        // s[j..i) is in `dictionarySet`.
        if (dictionarySet.count(s.substr(j, i - j)))
          dp[i] = min(dp[i], dp[j]);
        // s[j..i) are extra letters.
        else
          dp[i] = min(dp[i], dp[j] + i - j);

    return dp[n];
  }
};",2707
2705,"class Solution {
 public:
  long long maxStrength(vector<int>& nums) {
    long long posProd = 1;
    long long negProd = 1;
    int maxNeg = INT_MIN;
    int negCount = 0;
    bool hasPos = false;
    bool hasZero = false;

    for (const int num : nums)
      if (num > 0) {
        posProd *= num;
        hasPos = true;
      } else if (num < 0) {
        negProd *= num;
        maxNeg = max(maxNeg, num);
        ++negCount;
      } else {  // num == 0
        hasZero = true;
      }

    if (negCount == 0 && !hasPos)
      return 0;
    if (negCount % 2 == 0)
      return negProd * posProd;
    if (negCount >= 3)
      return negProd / maxNeg * posProd;
    if (hasPos)
      return posProd;
    if (hasZero)
      return 0;
    return maxNeg;
  }
};",2708
2706,"class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(id.begin(), id.end(), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int getSize(int i) {
    return sz[i];
  }

 private:
  vector<int> id;
  vector<int> sz;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  bool canTraverseAllPairs(vector<int>& nums) {
    const int n = nums.size();
    const int maxNum = ranges::max(nums);
    const vector<int> minPrimeFactors = sieveEratosthenes(maxNum + 1);
    unordered_map<int, int> primeToFirstIndex;
    UnionFind uf(n);

    for (int i = 0; i < n; ++i)
      for (const int primeFactor : getPrimeFactors(nums[i], minPrimeFactors))
        // `primeFactor` already appeared in the previous indices.
        if (const auto it = primeToFirstIndex.find(primeFactor);
            it != primeToFirstIndex.cend())
          uf.unionBySize(it->second, i);
        else
          primeToFirstIndex[primeFactor] = i;

    for (int i = 0; i < n; ++i)
      if (uf.getSize(i) == n)
        return true;

    return false;
  }

 private:
  // Gets the minimum prime factor of i, where 1 < i <= n.
  vector<int> sieveEratosthenes(int n) {
    vector<int> minPrimeFactors(n + 1);
    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);
    for (int i = 2; i * i < n; ++i)
      if (minPrimeFactors[i] == i)  // `i` is prime.
        for (int j = i * i; j < n; j += i)
          minPrimeFactors[j] = min(minPrimeFactors[j], i);
    return minPrimeFactors;
  }

  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactors) {
    vector<int> primeFactors;
    while (num > 1) {
      const int divisor = minPrimeFactors[num];
      primeFactors.push_back(divisor);
      while (num % divisor == 0)
        num /= divisor;
    }
    return primeFactors;
  }
};",2709
2707,"class Solution {
 public:
  string removeTrailingZeros(string num) {
    return regex_replace(num, regex(""0+$""), """");
  }
};",2710
2708,"class Solution {
 public:
  vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      fillInDiagonal(grid, i, 0, ans);

    for (int j = 1; j < n; ++j)
      fillInDiagonal(grid, 0, j, ans);

    return ans;
  }

 private:
  void fillInDiagonal(const vector<vector<int>>& grid, int i, int j,
                      vector<vector<int>>& ans) {
    unordered_set<int> topLeft;
    unordered_set<int> bottomRight;

    // Fill in the diagonal from the top-left to the bottom-right.
    while (i < grid.size() && j < grid[0].size()) {
      ans[i][j] = topLeft.size();
      // Post-addition, so this information can be utilized in subsequent cells.
      topLeft.insert(grid[i++][j++]);
    }

    --i;
    --j;

    // Fill in the diagonal from the bottom-right to the top-left.
    while (i >= 0 && j >= 0) {
      ans[i][j] = abs(ans[i][j] - static_cast<int>(bottomRight.size()));
      // Post-addition, so this information can be utilized in subsequent cells.
      bottomRight.insert(grid[i--][j--]);
    }
  }
};",2711
2709,"class Solution {
 public:
  long long minimumCost(string s) {
    const int n = s.length();
    long long ans = 0;

    for (int i = 1; i < n; ++i)
      if (s[i] != s[i - 1])
        // Invert s[0..i - 1] or s[i..n - 1].
        ans += min(i, n - i);

    return ans;
  }
};",2712
2710,"class Solution {
 public:
  int maxIncreasingCells(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    // rows[i] := the maximum path length for the i-th row
    vector<int> rows(m);
    // cols[j] := the maximum path length for the j-th column
    vector<int> cols(n);
    unordered_map<int, vector<pair<int, int>>> valToIndices;
    // maxPathLength[i][j] := the maximum path length from mat[i][j]
    vector<vector<int>> maxPathLength(m, vector<int>(n));
    // Sort all the unique values in the matrix in non-increasing order.
    set<int, greater<>> decreasingSet;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        valToIndices[mat[i][j]].emplace_back(i, j);
        decreasingSet.insert(mat[i][j]);
      }

    for (const int val : decreasingSet) {
      for (const auto& [i, j] : valToIndices[val])
        maxPathLength[i][j] = max(rows[i], cols[j]) + 1;
      for (const auto& [i, j] : valToIndices[val]) {
        rows[i] = max(rows[i], maxPathLength[i][j]);
        cols[j] = max(cols[j], maxPathLength[i][j]);
      }
    }

    return max(ranges::max(rows), ranges::max(cols));
  }
};",2713
2711,"class Solution {
 public:
  // Similar to 787. Cheapest Flights Within K Stops
  int shortestPathWithHops(int n, vector<vector<int>>& edges, int s, int d,
                           int k) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, s, d, k);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int k) {
    vector<vector<int>> dist(graph.size(), vector<int>(k + 1, INT_MAX));
    using T = tuple<int, int, int>;  // (d, u, hops)
    priority_queue<T, vector<T>, greater<>> minHeap;

    dist[src][k] = 0;
    minHeap.emplace(dist[src][k], src, k);

    while (!minHeap.empty()) {
      const auto [d, u, hops] = minHeap.top();
      minHeap.pop();
      if (u == dst)
        return d;
      for (const auto& [v, w] : graph[u]) {
        // Go from u -> v with w cost.
        if (d + w < dist[v][hops]) {
          dist[v][hops] = d + w;
          minHeap.emplace(dist[v][hops], v, hops);
        }
        // Hop from u -> v with 0 cost.
        if (hops > 0 && d < dist[v][hops - 1]) {
          dist[v][hops - 1] = d;
          minHeap.emplace(dist[v][hops - 1], v, hops - 1);
        }
      }
    }

    throw;
  }
};",2714
2712,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (...args: JSONValue[]) => void;

function cancellable(fn: Fn, args: JSONValue[], t: number): Function {
  const timer = setTimeout(() => fn(...args), t);
  return function () {
    clearTimeout(timer);
  };
}",2715
2713,"class Solution {
 public:
  int minimizedStringLength(string s) {
    return unordered_set(s.begin(), s.end()).size();
  }
};",2716
2714,"class Solution {
 public:
  int semiOrderedPermutation(vector<int>& nums) {
    const int n = nums.size();
    const int index1 = find(nums.begin(), nums.end(), 1) - nums.begin();
    const int indexN = find(nums.begin(), nums.end(), n) - nums.begin();
    return index1 + (n - 1 - indexN) - (index1 > indexN ? 1 : 0);
  }
};",2717
2715,"class Solution {
 public:
  long long matrixSumQueries(int n, vector<vector<int>>& queries) {
    long long ans = 0;
    // seen[0] := row, seen[1] := col
    vector<vector<bool>> seen(2, vector<bool>(n));
    // notSet[0] = row, notSet[1] := col
    vector<int> notSet(2, n);

    // Later queries dominate.
    for (int i = queries.size() - 1; i >= 0; --i) {
      const int type = queries[i][0];
      const int index = queries[i][1];
      const int val = queries[i][2];
      if (!seen[type][index]) {
        ans += val * notSet[type ^ 1];
        seen[type][index] = true;
        --notSet[type];
      }
    }

    return ans;
  }
};",2718
2716,"class Solution {
 public:
  int count(string num1, string num2, int min_sum, int max_sum) {
    const string num1WithLeadingZeros =
        string(num2.length() - num1.length(), '0') + num1;
    vector<vector<vector<vector<int>>>> mem(
        num2.length(),
        vector<vector<vector<int>>>(
            max_sum + 1, vector<vector<int>>(2, vector<int>(2, -1))));
    return (count(num1WithLeadingZeros, num2, 0, max_sum, true, true, mem) -
            count(num1WithLeadingZeros, num2, 0, min_sum - 1, true, true, mem) +
            kMod) %
           kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of valid integers, considering the i-th digit, where
  // `sum` is the maximum digit sum, `isTight1` indicates if the current digit
  // is tightly bound for `num1` and `isTight2` indicates if the current digit
  // is tightly bound for `num2`
  int count(const string& num1, const string& num2, int i, int sum,
            bool isTight1, bool isTight2,
            vector<vector<vector<vector<int>>>>& mem) {
    if (sum < 0)
      return 0;
    if (i == num2.length())
      return 1;
    if (mem[i][sum][isTight1][isTight2] != -1)
      return mem[i][sum][isTight1][isTight2];

    int res = 0;

    const int minDigit = isTight1 ? num1[i] - '0' : 0;
    const int maxDigit = isTight2 ? num2[i] - '0' : 9;
    for (int d = minDigit; d <= maxDigit; ++d) {
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      res += count(num1, num2, i + 1, sum - d, nextIsTight1, nextIsTight2, mem);
      res %= kMod;
    }

    return mem[i][sum][isTight1][isTight2] = res;
  }
};",2719
2717,"WITH
  TwoWayFriends AS (
    SELECT user1, user2 FROM Friends
    UNION ALL
    SELECT user2, user1 FROM Friends
  )
SELECT
  user1,
  ROUND(
    100 * (
      COUNT(DISTINCT user2) / (COUNT(*) OVER ())
    ),
    2
  ) AS percentage_popularity
FROM TwoWayFriends
GROUP BY 1
ORDER BY 1;",2720
2718,"type Fn<T> = () => Promise<T>;

function promiseAll<T>(functions: Fn<T>[]): Promise<T[]> {
  return new Promise((resolve, reject) => {
    const ans: T[] = [];
    let resolveCount = 0;
    functions.forEach((fn, index) => {
      fn()
        .then((val) => {
          ans[index] = val;
          if (++resolveCount === functions.length) {
            resolve(ans);
          }
        })
        .catch((error) => {
          reject(error);
        });
    });
  });
}",2721
2719,"type JSONValue =
  | {}
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

type Item = { [key: string]: JSONValue } & {
  id: number;
};

function join(arr1: Item[], arr2: Item[]): Item[] {
  const idToObj: { [key: number]: Item } = {};
  for (const item of arr1) {
    idToObj[item.id] = item;
  }
  for (const item of arr2) {
    if (idToObj[item.id] === undefined) {
      idToObj[item.id] = item;
    } else {
      for (const key of Object.keys(item)) {
        idToObj[item.id][key] = item[key];
      }
    }
  }
  const ans = Object.values(idToObj);
  ans.sort((a, b) => a.id - b.id);
  return ans;
}",2722
2720,"type P = Promise<number>;

async function addTwoPromises(promise1: P, promise2: P): P {
  const results = await Promise.all([promise1, promise2]);
  return results[0] + results[1];
}",2723
2721,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (value: JSONValue) => number;

function sortBy(arr: JSONValue[], fn: Fn): JSONValue[] {
  arr.sort((a, b) => fn(a) - fn(b));
  return arr;
}",2724
2722,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (...args: JSONValue[]) => void;

function cancellable(fn: Fn, args: JSONValue[], t: number): Function {
  fn(...args);
  const timer = setInterval(() => fn(...args), t);
  return function () {
    clearInterval(timer);
  };
}",2725
2723,"class Calculator {
  private cur: number;

  constructor(value: number) {
    this.cur = value;
  }

  add(value: number): Calculator {
    this.cur += value;
    return this;
  }

  subtract(value: number): Calculator {
    this.cur -= value;
    return this;
  }

  multiply(value: number): Calculator {
    this.cur *= value;
    return this;
  }

  divide(value: number): Calculator {
    if (value === 0) throw new Error('Division by zero is not allowed');
    this.cur /= value;
    return this;
  }

  power(value: number): Calculator {
    this.cur **= value;
    return this;
  }

  getResult(): number {
    return this.cur;
  }
}",2726
2724,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | JSONValue[];

function isEmpty(obj: Obj): boolean {
  if (Array.isArray(obj)) {
    return obj.length === 0;
  }
  return Object.keys(obj).length === 0;
}",2727
2725,"/**
 * Definition for a street.
 * class Street {
 *  public:
 *   Street(vector<int> doors);
 *   void openDoor();
 *   void closeDoor();
 *   bool isDoorOpen();
 *   void moveRight();
 *   void moveLeft();
 * };
 */

class Solution {
 public:
  int houseCount(Street* street, int k) {
    for (int i = 0; i < k; ++i) {
      if (street->isDoorOpen())
        street->closeDoor();
      street->moveRight();
    }

    for (int ans = 0;; ++ans) {
      if (street->isDoorOpen())
        return ans;
      street->openDoor();
      street->moveRight();
    }

    throw;
  }
};",2728
2726,"class Solution {
 public:
  bool isFascinating(int n) {
    string s = to_string(n) + to_string(2 * n) + to_string(3 * n);
    ranges::sort(s);
    return s == ""123456789"";
  }
};",2729
2727,"class Solution {
 public:
  int longestSemiRepetitiveSubstring(string s) {
    int ans = 1;
    int prevStart = 0;
    int start = 0;

    for (int i = 1; i < s.length(); ++i) {
      if (s[i] == s[i - 1]) {
        if (prevStart > 0)
          start = prevStart;
        prevStart = i;
      }
      ans = max(ans, i - start + 1);
    }

    return ans;
  }
};",2730
2728,"class Solution {
 public:
  int sumDistance(vector<int>& nums, string s, int d) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    int prefix = 0;
    vector<int> pos;

    for (int i = 0; i < nums.size(); ++i)
      if (s[i] == 'L')
        pos.push_back(nums[i] - d);
      else
        pos.push_back(nums[i] + d);

    ranges::sort(pos);

    for (int i = 0; i < n; ++i) {
      ans = ((ans + 1LL * i * pos[i] - prefix) % kMod + kMod) % kMod;
      prefix = ((0LL + prefix + pos[i]) % kMod + kMod) % kMod;
    }

    return ans;
  }
};",2731
2729,"class Solution {
 public:
  vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {
    constexpr int kMaxBit = 30;
    unordered_map<int, int> maskToIndex;

    for (int i = 0; i < grid.size(); ++i) {
      const int mask = getMask(grid[i]);
      if (mask == 0)
        return {i};
      for (int prevMask = 1; prevMask < kMaxBit; ++prevMask)
        if ((mask & prevMask) == 0 && maskToIndex.count(prevMask))
          return {maskToIndex[prevMask], i};
      maskToIndex[mask] = i;
    }

    return {};
  }

 private:
  int getMask(const vector<int>& row) {
    int mask = 0;
    for (int i = 0; i < row.size(); ++i)
      if (row[i] == 1)
        mask |= 1 << i;
    return mask;
  }
};",2732
2730,"class Solution {
 public:
  int findNonMinOrMax(vector<int>& nums) {
    if (nums.size() < 3)
      return -1;
    sort(nums.begin(), nums.begin() + 3);
    return nums[1];
  }
};",2733
2731,"class Solution {
 public:
  string smallestString(string s) {
    const int n = s.length();
    int i = 0;

    while (i < n && s[i] == 'a')
      ++i;
    if (i == n) {
      s[n - 1] = 'z';
      return s;
    }

    while (i < n && s[i] != 'a')
      --s[i++];

    return s;
  }
};",2734
2732,"class Solution {
 public:
  long long minCost(vector<int>& nums, long long x) {
    const int n = nums.size();
    long long ans = LLONG_MAX;
    // minCost[i] := the minimum cost to collect the i-th type
    vector<int> minCost(n, INT_MAX);

    for (int rotate = 0; rotate < n; ++rotate) {
      for (int i = 0; i < n; ++i)
        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n]);
      ans = min(ans,
                accumulate(minCost.begin(), minCost.end(), 0LL) + rotate * x);
    }

    return ans;
  }
};",2735
2733,"struct Pair {
  int x;
  int y;
};

struct IndexedQuery {
  int queryIndex;
  int minX;
  int minY;
};

class Solution {
 public:
  vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2,
                                vector<vector<int>>& queries) {
    const vector<Pair> pairs = getPairs(nums1, nums2);
    vector<int> ans(queries.size());
    vector<pair<int, int>> stack;  // [(y, x + y)]

    int pairsIndex = 0;
    for (const auto& [queryIndex, minX, minY] : getIndexedQueries(queries)) {
      while (pairsIndex < pairs.size() && pairs[pairsIndex].x >= minX) {
        const auto [x, y] = pairs[pairsIndex++];
        // x + y is a better candidate. Given that x is decreasing, the
        // condition ""x + y >= stack.back().second"" suggests that y is
        // relatively larger, thereby making it a better candidate.
        while (!stack.empty() && x + y >= stack.back().second)
          stack.pop_back();
        if (stack.empty() || y > stack.back().first)
          stack.emplace_back(y, x + y);
      }
      const auto it = ranges::lower_bound(stack, pair<int, int>{minY, INT_MIN});
      ans[queryIndex] = it == stack.end() ? -1 : it->second;
    }

    return ans;
  }

 private:
  vector<Pair> getPairs(const vector<int>& nums1, const vector<int>& nums2) {
    vector<Pair> pairs;
    for (int i = 0; i < nums1.size(); ++i)
      pairs.push_back({nums1[i], nums2[i]});
    ranges::sort(pairs, [](const Pair& a, const Pair& b) { return a.x > b.x; });
    return pairs;
  }

  vector<IndexedQuery> getIndexedQueries(const vector<vector<int>>& queries) {
    vector<IndexedQuery> indexedQueries;
    for (int i = 0; i < queries.size(); ++i)
      indexedQueries.push_back({i, queries[i][0], queries[i][1]});
    ranges::sort(indexedQueries,
                 [](const IndexedQuery& a, const IndexedQuery& b) {
      return a.minX > b.minX;
    });
    return indexedQueries;
  }
};",2736
2734,"class Solution {
 public:
  int minimumDistance(int n, vector<vector<int>>& edges, int s,
                      vector<int>& marked) {
    int ans = INT_MAX;
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
    }

    const vector<int> dist = dijkstra(graph, s);

    for (const int u : marked)
      ans = min(ans, dist[u]);

    return ans == INT_MAX ? -1 : ans;
  }

 private:
  vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {
    vector<int> dist(graph.size(), INT_MAX);
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
    }

    return dist;
  }
};",2737
2735,"SELECT 'bull' AS word, SUM(content LIKE '% bull %') AS count
FROM Files
UNION ALL
SELECT 'bear' AS word, SUM(content LIKE '% bear %') AS count
FROM Files;",2738
2736,"class Solution {
 public:
  int distanceTraveled(int mainTank, int additionalTank) {
    // M  M M M M  A  M M M M   A
    // 1 [2 3 4 5] 6 [7 8 9 10] 11
    return (mainTank + min((mainTank - 1) / 4, additionalTank)) * 10;
  }
};",2739
2737,"class Solution {
 public:
  int findValueOfPartition(vector<int>& nums) {
    int ans = INT_MAX;

    sort(begin(nums), end(nums));

    for (int i = 1; i < nums.size(); ++i)
      ans = min(ans, nums[i] - nums[i - 1]);

    return ans;
  }
};",2740
2738,"class Solution {
 public:
  int specialPerm(vector<int>& nums) {
    const int n = nums.size();
    const int maxMask = 1 << n;
    int ans = 0;
    vector<vector<int>> mem(n, vector<int>(maxMask));

    for (int i = 0; i < n; ++i) {
      ans += specialPerm(nums, i, 1 << i, maxMask, mem);
      ans %= kMod;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of special permutations, where the previous number is
  // nums[i] and `mask` is the bitmask of the used numbers.
  int specialPerm(const vector<int>& nums, int prev, int mask,
                  const int& maxMask, vector<vector<int>>& mem) {
    if (mask == maxMask - 1)
      return 1;
    if (mem[prev][mask] > 0)
      return mem[prev][mask];

    int res = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (mask >> i & 1)
        continue;
      if (nums[i] % nums[prev] == 0 || nums[prev] % nums[i] == 0) {
        res += specialPerm(nums, i, mask | 1 << i, maxMask, mem);
        res %= kMod;
      }
    }

    return mem[prev][mask] = res;
  }
};",2741
2739,"class Solution {
 public:
  int paintWalls(vector<int>& cost, vector<int>& time) {
    const int n = cost.size();
    vector<vector<int>> mem(n, vector<int>(n + 1));
    return paintWalls(cost, time, 0, time.size(), mem);
  }

 private:
  static constexpr int kMax = 500'000'000;

  // Returns the minimum cost to paint j walls by painters[i..n).
  int paintWalls(const vector<int>& cost, const vector<int>& time, int i,
                 int walls, vector<vector<int>>& mem) {
    if (walls <= 0)
      return 0;
    if (i == cost.size())
      return kMax;
    if (mem[i][walls] > 0)
      return mem[i][walls];
    const int pick =
        cost[i] + paintWalls(cost, time, i + 1, walls - time[i] - 1, mem);
    const int skip = paintWalls(cost, time, i + 1, walls, mem);
    return mem[i][walls] = min(pick, skip);
  }
};",2742
2740,"class Solution {
 public:
  int numberOfSpecialSubstrings(string s) {
    int ans = 0;
    vector<int> count(26);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      ++count[s[r] - 'a'];
      while (count[s[r] - 'a'] == 2)
        --count[s[l++] - 'a'];
      ans += r - l + 1;
    }

    return ans;
  }
};",2743
2741,"class Solution {
 public:
  int maximumNumberOfStringPairs(vector<string>& words) {
    int ans = 0;
    vector<bool> seen(26 * 26);

    for (const string& word : words) {
      if (seen[val(word[1]) * 26 + val(word[0])])
        ++ans;
      seen[val(word[0]) * 26 + val(word[1])] = true;
    }

    return ans;
  }

 private:
  constexpr int val(char c) {
    return c - 'a';
  }
};",2744
2742,"class Solution {
 public:
  int longestString(int x, int y, int z) {
    //""AB"" can always be easily appended within the string.
    // Alternating ""AA"" and ""BB"" can be appended, creating a pattern like ""AABB""
    // If x == y, we repeat the pattern ""AABBAABB...AABB"".
    // If x != y, the pattern becomes ""AABBAABB...AABBAA"" or ""BBAABBAABB...AABB""
    const int mini = min(x, y);
    if (x == y)
      return (mini * 2 + z) * 2;
    return (mini * 2 + 1 + z) * 2;
  }
};",2745
2743,"class Solution {
 public:
  int minimizeConcatenatedLength(vector<string>& words) {
    vector<vector<vector<int>>> mem(words.size(),
                                    vector<vector<int>>(26, vector<int>(26)));
    return words[0].length() + minimizeConcatenatedLength(words, 1,
                                                          words[0].front(),
                                                          words[0].back(), mem);
  }

 private:
  // Returns the minimum concatenated length of the first i words starting with
  // `first` and ending in `last`.
  int minimizeConcatenatedLength(const vector<string>& words, int i, char first,
                                 char last, vector<vector<vector<int>>>& mem) {
    if (i == words.size())
      return 0;
    const int j = first - 'a';
    const int k = last - 'a';
    if (mem[i][j][k] > 0)
      return mem[i][j][k];
    const char nextFirst = words[i].front();
    const char nextLast = words[i].back();
    return mem[i][j][k] =  //
           words[i].length() +
           min(
               // join(words[i - 1], words[i])
               minimizeConcatenatedLength(words, i + 1, first, nextLast, mem) -
                   (last == nextFirst ? 1 : 0),
               // join(words[i], words[i - 1])
               minimizeConcatenatedLength(words, i + 1, nextFirst, last, mem) -
                   (first == nextLast ? 1 : 0));
  }
};",2746
2744,"struct IndexedQuery {
  int queryIndex;
  int query;
};

class Solution {
 public:
  vector<int> countServers(int n, vector<vector<int>>& logs, int x,
                           vector<int>& queries) {
    vector<int> ans(queries.size());
    vector<int> count(n + 1);

    ranges::sort(logs, [](const vector<int>& a, const vector<int>& b) {
      return a[1] < b[1];
    });

    int i = 0;
    int j = 0;
    int servers = 0;

    // For each query, we care about logs[i..j].
    for (const auto& [queryIndex, query] : getIndexedQueries(queries)) {
      for (; j < logs.size() && logs[j][1] <= query; ++j)
        if (++count[logs[j][0]] == 1)
          ++servers;
      for (; i < logs.size() && logs[i][1] < query - x; ++i)
        if (--count[logs[i][0]] == 0)
          --servers;
      ans[queryIndex] = n - servers;
    }

    return ans;
  }

 private:
  vector<IndexedQuery> getIndexedQueries(const vector<int>& queries) {
    vector<IndexedQuery> indexedQueries;
    for (int i = 0; i < queries.size(); ++i)
      indexedQueries.push_back({i, queries[i]});
    ranges::sort(indexedQueries,
                 [](const IndexedQuery& a, const IndexedQuery& b) {
      return a.query < b.query;
    });
    return indexedQueries;
  }
};",2747
2745,"class Solution {
 public:
  int countBeautifulPairs(vector<int>& nums) {
    int ans = 0;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = i + 1; j < nums.size(); ++j)
        if (__gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1)
          ++ans;

    return ans;
  }

 private:
  int firstDigit(int num) {
    return to_string(num)[0] - '0';
  }

  int lastDigit(int num) {
    return num % 10;
  }
};",2748
2746,"class Solution {
 public:
  int makeTheIntegerZero(int num1, int num2) {
    // If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +
    // ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +
    // ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].
    // Note that for any number x, we can use ""x's bit count"" operations to make
    // x equal to 0. Additionally, we can also use x operations to deduct x by
    // 2^0 (x times), which also results in 0.

    for (long ops = 0; ops <= 60; ++ops) {
      const long target = num1 - ops * num2;
      if (__builtin_popcountl(target) <= ops && ops <= target)
        return ops;
    }

    return -1;
  }
};",2749
2747,"class Solution {
 public:
  int numberOfGoodSubarraySplits(vector<int>& nums) {
    if (ranges::count(nums, 1) == 0)
      return 0;

    constexpr int kMod = 1'000'000'007;
    int prev = -1;  // the previous index of 1
    int ans = 1;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == 1) {
        if (prev != -1)
          ans = ans * static_cast<long>(i - prev) % kMod;
        prev = i;
      }

    return ans;
  }
};",2750
2748,"struct Robot {
  int index;
  int position;
  int health;
  char direction;
};

class Solution {
 public:
  vector<int> survivedRobotsHealths(vector<int>& positions,
                                    vector<int>& healths, string directions) {
    vector<int> ans;
    vector<Robot> robots;
    vector<Robot> stack;  // the runnnig robots

    for (int i = 0; i < positions.size(); ++i)
      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});

    ranges::sort(robots, [](const Robot& a, const Robot& b) {
      return a.position < b.position;
    });

    for (Robot& robot : robots) {
      if (robot.direction == 'R') {
        stack.push_back(robot);
        continue;
      }
      // Collide with robots going right if any.
      while (!stack.empty() && stack.back().direction == 'R' &&
             robot.health > 0) {
        if (stack.back().health == robot.health) {
          stack.pop_back();
          robot.health = 0;
        } else if (stack.back().health < robot.health) {
          stack.pop_back();
          robot.health -= 1;
        } else {  // stack.back().health > robot.health
          stack.back().health -= 1;
          robot.health = 0;
        }
      }
      if (robot.health > 0)
        stack.push_back(robot);
    }

    ranges::sort(stack, [](const Robot& a, const Robot& b) {
      return a.index < b.index;
    });

    for (const Robot& robot : stack)
      ans.push_back(robot.health);

    return ans;
  }
};",2751
2749,"WITH
  TransactionsWithGroupId AS (
    SELECT
      customer_id,
      TO_DAYS(transaction_date) - ROW_NUMBER() OVER(
        PARTITION BY customer_id
        ORDER BY transaction_date
      ) AS group_id
    FROM Transactions
  ),
  RankedCustomers AS (
    SELECT
      customer_id,
      RANK() OVER(ORDER BY COUNT(*) DESC) AS `rank`
    FROM TransactionsWithGroupId
    GROUP BY customer_id, group_id
  )
SELECT customer_id
FROM RankedCustomers
WHERE `rank` = 1
ORDER BY 1;",2752
2750,"/**
 * Definition for a street.
 * class Street {
 *  public:
 *   Street(vector<int> doors);
 *   void closeDoor();
 *   bool isDoorOpen();
 *   void moveRight();
 * };
 */
class Solution {
 public:
  int houseCount(Street* street, int k) {
    int ans = 0;

    // Go to the first open door.
    while (!street->isDoorOpen())
      street->moveRight();

    street->moveRight();

    for (int count = 1; count <= k; ++count) {
      // Each time we encounter an open door, there's a possibility that it's
      // the first open door we intentionally left open.
      if (street->isDoorOpen()) {
        ans = count;
        street->closeDoor();
      }
      street->moveRight();
    }

    return ans;
  }
};",2753
2751,"type Fn = (...args) => any;

declare global {
  interface Function {
    bindPolyfill(obj: Record<any, any>): Fn;
  }
}

Function.prototype.bindPolyfill = function (obj): Fn {
  return (...newArgs) => this.call(obj, ...newArgs);
};",2754
2752,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function deepMerge(obj1: JSONValue, obj2: JSONValue): JSONValue {
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return obj2;
  }
  if (obj1 === null || obj2 === null) {
    return obj2;
  }
  if (Array.isArray(obj1) !== Array.isArray(obj2)) {
    return obj2;
  }
  const ans = obj1;
  for (const key in obj2) {
    if (key in ans) {
      ans[key] = deepMerge(ans[key], obj2[key]);
    } else {
      ans[key] = obj2[key];
    }
  }
  return ans;
}",2755
2753,"type QueryMultipleFn = (keys: string[]) => Promise<string[]>;

type ThrottledRequest = {
  key: string;
  resolve: (result: string) => void;
};

class QueryBatcher {
  private readonly queryMultiple: QueryMultipleFn;
  private readonly throttleTime: number;
  private isThrottling: boolean;
  private throttledRequests: ThrottledRequest[];

  constructor(queryMultiple: QueryMultipleFn, t: number) {
    this.queryMultiple = queryMultiple;
    this.throttleTime = t;
    this.isThrottling = false;
    this.throttledRequests = [];
  }

  async getValue(key: string): Promise<string> {
    if (this.throttleTime === 0) {
      const results = await this.queryMultiple([key]);
      return results[0];
    }
    if (this.isThrottling) {
      return new Promise<string>((resolve) => {
        this.throttledRequests.push({ key, resolve });
      });
    }
    this.isThrottling = true;
    setTimeout(() => this.deThrottle(), this.throttleTime);
    const results = await this.queryMultiple([key]);
    return results[0];
  }

  // De-throttles and processes any pending requests.
  private deThrottle(): void {
    const throttledRequests = this.throttledRequests;
    if (throttledRequests.length === 0) {
      this.isThrottling = false;
    } else {
      const keys = throttledRequests.map((req) => req.key);
      this.queryMultiple(keys).then((results) => {
        results.forEach((result, index) => {
          throttledRequests[index].resolve(result);
        });
      });
      setTimeout(() => this.deThrottle(), this.throttleTime);
      this.throttledRequests = [];
    }
  }
}",2756
2754,"function* cycleGenerator(
  arr: number[],
  startIndex: number
): Generator<number, void, number> {
  const n = arr.length;
  let index = startIndex;
  while (true) {
    const jump = yield arr[index];
    index = (index + (jump % n) + n) % n;
  }
}",2757
2755,"declare global {
  interface Date {
    nextDay(): string;
  }
}

Date.prototype.nextDay = function () {
  const today = new Date(this.getTime());
  today.setDate(today.getDate() + 1);
  return today.toISOString().split('T')[0];
};",2758
2756,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

class JSONParser {
  private str: string;
  private i: number;

  constructor(str: string) {
    this.str = str;
    this.i = 0;
  }

  public parse(): JSONValue {
    return this.parseValue();
  }

  private parseValue(): JSONValue {
    switch (this.str[this.i]) {
      case '{':
        return this.parseObject();
      case '[':
        return this.parseArray();
      case 't': // true
      case 'f': // false
      case 'n': // null
        return this.parseLiteral();
      case '""':
        return this.parseString();
      default:
        return this.parseNumber();
    }
  }

  private parseObject(): JSONValue {
    ++this.i;

    const ans: JSONValue = {};

    while (this.i < this.str.length && this.str[this.i] !== '}') {
      const key = this.parseString();
      this.expectChar(':');
      const value = this.parseValue();

      ans[key] = value;
      if (this.str[this.i] === ',') {
        ++this.i;
      }
    }

    ++this.i;
    return ans;
  }

  private parseArray(): JSONValue[] {
    ++this.i;

    const ans: JSONValue[] = [];

    while (this.i < this.str.length && this.str[this.i] !== ']') {
      const value = this.parseValue();
      ans.push(value);
      if (this.str[this.i] === ',') {
        ++this.i;
      }
    }

    ++this.i;
    return ans;
  }

  private parseLiteral(): boolean | null {
    if (this.str.startsWith('true', this.i)) {
      this.i += 4;
      return true;
    }
    if (this.str.startsWith('false', this.i)) {
      this.i += 5;
      return false;
    }
    if (this.str.startsWith('null', this.i)) {
      this.i += 4;
      return null;
    }
    throw new Error(`Unexpected token at position ${this.i}`);
  }

  private parseString(): string {
    let ans = '';
    ++this.i;

    while (this.i < this.str.length && this.str[this.i] !== '""') {
      ans += this.str[this.i];
      ++this.i;
    }

    ++this.i;
    return ans;
  }

  private parseNumber(): number {
    let start = this.i;

    if (this.str[this.i] === '-') {
      ++this.i;
    }

    while (this.i < this.str.length && this.isDigit(this.str[this.i])) {
      ++this.i;
    }

    if (this.str[this.i] === '.') {
      ++this.i;
      while (this.i < this.str.length && this.isDigit(this.str[this.i])) {
        ++this.i;
      }
    }

    return Number(this.str.slice(start, this.i));
  }

  private isDigit(n: string): boolean {
    return n >= '0' && n <= '9';
  }

  private expectChar(char: string): void {
    if (this.str[this.i] !== char) {
      throw new Error(`Expected '${char}' at position ${this.i}`);
    }
    ++this.i;
  }
}

function jsonParse(str: string): JSONValue {
  const parser = new JSONParser(str);
  return parser.parse();
}",2759
2757,"class Solution {
 public:
  int longestAlternatingSubarray(vector<int>& nums, int threshold) {
    int ans = 0;
    int dp = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > threshold)
        dp = 0;
      else if (i > 0 && dp > 0 && isOddEven(nums[i - 1], nums[i]))
        // Increase the size of the subarray.
        ++dp;
      else
        // Start a new subarray if the start is valid.
        dp = nums[i] % 2 == 0 ? 1 : 0;
      ans = max(ans, dp);
    }

    return ans;
  }

 private:
  bool isOddEven(int a, int b) {
    return a % 2 != b % 2;
  }
};",2760
2758,"class Solution {
 public:
  vector<vector<int>> findPrimePairs(int n) {
    const vector<bool> isPrime = sieveEratosthenes(n + 1);
    vector<vector<int>> ans;

    for (int i = 2; i <= n / 2; ++i)
      if (isPrime[i] && isPrime[n - i])
        ans.push_back({i, n - i});

    return ans;
  }

 private:
  vector<bool> sieveEratosthenes(int n) {
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    return isPrime;
  }
};",2761
2759,"class Solution {
 public:
  long long continuousSubarrays(vector<int>& nums) {
    long long ans = 1;  // [nums[0]]
    int left = nums[0] - 2;
    int right = nums[0] + 2;
    int l = 0;

    // nums[l..r] is a valid window with range in [left, right].
    for (int r = 1; r < nums.size(); r++) {
      if (left <= nums[r] && nums[r] <= right) {
        left = max(left, nums[r] - 2);
        right = min(right, nums[r] + 2);
      } else {
        // nums[r] is out-of-bounds, so reconstruct the window.
        left = nums[r] - 2;
        right = nums[r] + 2;
        l = r;
        // If we consistently move leftward in each iteration, it implies that
        // the entire left subarray satisfies the given condition. For every
        // subarray with l in the range [0, r], the condition is met, preventing
        // the code from reaching the final ""else"" condition. Instead, it stops
        // at the ""if"" condition.
        while (nums[r] - 2 <= nums[l] && nums[l] <= nums[r] + 2) {
          left = max(left, nums[l] - 2);
          right = min(right, nums[l] + 2);
          --l;
        }
        ++l;
      }
      // nums[l..r], nums[l + 1..r], ..., nums[r]
      ans += r - l + 1;
    }

    return ans;
  }
};",2762
2760,"class Solution {
 public:
  // If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead
  // of determining the number of gaps in each subarray, let's find out how many
  // subarrays contain each gap.
  int sumImbalanceNumbers(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // Note that to avoid double counting, only `left` needs to check nums[i].
    // This adjustment ensures that i represents the position of the leftmost
    // element of nums[i] within the subarray.

    // left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1
    vector<int> left(n);
    // right[i] := the minimum index r s.t. nums[r] = nums[i]
    vector<int> right(n);

    vector<int> numToIndex(n + 2, -1);
    for (int i = 0; i < n; ++i) {
      left[i] = max(numToIndex[nums[i]], numToIndex[nums[i] + 1]);
      numToIndex[nums[i]] = i;
    }

    fill(numToIndex.begin(), numToIndex.end(), n);
    for (int i = n - 1; i >= 0; --i) {
      right[i] = numToIndex[nums[i] + 1];
      numToIndex[nums[i]] = i;
    }

    // The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.
    // Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]
    // and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)
    // subarrays satisfying this condition.
    for (int i = 0; i < n; ++i)
      ans += (i - left[i]) * (right[i] - i);

    // Subtract n * (n + 1) / 2 to account for the overcounting of elements
    // initially assumed to have a gap. This adjustment is necessary as the
    // maximum element of every subarray does not have a gap.
    return ans - n * (n + 1) / 2;
  }
};",2763
2761,"class Solution {
 public:
  bool isPreorder(vector<vector<int>>& nodes) {
    stack<int> stack;  // Stores `id`s.

    for (const vector<int>& node : nodes) {
      const int id = node[0];
      const int parentId = node[1];
      if (parentId == -1) {
        stack.push(id);
        continue;
      }
      while (!stack.empty() && stack.top() != parentId)
        stack.pop();
      if (stack.empty())
        return false;
      stack.push(id);
    }

    return true;
  }
};",2764
2762,"class Solution {
 public:
  int alternatingSubarray(vector<int>& nums) {
    int ans = 1;
    int dp = 1;

    for (int i = 1; i < nums.size(); ++i) {
      const int targetDiff = dp % 2 == 0 ? -1 : 1;
      // Append nums[i] to the current alternating subarray.
      if (nums[i] - nums[i - 1] == targetDiff)
        ++dp;
      // Reset the alternating subarray to nums[i - 1..i].
      else if (nums[i] - nums[i - 1] == 1)
        dp = 2;
      // Reset the alternating subarray to nums[i].
      else
        dp = 1;
      ans = max(ans, dp);
    }

    return ans == 1 ? -1 : ans;
  }
};",2765
2763,"class Solution {
 public:
  vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom,
                              vector<int>& moveTo) {
    set<int> numsSet{nums.begin(), nums.end()};

    for (int i = 0; i < moveFrom.size(); ++i) {
      numsSet.erase(numsSet.find(moveFrom[i]));
      numsSet.insert(moveTo[i]);
    }

    return {numsSet.begin(), numsSet.end()};
  }
};",2766
2764,"class Solution {
 public:
  int minimumBeautifulSubstrings(string s) {
    const int n = s.length();
    // dp[i] := the minimum number of beautiful substrings for the first i chars
    vector<int> dp(n + 1, n + 1);
    dp[0] = 0;

    for (int i = 1; i <= n; ++i) {
      if (s[i - 1] == '0')
        continue;
      int num = 0;  // num of s[i - 1..j - 1]
      for (int j = i; j <= n; ++j) {
        num = (num << 1) + s[j - 1] - '0';
        if (isPowerOfFive(num))
          dp[j] = min(dp[j], dp[i - 1] + 1);
      }
    }

    return dp[n] == n + 1 ? -1 : dp[n];
  }

 private:
  bool isPowerOfFive(int num) {
    while (num % 5 == 0)
      num /= 5;
    return num == 1;
  }
};",2767
2765,"class Solution {
 public:
  vector<long long> countBlackBlocks(int m, int n,
                                     vector<vector<int>>& coordinates) {
    vector<long long> ans(5);
    // count[i * n + j] := the number of black cells in
    // (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)
    unordered_map<long long, int> count;

    for (const vector<int>& coordinate : coordinates) {
      const int x = coordinate[0];
      const int y = coordinate[1];
      for (long long i = x; i < x + 2; ++i)
        for (long long j = y; j < y + 2; ++j)
          // 2 x 2 submatrix with right-bottom conner being (i, j) contains the
          // current black cell (x, y).
          if (i - 1 >= 0 && i < m && j - 1 >= 0 && j < n)
            ++count[i * n + j];
    }

    for (const auto& [_, freq] : count)
      ++ans[freq];

    ans[0] = (m - 1LL) * (n - 1) - accumulate(ans.begin(), ans.end(), 0LL);
    return ans;
  }
};",2768
2766,"class Solution {
 public:
  int theMaximumAchievableX(int num, int t) {
    return num + 2 * t;
  }
};",2769
2767,"class Solution {
 public:
  int maximumJumps(vector<int>& nums, int target) {
    const int n = nums.size();
    // dp[i] := the maximum number of jumps to reach i from 0
    vector<int> dp(n, -1);
    dp[0] = 0;

    for (int j = 1; j < n; ++j)
      for (int i = 0; i < j; ++i)
        if (dp[i] != -1 && abs(nums[j] - nums[i]) <= target)
          dp[j] = max(dp[j], dp[i] + 1);

    return dp[n - 1];
  }
};",2770
2768,"class Solution {
 public:
  int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {
    int ans = 1;
    int dp1 = 1;  // the longest subarray that ends in nums1[i] so far
    int dp2 = 1;  // the longest subarray that ends in nums2[i] so far

    for (int i = 1; i < nums1.size(); ++i) {
      const int dp11 = nums1[i - 1] <= nums1[i] ? dp1 + 1 : 1;
      const int dp21 = nums2[i - 1] <= nums1[i] ? dp2 + 1 : 1;
      const int dp12 = nums1[i - 1] <= nums2[i] ? dp1 + 1 : 1;
      const int dp22 = nums2[i - 1] <= nums2[i] ? dp2 + 1 : 1;
      dp1 = max(dp11, dp21);
      dp2 = max(dp12, dp22);
      ans = max({ans, dp1, dp2});
    }

    return ans;
  }
};",2771
2769,"class Solution {
 public:
  bool checkArray(vector<int>& nums, int k) {
    if (k == 1)
      return true;

    int needDecrease = 0;
    // Store nums[i - k + 1..i] with decreasing nums[i - k + 1].
    deque<int> dq;

    for (int i = 0; i < nums.size(); ++i) {
      if (i >= k) {
        needDecrease -= dq.front();
        dq.pop_front();
      }
      if (nums[i] < needDecrease)
        return false;
      const int decreasedNum = nums[i] - needDecrease;
      dq.push_back(decreasedNum);
      needDecrease += decreasedNum;
    }

    return dq.back() == 0;
  }
};",2772
2770,"class Solution {
 public:
  int heightOfTree(TreeNode* root) {
    if (root == nullptr)
      return 0;
    // a leaf node
    if (root->left != nullptr && root->left->right == root)
      return 0;
    return 1 + max(heightOfTree(root->left), heightOfTree(root->right));
  }
};",2773
2771,"declare global {
  interface Array<T> {
    upperBound(target: number): number;
  }
}

Array.prototype.upperBound = function (target): number {
  let l = 0;
  let r = this.length - 1;
  while (l < r) {
    const m = (l + r + 1) >> 1;
    if (this[m] > target) {
      r = m - 1;
    } else {
      l = m;
    }
  }
  return this[l] == target ? l : -1;
};",2774
2772,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Value =
  | undefined
  | null
  | boolean
  | number
  | string
  | Value[]
  | { [key: string]: Value };

type Obj1 = Record<string, Value> | Array<Value>;
type Obj2 = Record<string, JSONValue> | Array<JSONValue>;

function undefinedToNull(obj: Obj1): Obj2 {
  if (obj === undefined || obj === null) {
    return null;
  }
  if (
    typeof obj === 'boolean' ||
    typeof obj === 'number' ||
    typeof obj === 'string'
  ) {
    return obj;
  }
  for (const key in obj) {
    obj[key] = undefinedToNull(obj[key]);
  }
  return obj;
}",2775
2773,"type CallbackFn = (
  next: (data: number, error: string) => void,
  ...args: number[]
) => void;
type Promisified = (...args: number[]) => Promise<number>;

function promisify(fn: CallbackFn): Promisified {
  return async function (...args: number[]): Promise<number> {
    return new Promise((resolve, reject) =>
      fn((data, err) => (err ? reject(err) : resolve(data)), ...args)
    );
  };
}",2776
2774,"// Similar to 2758. Next Day
function* dateRangeGenerator(
  start: string,
  end: string,
  step: number
): Generator<string> {
  const startDate = new Date(start);
  const endDate = new Date(end);
  let currentDate = startDate;
  while (currentDate <= endDate) {
    yield currentDate.toISOString().split('T')[0];
    currentDate.setDate(currentDate.getDate() + step);
  }
}",2777
2775,"class Solution {
 public:
  int sumOfSquares(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;

    for (int i = 0; i < n; ++i)
      if (n % (i + 1) == 0)
        ans += nums[i] * nums[i];

    return ans;
  }
};",2778
2776,"class Solution {
 public:
  int maximumBeauty(vector<int>& nums, int k) {
    int ans = 0;

    ranges::sort(nums);

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (nums[r] - nums[l] > 2 * k)
        ++l;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",2779
2777,"class Solution {
 public:
  int minimumIndex(vector<int>& nums) {
    const int n = nums.size();
    unordered_map<int, int> count1;
    unordered_map<int, int> count2;

    for (const int num : nums)
      ++count2[num];

    for (int i = 0; i < n; ++i) {
      const int freq1 = ++count1[nums[i]];
      const int freq2 = --count2[nums[i]];
      if (freq1 * 2 > i + 1 && freq2 * 2 > n - 1 - i)
        return i;
    }

    return -1;
  }
};",2780
2778,"class Solution {
 public:
  int longestValidSubstring(string word, vector<string>& forbidden) {
    int ans = 0;
    unordered_set<string> forbiddenSet{forbidden.begin(), forbidden.end()};

    // r is the rightmost index to make word[l..r] a valid substring.
    int r = word.length() - 1;
    for (int l = word.length() - 1; l >= 0; --l) {
      for (int end = l; end < min(l + 10, r + 1); ++end)
        if (forbiddenSet.count(word.substr(l, end - l + 1))) {
          r = end - 1;
          break;
        }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",2781
2779,"/**
 * Definition for a category handler.
 * class CategoryHandler {
 *  public:
 *   CategoryHandler(vector<int> categories);
 *   bool haveSameCategory(int a, int b);
 * };
 */

class Solution {
 public:
  int numberOfCategories(int n, CategoryHandler* categoryHandler) {
    int ans = 0;

    for (int i = 0; i < n; ++i)
      if (!haveSameCategoryPreviously(i, n, categoryHandler))
        ++ans;

    return ans;
  }

 private:
  bool haveSameCategoryPreviously(int i, int n,
                                  CategoryHandler* categoryHandler) {
    for (int j = 0; j < i; ++j)
      if (categoryHandler->haveSameCategory(i, j))
        return true;
    return false;
  }
};",2782
2780,"SELECT
  Flights.flight_id,
  LEAST(Flights.capacity, COUNT(Passengers.flight_id)) AS booked_cnt,
  GREATEST(0, COUNT(Passengers.flight_id) - Flights.capacity) AS waitlist_cnt
FROM Flights
LEFT JOIN Passengers
  USING (flight_id)
GROUP BY 1
ORDER BY 1;",2783
2781,"class Solution {
 public:
  bool isGood(vector<int>& nums) {
    constexpr int kMax = 200;
    const int n = nums.size() - 1;
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    return all_of(count.begin() + 1, count.begin() + n,
                  [](int c) { return c == 1; }) &&
           count[n] == 2;
  }
};",2784
2782,"class Solution {
 public:
  string sortVowels(string s) {
    string ans;
    vector<char> vowels;

    for (const char c : s)
      if (isVowel(c))
        vowels.push_back(c);

    ranges::sort(vowels);

    int i = 0;  // vowels' index
    for (const char c : s)
      ans += isVowel(c) ? vowels[i++] : c;

    return ans;
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }
};",2785
2783,"class Solution {
 public:
  long long maxScore(vector<int>& nums, int x) {
    // Note that we always need to take nums[0], so the initial definition might
    // not hold true.

    // dp0 := the maximum score so far with `nums` ending in an even number
    long long dp0 = nums[0] - (nums[0] % 2 == 1 ? x : 0);
    // dp1 := the maximum score so far with `nums` ending in an odd number
    long long dp1 = nums[0] - (nums[0] % 2 == 0 ? x : 0);

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] % 2 == 0)
        dp0 = nums[i] + max(dp0, dp1 - x);
      else
        dp1 = nums[i] + max(dp1, dp0 - x);

    return max(dp0, dp1);
  }
};",2786
2784,"class Solution {
 public:
  int numberOfWays(int n, int x) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := the number of ways to express i
    vector<int> dp(n + 1);
    int ax;  // a^x

    dp[0] = 1;

    for (int a = 1; (ax = pow(a, x)) <= n; ++a)
      for (int i = n; i >= ax; --i) {
        dp[i] += dp[i - ax];
        dp[i] %= kMod;
      }

    return dp[n];
  }
};",2787
2785,"class Solution {
 public:
  vector<string> splitWordsBySeparator(vector<string>& words, char separator) {
    vector<string> ans;

    for (const string& word : words) {
      istringstream iss(word);
      for (string word; getline(iss, word, separator);)
        if (!word.empty())
          ans.push_back(word);
    }

    return ans;
  }
};",2788
2786,"class Solution {
 public:
  long long maxArrayValue(vector<int>& nums) {
    long long ans = nums.back();

    for (int i = nums.size() - 2; i >= 0; --i)
      if (nums[i] > ans)
        ans = nums[i];
      else
        ans += nums[i];

    return ans;
  }
};",2789
2787,"class Solution {
 public:
  int maxIncreasingGroups(vector<int>& usageLimits) {
    int ans = 1;  // the next target length
    long long availableLimits = 0;

    ranges::sort(usageLimits);

    for (const int usageLimit : usageLimits) {
      availableLimits += usageLimit;
      // Can create groups 1, 2, ..., ans.
      if (availableLimits >= ans * static_cast<long>(ans + 1) / 2)
        ++ans;
    }

    return ans - 1;
  }
};",2790
2788,"class Solution {
 public:
  long long countPalindromePaths(vector<int>& parent, string s) {
    // A valid (u, v) has at most 1 letter with odd frequency on its path. The
    // frequency of a letter on the u-v path is equal to the sum of its
    // frequencies on the root-u and root-v paths substract twice of its
    // frequency on the root-LCA(u, v) path. Considering only the parity
    // (even/odd), the part involving root-LCA(u, v) can be ignored, making it
    // possible to calculate both parts easily using a simple DFS.
    vector<vector<int>> tree(parent.size());

    for (int i = 1; i < parent.size(); ++i)
      tree[parent[i]].push_back(i);

    return dfs(tree, 0, 0, s, {{0, 1}});
  }

 private:
  // mask := 26 bits that represent the parity of each character in the alphabet
  // on the path from node 0 to node u
  long long dfs(const vector<vector<int>>& tree, int u, int mask,
                const string& s, unordered_map<int, int>&& maskToCount) {
    long long res = 0;
    if (u > 0) {
      mask ^= 1 << (s[u] - 'a');
      // Consider any u-v path with 1 bit set.
      for (int i = 0; i < 26; ++i)
        if (const auto it = maskToCount.find(mask ^ (1 << i));
            it != maskToCount.cend())
          res += it->second;
      // Consider u-v path with 0 bit set.
      res += maskToCount[mask ^ 0]++;
    }
    for (const int v : tree[u])
      res += dfs(tree, v, mask, s, move(maskToCount));
    return res;
  }
};",2791
2789,"class Solution {
 public:
  int countGreatEnoughNodes(TreeNode* root, int k) {
    int ans = 0;
    dfs(root, k, ans);
    return ans;
  }

 private:
  multiset<int> dfs(TreeNode* root, int k, int& ans) {
    if (root == nullptr)
      return {};

    multiset<int> kSmallest = dfs(root->left, k, ans);
    multiset<int> kSmallestRight = dfs(root->right, k, ans);
    kSmallest.merge(kSmallestRight);

    if (kSmallest.size() > k)
      kSmallest.erase(next(kSmallest.begin(), k), kSmallest.end());
    if (kSmallest.size() == k && root->val > *kSmallest.rbegin())
      ++ans;

    kSmallest.insert(root->val);
    return kSmallest;
  }
};",2792
2790,"SELECT
  Passengers.passenger_id,
  IF(
    RANK() OVER(
      PARTITION BY Passengers.flight_id
      ORDER BY Passengers.booking_time
    ) <= Flights.capacity,
    'Confirmed',
    'Waitlist'
  ) AS status
FROM Passengers
INNER JOIN Flights
  USING (flight_id)
ORDER BY 1;",2793
2791,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };

function createObject(
  keysArr: JSONValue[],
  valuesArr: JSONValue[]
): Record<string, JSONValue> {
  let ans: Record<string, JSONValue> = {};
  keysArr.forEach((key, index) => {
    let stringKey: string = typeof key === 'string' ? key : String(key);
    if (!(stringKey in ans)) {
      ans[stringKey] = valuesArr[index];
    }
  });
  return ans;
}",2794
2792,"type FulfilledObj = {
  status: 'fulfilled';
  value: string;
};
type RejectedObj = {
  status: 'rejected';
  reason: string;
};
type Obj = FulfilledObj | RejectedObj;

function promiseAllSettled(functions: Function[]): Promise<Obj[]> {
  return new Promise((resolve) => {
    const results: Obj[] = Array.from({ length: functions.length });
    let count = 0;
    functions.forEach((fn, index) => {
      fn()
        .then((value) => {
          results[index] = { status: 'fulfilled', value };
        })
        .catch((reason) => {
          results[index] = { status: 'rejected', reason };
        })
        .finally(() => {
          if (++count === functions.length) {
            resolve(results);
          }
        });
    });
  });
}",2795
2793,"declare global {
  interface String {
    replicate(times: number): string;
  }
}

String.prototype.replicate = function (times): string {
  return Array(times).fill(this).join('');
};",2796
2794,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Fn = (...args: JSONValue[]) => JSONValue;

function partial(fn: Fn, args: JSONValue[]): Fn {
  return function (...restArgs) {
    return fn(
      ...args
        .map((arg) => (arg === '_' ? restArgs.shift() : arg))
        .concat(restArgs)
    );
  };
}",2797
2795,"class Solution {
 public:
  int numberOfEmployeesWhoMetTarget(vector<int>& hours, int target) {
    return ranges::count_if(hours,
                            [target](int hour) { return hour >= target; });
  }
};",2798
2796,"class Solution {
 public:
  int countCompleteSubarrays(vector<int>& nums) {
    constexpr int kMax = 2000;
    const int totalDistinct =
        unordered_set<int>(nums.begin(), nums.end()).size();
    int ans = 0;
    int distinct = 0;
    vector<int> count(kMax + 1);

    int l = 0;
    for (const int num : nums) {
      if (++count[num] == 1)
        ++distinct;
      while (distinct == totalDistinct)
        if (--count[nums[l++]] == 0)
          --distinct;
      // Assume nums[r] = num,
      // nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.
      ans += l;
    }

    return ans;
  }
};",2799
2797,"class Solution {
 public:
  string minimumString(string a, string b, string c) {
    const string abc = merge(a, merge(b, c));
    const string acb = merge(a, merge(c, b));
    const string bac = merge(b, merge(a, c));
    const string bca = merge(b, merge(c, a));
    const string cab = merge(c, merge(a, b));
    const string cba = merge(c, merge(b, a));
    return getMin({abc, acb, bac, bca, cab, cba});
  }

 private:
  // Merges a and b.
  string merge(const string& a, const string& b) {
    if (b.find(a) != string::npos)  // a is a substring of b.
      return b;
    for (int i = 0; i < a.length(); ++i) {
      const string aSuffix = a.substr(i);
      const string bPrefix = b.substr(0, min(b.length(), aSuffix.length()));
      if (aSuffix == bPrefix)
        return a + b.substr(bPrefix.length());
    }
    return a + b;
  }

  // Returns the lexicographically smallest string.
  string getMin(const vector<string>& words) {
    string res = words[0];
    for (int i = 1; i < words.size(); ++i)
      res = getMin(res, words[i]);
    return res;
  }

  // Returns the lexicographically smaller string.
  string getMin(const string& a, const string& b) {
    return (a.length() < b.length() || (a.length() == b.length() && a < b)) ? a
                                                                            : b;
  }
};",2800
2798,"class Solution {
 public:
  int countSteppingNumbers(string low, string high) {
    const string lowWithLeadingZeros =
        string(high.length() - low.length(), '0') + low;
    vector<vector<vector<vector<int>>>> mem(
        high.length(), vector<vector<vector<int>>>(
                           11, vector<vector<int>>(2, vector<int>(2, -1))));
    return count(lowWithLeadingZeros, high, 0, 10, /*isLeadingZero=*/true, true,
                 true, mem);
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns the number of valid integers, considering the i-th digit, where
  // `prevDigit` is the previous digit, `isTight1` indicates if the current
  // digit is tightly bound for `low`, and `isTight2` indicates if the current
  // digit is tightly bound for `high`.
  int count(const string& low, const string& high, int i, int prevDigit,
            bool isLeadingZero, bool isTight1, bool isTight2,
            vector<vector<vector<vector<int>>>>& mem) {
    if (i == high.length())
      return 1;
    if (mem[i][prevDigit][isTight1][isTight2] != -1)
      return mem[i][prevDigit][isTight1][isTight2];

    int res = 0;
    const int minDigit = isTight1 ? low[i] - '0' : 0;
    const int maxDigit = isTight2 ? high[i] - '0' : 9;

    for (int d = minDigit; d <= maxDigit; ++d) {
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      if (isLeadingZero)
        // Can place any digit in [minDigit, maxDigit].
        res += count(low, high, i + 1, d, isLeadingZero && d == 0, nextIsTight1,
                     nextIsTight2, mem);
      else if (abs(d - prevDigit) == 1)
        // Can only place prevDigit - 1 or prevDigit + 1.
        res +=
            count(low, high, i + 1, d, false, nextIsTight1, nextIsTight2, mem);
      res %= kMod;
    }

    return mem[i][prevDigit][isTight1][isTight2] = res;
  }
};",2801
2799,"class Solution {
 public:
  string kthLuckyNumber(int k) {
    string ans;

    for (int i = k + 1; i > 0; i /= 2)
      ans += i & 1 ? '7' : '4';

    reverse(ans.begin(), ans.end());
    return ans.substr(1);
  }
};",2802
2800,"function* factorial(n: number): Generator<number> {
  if (n === 0) {
    yield 1;
  }
  let fact = 1;
  for (let i = 1; i <= n; ++i) {
    fact *= i;
    yield fact;
  }
}",2803
2801,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Callback = (
  currentValue: JSONValue,
  index: number,
  array: JSONValue[]
) => any;
type Context = Record<string, JSONValue>;

Array.prototype.forEach = function (
  callback: Callback,
  context: Context
): void {
  for (let i = 0; i < this.length; ++i) {
    callback.call(context, this[i], i, this);
  }
};",2804
2802,"let id = 0;
const idToTimeout = {};

function customInterval(fn: Function, delay: number, period: number): number {
  ++id;
  (function callFnWithCountPlusOne(count: number): void {
    const timeout = setTimeout(() => {
      fn();
      callFnWithCountPlusOne(count + 1);
    }, delay + period * count);
    idToTimeout[id] = timeout;
  })(0);
  return id;
}

function customClearInterval(id: number): void {
  clearTimeout(idToTimeout[id]);
}",2805
2803,"class Solution {
 public:
  int accountBalanceAfterPurchase(int purchaseAmount) {
    return 100 - ((purchaseAmount + 5) / 10) * 10;
  }
};",2806
2804,"class Solution {
 public:
  ListNode* insertGreatestCommonDivisors(ListNode* head) {
    for (ListNode* curr = head; curr->next != nullptr;) {
      ListNode* inserted =
          new ListNode(__gcd(curr->val, curr->next->val), curr->next);
      curr->next = inserted;
      curr = inserted->next;
    }
    return head;
  }
};",2807
2805,"class Solution {
 public:
  int minimumSeconds(vector<int>& nums) {
    const int n = nums.size();
    int ans = n;
    unordered_map<int, vector<int>> numToIndices;

    for (int i = 0; i < n; ++i)
      numToIndices[nums[i]].push_back(i);

    for (const auto& [_, indices] : numToIndices) {
      int seconds = getSeconds(indices.front() + n, indices.back());
      for (int i = 1; i < indices.size(); ++i)
        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]));
      ans = min(ans, seconds);
    }

    return ans;
  }

 private:
  // Returns the number of seconds required to make nums[i..j] the same.
  int getSeconds(int i, int j) {
    return (i - j) / 2;
  }
};",2808
2806,"class Solution {
 public:
  int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {
    const int n = nums1.size();
    const int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
    const int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
    // dp[i][j] := the maximum reduced value if we do j operations on the first
    // i numbers
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));
    vector<pair<int, int>> sortedNums;

    for (int i = 0; i < n; ++i)
      sortedNums.emplace_back(nums2[i], nums1[i]);

    ranges::sort(sortedNums);

    for (int i = 1; i <= n; ++i) {
      const auto [num2, num1] = sortedNums[i - 1];
      for (int j = 1; j <= i; ++j)
        dp[i][j] = max(
            // the maximum reduced value if we do j operations on the first
            // i - 1 numbers
            dp[i - 1][j],
            // the maximum reduced value if we do j - 1 operations on the first
            // i - 1 numbers + making the i-th number of `nums1` to 0 at the
            // j-th operation
            dp[i - 1][j - 1] + num2 * j + num1);
    }

    for (int op = 0; op <= n; ++op)
      if (sum1 + sum2 * op - dp[n][op] <= x)
        return op;

    return -1;
  }
};",2809
2807,"class Solution {
 public:
  string finalString(string s) {
    deque<char> dq;
    bool inversed = false;

    for (const char c : s)
      if (c == 'i')
        inversed = !inversed;
      else if (inversed)
        dq.push_front(c);
      else
        dq.push_back(c);

    return inversed ? string{dq.rbegin(), dq.rend()}
                    : string{dq.begin(), dq.end()};
  }
};",2810
2808,"class Solution {
 public:
  bool canSplitArray(vector<int>& nums, int m) {
    if (nums.size() < 3)
      return true;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] + nums[i - 1] >= m)
        return true;

    return false;
  }
};",2811
2809,"class Solution {
 public:
  int maximumSafenessFactor(vector<vector<int>>& grid) {
    const vector<vector<int>> distToThief = getDistToThief(grid);
    int l = 0;
    int r = grid.size() * 2;

    while (l < r) {
      const int m = (l + r) / 2;
      if (hasValidPath(distToThief, m))
        l = m + 1;
      else
        r = m;
    }

    return l - 1;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  bool hasValidPath(const vector<vector<int>>& distToThief, int safeness) {
    if (distToThief[0][0] < safeness)
      return false;

    const int n = distToThief.size();
    queue<pair<int, int>> q{{{0, 0}}};
    vector<vector<bool>> seen(n, vector<bool>(n));
    seen[0][0] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      if (distToThief[i][j] < safeness)
        continue;
      if (i == n - 1 && j == n - 1)
        return true;
      for (const auto& [dx, dy] : dirs) {
        const int x = i + dx;
        const int y = j + dy;
        if (x < 0 || x == n || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

  vector<vector<int>> getDistToThief(const vector<vector<int>>& grid) {
    const int n = grid.size();
    vector<vector<int>> distToThief(n, vector<int>(n));
    queue<pair<int, int>> q;
    vector<vector<bool>> seen(n, vector<bool>(n));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          q.emplace(i, j);
          seen[i][j] = true;
        }

    for (int dist = 0; !q.empty(); ++dist) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        distToThief[i][j] = dist;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == n || y < 0 || y == n)
            continue;
          if (seen[x][y])
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return distToThief;
  }
};",2812
2810,"class Solution {
 public:
  long long findMaximumElegance(vector<vector<int>>& items, int k) {
    long long ans = 0;
    long long totalProfit = 0;
    unordered_set<int> seenCategories;
    stack<int> decreasingDuplicateProfits;

    ranges::sort(items, greater<>());

    for (int i = 0; i < k; i++) {
      const int profit = items[i][0];
      const int category = items[i][1];
      totalProfit += profit;
      if (seenCategories.count(category))
        decreasingDuplicateProfits.push(profit);
      else
        seenCategories.insert(category);
    }

    ans = totalProfit + 1LL * seenCategories.size() * seenCategories.size();

    for (int i = k; i < items.size(); ++i) {
      const int profit = items[i][0];
      const int category = items[i][1];
      if (!seenCategories.count(category) &&
          !decreasingDuplicateProfits.empty()) {
        // If this is a new category we haven't seen before, it's worth
        // considering taking it and replacing the one with the least profit
        // since it will increase the distinct_categories and potentially result
        // in a larger total_profit + distinct_categories^2.
        totalProfit -= decreasingDuplicateProfits.top(),
            decreasingDuplicateProfits.pop();
        totalProfit += profit;
        seenCategories.insert(category);
        ans = max(ans, static_cast<long long>(totalProfit +
                                              1LL * seenCategories.size() *
                                                  seenCategories.size()));
      }
    }

    return ans;
  }
};",2813
2811,"class Solution {
 public:
  int minimumSeconds(vector<vector<string>>& land) {
    const int m = land.size();
    const int n = land[0].size();
    const vector<vector<int>> floodDist = getFloodDist(land);
    queue<pair<int, int>> q;
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (land[i][j] == ""S"") {
          q.emplace(i, j);
          seen[i][j] = true;
        }

    for (int step = 1; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (land[x][y] == ""D"")
            return step;
          if (floodDist[x][y] <= step || land[x][y] == ""X"" || seen[x][y])
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }

    return -1;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  vector<vector<int>> getFloodDist(const vector<vector<string>>& land) {
    const int m = land.size();
    const int n = land[0].size();
    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
    queue<pair<int, int>> q;
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (land[i][j] == ""*"") {
          q.emplace(i, j);
          seen[i][j] = true;
        }

    for (int d = 0; !q.empty(); ++d)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        dist[i][j] = d;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (land[x][y] == ""X"" || land[x][y] == ""D"" || seen[x][y])
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }

    return dist;
  }
};",2814
2812,"class Solution {
 public:
  int maxSum(vector<int>& nums) {
    int ans = 0;
    // maxNum[i] := the maximum num we met so far with the maximum digit i
    vector<int> maxNum(10);

    for (const int num : nums) {
      const int d = getMaxDigit(num);
      if (maxNum[d] > 0)
        ans = max(ans, num + maxNum[d]);
      maxNum[d] = max(maxNum[d], num);
    }

    return ans == 0 ? -1 : ans;
  }

 private:
  int getMaxDigit(int num) {
    int maxDigit = 0;
    while (num > 0) {
      maxDigit = max(maxDigit, num % 10);
      num /= 10;
    }
    return maxDigit;
  }
};",2815
2813,"class Solution {
 public:
  ListNode* doubleIt(ListNode* head) {
    if (getCarry(head) == 1)
      return new ListNode(1, head);
    return head;
  }

 private:
  int getCarry(ListNode* node) {
    int val = node->val * 2;
    if (node->next != nullptr)
      val += getCarry(node->next);

    node->val = val % 10;
    return val / 10;
  }
};",2816
2814,"class Solution {
 public:
  int minAbsoluteDifference(vector<int>& nums, int x) {
    int ans = INT_MAX;
    set<int> seen;

    for (int i = x; i < nums.size(); ++i) {
      seen.insert(nums[i - x]);
      // `upper_bound` works as well.
      const auto it = seen.lower_bound(nums[i]);
      if (it != seen.cend())
        ans = min(ans, *it - nums[i]);
      if (it != seen.cbegin())
        ans = min(ans, nums[i] - *prev(it));
    }

    return ans;
  }
};",2817
2815,"class Solution {
 public:
  int maximumScore(vector<int>& nums, int k) {
    const int n = nums.size();
    const int maxNum = ranges::max(nums);
    const vector<int> minPrimeFactors = sieveEratosthenes(maxNum + 1);
    const vector<int> primeScores = getPrimeScores(nums, minPrimeFactors);
    int ans = 1;
    // left[i] := the next index on the left (if any) s.t.
    // primeScores[left[i]] >= primeScores[i]
    vector<int> left(n, -1);
    // right[i] := the next index on the right (if any) s.t.
    // primeScores[right[i]] > primeScores[i]
    vector<int> right(n, n);
    stack<int> stack;

    // Find the next indices on the left where `primeScores` are greater or
    // equal.
    for (int i = n - 1; i >= 0; --i) {
      while (!stack.empty() && primeScores[stack.top()] <= primeScores[i])
        left[stack.top()] = i, stack.pop();
      stack.push(i);
    }

    stack = std::stack<int>();

    // Find the next indices on the right where `primeScores` are greater.
    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && primeScores[stack.top()] < primeScores[i])
        right[stack.top()] = i, stack.pop();
      stack.push(i);
    }

    vector<pair<int, int>> numAndIndexes;

    for (int i = 0; i < n; ++i)
      numAndIndexes.emplace_back(nums[i], i);

    ranges::sort(numAndIndexes,
                 [&](const pair<int, int>& a, const pair<int, int>& b) {
      return a.first == b.first ? a.second < b.second : a.first > b.first;
    });

    for (const auto& [num, i] : numAndIndexes) {
      // nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]
      // So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will
      // be chosen.
      const int rangeCount = (i - left[i]) * (right[i] - i);
      const int actualCount = min(rangeCount, k);
      k -= actualCount;
      ans = (1LL * ans * modPow(num, actualCount)) % kMod;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }

  // Gets the minimum prime factor of i, where 1 < i <= n.
  vector<int> sieveEratosthenes(int n) {
    vector<int> minPrimeFactors(n + 1);
    iota(minPrimeFactors.begin() + 2, minPrimeFactors.end(), 2);
    for (int i = 2; i * i < n; ++i)
      if (minPrimeFactors[i] == i)  // `i` is prime.
        for (int j = i * i; j < n; j += i)
          minPrimeFactors[j] = min(minPrimeFactors[j], i);
    return minPrimeFactors;
  }

  vector<int> getPrimeScores(const vector<int>& nums,
                             const vector<int>& minPrimeFactors) {
    vector<int> primeScores;
    for (const int num : nums)
      primeScores.push_back(getPrimeScore(num, minPrimeFactors));
    return primeScores;
  }

  int getPrimeScore(int num, const vector<int>& minPrimeFactors) {
    unordered_set<int> primeFactors;
    while (num > 1) {
      const int divisor = minPrimeFactors[num];
      primeFactors.insert(divisor);
      while (num % divisor == 0)
        num /= divisor;
    }
    return primeFactors.size();
  }
};",2818
2816,"class Solution {
 public:
  vector<long long> minimumRelativeLosses(vector<int>& prices,
                                          vector<vector<int>>& queries) {
    const int n = prices.size();
    vector<long long> ans;
    vector<long long> prefix{0};

    ranges::sort(prices);

    for (const int price : prices)
      prefix.push_back(prefix.back() + price);

    for (const vector<int>& query : queries) {
      const int k = query[0];
      const int m = query[1];
      const int countFront = getCountFront(k, m, prices, prefix);
      const int countBack = m - countFront;
      ans.push_back(getRelativeLoss(countFront, countBack, k, prefix));
    }

    return ans;
  }

 private:
  // Returns `countFront` for query (k, m) s.t. picking the first `countFront`
  // and the last `m - countFront` chocolates is optimal.
  //
  // Define loss[i] := the relative loss of picking `prices[i]`.
  // 1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.
  //    Thus, loss[i] = prices[i] - 0 = prices[i].
  // 2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.
  //    Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].
  // By observation, we deduce that it is always better to pick from the front
  // or the back since loss[i] is increasing for 1. and is decreasing for 2.
  //
  // Assume that picking `left` chocolates from the left and `right = m - left`
  // chocolates from the right is optimal. Therefore, we are selecting
  // chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.
  //
  // To determine the optimal `left` in each iteration, we simply compare
  // `loss[left]` with `loss[n - right]`; if `loss[left] < loss[n - right]`,
  // it's worth increasing `left`.
  int getCountFront(int k, int m, const vector<int>& prices,
                    const vector<long long>& prefix) {
    const int n = prices.size();
    const int countNoGreaterThanK =
        ranges::upper_bound(prices, k) - prices.begin();
    int l = 0;
    int r = min(countNoGreaterThanK, m);

    while (l < r) {
      const int mid = (l + r) / 2;
      const int right = m - mid;
      // Picking prices[mid] is better than picking prices[n - right].
      if (prices[mid] < 2LL * k - prices[n - right])
        l = mid + 1;
      else
        r = mid;
    }

    return l;
  }

  // Returns the relative loss of picking `countFront` and `countBack`
  // chocolates.
  long long getRelativeLoss(int countFront, int countBack, int k,
                            const vector<long long>& prefix) {
    const long long lossFront = prefix[countFront];
    const long long lossBack =
        2LL * k * countBack -
        (prefix.back() - prefix[prefix.size() - 1 - countBack]);
    return lossFront + lossBack;
  }
};",2819
2817,"WITH 
  VoterToValue AS (
    SELECT
      voter,
      1 / COUNT(*) AS value
    FROM Votes
    GROUP BY voter
  ),
  RankedCandidates AS (
    SELECT
      candidate,
      RANK() OVER(ORDER BY SUM(value) DESC) AS `rank`
    FROM Votes
    INNER JOIN VoterToValue
      USING (voter)
    WHERE candidate IS NOT NULL
    GROUP BY 1
  )
SELECT candidate
FROM RankedCandidates
WHERE `rank` = 1
ORDER BY 1;",2820
2818,"type Fn = () => Promise<any>;

function delayAll(functions: Fn[], ms: number): Fn[] {
  return functions.map((fn) => {
    return async () => {
      await new Promise((resolve) => setTimeout(resolve, ms));
      try {
        const result = await fn();
        return Promise.resolve(result);
      } catch (error) {
        return Promise.reject(error);
      }
    };
  });
}",2821
2819,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function invertObject(obj: Obj): Record<string, JSONValue> {
  const ans: Record<string, JSONValue> = {};

  for (const [key, value] of Object.entries(obj)) {
    const valueKey = value as string;
    if (ans.hasOwnProperty(valueKey)) {
      const curr = ans[valueKey];
      if (!Array.isArray(curr)) {
        ans[valueKey] = [curr];
      }
      (ans[valueKey] as JSONValue[]).push(key);
    } else {
      ans[valueKey] = key;
    }
  }

  return ans;
}",2822
2820,"type JSONValue =
  | null
  | boolean
  | number
  | string
  | JSONValue[]
  | { [key: string]: JSONValue };
type Obj = Record<string, JSONValue> | Array<JSONValue>;

function deepFilter(obj: Obj, fn: Function): Obj | undefined {
  if (obj === null || typeof obj !== 'object') {
    return fn(obj) ? obj : undefined;
  }
  if (Array.isArray(obj)) {
    const ans = (obj as Obj[])
      .map((item) => deepFilter(item, fn))
      .filter((item) => item !== undefined);
    return ans.length > 0 ? ans : undefined;
  }
  let ans = {};
  for (const [key, value] of Object.entries(obj)) {
    const ans = deepFilter(value as Obj, fn);
    if (ans !== undefined) {
      ans[key] = ans;
    }
  }
  return Object.keys(ans).length > 0 ? ans : undefined;
}",2823
2821,"class Solution {
 public:
  int countPairs(vector<int>& nums, int target) {
    int ans = 0;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = i + 1; j < nums.size(); ++j)
        if (nums[i] + nums[j] < target)
          ++ans;

    return ans;
  }
};",2824
2822,"class Solution {
 public:
  bool canMakeSubsequence(string str1, string str2) {
    int i = 0;  // str2's index

    for (const char c : str1)
      if (c == str2[i] || ('a' + ((c - 'a' + 1) % 26)) == str2[i])
        if (++i == str2.length())
          return true;

    return false;
  }
};",2825
2823,"class Solution {
 public:
  int minimumOperations(vector<int>& nums) {
    // dp[i] := the longest non-decreasing subsequence so far with numbers in
    // [1..i]
    vector<int> dp(4);

    for (const int num : nums) {
      ++dp[num];
      dp[2] = max(dp[2], dp[1]);
      dp[3] = max(dp[3], dp[2]);
    }

    return nums.size() - dp[3];
  }
};",2826
2824,"class Solution {
 public:
  int numberOfBeautifulIntegers(int low, int high, int k) {
    const string lowString = to_string(low);
    const string highString = to_string(high);
    const string lowWithLeadingZeros =
        string(highString.length() - lowString.length(), '0') + lowString;
    vector<vector<vector<vector<vector<vector<int>>>>>> mem(
        highString.length(),
        vector<vector<vector<vector<vector<int>>>>>(
            10, vector<vector<vector<vector<int>>>>(
                    10, vector<vector<vector<int>>>(
                            k, vector<vector<int>>(2, vector<int>(2, -1))))));
    return count(lowWithLeadingZeros, highString, k, 0, 0, 0, 0, true, true,
                 true, mem);
  }

 private:
  // Returns the number of beautiful integers, considering the i-th digit with
  // counts of even `even` digits and odd `odd` digits, where the current number
  // modulo k equals remainder, `isTight1` indicates if the current digit is
  // tightly bound for `low` and `isTight2` indicates if the current digit is
  // tightly bound for `high`
  int count(const string& low, const string& high, int k, int i, int even,
            int odd, int remainder, bool isLeadingZero, bool isTight1,
            bool isTight2,
            vector<vector<vector<vector<vector<vector<int>>>>>>& mem) {
    if (i == high.length())
      return !isLeadingZero && even == odd && remainder == 0;
    if (mem[i][even][odd][remainder][isTight1][isTight2] != -1)
      return mem[i][even][odd][remainder][isTight1][isTight2];

    int res = 0;
    const int minDigit = isTight1 ? low[i] - '0' : 0;
    const int maxDigit = isTight2 ? high[i] - '0' : 9;

    for (int d = minDigit; d <= maxDigit; ++d) {
      const int nextEven = even + ((!isLeadingZero || d > 0) && d % 2 == 0);
      const int nextOdd = odd + (d % 2 == 1);
      const int nextRemainder = (remainder * 10 + d) % k;
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      res += count(low, high, k, i + 1, nextEven, nextOdd, nextRemainder,
                   isLeadingZero && d == 0, nextIsTight1, nextIsTight2, mem);
    }

    return mem[i][even][odd][remainder][isTight1][isTight2] = res;
  }
};",2827
2825,"class Solution {
 public:
  bool isAcronym(vector<string>& words, string s) {
    if (words.size() != s.length())
      return false;

    for (int i = 0; i < words.size(); ++i)
      if (words[i][0] != s[i])
        return false;

    return true;
  }
};",2828
2826,"class Solution {
 public:
  int minimumSum(int n, int k) {
    // These are the unique pairs that sum up to k:
    // (1, k - 1), (2, k - 2), ..., (ceil(k / 2), floor(k / 2)).
    // Our optimal strategy is to select 1, 2, ..., floor(k / 2), and then
    // choose k, k + 1, ... if necessary, as selecting any number in the range
    // [ceil(k / 2), k - 1] will result in a pair summing up to k.
    const int mid = k / 2;  // floor(k / 2)
    if (n <= mid)
      return trapezoid(1, n);
    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1));
  }

 private:
  // Returns sum(a..b).
  int trapezoid(int a, int b) {
    return (a + b) * (b - a + 1) / 2;
  }
};",2829
2827,"class Solution {
 public:
  int maximizeTheProfit(int n, vector<vector<int>>& offers) {
    // dp[i] := the maximum amount of gold of selling the first i houses
    vector<int> dp(n + 1);
    vector<vector<pair<int, int>>> endToStartAndGolds(n);

    for (const vector<int>& offer : offers) {
      const int start = offer[0];
      const int end = offer[1];
      const int gold = offer[2];
      endToStartAndGolds[end].emplace_back(start, gold);
    }

    for (int end = 1; end <= n; ++end) {
      // Get at least the same gold as selling the first `end - 1` houses.
      dp[end] = dp[end - 1];
      for (const auto& [start, gold] : endToStartAndGolds[end - 1])
        dp[end] = max(dp[end], dp[start] + gold);
    }

    return dp[n];
  }
};",2830
2828,"class Solution {
 public:
  int longestEqualSubarray(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      ans = max(ans, ++count[nums[r]]);
      while (r - l + 1 - k > ans)
        --count[nums[l++]];
    }

    return ans;
  }
};",2831
2829,"class Solution {
 public:
  vector<int> maximumLengthOfRanges(vector<int>& nums) {
    vector<int> ans(nums.size());
    stack<int> stack;  // a decreasing stack

    for (int i = 0; i <= nums.size(); ++i) {
      while (!stack.empty() &&
             (i == nums.size() || nums[stack.top()] < nums[i])) {
        const int index = stack.top();
        stack.pop();
        const int left = stack.empty() ? -1 : stack.top();
        ans[index] = i - left - 1;
      }
      stack.push(i);
    }

    return ans;
  }
};",2832
2830,"class Solution {
 public:
  int furthestDistanceFromOrigin(string moves) {
    int countL = 0;
    int countR = 0;
    int countUnderline = 0;

    for (const char c : moves)
      if (c == 'L')
        ++countL;
      else if (c == 'R')
        ++countR;
      else  // c == '_'
        ++countUnderline;

    return abs(countL - countR) + countUnderline;
  }
};",2833
2831,"class Solution {
 public:
  // Same as 2829. Determine the Minimum Sum of a k-avoiding Array
  int minimumPossibleSum(int n, int target) {
    // These are the unique pairs that sum up to target (k):
    // (1, k - 1), (2, k - 2), ..., (ceil(k / 2), floor(k / 2)).
    // Our optimal strategy is to select 1, 2, ..., floor(k / 2), and then
    // choose k, k + 1, ... if necessary, as selecting any number in the range
    // [ceil(k / 2), k - 1] will result in a pair summing up to k.
    const int mid = target / 2;
    if (n <= mid)
      return trapezoid(1, n);
    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) %
           kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  // Returns sum(a..b).
  long trapezoid(long a, long b) {
    return (a + b) * (b - a + 1) / 2;
  }
};",2834
2832,"class Solution {
 public:
  int minOperations(vector<int>& nums, int target) {
    constexpr int kNoMissingBit = 31;
    constexpr int maxBit = 31;
    int ans = 0;
    int minMissingBit = kNoMissingBit;
    // count[i] := the number of occurrences of 2^i
    vector<int> count(maxBit + 1);

    for (const int num : nums)
      ++count[static_cast<int>(log2(num))];

    for (int bit = 0; bit < maxBit; ++bit) {
      // Check if `bit` is in the target.
      if (target >> bit & 1) {
        // If there are available bits, use one bit.
        if (count[bit] > 0)
          --count[bit];
        else
          minMissingBit = min(minMissingBit, bit);
      }
      // If we previously missed a bit and there are available bits.
      if (minMissingBit != kNoMissingBit && count[bit] > 0) {
        --count[bit];
        // Count the operations to break `bit` into `minMissingBit`.
        ans += bit - minMissingBit;
        minMissingBit = kNoMissingBit;
      }
      // Combining smaller numbers costs nothing.
      count[bit + 1] += count[bit] / 2;
    }

    // Check if all target bits have been covered, otherwise return -1.
    return minMissingBit == kNoMissingBit ? ans : -1;
  }
};",2835
2833,"class Solution {
 public:
  long long getMaxFunctionValue(vector<int>& receiver, long long k) {
    const int n = receiver.size();
    const int m = log2(k) + 1;
    long long ans = 0;
    // jump[i][j] := the the node you reach after jumping 2^j steps from i
    vector<vector<int>> jump(n, vector<int>(m));
    // sum[i][j] := the sum of the first 2^j nodes you reach when jumping from i
    vector<vector<long long>> sum(n, vector<long long>(m));

    for (int i = 0; i < n; ++i) {
      jump[i][0] = receiver[i];
      sum[i][0] = receiver[i];
    }

    // Calculate binary lifting.
    for (int j = 1; j < m; ++j)
      for (int i = 0; i < n; ++i) {
        const int midNode = jump[i][j - 1];
        //   the the node you reach after jumping 2^j steps from i
        // = the node you reach after jumping 2^(j - 1) steps from i
        // + the node you reach after jumping another 2^(j - 1) steps
        jump[i][j] = jump[midNode][j - 1];
        //   the sum of the first 2^j nodes you reach when jumping from i
        // = the sum of the first 2^(j - 1) nodes you reach when jumping from i
        // + the sum of another 2^(j - 1) nodes you reach
        sum[i][j] = sum[i][j - 1] + sum[midNode][j - 1];
      }

    for (int i = 0; i < n; ++i) {
      long long currSum = i;
      int currPos = i;
      for (int j = 0; j < m; ++j)
        if (k >> j & 1) {
          currSum += sum[currPos][j];
          currPos = jump[currPos][j];
        }
      ans = max(ans, currSum);
    }

    return ans;
  }
};",2836
2834,"SELECT
  Users.user_id,
  Users.name,
  SUM(IFNULL(Rides.distance, 0)) AS 'traveled distance'
FROM Users
LEFT JOIN Rides
  USING (user_id)
GROUP BY 1
ORDER BY 1;",2837
2835,"class Solution {
 public:
  vector<long long> maximumCoins(vector<int>& heroes, vector<int>& monsters,
                                 vector<int>& coins) {
    const vector<pair<int, int>> monsterAndCoins =
        getSortedMonsterAndCoins(monsters, coins);
    vector<long long> ans;
    vector<long long> coinsPrefix{0};

    for (const auto& [_, coin] : monsterAndCoins)
      coinsPrefix.push_back(coinsPrefix.back() + coin);

    for (const int hero : heroes)
      ans.push_back(coinsPrefix[firstGreaterEqual(monsterAndCoins, hero)]);

    return ans;
  }

 private:
  vector<pair<int, int>> getSortedMonsterAndCoins(const vector<int>& monsters,
                                                  const vector<int>& coins) {
    vector<pair<int, int>> monsterAndCoins;
    for (int i = 0; i < monsters.size(); ++i)
      monsterAndCoins.emplace_back(monsters[i], coins[i]);
    ranges::sort(monsterAndCoins);
    return monsterAndCoins;
  }

  int firstGreaterEqual(const vector<pair<int, int>>& monsterAndCoins,
                        int hero) {
    int l = 0;
    int r = monsterAndCoins.size();
    while (l < r) {
      const int m = (l + r) / 2;
      if (monsterAndCoins[m].first > hero)
        r = m;
      else
        l = m + 1;
    }
    return l;
  }
};",2838
2836,"class Solution {
 public:
  bool canBeEqual(string s1, string s2) {
    for (const string& a : swappedStrings(s1))
      for (const string& b : swappedStrings(s2))
        if (a == b)
          return true;
    return false;
  }

 private:
  vector<string> swappedStrings(const string& s) {
    vector<char> chars(s.begin(), s.end());
    return {s, string({chars[2], chars[1], chars[0], chars[3]}),
            string({chars[0], chars[3], chars[2], chars[1]}),
            string({chars[2], chars[3], chars[0], chars[1]})};
  }
};",2839
2837,"class Solution {
 public:
  bool checkStrings(string s1, string s2) {
    vector<vector<int>> count(2, vector<int>(26));

    for (int i = 0; i < s1.length(); ++i) {
      ++count[i % 2][s1[i] - 'a'];
      --count[i % 2][s2[i] - 'a'];
    }

    for (int i = 0; i < 26; ++i)
      if (count[0][i] > 0 || count[1][i] > 0)
        return false;

    return true;
  }
};",2840
2838,"class Solution {
 public:
  long long maxSum(vector<int>& nums, int m, int k) {
    long long ans = 0;
    long long sum = 0;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i) {
      sum += nums[i];
      ++count[nums[i]];
      if (i >= k) {
        const int numToRemove = nums[i - k];
        sum -= numToRemove;
        if (--count[numToRemove] == 0)
          count.erase(numToRemove);
      }
      if (count.size() >= m)
        ans = max(ans, sum);
    }

    return ans;
  }
};",2841
2839,"class Solution {
 public:
  int countKSubsequencesWithMaxBeauty(string s, int k) {
    unordered_map<char, int> count;
    for (const char c : s)
      ++count[c];
    if (count.size() < k)
      return 0;

    long ans = 1;

    for (const auto& [fc, numOfChars] : getFreqCountPairs(count)) {
      if (numOfChars >= k) {
        ans *= nCk(numOfChars, k);
        ans %= kMod;
        return ans * modPow(fc, k) % kMod;
      }
      ans *= modPow(fc, numOfChars);
      ans %= kMod;
      k -= numOfChars;
    }

    return ans;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  vector<pair<int, int>> getFreqCountPairs(
      const unordered_map<char, int>& count) {
    unordered_map<int, int> freqCount;
    for (const auto& [_, value] : count)
      ++freqCount[value];
    vector<pair<int, int>> freqCountPairs;
    for (const auto& [fc, numOfChars] : freqCount)
      freqCountPairs.emplace_back(fc, numOfChars);
    ranges::sort(freqCountPairs,
                 [](const pair<int, int>& a, const pair<int, int>& b) {
      return b.first < a.first;
    });
    return freqCountPairs;
  }

  long nCk(int n, int k) {
    long res = 1;
    for (int i = 1; i <= k; ++i)
      res = res * (n - i + 1) / i;
    return res;
  }

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2842
2840,"class Solution {
 public:
  int countSymmetricIntegers(int low, int high) {
    int ans = 0;

    for (int num = low; num <= high; ++num)
      if (isSymmetricInteger(num))
        ++ans;

    return ans;
  }

 private:
  bool isSymmetricInteger(int num) {
    if (num >= 10 && num <= 99)
      return num / 10 == num % 10;
    if (num >= 1000 && num <= 9999) {
      const int left = num / 100;
      const int right = num % 100;
      return left / 10 + left % 10 == right / 10 + right % 10;
    }
    return false;
  }
};",2843
2841,"class Solution {
 public:
  int minimumOperations(string num) {
    const int n = num.length();
    bool seenFive = false;
    bool seenZero = false;

    for (int i = n - 1; i >= 0; --i) {
      if (seenZero && num[i] == '0')  // '00'
        return n - i - 2;
      if (seenZero && num[i] == '5')  // '50'
        return n - i - 2;
      if (seenFive && num[i] == '2')  // '25'
        return n - i - 2;
      if (seenFive && num[i] == '7')  // '75'
        return n - i - 2;
      seenZero = seenZero || num[i] == '0';
      seenFive = seenFive || num[i] == '5';
    }

    return seenZero ? n - 1 : n;
  }
};",2844
2842,"class Solution {
 public:
  long countInterestingSubarrays(vector<int>& nums, int modulo, int k) {
    long ans = 0;
    int prefix = 0;  // (number of nums[i] % modulo == k so far) % modulo
    unordered_map<int, int> prefixCount{{0, 1}};

    for (const int num : nums) {
      if (num % modulo == k)
        prefix = (prefix + 1) % modulo;
      ans += prefixCount[(prefix - k + modulo) % modulo];
      ++prefixCount[prefix];
    }

    return ans;
  }
};",2845
2843,"class Solution {
 public:
  vector<int> minOperationsQueries(int n, vector<vector<int>>& edges,
                                   vector<vector<int>>& queries) {
    constexpr int kMax = 26;
    const int m = log2(n) + 1;
    vector<int> ans;
    vector<vector<pair<int, int>>> graph(n);
    // jump[i][j] := the node you reach after jumping 2^j from i
    vector<vector<int>> jump(n, vector<int>(m));
    // count[i][j] := the count of j from root to i, where 1 <= j <= 26
    vector<vector<int>> count(n);
    // depth[i] := the depth of i
    vector<int> depth(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    count[0] = vector<int>(kMax + 1);
    dfs(graph, 0, /*prev=*/-1, 0, jump, count, depth);

    // Calculate binary lifting.
    for (int j = 1; j < m; ++j)
      for (int i = 0; i < n; ++i)
        jump[i][j] = jump[jump[i][j - 1]][j - 1];

    for (const vector<int>& query : queries) {
      const int u = query[0];
      const int v = query[1];
      const int lca = getLCA(u, v, jump, depth);
      // the number of edges between (u, v).
      const int numEdges = depth[u] + depth[v] - 2 * depth[lca];
      // the maximum frequency of edges between (u, v)
      int maxFreq = 0;
      for (int j = 1; j <= kMax; ++j)
        maxFreq = max(maxFreq, count[u][j] + count[v][j] - 2 * count[lca][j]);
      ans.push_back(numEdges - maxFreq);
    }

    return ans;
  }

 private:
  void dfs(const vector<vector<pair<int, int>>>& graph, int u, int prev, int d,
           vector<vector<int>>& jump, vector<vector<int>>& count,
           vector<int>& depth) {
    if (prev != -1)
      jump[u][0] = prev;
    depth[u] = d;
    for (const auto& [v, w] : graph[u]) {
      if (v == prev)
        continue;
      // Inherit the count from the parent.
      count[v] = count[u];
      // Add one to this edge.
      ++count[v][w];
      dfs(graph, v, u, d + 1, jump, count, depth);
    }
  }

  // Returns the lca(u, v) via Calculate binary lifting.
  int getLCA(int u, int v, const vector<vector<int>>& jump,
             const vector<int>& depth) {
    // v is always deeper than u.
    if (depth[u] > depth[v])
      return getLCA(v, u, jump, depth);
    // Jump v to the same height of u.
    for (int j = 0; j < jump[0].size(); ++j)
      if (depth[v] - depth[u] >> j & 1)
        v = jump[v][j];
    if (u == v)
      return u;
    // Jump u and v to the node right below the lca.
    for (int j = jump[0].size() - 1; j >= 0; --j)
      if (jump[u][j] != jump[v][j]) {
        u = jump[u][j];
        v = jump[v][j];
      }
    return jump[v][0];
  }
};",2846
2844,"class Solution {
 public:
  string smallestNumber(long long n) {
    if (n <= 9)
      return to_string(n);

    string ans;

    for (int divisor = 9; divisor > 1; --divisor)
      while (n % divisor == 0) {
        ans += to_string(divisor);
        n /= divisor;
      }

    return n > 1 ? ""-1"" : string{ans.rbegin(), ans.rend()};
  }
};",2847
2845,"class Solution {
 public:
  int numberOfPoints(vector<vector<int>>& nums) {
    constexpr int kMax = 100;
    int ans = 0;
    int runningSum = 0;
    vector<int> count(kMax + 2);

    for (const vector<int>& num : nums) {
      const int start = num[0];
      const int end = num[1];
      ++count[start];
      --count[end + 1];
    }

    for (int i = 1; i <= kMax; ++i) {
      runningSum += count[i];
      if (runningSum > 0)
        ++ans;
    }

    return ans;
  }
};",2848
2846,"class Solution {
 public:
  bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {
    const int minStep = max(abs(sx - fx), abs(sy - fy));
    return minStep == 0 ? t != 1 : minStep <= t;
  }
};",2849
2847,"class Solution {
 public:
  int minimumMoves(vector<vector<int>>& grid) {
    const int zeroCount = accumulate(grid.begin(), grid.end(), 0,
                                     [](int subtotal, const vector<int>& row) {
      return subtotal + ranges::count(row, 0);
    });
    if (zeroCount == 0)
      return 0;

    int ans = INT_MAX;

    for (int i = 0; i < 3; ++i)
      for (int j = 0; j < 3; ++j)
        if (grid[i][j] == 0)
          for (int x = 0; x < 3; ++x)
            for (int y = 0; y < 3; ++y)
              // Move a stone at (x, y) to (i, j).
              if (grid[x][y] > 1) {
                --grid[x][y];
                ++grid[i][j];
                ans = min(ans, abs(x - i) + abs(y - j) + minimumMoves(grid));
                ++grid[x][y];
                --grid[i][j];
              }

    return ans;
  }
};",2850
2848,"class Solution {
 public:
  // This dynamic programming table dp[k][i] represents the number of ways to
  // rearrange the string s after k steps such that it starts with s[i].
  // A string can be rotated from 1 to n - 1 times. The transition rule is
  // dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and
  // k = 3, the table looks like this:
  //
  // -----------------------------------------------------------
  // |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |
  // -----------------------------------------------------------
  // | k = 0 |   1   |   0   |   0   |   0   |        1        |
  // | k = 1 |   0   |   1   |   1   |   1   |        3        |
  // | k = 2 |   3   |   2   |   2   |   2   |        9        |
  // | k = 3 |   6   |   7   |   7   |   7   |       27        |
  // -----------------------------------------------------------
  //
  // By observation, we have
  //   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n
  //   * dp[k][0] = dp[k][!0] + (-1)^k
  int numberOfWays(string s, string t, long long k) {
    const int n = s.length();
    const int negOnePowK = (k % 2 == 0 ? 1 : -1);  // (-1)^k
    const vector<int> z = zFunction(s + t + t);
    const vector<int> indices = getIndices(z, n);
    vector<int> dp(2);  // dp[0] := dp[k][0]; dp[1] := dp[k][!0]
    dp[1] = (modPow(n - 1, k) - negOnePowK + kMod) % kMod *
            modPow(n, kMod - 2) % kMod;
    dp[0] = (dp[1] + negOnePowK + kMod) % kMod;
    return accumulate(indices.begin(), indices.end(), 0LL,
                      [&](long long subtotal, int index) {
      return (subtotal + dp[index == 0 ? 0 : 1]) % kMod;
    });
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x, n - 1) % kMod;
    return modPow(x * x % kMod, n / 2);
  }

  // Returns the z array, where z[i] is the length of the longest prefix of
  // s[i..n) which is also a prefix of s.
  //
  // https://cp-algorithms.com/string/z-function.html#implementation
  vector<int> zFunction(const string& s) {
    const int n = s.length();
    vector<int> z(n);
    int l = 0;
    int r = 0;
    for (int i = 1; i < n; ++i) {
      if (i < r)
        z[i] = min(r - i, z[i - l]);
      while (i + z[i] < n && s[z[i]] == s[i + z[i]])
        ++z[i];
      if (i + z[i] > r) {
        l = i;
        r = i + z[i];
      }
    }
    return z;
  }

  // Returns the indices in `s` s.t. for each `i` in the returned indices,
  // `s[i..n) + s[0..i) = t`.
  vector<int> getIndices(const vector<int>& z, int n) {
    vector<int> indices;
    for (int i = n; i < n + n; ++i)
      if (z[i] >= n)
        indices.push_back(i - n);
    return indices;
  }
};",2851
2849,"class Solution {
 public:
  long long sumRemoteness(vector<vector<int>>& grid) {
    const long long sum =
        accumulate(grid.begin(), grid.end(), 0LL,
                   [](long long subtotal, const vector<int>& row) {
      return subtotal + accumulate(row.begin(), row.end(), 0LL,
                                   [](long long subtotal, const int cell) {
        return subtotal + max(0, cell);
      });
    });

    long long ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] > 0) {
          const auto [count, componentSum] = dfs(grid, i, j);
          ans += (sum - componentSum) * count;
        }

    return ans;
  }

 private:
  static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  // Returns the (count, componentSum) of the connected component that contains
  // (x, y).
  pair<int, long long> dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return {0, 0};
    if (grid[i][j] == -1)
      return {0, 0};

    int count = 1;
    long long componentSum = grid[i][j];
    grid[i][j] = -1;  // Mark as visited.;

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      const auto [nextCount, nextComponentSum] = dfs(grid, x, y);
      count += nextCount;
      componentSum += nextComponentSum;
    }

    return {count, componentSum};
  }
};",2852
2850,"SELECT ABS(
    (
      SELECT MAX(salary) AS salary
      FROM Salaries
      WHERE department = 'Engineering'
    ) - (
      SELECT MAX(salary) AS salary
      FROM Salaries
      WHERE department = 'Marketing'
    )
  ) AS salary_difference;",2853
2851,"WITH
  StepsWithRollingAverage AS (
    SELECT
      user_id,
      steps_date,
      ROUND(
        AVG(steps_count) OVER(
          PARTITION by user_id
          ORDER BY steps_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ),
        2
      ) AS rolling_average,
      LAG(steps_date, 2) OVER(
        PARTITION by user_id
        ORDER BY steps_date
      ) AS two_dates_before
    FROM Steps
  )
SELECT
  user_id,
  steps_date,
  rolling_average
FROM StepsWithRollingAverage
WHERE DATEDIFF(steps_date, two_dates_before) = 2
ORDER BY 1, 2;",2854
2852,"class Solution {
 public:
  int minimumRightShifts(vector<int>& nums) {
    int count = 0;
    int pivot = -1;

    for (int i = 0; i + 1 < nums.size(); i++)
      if (nums[i] > nums[i + 1]) {
        ++count;
        pivot = i;
      }

    if (count == 0)
      return 0;
    if (count > 1 || nums.back() > nums.front())
      return -1;
    return nums.size() - 1 - pivot;
  }
};",2855
2853,"class Solution {
 public:
  int minLengthAfterRemovals(vector<int>& nums) {
    const int n = nums.size();
    unordered_map<int, int> count;
    int maxFreq = 0;

    for (const int num : nums)
      ++count[num];

    for (const auto& [_, freq] : count)
      maxFreq = max(maxFreq, freq);

    // The number with the maximum frequency cancel all the other numbers.
    if (maxFreq <= n / 2)
      return n % 2;
    // The number with the maximum frequency cancel all the remaining numbers.
    return maxFreq - (n - maxFreq);
  }
};",2856
2854,"class Solution {
 public:
  int countPairs(vector<vector<int>>& coordinates, int k) {
    int ans = 0;

    for (int x = 0; x <= k; ++x) {
      const int y = k - x;
      unordered_map<pair<int, int>, int, PairHash> count;
      for (const vector<int>& point : coordinates) {
        const int xi = point[0];
        const int yi = point[1];
        if (const auto it = count.find({xi ^ x, yi ^ y}); it != count.cend())
          ans += it->second;
        ++count[{xi, yi}];
      }
    }

    return ans;
  }

 private:
  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",2857
2855,"class Solution {
 public:
  vector<int> minEdgeReversals(int n, vector<vector<int>>& edges) {
    vector<int> ans(n);
    vector<vector<pair<int, bool>>> graph(n);
    vector<bool> seen(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, /*isForward=*/true);
      graph[v].emplace_back(u, /*isForward=*/false);
    }

    vector<int> mem(n, -1);
    ans[0] = minEdgeReversals(graph, 0, seen, mem);
    seen = vector<bool>(n);
    dfs(graph, 0, seen, ans);
    return ans;
  }

 private:
  // Returns the minimum number of edge reversals so node u can reach every
  // node in its subtree.
  int minEdgeReversals(const vector<vector<pair<int, bool>>>& graph, int u,
                       vector<bool>& seen, vector<int>& mem) {
    if (mem[u] != -1)
      return mem[u];
    int res = 0;
    seen[u] = true;
    for (const auto& [v, isForward] : graph[u]) {
      if (seen[v])
        continue;
      seen[v] = true;
      res += minEdgeReversals(graph, v, seen, mem) + (isForward ? 0 : 1);
    }
    return mem[u] = res;
  }

  void dfs(const vector<vector<pair<int, bool>>>& graph, int u,
           vector<bool>& seen, vector<int>& ans) {
    seen[u] = true;
    for (const auto& [v, isForward] : graph[u]) {
      if (seen[v])
        continue;
      seen[v] = true;
      ans[v] = ans[u] + (isForward ? 1 : -1);
      dfs(graph, v, seen, ans);
    }
  }
};",2858
2856,"class Solution {
 public:
  int sumIndicesWithKSetBits(vector<int>& nums, int k) {
    int ans = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (__builtin_popcount(i) == k)
        ans += nums[i];

    return ans;
  }
};",2859
2857,"class Solution {
 public:
  int countWays(vector<int>& nums) {
    nums.push_back(-1);
    nums.push_back(INT_MAX);
    ranges::sort(nums);

    int ans = 0;

    // i := the number of the selected numbers
    for (int i = 0; i + 1 < nums.size(); ++i)
      if (nums[i] < i && i < nums[i + 1])
        ++ans;

    return ans;
  }
};",2860
2858,"class Solution {
 public:
  int maxNumberOfAlloys(int n, int k, int budget,
                        vector<vector<int>>& composition, vector<int>& stock,
                        vector<int>& cost) {
    int l = 1;
    int r = 1'000'000'000;

    while (l < r) {
      const int m = (l + r) / 2;
      if (isPossible(n, budget, composition, stock, cost, m))
        l = m + 1;
      else
        r = m;
    }

    return l - 1;
  }

 private:
  // Returns true if it's possible to create `m` alloys by using any machine.
  bool isPossible(int n, int budget, const vector<vector<int>>& composition,
                  const vector<int>& stock, const vector<int>& costs, int m) {
    // Try all the possible machines.
    for (const vector<int>& machine : composition) {
      long requiredMoney = 0;
      for (int j = 0; j < n; ++j) {
        const long requiredUnits =
            max(0L, static_cast<long>(machine[j]) * m - stock[j]);
        requiredMoney += static_cast<long>(requiredUnits) * costs[j];
      }
      if (requiredMoney <= budget)
        return true;
    }
    return false;
  }
};",2861
2859,"class Solution {
 public:
  long long maximumSum(vector<int>& nums) {
    long long ans = 0;
    unordered_map<int, long long> oddPowerToSum;

    for (int i = 0; i < nums.size(); ++i) {
      const int oddPower = divideSquares(i + 1);
      ans = max(ans, oddPowerToSum[oddPower] += nums[i]);
    }

    return ans;
  }

 private:
  int divideSquares(int val) {
    for (int num = 2; num * num <= val; ++num)
      while (val % (num * num) == 0)
        val /= num * num;
    return val;
  }
};",2862
2860,"class Solution {
 public:
  int maxSubarrayLength(vector<int>& nums) {
    int ans = 0;
    stack<int> stack;

    for (int i = nums.size() - 1; i >= 0; --i)
      // If nums[stack.top()] <= nums[i], stack.top() is better than i.
      // So, no need to push it.
      if (stack.empty() || nums[stack.top()] > nums[i])
        stack.push(i);

    for (int i = 0; i < nums.size(); ++i)
      while (!stack.empty() && num > nums[stack.top()])
        ans = max(ans, stack.top() - i + 1), stack.pop();

    return ans;
  }
};",2863
2861,"class Solution {
 public:
  string maximumOddBinaryNumber(string s) {
    const int zeros = ranges::count(s, '0');
    const int ones = s.length() - zeros;
    return string(ones - 1, '1') + string(zeros, '0') + '1';
  }
};",2864
2862,"class Solution {
 public:
  long long maximumSumOfHeights(vector<int>& maxHeights) {
    const int n = maxHeights.size();
    vector<long> maxSum(n);  // maxSum[i] := the maximum sum with peak i

    stack<int> stack{{-1}};
    long summ = 0;

    for (int i = 0; i < n; ++i) {
      summ = process(stack, maxHeights, i, summ);
      maxSum[i] = summ;
    }

    stack = std::stack<int>{{n}};
    summ = 0;

    for (int i = n - 1; i >= 0; --i) {
      summ = process(stack, maxHeights, i, summ);
      maxSum[i] += summ - maxHeights[i];
    }

    return ranges::max(maxSum);
  }

 private:
  long process(stack<int>& stack, vector<int>& maxHeights, int i, long summ) {
    while (stack.size() > 1 && maxHeights[stack.top()] > maxHeights[i]) {
      int j = stack.top();
      stack.pop();
      // The last abs(j - stack.top()) heights are maxHeights[j].
      summ -= abs(j - stack.top()) * static_cast<long>(maxHeights[j]);
    }
    // Put abs(i - stack.top()) * maxHeights[i] in `heights`.
    summ += abs(i - stack.top()) * static_cast<long>(maxHeights[i]);
    stack.push(i);
    return summ;
  }
};",2865
2863,"class Solution {
 public:
  // Same as 2865. Beautiful Towers I
  long long maximumSumOfHeights(vector<int>& maxHeights) {
    const int n = maxHeights.size();
    vector<long> maxSum(n);  // maxSum[i] := the maximum sum with peak i

    stack<int> stack{{-1}};
    long summ = 0;

    for (int i = 0; i < n; ++i) {
      summ = process(stack, maxHeights, i, summ);
      maxSum[i] = summ;
    }

    stack = std::stack<int>{{n}};
    summ = 0;

    for (int i = n - 1; i >= 0; --i) {
      summ = process(stack, maxHeights, i, summ);
      maxSum[i] += summ - maxHeights[i];
    }

    return ranges::max(maxSum);
  }

 private:
  long process(stack<int>& stack, vector<int>& maxHeights, int i, long summ) {
    while (stack.size() > 1 && maxHeights[stack.top()] > maxHeights[i]) {
      int j = stack.top();
      stack.pop();
      // The last abs(j - stack.top()) heights are maxHeights[j].
      summ -= abs(j - stack.top()) * static_cast<long>(maxHeights[j]);
    }
    // Put abs(i - stack.top()) * maxHeights[i] in `heights`.
    summ += abs(i - stack.top()) * static_cast<long>(maxHeights[i]);
    stack.push(i);
    return summ;
  }
};",2866
2864,"class Solution {
 public:
  long long countPaths(int n, vector<vector<int>>& edges) {
    long long ans = 0;
    const vector<bool> isPrime = sieveEratosthenes(n + 1);
    vector<vector<int>> graph(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    dfs(graph, 1, /*prev=*/-1, isPrime, ans);
    return ans;
  }

 private:
  pair<long, long> dfs(const vector<vector<int>>& graph, int u, int prev,
                       const vector<bool>& isPrime, long long& ans) {
    long countZeroPrimePath = !isPrime[u];
    long countOnePrimePath = isPrime[u];

    for (const int v : graph[u]) {
      if (v == prev)
        continue;
      const auto& [countZeroPrimeChildPath, countOnePrimeChildPath] =
          dfs(graph, v, u, isPrime, ans);
      ans += countZeroPrimePath * countOnePrimeChildPath +
             countOnePrimePath * countZeroPrimeChildPath;
      if (isPrime[u]) {
        countOnePrimePath += countZeroPrimeChildPath;
      } else {
        countZeroPrimePath += countZeroPrimeChildPath;
        countOnePrimePath += countOnePrimeChildPath;
      }
    }

    return {countZeroPrimePath, countOnePrimePath};
  }

  vector<bool> sieveEratosthenes(int n) {
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    return isPrime;
  }
};",2867
2865,"class Solution {
 public:
  bool canAliceWin(vector<string>& a, vector<string>& b) {
    // words[0][i] := the biggest word starting with ('a' + i) for Alice
    // words[1][i] := the biggest word starting with ('a' + i) for Bob
    vector<vector<string>> words(2, vector<string>(26));

    // For each letter, only the biggest word is useful.
    for (const string& word : a)
      words[0][word[0] - 'a'] = word;

    for (const string& word : b)
      words[1][word[0] - 'a'] = word;

    // Find Alice's smallest word.
    int i = 0;
    while (words[0][i].empty())
      ++i;

    // Iterate each letter until we find a winner.
    // Start with Alice's turn (0), so it's Bob's turn (1) now.
    for (int turn = 1; true; turn = turn ^ 1)
      // If the current player has a word that having the letter that is greater
      // than the opponent's word, choose it.
      if (!words[turn][i].empty() && words[turn][i] > words[turn ^ 1][i]) {
        // Choose the current words[turn][i].
      } else if (!words[turn][i + 1].empty()) {
        // Choose the next words[turn][i + 1].
        ++i;
      } else {
        // Game over. If it's Bob's turn, Alice wins, and vice versa.
        return turn == 1;
      }
  }
};",2868
2866,"class Solution {
 public:
  int minOperations(vector<int>& nums, int k) {
    unordered_set<int> seen;

    for (int i = nums.size() - 1; i >= 0; --i) {
      if (nums[i] > k)
        continue;
      seen.insert(nums[i]);
      if (seen.size() == k)
        return nums.size() - i;
    }

    throw;
  }
};",2869
2867,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [_, freq] : count) {
      // If freq == 3k, need k operations.
      // If freq == 3k + 1 = 3*(k - 1) + 2*2, need k + 1 operations.
      // If freq == 3k + 2, need k + 1 operations.
      if (freq == 1)
        return -1;
      ans += (freq + 2) / 3;
    }

    return ans;
  }
};",2870
2868,"class Solution {
 public:
  int maxSubarrays(vector<int>& nums) {
    int ans = 0;
    int score = 0;

    for (const int num : nums) {
      score = score == 0 ? num : score & num;
      if (score == 0)
        ++ans;
    }

    return max(1, ans);
  }
};",2871
2869,"class Solution {
 public:
  int maxKDivisibleComponents(int n, vector<vector<int>>& edges,
                              vector<int>& values, int k) {
    int ans = 0;
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    dfs(graph, 0, /*prev=*/-1, values, k, ans);
    return ans;
  }

 private:
  long long dfs(const vector<vector<int>>& graph, int u, int prev,
                const vector<int>& values, int k, int& ans) {
    long long treeSum = values[u];

    for (const int v : graph[u])
      if (v != prev)
        treeSum += dfs(graph, v, u, values, k, ans);

    if (treeSum % k == 0)
      ++ans;
    return treeSum;
  }
};",2872
2870,"class Solution {
 public:
  long long maximumTripletValue(vector<int>& nums) {
    long long ans = 0;
    int maxDiff = 0;  // max(nums[i] - nums[j])
    int maxNum = 0;   // max(nums[i])

    for (const int num : nums) {
      ans = max(ans, static_cast<long long>(maxDiff) * num);  // num := nums[k]
      maxDiff = max(maxDiff, maxNum - num);                   // num := nums[j]
      maxNum = max(maxNum, num);                              // num := nums[i]
    }

    return ans;
  }
};",2873
2871,"class Solution {
 public:
  // Same as 2873. Maximum Value of an Ordered Triplet I
  long long maximumTripletValue(vector<int>& nums) {
    long long ans = 0;
    int maxDiff = 0;  // max(nums[i] - nums[j])
    int maxNum = 0;   // max(nums[i])

    for (const int num : nums) {
      ans = max(ans, static_cast<long long>(maxDiff) * num);  // num := nums[k]
      maxDiff = max(maxDiff, maxNum - num);                   // num := nums[j]
      maxNum = max(maxNum, num);                              // num := nums[i]
    }

    return ans;
  }
};",2874
2872,"class Solution {
 public:
  int minSizeSubarray(vector<int>& nums, int target) {
    const long sum = accumulate(nums.begin(), nums.end(), 0L);
    const int n = nums.size();
    const int remainingTarget = target % sum;
    const int repeatLength = (target / sum) * n;
    if (remainingTarget == 0)
      return repeatLength;

    int suffixPlusPrefixLength = n;
    long prefix = 0;
    unordered_map<long, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < 2 * n; ++i) {
      prefix += nums[i % n];
      if (const auto it = prefixToIndex.find(prefix - remainingTarget);
          it != prefixToIndex.cend())
        suffixPlusPrefixLength = min(suffixPlusPrefixLength, i - it->second);
      prefixToIndex[prefix] = i;
    }

    return suffixPlusPrefixLength == n ? -1
                                       : suffixPlusPrefixLength + repeatLength;
  }
};",2875
2873,"class Solution {
 public:
  vector<int> countVisitedNodes(vector<int>& edges) {
    const int n = edges.size();
    vector<int> ans(n);
    vector<int> inDegrees(n);
    vector<bool> seen(n);
    queue<int> q;
    stack<int> stack;

    for (const int v : edges)
      ++inDegrees[v];

    // Perform topological sorting.
    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0)
        q.push(i);

    // Push non-cyclic nodes to stack.
    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      if (--inDegrees[edges[u]] == 0)
        q.push(edges[u]);
      stack.push(u);
      seen[u] = true;
    }

    // Fill the length of cyclic nodes.
    for (int i = 0; i < n; ++i)
      if (!seen[i])
        fillCycle(edges, i, seen, ans);

    // Fill the length of non-cyclic nodes.
    while (!stack.empty()) {
      const int u = stack.top();
      stack.pop();
      ans[u] = ans[edges[u]] + 1;
    }

    return ans;
  }

 private:
  void fillCycle(const vector<int>& edges, int start, vector<bool>& seen,
                 vector<int>& ans) {
    int cycleLength = 0;
    for (int u = start; !seen[u]; u = edges[u]) {
      ++cycleLength;
      seen[u] = true;
    }
    ans[start] = cycleLength;
    for (int u = edges[start]; u != start; u = edges[u])
      ans[u] = cycleLength;
  }
};",2876
2874,"import pandas as pd


def createDataframe(student_data: List[List[int]]) -> pd.DataFrame:
  return pd.DataFrame(student_data, columns=['student_id', 'age'])",2877
2875,"import pandas as pd


def getDataframeSize(players: pd.DataFrame) -> List[int]:
  return [*players.shape]",2878
2876,"import pandas as pd


def selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:
  return employees.head(3)",2879
2877,"import pandas as pd


def selectData(students: pd.DataFrame) -> pd.DataFrame:
  return students.loc[students['student_id'] == 101, ['name', 'age']]",2880
2878,"import pandas as pd


def createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:
  employees['bonus'] = employees['salary'] * 2
  return employees",2881
2879,"import pandas as pd


def dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:
  customers.drop_duplicates(subset='email', keep='first', inplace=True)
  return customers",2882
2880,"import pandas as pd


def dropMissingData(students: pd.DataFrame) -> pd.DataFrame:
  students.dropna(subset=['name'], inplace=True)
  return students",2883
2881,"import pandas as pd


def modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:
  employees['salary'] = employees['salary'] * 2
  return employees",2884
2882,"import pandas as pd


def renameColumns(students: pd.DataFrame) -> pd.DataFrame:
  return students.rename(
      columns={
          ""id"": ""student_id"",
          ""first"": ""first_name"",
          ""last"": ""last_name"",
          ""age"": ""age_in_years"",
      }
  )",2885
2883,"import pandas as pd


def changeDatatype(students: pd.DataFrame) -> pd.DataFrame:
  return students.astype({'grade': int})",2886
2884,"import pandas as pd


def fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:
  products['quantity'].fillna(0, inplace=True)
  return products",2887
2885,"import pandas as pd


def concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:
  return pd.concat([df1, df2], axis=0)",2888
2886,"import pandas as pd


def pivotTable(weather: pd.DataFrame) -> pd.DataFrame:
  return weather.pivot_table(
      index='month',
      columns='city',
      values='temperature',
      aggfunc='max',
  )",2889
2887,"import pandas as pd


def meltTable(report: pd.DataFrame) -> pd.DataFrame:
  return pd.melt(
      report,
      id_vars=['product'],
      var_name='quarter',
      value_name='sales',
  )",2890
2888,"import pandas as pd


def findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:
  return animals[animals['weight'] > 100].sort_values(
      by='weight',
      ascending=False
  )[['name']]",2891
2889,"class Solution {
 public:
  int minArrayLength(vector<int>& nums, int k) {
    int count = 0;
    long prod = -1;

    for (const int num : nums) {
      if (num == 0)
        return 1;
      if (prod != -1 && prod * num <= k) {
        prod *= num;
      } else {
        prod = num;
        ++count;
      }
    }

    return count;
  }
};",2892
2890,"SELECT
  CEIL(minute / 6) AS interval_no,
  SUM(order_count) AS total_orders
FROM Orders
GROUP BY 1
ORDER BY 1;",2893
2891,"class Solution {
 public:
  int differenceOfSums(int n, int m) {
    const int sum = (1 + n) * n / 2;
    const int num2 = getDivisibleSum(n, m);
    const int num1 = sum - num2;
    return num1 - num2;
  }

 private:
  // Returns the sum of all the integers in [1, n] that are divisible by m.
  int getDivisibleSum(int n, int m) {
    const int last = n / m * m;
    if (last == 0)
      return 0;
    const int first = m;
    const int count = (last - first) / m + 1;
    return (first + last) * count / 2;
  }
};",2894
2892,"class Solution {
 public:
  int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {
    int ans = 0;
    ranges::sort(processorTime);
    ranges::sort(tasks, greater<>());

    // It's optimal to run each 4 longer tasks with a smaller processor time.
    // Therefore, for each processor, take the maximum of the sum of the
    // processor time and the largest assigned tasks[i].
    for (int i = 0; i < processorTime.size(); ++i)
      ans = max(ans, processorTime[i] + tasks[i * 4]);

    return ans;
  }
};",2895
2893,"class Solution {
 public:
  int minOperations(string s1, string s2, int x) {
    const vector<int> diffIndices = getDiffIndices(s1, s2);
    if (diffIndices.empty())
      return 0;
    // It's impossible to make two strings equal if there are an odd number of
    // differences.
    if (diffIndices.size() % 2 == 1)
      return -1;
    vector<double> mem(diffIndices.size(), -1.0);
    return minOperations(diffIndices, 0, x, mem);
  }

 private:
  // Returns the minimum cost to correct diffIndices[i..n).
  double minOperations(const vector<int>& diffIndices, int i, double x,
                       vector<double>& mem) {
    if (i == diffIndices.size())
      return 0;
    if (i == diffIndices.size() - 1)
      return x / 2;
    if (mem[i] != -1.0)
      return mem[i];
    return mem[i] = min(minOperations(diffIndices, i + 1, x, mem) + x / 2,
                        minOperations(diffIndices, i + 2, x, mem) +
                            diffIndices[i + 1] - diffIndices[i]);
  }

  vector<int> getDiffIndices(const string& s1, const string& s2) {
    vector<int> diffIndices;
    for (int i = 0; i < s1.length(); ++i)
      if (s1[i] != s2[i])
        diffIndices.push_back(i);
    return diffIndices;
  }
};",2896
2894,"class Solution {
 public:
  int maxSum(vector<int>& nums, int k) {
    constexpr int kMod = 1'000'000'007;
    constexpr int kMaxBit = 30;
    int ans = 0;
    // minIndices[i] := the minimum index in `optimalNums` that the i-th bit
    // should be moved to
    vector<int> minIndices(kMaxBit);
    vector<int> optimalNums(nums.size());

    for (const int num : nums)
      for (int i = 0; i < kMaxBit; ++i)
        if (num >> i & 1)
          optimalNums[minIndices[i]++] |= 1 << i;

    for (int i = 0; i < k; ++i)
      ans = (ans + static_cast<long>(optimalNums[i]) * optimalNums[i]) % kMod;

    return ans;
  }
};",2897
2895,"class Solution {
 public:
  long long maxScore(vector<int>& prices) {
    //    prices[indexes[j]] - prices[indexes[j - 1]]
    // == indexes[j] - indexes[j - 1]
    //    prices[indexes[j]] - indexes[j]
    // == prices[indexes[j - 1]] - indexes[j - 1]
    //
    // So, elements in the same subsequence must have the same prices[i] - i.
    unordered_map<int, long long> groupIdToSum;

    for (int i = 0; i < prices.size(); ++i)
      groupIdToSum[prices[i] - i] += prices[i];

    return ranges::max_element(groupIdToSum,
                               [](const std::pair<int, long long>& p1,
                                  const std::pair<int, long long>& p2) {
      return p1.second < p2.second;
    })->second;
  }
};",2898
2896,"class Solution {
 public:
  vector<int> lastVisitedIntegers(vector<string>& words) {
    vector<int> ans;
    vector<int> nums;
    int k = 0;

    for (const string& word : words)
      if (word == ""prev"") {
        ++k;
        ans.push_back(k > nums.size() ? -1 : nums[nums.size() - k]);
      } else {
        k = 0;
        nums.push_back(stoi(word));
      }

    return ans;
  }
};",2899
2897,"class Solution {
 public:
  vector<string> getWordsInLongestSubsequence(int n, vector<string>& words,
                                              vector<int>& groups) {
    vector<string> ans;
    int groupId = -1;

    for (int i = 0; i < n; ++i)
      if (groups[i] != groupId) {
        groupId = groups[i];
        ans.push_back(words[i]);
      }

    return ans;
  }
};",2900
2898,"class Solution {
 public:
  vector<string> getWordsInLongestSubsequence(int n, vector<string>& words,
                                              vector<int>& groups) {
    vector<string> ans;
    // dp[i] := the length of the longest subsequence ending in `words[i]`
    vector<int> dp(n, 1);
    // prev[i] := the best index of words[i]
    vector<int> prev(n, -1);

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        if (groups[i] == groups[j])
          continue;
        if (words[i].length() != words[j].length())
          continue;
        if (hammingDist(words[i], words[j]) != 1)
          continue;
        if (dp[i] < dp[j] + 1) {
          dp[i] = dp[j] + 1;
          prev[i] = j;
        }
      }

    // Find the last index of the subsequence.
    int index = ranges::max_element(dp) - dp.begin();
    while (index != -1) {
      ans.push_back(words[index]);
      index = prev[index];
    }

    return {ans.rbegin(), ans.rend()};
  }

 private:
  int hammingDist(const string& s1, const string& s2) {
    int dist = 0;
    for (int i = 0; i < s1.length(); ++i)
      if (s1[i] != s2[i])
        ++dist;
    return dist;
  }
};",2901
2899,"class Solution {
 public:
  int countSubMultisets(vector<int>& nums, int l, int r) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := the number of submultisets of `nums` with sum i
    vector<long> dp(r + 1);
    dp[0] = 1;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    const int zeros = count[0];
    count.erase(0);

    for (const auto& [num, freq] : count) {
      // stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...
      vector<long> stride = dp;
      for (int i = num; i <= r; ++i)
        stride[i] += stride[i - num];
      for (int i = r; i > 0; --i)
        if (i >= num * (freq + 1))
          // dp[i] + dp[i - num] + dp[i - freq * num]
          dp[i] = (stride[i] - stride[i - num * (freq + 1)]) % kMod;
        else
          dp[i] = stride[i] % kMod;
    }

    long ans = 0;
    for (int i = l; i <= r; ++i)
      ans = (ans + dp[i]) % kMod;
    return ((zeros + 1) * ans) % kMod;
  }
};",2902
2900,"class Solution {
 public:
  vector<int> findIndices(vector<int>& nums, int indexDifference,
                          int valueDifference) {
    // nums[minIndex] := the minimum number with enough index different from the
    // current number
    int minIndex = 0;
    // nums[maxIndex] := the maximum number with enough index different from the
    // current number
    int maxIndex = 0;

    for (int i = indexDifference; i < nums.size(); ++i) {
      if (nums[i - indexDifference] < nums[minIndex])
        minIndex = i - indexDifference;
      if (nums[i - indexDifference] > nums[maxIndex])
        maxIndex = i - indexDifference;
      if (nums[i] - nums[minIndex] >= valueDifference)
        return {i, minIndex};
      if (nums[maxIndex] - nums[i] >= valueDifference)
        return {i, maxIndex};
    }

    return {-1, -1};
  }
};",2903
2901,"class Solution {
 public:
  // Same as 76. Minimum Window Substring
  string shortestBeautifulSubstring(string s, int k) {
    int bestLeft = -1;
    int minLength = s.length() + 1;
    int ones = 0;

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (s[r] == '1')
        ++ones;
      while (ones == k) {
        if (r - l + 1 < minLength) {
          bestLeft = l;
          minLength = r - l + 1;
        } else if (r - l + 1 == minLength &&
                   s.compare(l, minLength, s, bestLeft, minLength) < 0) {
          bestLeft = l;
        }
        if (s[l++] == '1')
          --ones;
      }
    }

    return bestLeft == -1 ? """" : s.substr(bestLeft, minLength);
  }
};",2904
2902,"class Solution {
 public:
  vector<int> findIndices(vector<int>& nums, int indexDifference,
                          int valueDifference) {
    // nums[minIndex] := the minimum number with enough index different from the
    // current number
    int minIndex = 0;
    // nums[maxIndex] := the maximum number with enough index different from the
    // current number
    int maxIndex = 0;

    for (int i = indexDifference; i < nums.size(); ++i) {
      if (nums[i - indexDifference] < nums[minIndex])
        minIndex = i - indexDifference;
      if (nums[i - indexDifference] > nums[maxIndex])
        maxIndex = i - indexDifference;
      if (nums[i] - nums[minIndex] >= valueDifference)
        return {i, minIndex};
      if (nums[maxIndex] - nums[i] >= valueDifference)
        return {i, maxIndex};
    }

    return {-1, -1};
  }
};",2905
2903,"class Solution {
 public:
  vector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {
    constexpr int kMod = 12345;
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    vector<int> prefix{1};
    int suffix = 1;

    for (const vector<int>& row : grid)
      for (const int cell : row)
        prefix.push_back(static_cast<long>(prefix.back()) * cell % kMod);

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        ans[i][j] = prefix[i * n + j] * suffix % kMod;
        suffix = static_cast<long>(suffix) * grid[i][j] % kMod;
      }

    return ans;
  }
};",2906
2904,"class FenwickTree {
 public:
  FenwickTree(int n) : vals(n + 1) {}

  void update(int i, int val) {
    while (i < vals.size()) {
      vals[i] = max(vals[i], val);
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int res = 0;
    while (i > 0) {
      res = max(res, vals[i]);
      i -= lowbit(i);
    }
    return res;
  }

 private:
  vector<int> vals;

  static int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int maxProfit(vector<int>& prices, vector<int>& profits) {
    const int maxPrice = ranges::max(prices);
    int ans = -1;
    FenwickTree maxProfitTree1(maxPrice);
    FenwickTree maxProfitTree2(maxPrice);

    for (int i = 0; i < prices.size(); ++i) {
      const int price = prices[i];
      const int profit = profits[i];
      // max(proftis[i])
      const int maxProfit1 = maxProfitTree1.get(price - 1);
      // max(proftis[i]) + max(profits[j])
      const int maxProfit2 = maxProfitTree2.get(price - 1);
      maxProfitTree1.update(price, profit);
      if (maxProfit1 > 0)
        maxProfitTree2.update(price, profit + maxProfit1);
      if (maxProfit2 > 0)
        ans = max(ans, profit + maxProfit2);
    }

    return ans;
  }
};",2907
2905,"class Solution {
 public:
  int minimumSum(vector<int>& nums) {
    const int n = nums.size();
    int ans = INT_MAX;
    vector<int> minPrefix(n);
    vector<int> minSuffix(n);

    partial_sum(nums.begin(), nums.end(), minPrefix.begin(),
                [](int x, int y) { return min(x, y); });
    partial_sum(nums.rbegin(), nums.rend(), minSuffix.begin(),
                [](int x, int y) { return min(x, y); });
    reverse(minSuffix.begin(), minSuffix.end());

    for (int i = 0; i < n; ++i)
      if (nums[i] > minPrefix[i] && nums[i] > minSuffix[i])
        ans = min(ans, nums[i] + minPrefix[i] + minSuffix[i]);

    return ans == INT_MAX ? -1 : ans;
  }
};",2908
2906,"class Solution {
 public:
  // Same as 2908. Minimum Sum of Mountain Triplets I
  int minimumSum(vector<int>& nums) {
    const int n = nums.size();
    int ans = INT_MAX;
    vector<int> minPrefix(n);
    vector<int> minSuffix(n);

    partial_sum(nums.begin(), nums.end(), minPrefix.begin(),
                [](int x, int y) { return min(x, y); });
    partial_sum(nums.rbegin(), nums.rend(), minSuffix.begin(),
                [](int x, int y) { return min(x, y); });
    reverse(minSuffix.begin(), minSuffix.end());

    for (int i = 0; i < n; ++i)
      if (nums[i] > minPrefix[i] && nums[i] > minSuffix[i])
        ans = min(ans, nums[i] + minPrefix[i] + minSuffix[i]);

    return ans == INT_MAX ? -1 : ans;
  }
};",2909
2907,"class Solution {
 public:
  int minGroupsForValidAssignment(vector<int>& nums) {
    unordered_map<int, int> count;
    int minFreq = nums.size();

    for (const int num : nums)
      ++count[num];

    for (const auto& [_, freq] : count)
      minFreq = min(minFreq, freq);

    for (int groupSize = minFreq; groupSize >= 1; --groupSize) {
      const int numGroups = getNumGroups(count, groupSize);
      if (numGroups > 0)
        return numGroups;
    }

    throw;
  }

 private:
  // Returns the number of groups if each group's size is `groupSize` or
  // `groupSize + 1`.
  int getNumGroups(unordered_map<int, int>& count, int groupSize) {
    int numGroups = 0;
    for (const auto& [_, freq] : count) {
      const int a = freq / (groupSize + 1);
      const int b = freq % (groupSize + 1);
      if (b == 0) {
        numGroups += a;
      } else if (groupSize - b <= a) {
        // Assign 1 number from `groupSize - b` out of `a` groups to this group,
        // so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`
        // and `groupSize - b + 1` groups of size `groupSize`. In total, we have
        // `a + 1` groups.
        numGroups += a + 1;
      } else {
        return 0;
      }
    }
    return numGroups;
  }
};",2910
2908,"class Solution {
 public:
  int minimumChanges(string s, int k) {
    const int n = s.length();
    // factors[i] := factors of i
    const vector<vector<int>> factors = getFactors(n);
    // cost[i][j] := changes to make s[i..j] a semi-palindrome
    const vector<vector<int>> cost = getCost(s, n, factors);
    // dp[i][j] := the minimum changes to split s[i:] into j valid parts
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, n));

    dp[n][0] = 0;

    for (int i = n - 1; i >= 0; --i)
      for (int j = 1; j <= k; ++j)
        for (int l = i + 1; l < n; ++l)
          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l]);

    return dp[0][k];
  }

 private:
  vector<vector<int>> getFactors(int n) {
    vector<vector<int>> factors(n + 1);
    for (int i = 1; i <= n; ++i)
      factors[i].push_back(1);
    for (int d = 2; d < n; ++d)
      for (int i = d * 2; i <= n; i += d)
        factors[i].push_back(d);
    return factors;
  }

  vector<vector<int>> getCost(const string& s, int n,
                              const vector<vector<int>>& factors) {
    vector<vector<int>> cost(n, vector<int>(n));
    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        const int length = j - i + 1;
        int minCost = length;
        for (const int d : factors[length])
          minCost = min(minCost, getCost(s, i, j, d));
        cost[i][j] = minCost;
      }
    return cost;
  }

  // Returns the cost to make s[i..j] a semi-palindrome of `d`.
  int getCost(const string& s, int i, int j, int d) {
    int cost = 0;
    for (int offset = 0; offset < d; ++offset) {
      int l = i + offset;
      int r = j - d + 1 + offset;
      while (l < r) {
        if (s[l] != s[r])
          ++cost;
        l += d;
        r -= d;
      }
    }
    return cost;
  }
};",2911
2909,"class Solution {
 public:
  int numberOfWays(int n, int m, int k, vector<int>& source,
                   vector<int>& dest) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][0] := the the number of ways of `source` to `dest` using i
    // steps dp[i][1] := the the number of ways of `source` to dest's row
    // using i steps dp[i][2] := the the number of ways of `source` to
    // dest's col using i steps dp[i][3] := the the number of ways of
    // `source` to others using i steps
    vector<vector<int>> dp(k + 1, vector<int>(4));
    if (source == dest)
      dp[0][0] = 1;
    else if (source[0] == dest[0])
      dp[0][1] = 1;
    else if (source[1] == dest[1])
      dp[0][2] = 1;
    else
      dp[0][3] = 1;

    for (int i = 1; i <= k; i++) {
      dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % kMod;
      dp[i][1] = ((dp[i - 1][0] * (m - 1L) +  // -self
                   dp[i - 1][1] * (m - 2L) +  // -self, -center
                   dp[i - 1][3]) %
                  kMod);
      dp[i][2] = ((dp[i - 1][0] * (n - 1L) +  // -self
                   dp[i - 1][2] * (n - 2L) +  // -self, -center
                   dp[i - 1][3]) %
                  kMod);
      dp[i][3] = ((dp[i - 1][1] * (n - 1L) +         // -self
                   dp[i - 1][2] * (m - 1L) +         // -self
                   dp[i - 1][3] * (m + n - 1 - 3L))  // -self, -row, -col
                  % kMod);
    }

    return dp[k][0];
  }
};",2912
2910,"class SegmentTree {
 public:
  SegmentTree(int n, int kMod)
      : n(n), kMod(kMod), lazy(4 * n), sums(4 * n), squaredSums(4 * n) {}

  void updateRange(int l, int r) {
    return updateRange(/*i=*/0, /*start=*/0, /*end=*/n - 1, l, r);
  }

  void propagate(int i, int l, int r) {
    const int gap = r - l + 1;
    // (a + L)^2 + (b + L)^2 + (c + L)^2, where L = lazy[i]
    // a^2 + b^2 + c^2 + 2 * L (a + b + c) + L^2 * gap, where gap = 3
    squaredSums[i] += 2 * lazy[i] * sums[i] + lazy[i] * lazy[i] * gap;
    squaredSums[i] %= kMod;
    sums[i] += lazy[i] * gap;
    sums[i] %= kMod;
    if (l < r) {
      lazy[i * 2 + 1] += lazy[i];
      lazy[i * 2 + 2] += lazy[i];
    }
    lazy[i] = 0;
  }

  int getTreeSquaredSums() {
    return squaredSums[0];
  }

 private:
  const int kMod;
  const int n;
  vector<long> lazy;
  vector<long> sums;
  vector<long> squaredSums;

  void updateRange(int i, int start, int end, int l, int r) {
    if (lazy[i] > 0)
      propagate(i, start, end);
    if (end < l || start > r)
      return;
    if (start >= l && end <= r) {
      lazy[i] = 1;
      propagate(i, start, end);
      return;
    }
    const int mid = (start + end) / 2;
    updateRange(i * 2 + 1, start, mid, l, r);
    updateRange(i * 2 + 2, mid + 1, end, l, r);
    sums[i] = (sums[i * 2 + 1] + sums[i * 2 + 2]) % kMod;
    squaredSums[i] = (squaredSums[i * 2 + 1] + squaredSums[i * 2 + 2]) % kMod;
  }
};

class Solution {
 public:
  int sumCounts(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    unordered_map<int, int> lastSeen;
    SegmentTree tree(n, kMod);

    for (int r = 0; r < n; ++r) {
      const int l = lastSeen.count(nums[r]) ? lastSeen[nums[r]] + 1 : 0;
      tree.updateRange(l, r);
      lastSeen[nums[r]] = r;
      ans = (ans + tree.getTreeSquaredSums()) % kMod;
    }

    return ans;
  }
};",2913
2911,"class Solution {
 public:
  int minChanges(string s) {
    int ans = 0;

    for (int i = 0; i + 1 < s.length(); i += 2)
      if (s[i] != s[i + 1])
        ++ans;

    return ans;
  }
};",2914
2912,"class Solution {
 public:
  int lengthOfLongestSubsequence(vector<int>& nums, int target) {
    const int n = nums.size();
    // dp[i][j] := the maximum length of any subsequence of the first i numbers
    // that sum to j
    vector<vector<int>> dp(n + 1, vector<int>(target + 1, -1));

    for (int i = 0; i <= n; ++i)
      dp[i][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 1; j <= target; ++j)
        // Case 1: Skip `num`.
        if (j < num || dp[i - 1][j - num] == -1)
          dp[i][j] = dp[i - 1][j];
        // Case 2: Skip `num` or pick `num`.
        else
          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num]);
    }

    return dp[n][target];
  }
};",2915
2913,"class SegmentTree {
 public:
  SegmentTree(int n, int kMod)
      : n(n), kMod(kMod), lazy(4 * n), sums(4 * n), squaredSums(4 * n) {}

  void updateRange(int l, int r) {
    return updateRange(/*i=*/0, /*start=*/0, /*end=*/n - 1, l, r);
  }

  void propagate(int i, int l, int r) {
    const int gap = r - l + 1;
    // (a + L)^2 + (b + L)^2 + (c + L)^2, where L = lazy[i]
    // a^2 + b^2 + c^2 + 2 * L (a + b + c) + L^2 * gap, where gap = 3
    squaredSums[i] += 2 * lazy[i] * sums[i] + lazy[i] * lazy[i] * gap;
    squaredSums[i] %= kMod;
    sums[i] += lazy[i] * gap;
    sums[i] %= kMod;
    if (l < r) {
      lazy[i * 2 + 1] += lazy[i];
      lazy[i * 2 + 2] += lazy[i];
    }
    lazy[i] = 0;
  }

  int getTreeSquaredSums() {
    return squaredSums[0];
  }

 private:
  const int kMod;
  const int n;
  vector<long> lazy;
  vector<long> sums;
  vector<long> squaredSums;

  void updateRange(int i, int start, int end, int l, int r) {
    if (lazy[i] > 0)
      propagate(i, start, end);
    if (end < l || start > r)
      return;
    if (start >= l && end <= r) {
      lazy[i] = 1;
      propagate(i, start, end);
      return;
    }
    const int mid = (start + end) / 2;
    updateRange(i * 2 + 1, start, mid, l, r);
    updateRange(i * 2 + 2, mid + 1, end, l, r);
    sums[i] = (sums[i * 2 + 1] + sums[i * 2 + 2]) % kMod;
    squaredSums[i] = (squaredSums[i * 2 + 1] + squaredSums[i * 2 + 2]) % kMod;
  }
};

class Solution {
 public:
  int sumCounts(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    unordered_map<int, int> lastSeen;
    SegmentTree tree(n, kMod);

    for (int r = 0; r < n; ++r) {
      const int l = lastSeen.count(nums[r]) ? lastSeen[nums[r]] + 1 : 0;
      tree.updateRange(l, r);
      lastSeen[nums[r]] = r;
      ans = (ans + tree.getTreeSquaredSums()) % kMod;
    }

    return ans;
  }
};",2916
2914,,2917
2915,"class Solution {
 public:
  long long minSum(vector<int>& nums1, vector<int>& nums2) {
    const long long sum1 = accumulate(nums1.begin(), nums1.end(), 0LL);
    const long long sum2 = accumulate(nums2.begin(), nums2.end(), 0LL);
    const int zero1 = ranges::count(nums1, 0);
    const int zero2 = ranges::count(nums2, 0);
    if (zero1 == 0 && sum1 < sum2 + zero2)
      return -1;
    if (zero2 == 0 && sum2 < sum1 + zero1)
      return -1;
    return max(sum1 + zero1, sum2 + zero2);
  }
};",2918
2916,"class Solution {
 public:
  long long minIncrementOperations(std::vector<int>& nums, int k) {
    // the minimum operations to increase nums[i - 3] and nums[0..i - 3)
    long long prev3 = 0;
    // the minimum operations to increase nums[i - 2] and nums[0..i - 2)
    long long prev2 = 0;
    // the minimum operations to increase nums[i - 1] and nums[0..i - 1)
    long long prev1 = 0;

    for (const int& num : nums) {
      const long long dp = min({prev1, prev2, prev3}) + max(0, k - num);
      prev3 = prev2;
      prev2 = prev1;
      prev1 = dp;
    }

    return min({prev1, prev2, prev3});
  }
};",2919
2917,"class Solution {
 public:
  int maximumPoints(vector<vector<int>>& edges, vector<int>& coins, int k) {
    const int n = coins.size();
    vector<vector<int>> graph(n);
    vector<vector<int>> mem(n, vector<int>(kMaxHalved + 1, -1));

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    return dfs(graph, 0, /*prev=*/-1, coins, k, /*halved=*/0, mem);
  }

 private:
  static constexpr int kMaxCoin = 10000;
  static constexpr int kMaxHalved = 13;  // log2(kMaxCoin) = 13

  int dfs(const vector<vector<int>>& graph, int u, int prev,
          const vector<int>& coins, int k, int halved,
          vector<vector<int>>& mem) {
    // All the children will be 0, so no need to explore.
    if (halved > kMaxHalved)
      return 0;
    if (mem[u][halved] != -1)
      return mem[u][halved];

    const int val = coins[u] / (1 << halved);
    int takeAll = val - k;
    int takeHalf = floor(val / 2.0);

    for (const int v : graph[u]) {
      if (v == prev)
        continue;
      takeAll += dfs(graph, v, u, coins, k, halved, mem);
      takeHalf += dfs(graph, v, u, coins, k, halved + 1, mem);
    }

    return mem[u][halved] = max(takeAll, takeHalf);
  }
};",2920
2918,"class FenwickTree {
 public:
  FenwickTree(int n) : vals(n + 1) {}

  void update(int i, int val) {
    while (i < vals.size()) {
      vals[i] = max(vals[i], val);
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int res = 0;
    while (i > 0) {
      res = max(res, vals[i]);
      i -= lowbit(i);
    }
    return res;
  }

 private:
  vector<int> vals;

  static int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  // Same as 2907. Maximum Profitable Triplets With Increasing Prices I
  int maxProfit(vector<int>& prices, vector<int>& profits) {
    const int maxPrice = ranges::max(prices);
    int ans = -1;
    FenwickTree maxProfitTree1(maxPrice);
    FenwickTree maxProfitTree2(maxPrice);

    for (int i = 0; i < prices.size(); ++i) {
      const int price = prices[i];
      const int profit = profits[i];
      // max(proftis[i])
      const int maxProfit1 = maxProfitTree1.get(price - 1);
      // max(proftis[i]) + max(profits[j])
      const int maxProfit2 = maxProfitTree2.get(price - 1);
      maxProfitTree1.update(price, profit);
      if (maxProfit1 > 0)
        maxProfitTree2.update(price, profit + maxProfit1);
      if (maxProfit2 > 0)
        ans = max(ans, profit + maxProfit2);
    }

    return ans;
  }
};",2921
2919,inDegrees,2922
2920,"class Solution {
 public:
  int findChampion(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = -1;
    int count = 0;
    vector<int> inDegrees(n);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        if (i == j)
          continue;
        grid[i][j] == 1 ? ++inDegrees[j] : ++inDegrees[i];
      }

    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0) {
        ++count;
        ans = i;
      }

    return count > 1 ? -1 : ans;
  }
};",2923
2921,"class Solution {
 public:
  int findChampion(int n, vector<vector<int>>& edges) {
    int ans = -1;
    int count = 0;
    vector<int> inDegrees(n);

    for (const vector<int>& edge : edges) {
      const int v = edge[1];
      ++inDegrees[v];
    }

    for (int i = 0; i < n; ++i)
      if (inDegrees[i] == 0) {
        ++count;
        ans = i;
      }

    return count > 1 ? -1 : ans;
  }
};",2924
2922,"class Solution {
 public:
  long long maximumScoreAfterOperations(vector<vector<int>>& edges,
                                        vector<int>& values) {
    vector<vector<int>> tree(values.size());

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    return accumulate(values.begin(), values.end(), 0LL) -
           dfs(tree, 0, /*prev=*/-1, values);
  }

 private:
  // Returns the minimum of sum to be reduced.
  long long dfs(const vector<vector<int>>& tree, int u, int prev,
                const vector<int>& values) {
    if (u > 0 && tree[u].size() == 1)
      return values[u];
    long long childrenSum = 0;
    for (const int v : tree[u])
      if (v != prev)
        childrenSum += dfs(tree, v, u, values);
    return min(childrenSum, 1LL * values[u]);
  }
};",2925
2923,"template <typename T>
class FenwickTree {
 public:
  FenwickTree(int n) : vals(n + 1) {}

  // Updates the maximum the sum of subsequence ending in (i - 1) with `val`.
  void update(int i, T val) {
    while (i < vals.size()) {
      vals[i] = max(vals[i], val);
      i += lowbit(i);
    }
  }

  // Returns the maximum the sum of subsequence ending in (i - 1).
  T get(int i) const {
    T res = 0;
    while (i > 0) {
      res = max(res, vals[i]);
      i -= lowbit(i);
    }
    return res;
  }

 private:
  vector<T> vals;

  static int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  long long maxBalancedSubsequenceSum(vector<int>& nums) {
    // Let's define maxSum[i] := subsequence with the maximum sum ending in i
    // By observation:
    //     nums[i] - nums[j] >= i - j
    //  => nums[i] - i >= nums[j] - j
    //  So, if nums[i] - i >= nums[j] - j, where i > j,
    //  maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])
    long long ans = LLONG_MIN;
    FenwickTree<long long> tree(nums.size());

    for (const auto& [_, i] : getPairs(nums)) {
      const long long subseqSum = tree.get(i) + nums[i];
      tree.update(i + 1, subseqSum);
      ans = max(ans, subseqSum);
    }

    return ans;
  }

 private:
  vector<pair<int, int>> getPairs(const vector<int>& nums) {
    vector<pair<int, int>> pairs;
    for (int i = 0; i < nums.size(); ++i)
      pairs.emplace_back(nums[i] - i, i);
    ranges::sort(pairs);
    return pairs;
  }
};",2926
2924,"class Solution {
 public:
  long long distributeCandies(int n, int limit) {
    const int limitPlusOne = limit + 1;
    const long long oneChildExceedsLimit = ways(n - limitPlusOne);
    const long long twoChildrenExceedLimit = ways(n - 2 * limitPlusOne);
    const long long threeChildrenExceedLimit = ways(n - 3 * limitPlusOne);
    // Principle of Inclusion-Exclusion (PIE)
    return ways(n) - 3 * oneChildExceedsLimit + 3 * twoChildrenExceedLimit -
           threeChildrenExceedLimit;
  }

 private:
  // Returns the number of ways to distribute n candies to 3 children.
  long long ways(int n) {
    if (n < 0)
      return 0;
    // Stars and bars method:
    // e.g. '**|**|*' means to distribute 5 candies to 3 children, where
    // stars (*) := candies and bars (|) := dividers between children.
    return nCk(n + 2, 2);
  }

  long long nCk(int n, int k) {
    long long ans = 1;
    for (int i = 1; i <= k; ++i)
      ans *= (n - i + 1);
    for (int i = 1; i <= k; ++i)
      ans /= i;
    return ans;
  }
};",2927
2925,"class Solution {
 public:
  // Same as 2927. Distribute Candies Among Children III
  int distributeCandies(int n, int limit) {
    const int limitPlusOne = limit + 1;
    const int oneChildExceedsLimit = ways(n - limitPlusOne);
    const int twoChildrenExceedLimit = ways(n - 2 * limitPlusOne);
    const int threeChildrenExceedLimit = ways(n - 3 * limitPlusOne);
    // Principle of Inclusion-Exclusion (PIE)
    return ways(n) - 3 * oneChildExceedsLimit + 3 * twoChildrenExceedLimit -
           threeChildrenExceedLimit;
  }

 private:
  // Returns the number of ways to distribute n candies to 3 children.
  int ways(int n) {
    if (n < 0)
      return 0;
    // Stars and bars method:
    // e.g. '**|**|*' means to distribute 5 candies to 3 children, where
    // stars (*) := candies and bars (|) := dividers between children.
    return nCk(n + 2, 2);
  }

  int nCk(int n, int k) {
    int ans = 1;
    for (int i = 1; i <= k; ++i)
      ans *= (n - i + 1);
    for (int i = 1; i <= k; ++i)
      ans /= i;
    return ans;
  }
};",2928
2926,"class Solution {
 public:
  // Same as 2927. Distribute Candies Among Children III
  long long distributeCandies(int n, int limit) {
    const int limitPlusOne = limit + 1;
    const long long oneChildExceedsLimit = ways(n - limitPlusOne);
    const long long twoChildrenExceedLimit = ways(n - 2 * limitPlusOne);
    const long long threeChildrenExceedLimit = ways(n - 3 * limitPlusOne);
    // Principle of Inclusion-Exclusion (PIE)
    return ways(n) - 3 * oneChildExceedsLimit + 3 * twoChildrenExceedLimit -
           threeChildrenExceedLimit;
  }

 private:
  // Returns the number of ways to distribute n candies to 3 children.
  long long ways(int n) {
    if (n < 0)
      return 0;
    // Stars and bars method:
    // e.g. '**|**|*' means to distribute 5 candies to 3 children, where
    // stars (*) := candies and bars (|) := dividers between children.
    return nCk(n + 2, 2);
  }

  long long nCk(int n, int k) {
    long long ans = 1;
    for (int i = 1; i <= k; ++i)
      ans *= (n - i + 1);
    for (int i = 1; i <= k; ++i)
      ans /= i;
    return ans;
  }
};",2929
2927,"class Solution {
 public:
  int stringCount(int n) {
    // There're three invalid conditions:
    //   a. count('l') == 0
    //   b. count('e') < 2
    //   c. count('t') == 0
    //
    // By Principle of Inclusion-Exclusion (PIE):
    //   ans = allCount - a - b - c + ab + ac + bc - abc
    const long allCount = modPow(26, n);
    const long a = modPow(25, n);
    const long b = modPow(25, n);
    const long c = modPow(25, n) + n * modPow(25, n - 1);
    const long ab = modPow(24, n) + n * modPow(24, n - 1);
    const long ac = modPow(24, n);
    const long bc = modPow(24, n) + n * modPow(24, n - 1);
    const long abc = modPow(23, n) + n * modPow(23, n - 1);
    return ((allCount - a - b - c + ab + ac + bc - abc) % kMod + kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2930
2928,"class Solution {
 public:
  long long maxSpending(vector<vector<int>>& values) {
    const int m = values.size();
    const int n = values[0].size();
    long long ans = 0;
    long long d = 1;
    vector<int> items;

    for (const vector<int>& shop : values)
      for (const int item : shop)
        items.push_back(item);

    ranges::sort(items);

    for (const int item : items)
      ans += item * d++;

    return ans;
  }
};",2931
2929,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  TrieNode() : children(2) {}
  int min = INT_MAX;
  int max = INT_MIN;
};

class BitTrie {
 public:
  BitTrie(int maxBit) : maxBit(maxBit) {}

  void insert(int num) {
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      node->min = min(node->min, num);
      node->max = max(node->max, num);
    }
  }

  // Returns max(x ^ y), where |x - y| <= min(x, y).
  //
  // If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.
  // So, y <= 2 * x.
  int getMaxXor(int x) {
    int maxXor = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = x >> i & 1;
      const int toggleBit = bit ^ 1;
      // If `node.children[toggleBit].max > x`, it means there's a number in the
      // node that satisfies the condition to ensure that x <= y among x and y.
      // If `node.children[toggleBit].min <= 2 * x`, it means there's a number
      // in the node that satisfies the condition for a valid y.
      if (node->children[toggleBit] != nullptr &&
          node->children[toggleBit]->max > x &&
          node->children[toggleBit]->min <= 2 * x) {
        maxXor = maxXor | 1 << i;
        node = node->children[toggleBit];
      } else if (node->children[bit] != nullptr) {
        node = node->children[bit];
      } else {  // There's nothing in the Bit Trie.
        return 0;
      }
    }
    return maxXor;
  }

 private:
  const int maxBit;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  // Similar to 421. Maximum XOR of Two Numbers in an Array
  int maximumStrongPairXor(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    const int maxBit = static_cast<int>(log2(maxNum));
    int ans = 0;
    BitTrie bitTrie(maxBit);

    for (const int num : nums)
      bitTrie.insert(num);

    for (const int num : nums)
      ans = max(ans, bitTrie.getMaxXor(num));

    return ans;
  }
};",2932
2930,"class Solution {
 public:
  vector<string> findHighAccessEmployees(vector<vector<string>>& access_times) {
    unordered_set<string> ans;

    ranges::sort(access_times);

    for (int i = 0; i + 2 < access_times.size(); ++i) {
      const string& name = access_times[i][0];
      if (ans.count(name))
        continue;
      if (name != access_times[i + 2][0])
        continue;
      if (stoi(access_times[i + 2][1]) - stoi(access_times[i][1]) < 100)
        ans.insert(name);
    }

    return {ans.begin(), ans.end()};
  }
};",2933
2931,"class Solution {
 public:
  int minOperations(vector<int>& nums1, vector<int>& nums2) {
    const int n = nums1.size();
    const int mini = min(nums1.back(), nums2.back());
    const int maxi = max(nums1.back(), nums2.back());
    // the number of the minimum operations, where nums1[n - 1] is not swapped
    // with nums2[n - 1]
    int dp1 = 0;
    // the number of the minimum operations, where nums1[n - 1] is swapped with
    // nums2[n - 1]
    int dp2 = 0;

    for (int i = 0; i < n; ++i) {
      const int a = nums1[i];
      const int b = nums2[i];
      if (min(a, b) > mini)
        return -1;
      if (max(a, b) > maxi)
        return -1;
      if (a > nums1.back() || b > nums2.back())
        ++dp1;
      if (a > nums2.back() || b > nums1.back())
        ++dp2;
    }

    return min(dp1, dp2);
  }
};",2934
2932,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  TrieNode() : children(2) {}
  int min = INT_MAX;
  int max = INT_MIN;
};

class BitTrie {
 public:
  BitTrie(int maxBit) : maxBit(maxBit) {}

  void insert(int num) {
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      node->min = min(node->min, num);
      node->max = max(node->max, num);
    }
  }

  // Returns max(x ^ y), where |x - y| <= min(x, y).
  //
  // If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.
  // So, y <= 2 * x.
  int getMaxXor(int x) {
    int maxXor = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = maxBit; i >= 0; --i) {
      const int bit = x >> i & 1;
      const int toggleBit = bit ^ 1;
      // If `node.children[toggleBit].max > x`, it means there's a number in the
      // node that satisfies the condition to ensure that x <= y among x and y.
      // If `node.children[toggleBit].min <= 2 * x`, it means there's a number
      // in the node that satisfies the condition for a valid y.
      if (node->children[toggleBit] != nullptr &&
          node->children[toggleBit]->max > x &&
          node->children[toggleBit]->min <= 2 * x) {
        maxXor = maxXor | 1 << i;
        node = node->children[toggleBit];
      } else if (node->children[bit] != nullptr) {
        node = node->children[bit];
      } else {  // There's nothing in the Bit Trie.
        return 0;
      }
    }
    return maxXor;
  }

 private:
  const int maxBit;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  // Same as 2932. Maximum Strong Pair XOR I
  int maximumStrongPairXor(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    const int maxBit = static_cast<int>(log2(maxNum));
    int ans = 0;
    BitTrie bitTrie(maxBit);

    for (const int num : nums)
      bitTrie.insert(num);

    for (const int num : nums)
      ans = max(ans, bitTrie.getMaxXor(num));

    return ans;
  }
};",2935
2933,"/**
 * Definition for BigArray.
 * class BigArray {
 *  public:
 *   BigArray(vector<int> elements);
 *   int at(long long index);
 *   long long size();
 * };
 */

class Solution {
 public:
  int countBlocks(BigArray* nums) {
    return countBlocks(nums, 0, nums->size() - 1, nums->at(0),
                       nums->at(nums->size() - 1));
  }

 private:
  // Returns the number of maximal blocks in nums[l..r].
  int countBlocks(BigArray* nums, long long l, long long r, int leftValue,
                  int rightValue) {
    if (leftValue == rightValue)  // nums[l..r] are identical.
      return 1;
    if (l + 1 == r)  // nums[l] != nums[r].
      return 2;
    const long long m = (l + r) / 2;
    const int midValue = nums->at(m);
    // Substract nums[m], which will be counted twice.
    return countBlocks(nums, l, m, leftValue, midValue) +
           countBlocks(nums, m, r, midValue, rightValue) - 1;
  }
};",2936
2934,"class Solution {
 public:
  int findMinimumOperations(string s1, string s2, string s3) {
    const int minLength = min({s1.length(), s2.length(), s3.length()});
    int i = 0;
    while (i < minLength && s1[i] == s2[i] && s2[i] == s3[i])
      ++i;
    return i == 0 ? -1 : s1.length() + s2.length() + s3.length() - i * 3;
  }
};",2937
2935,"class Solution {
 public:
  long long minimumSteps(string s) {
    long long ans = 0;
    int ones = 0;

    for (const char c : s)
      if (c == '1')
        ++ones;
      else  // Move 1s to the front of the current '0'.
        ans += ones;

    return ans;
  }
};",2938
2936,"class Solution {
 public:
  int maximumXorProduct(long long a, long long b, int n) {
    constexpr int kMod = 1'000'000'007;
    if (n > 0)
      for (long long bit = 1LL << (n - 1); bit > 0; bit >>= 1)
        // Pick a bit if it makes min(a, b) larger.
        if ((min(a, b) & bit) == 0) {
          a ^= bit;
          b ^= bit;
        }
    return a % kMod * (b % kMod) % kMod;
  }
};",2939
2937,"struct IndexedQuery {
  int queryIndex;
  int a;  // Alice's index
  int b;  // Bob's index
};

class Solution {
 public:
  // Similar to 2736. Maximum Sum Queries
  vector<int> leftmostBuildingQueries(vector<int>& heights,
                                      vector<vector<int>>& queries) {
    vector<int> ans(queries.size(), -1);
    // Store indices (heightsIndex) of heights with heights[heightsIndex] in
    // descending order.
    vector<int> stack;

    // Iterate through queries and heights simultaneously.
    int heightsIndex = heights.size() - 1;
    for (const auto& [queryIndex, a, b] : getIndexedQueries(queries)) {
      if (a == b || heights[a] < heights[b]) {
        // 1. Alice and Bob are already in the same index (a == b) or
        // 2. Alice can jump from a -> b (heights[a] < heights[b]).
        ans[queryIndex] = b;
      } else {
        // Now, a < b and heights[a] >= heights[b].
        // Gradually add heights with an index > b to the monotonic stack.
        while (heightsIndex > b) {
          // heights[heightsIndex] is a better candidate, given that
          // heightsIndex is smaller than the indices in the stack and
          // heights[heightsIndex] is larger or equal to the heights mapped in
          // the stack.
          while (!stack.empty() &&
                 heights[stack.back()] <= heights[heightsIndex])
            stack.pop_back();
          stack.push_back(heightsIndex--);
        }
        // Binary search to find the smallest index j such that j > b and
        // heights[j] > heights[a], thereby ensuring heights[j] > heights[b].
        if (const auto it = upper_bound(
                stack.rbegin(), stack.rend(), a,
                [&](int a, int b) { return heights[a] < heights[b]; });
            it != stack.rend())
          ans[queryIndex] = *it;
      }
    }

    return ans;
  }

 private:
  vector<IndexedQuery> getIndexedQueries(const vector<vector<int>>& queries) {
    vector<IndexedQuery> indexedQueries;
    for (int i = 0; i < queries.size(); ++i) {
      // Make sure that a <= b.
      const int a = min(queries[i][0], queries[i][1]);
      const int b = max(queries[i][0], queries[i][1]);
      indexedQueries.push_back({i, a, b});
    }
    ranges::sort(
        indexedQueries,
        [](const IndexedQuery& a, const IndexedQuery& b) { return a.b > b.b; });
    return indexedQueries;
  }
};",2940
2938,"class Solution {
 public:
  long long maxGcdSum(vector<int>& nums, int k) {
    long long ans = 0;
    // [(startIndex, gcd of subarray starting at startIndex)]
    vector<pair<int, int>> startIndexAndGcds;
    vector<long long> prefix = {0};

    for (const int num : nums)
      prefix.push_back(prefix.back() + num);

    for (int i = 0; i < nums.size(); ++i) {
      vector<pair<int, int>> nextStartIndexAndGcds;
      for (const auto& [startIndex, gcd] : startIndexAndGcds) {
        const int nextGcd = __gcd(gcd, nums[i]);
        if (nextStartIndexAndGcds.empty() ||
            nextStartIndexAndGcds.back().second != nextGcd)  // Skip duplicates.
          nextStartIndexAndGcds.emplace_back(startIndex, nextGcd);
      }
      startIndexAndGcds = move(nextStartIndexAndGcds);
      startIndexAndGcds.emplace_back(i, nums[i]);
      for (const auto& [startIndex, gcd] : startIndexAndGcds)
        if (i - startIndex + 1 >= k)
          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd);
    }

    return ans;
  }
};",2941
2939,"class Solution {
 public:
  vector<int> findWordsContaining(vector<string>& words, char x) {
    vector<int> ans;

    for (int i = 0; i < words.size(); ++i)
      if (words[i].find(x) != string::npos)
        ans.push_back(i);

    return ans;
  }
};",2942
2940,"class Solution {
 public:
  int maximizeSquareHoleArea(int n, int m, vector<int>& hBars,
                             vector<int>& vBars) {
    const int gap = min(maxContinousGap(hBars), maxContinousGap(vBars));
    return gap * gap;
  }

 private:
  int maxContinousGap(vector<int>& bars) {
    int res = 2;
    int runningGap = 2;
    ranges::sort(bars);
    for (int i = 1; i < bars.size(); ++i) {
      runningGap = bars[i] == bars[i - 1] + 1 ? runningGap + 1 : 2;
      res = max(res, runningGap);
    }
    return res;
  }
};",2943
2941,"class Solution {
 public:
  int minimumCoins(vector<int>& prices) {
    const int n = prices.size();
    vector<int> dp(n + 1, INT_MAX);
    dp[n] = 0;

    for (int i = n - 1; i >= 0; --i)
      for (int j = i + 1; j <= min((i + 1) * 2, n); ++j)
        dp[i] = min(dp[i], prices[i] + dp[j]);

    return dp[0];
  }
};",2944
2942,"class Solution:
  def findMaximumLength(self, nums: List[int]) -> int:
    n = len(nums)
    kInf = 10_000_000_000
    # prefix[i] := the sum of the first i nums
    prefix = list(itertools.accumulate(nums, initial=0))
    # dp[i] := the maximum number of elements in the increasing
    # sequence after processing the first i nums
    dp = [0] * (n + 1)
    # last[i] := the last sum after processing the first i nums
    last = [0] + [kInf] * n

    for i in range(n):
      j = self._findIndex(i, prefix, last)
      dp[i + 1] = max(dp[i], dp[j] + 1)
      last[i + 1] = prefix[i + 1] - prefix[j]

    return dp[n]

  def _findIndex(self, i: int, prefix: List[int], last: List[int]) -> int:
    """"""Returns the index in [0..i].

    Returns the maximum index j in [0..i] s.t.
    prefix[i + 1] - prefix[j] >= last[j].
    """"""
    for j in range(i, -1, -1):
      if prefix[i + 1] - prefix[j] >= last[j]:
        return j",2945
2943,"class Solution {
 public:
  bool areSimilar(vector<vector<int>>& mat, int k) {
    const int n = mat[0].size();
    for (const vector<int>& row : mat)
      for (int j = 0; j < n; ++j)
        if (row[j] != row[(j + k) % n])
          return false;
    return true;
  }
};",2946
2944,"class Solution {
 public:
  int beautifulSubstrings(string s, int k) {
    const int root = getRoot(k);
    int ans = 0;
    int vowels = 0;
    int vowelsMinusConsonants = 0;
    // {(vowels, vowelsMinusConsonants): count}
    unordered_map<pair<int, int>, int, PairHash> prefixCount{{{0, 0}, 1}};

    for (const char c : s) {
      if (isVowel(c)) {
        vowels = (vowels + 1) % root;
        ++vowelsMinusConsonants;
      } else {
        --vowelsMinusConsonants;
      }
      const pair<int, int> prefix{vowels, vowelsMinusConsonants};
      ans += prefixCount[prefix]++;
    }

    return ans;
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }

  int getRoot(int k) {
    for (int i = 1; i <= k; ++i)
      if (i * i % k == 0)
        return i;
    throw;
  }

  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",2947
2945,"class Solution {
 public:
  vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {
    vector<int> ans(nums.size());
    // [[(num, index)]], where the difference between in each pair in each
    // `[(num, index)]` group <= `limit`
    vector<vector<pair<int, int>>> numAndIndexesGroups;

    for (const pair<int, int>& numAndIndex : getNumAndIndexes(nums))
      if (numAndIndexesGroups.empty() ||
          numAndIndex.first - numAndIndexesGroups.back().back().first > limit) {
        // Start a new group.
        numAndIndexesGroups.push_back({numAndIndex});
      } else {
        // Append to the existing group.
        numAndIndexesGroups.back().push_back(numAndIndex);
      }

    for (const vector<pair<int, int>>& numAndIndexesGroup :
         numAndIndexesGroups) {
      vector<int> sortedNums;
      vector<int> sortedIndices;
      for (const auto& [num, index] : numAndIndexesGroup) {
        sortedNums.push_back(num);
        sortedIndices.push_back(index);
      }
      ranges::sort(sortedIndices);
      for (int i = 0; i < sortedNums.size(); ++i)
        ans[sortedIndices[i]] = sortedNums[i];
    }

    return ans;
  }

 private:
  vector<pair<int, int>> getNumAndIndexes(const vector<int>& nums) {
    vector<pair<int, int>> numAndIndexes;
    for (int i = 0; i < nums.size(); ++i)
      numAndIndexes.emplace_back(nums[i], i);
    ranges::sort(numAndIndexes);
    return numAndIndexes;
  }
};",2948
2946,"class Solution {
 public:
  // Same as 2947. Count Beautiful Substrings I
  int beautifulSubstrings(string s, int k) {
    const int root = getRoot(k);
    int ans = 0;
    int vowels = 0;
    int vowelsMinusConsonants = 0;
    // {(vowels, vowelsMinusConsonants): count}
    unordered_map<pair<int, int>, int, PairHash> prefixCount{{{0, 0}, 1}};

    for (const char c : s) {
      if (isVowel(c)) {
        vowels = (vowels + 1) % root;
        ++vowelsMinusConsonants;
      } else {
        --vowelsMinusConsonants;
      }
      const pair<int, int> prefix{vowels, vowelsMinusConsonants};
      ans += prefixCount[prefix]++;
    }

    return ans;
  }

 private:
  bool isVowel(char c) {
    static constexpr string_view kVowels = ""aeiouAEIOU"";
    return kVowels.find(c) != string_view::npos;
  }

  int getRoot(int k) {
    for (int i = 1; i <= k; ++i)
      if (i * i % k == 0)
        return i;
    throw;
  }

  struct PairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",2949
2947,"class Solution {
 public:
  int countDivisibleSubstrings(string word) {
    // Let f(c) = d, where d = 1, 2, ..., 9.
    // Rephrase the question to return the number of substrings that satisfy
    //    f(c1) + f(c2) + ... + f(ck) / k = avg
    // => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].
    int ans = 0;

    for (int avg = 1; avg <= 9; ++avg) {
      int prefix = 0;
      unordered_map<int, int> prefixCount{{0, 1}};
      for (const char c : word) {
        prefix += f(c) - avg;
        ans += prefixCount[prefix]++;
      }
    }

    return ans;
  }

 private:
  int f(char c) {
    return 9 - ('z' - c) / 3;
  }
};",2950
2948,"class Solution {
 public:
  vector<int> findPeaks(vector<int>& mountain) {
    vector<int> ans;
    for (int i = 1; i + 1 < mountain.size(); ++i)
      if (mountain[i] > mountain[i - 1] && mountain[i] > mountain[i + 1])
        ans.push_back(i);
    return ans;
  }
};",2951
2949,"class Solution {
 public:
  // Same as 330. Patching Array
  int minimumAddedCoins(vector<int>& coins, int target) {
    int ans = 0;
    int i = 0;      // coins' index
    long miss = 1;  // the minimum sum in [1, n] we might miss

    ranges::sort(coins);

    while (miss <= target)
      if (i < coins.size() && coins[i] <= miss) {
        miss += coins[i++];
      } else {
        // Greedily add `miss` itself to increase the range from
        // [1, miss) to [1, 2 * miss).
        miss += miss;
        ++ans;
      }

    return ans;
  }
};",2952
2950,"class Solution {
 public:
  int countCompleteSubstrings(string word, int k) {
    const int uniqueLetters =
        unordered_set<char>{word.begin(), word.end()}.size();
    int ans = 0;

    for (int windowSize = k;
         windowSize <= k * uniqueLetters && windowSize <= word.length();
         windowSize += k)
      ans += countCompleteStrings(word, k, windowSize);

    return ans;
  }

 private:
  // Returns the number of complete substrings of `windowSize` of `word`.
  int countCompleteStrings(const string& word, int k, int windowSize) {
    int res = 0;
    int countLetters = 0;  // the number of letters in the running substring
    vector<int> count(26);

    for (int i = 0; i < word.length(); ++i) {
      ++count[word[i] - 'a'];
      ++countLetters;
      if (i > 0 && abs(word[i] - word[i - 1]) > 2) {
        count = vector<int>(26);
        // Start a new substring starting at word[i].
        ++count[word[i] - 'a'];
        countLetters = 1;
      }
      if (countLetters == windowSize + 1) {
        --count[word[i - windowSize] - 'a'];
        --countLetters;
      }
      if (countLetters == windowSize)
        res += ranges::all_of(count,
                              [k](int freq) { return freq == 0 || freq == k; })
                   ? 1
                   : 0;
    }

    return res;
  }
};",2953
2951,"class Solution {
 public:
  int numberOfSequence(int n, vector<int>& sick) {
    const auto [fact, invFact] = getFactAndInvFact(n - sick.size());
    long ans = fact[n - sick.size()];  // the number of infected children
    int prevSick = -1;

    for (int i = 0; i < sick.size(); ++i) {
      // The segment [prevSick + 1, sick - 1] are the current non-infected
      // children.
      const int nonInfected = sick[i] - prevSick - 1;
      prevSick = sick[i];
      if (nonInfected == 0)
        continue;
      ans *= invFact[nonInfected];
      ans %= kMod;
      if (i > 0) {
        // There're two choices per second since the children at the two
        // endpoints can both be the infect candidates. So, there are
        // 2^{nonInfected - 1} ways to infect all children in the current
        // segment.
        ans *= modPow(2, nonInfected - 1);
        ans %= kMod;
      }
    }

    const int nonInfected = n - sick.back() - 1;
    ans *= invFact[nonInfected];
    return ans % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  pair<vector<long>, vector<long>> getFactAndInvFact(int n) {
    vector<long> fact(n + 1);
    vector<long> invFact(n + 1);
    vector<long> inv(n + 1);
    fact[0] = invFact[0] = 1;
    inv[0] = inv[1] = 1;
    for (int i = 1; i <= n; ++i) {
      if (i >= 2)
        inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;
      fact[i] = fact[i - 1] * i % kMod;
      invFact[i] = invFact[i - 1] * inv[i] % kMod;
    }
    return {fact, invFact};
  }

  long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % kMod, (n - 1)) % kMod;
    return modPow(x * x % kMod, (n / 2)) % kMod;
  }
};",2954
2952,"class Solution {
 public:
  vector<int> sameEndSubstringCount(string s, vector<vector<int>>& queries) {
    vector<int> ans;
    vector<int> count(26);
    // counts[i] := the count of s[0..i)
    vector<vector<int>> counts = {count};

    for (const char c : s) {
      ++count[c - 'a'];
      counts.push_back(count);
    }

    for (const vector<int>& query : queries) {
      const int l = query[0];
      const int r = query[1];
      int sameEndCount = 0;
      for (char c = 'a'; c <= 'z'; ++c) {
        //   the count of s[0..r + 1) - the count of s[0..l)
        // = the count of s[l..r]
        const int freq = counts[r + 1][c - 'a'] - counts[l][c - 'a'];
        //   C(freq, 2) + freq
        // = freq * (freq - 1) / 2 + freq
        // = freq * (freq + 1) / 2
        sameEndCount += freq * (freq + 1) / 2;
      }
      ans.push_back(sameEndCount);
    }

    return ans;
  }
};",2955
2953,"class Solution {
 public:
  vector<int> findIntersectionValues(vector<int>& nums1, vector<int>& nums2) {
    const unordered_set<int> set1{nums1.begin(), nums1.end()};
    const unordered_set<int> set2{nums2.begin(), nums2.end()};
    const int ans1 =
        ranges::count_if(nums1, [&set2](int num) { return set2.count(num); });
    const int ans2 =
        ranges::count_if(nums2, [&set1](int num) { return set1.count(num); });
    return {ans1, ans2};
  }
};",2956
2954,"class Solution {
 public:
  int removeAlmostEqualCharacters(string word) {
    int ans = 0;

    int i = 1;
    while (i < word.length())
      if (abs(word[i] - word[i - 1]) <= 1) {
        ++ans;
        i += 2;
      } else {
        i += 1;
      }

    return ans;
  }
};",2957
2955,"class Solution {
 public:
  int maxSubarrayLength(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      ++count[nums[r]];
      while (count[nums[r]] == k + 1)
        --count[nums[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",2958
2956,"class Solution {
 public:
  int numberOfSets(int n, int maxDistance, vector<vector<int>>& roads) {
    const int maxMask = 1 << n;
    int ans = 0;

    for (int mask = 0; mask < maxMask; ++mask)
      if (floydWarshall(n, maxDistance, roads, mask) <= maxDistance)
        ++ans;

    return ans;
  }

 private:
  // Returns the maximum distance between any two branches, where the mask
  // represents the selected branches.
  int floydWarshall(int n, int maxDistanceThreshold, vector<vector<int>>& roads,
                    int mask) {
    int maxDistance = 0;
    vector<vector<int>> dist(n, vector<int>(n, maxDistanceThreshold + 1));

    for (int i = 0; i < n; ++i)
      if (mask >> i & 1)
        dist[i][i] = 0;

    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      const int w = road[2];
      if (mask >> u & 1 && mask >> v & 1) {
        dist[u][v] = min(dist[u][v], w);
        dist[v][u] = min(dist[v][u], w);
      }
    }

    for (int k = 0; k < n; ++k)
      if (mask >> k & 1)
        for (int i = 0; i < n; ++i)
          if (mask >> i & 1)
            for (int j = 0; j < n; ++j)
              if (mask >> j & 1)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    for (int i = 0; i < n; ++i)
      if (mask >> i & 1)
        for (int j = i + 1; j < n; ++j)
          if (mask >> j & 1)
            maxDistance = max(maxDistance, dist[i][j]);

    return maxDistance;
  }
};",2959
2957,"class Solution {
 public:
  int countTestedDevices(vector<int>& batteryPercentages) {
    int ans = 0;

    for (const int batteryPercentage : batteryPercentages)
      if (batteryPercentage - ans > 0)
        ++ans;

    return ans;
  }
};",2960
2958,"class Solution {
 public:
  vector<int> getGoodIndices(vector<vector<int>>& variables, int target) {
    vector<int> ans;
    for (int i = 0; i < variables.size(); ++i) {
      const int a = variables[i][0];
      const int b = variables[i][1];
      const int c = variables[i][2];
      const int m = variables[i][3];
      if (modPow(modPow(a, b, 10), c, m) == target)
        ans.push_back(i);
    }
    return ans;
  }

 private:
  long modPow(long x, long n, int mod) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x % mod, (n - 1), mod) % mod;
    return modPow(x * x % mod, (n / 2), mod) % mod;
  }
};",2961
2959,"class Solution {
 public:
  long long countSubarrays(vector<int>& nums, int k) {
    const int maxNum = ranges::max(nums);
    long long ans = 0;
    int count = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == maxNum)
        ++count;
      // Keep the window to include k - 1 times of the maximum number.
      while (count == k)
        if (nums[l++] == maxNum)
          --count;
      // If l > 0, nums[l..r] has k - 1 times of the maximum number. For any
      // subarray nums[i..r], where i < l, it will have at least k times of the
      // maximum number, since nums[l - 1] equals the maximum number.
      ans += l;
    }

    return ans;
  }
};",2962
2960,"class Solution {
 public:
  int numberOfGoodPartitions(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    int ans = 1;
    // lastSeen[num] := the index of the last time `num` appeared
    unordered_map<int, int> lastSeen;

    for (int i = 0; i < nums.size(); ++i)
      lastSeen[nums[i]] = i;

    // Track the maximum right index of each running partition by ensuring that
    // the first and last occurrences of a number fall within the same
    // partition.
    int maxRight = 0;
    for (int i = 0; i < nums.size(); ++i) {
      if (i > maxRight)
        // Start a new partition that starts from nums[i].
        // Each partition doubles the total number of good partitions.
        ans = (ans * 2L) % kMod;
      maxRight = max(maxRight, lastSeen[nums[i]]);
    }

    return ans;
  }
};",2963
2961,"class Solution {
 public:
  // Similar to 1995. Count Special Quadruplets
  int divisibleTripletCount(vector<int>& nums, int d) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int j = nums.size() - 1; j > 0; --j) {  // 'j' also represents k.
      for (int i = j - 1; i >= 0; --i)
        ans += count[(-(nums[i] + nums[j]) % d + d) % d];
      ++count[nums[j] % d];  // j := k
    }

    return ans;
  }
};",2964
2962,"class Solution {
 public:
  vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {
    const int n = grid.size();
    const int nSquared = n * n;
    vector<int> count(nSquared + 1);

    for (const vector<int>& row : grid)
      for (const int num : row)
        ++count[num];

    int repeated = -1;
    int missing = -1;

    for (int i = 1; i <= nSquared; ++i) {
      if (count[i] == 2)
        repeated = i;
      if (count[i] == 0)
        missing = i;
    }

    return {repeated, missing};
  }
};",2965
2963,"class Solution {
 public:
  vector<vector<int>> divideArray(vector<int>& nums, int k) {
    vector<vector<int>> ans;

    ranges::sort(nums);

    for (int i = 2; i < nums.size(); i += 3) {
      if (nums[i] - nums[i - 2] > k)
        return {};
      ans.push_back({nums[i - 2], nums[i - 1], nums[i]});
    }

    return ans;
  }
};",2966
2964,"class Solution {
 public:
  long long minimumCost(vector<int>& nums) {
    ranges::sort(nums);
    const int median = nums[nums.size() / 2];
    const int nextPalindrome = getPalindrome(median, /*delta=*/1);
    const int prevPalindrome = getPalindrome(median, /*delta=*/-1);
    return min(cost(nums, nextPalindrome), cost(nums, prevPalindrome));
  }

 private:
  // Returns the cost to change all the numbers to `palindrome`.
  long long cost(const vector<int>& nums, int palindrome) {
    return accumulate(nums.begin(), nums.end(), 0LL,
                      [palindrome](long long subtotal, int num) {
      return subtotal + abs(palindrome - num);
    });
  }

  // Returns the palindrome `p`, where p = num + a * delta and a > 0.
  int getPalindrome(int num, int delta) {
    while (!isPalindrome(num))
      num += delta;
    return num;
  }

  bool isPalindrome(int num) {
    const string original = to_string(num);
    const string reversed = {original.rbegin(), original.rend()};
    return original == reversed;
  }
};",2967
2965,"class Solution {
 public:
  int maxFrequencyScore(vector<int>& nums, long long k) {
    int ans = 0;
    long long cost = 0;

    ranges::sort(nums);

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      cost += nums[r] - nums[(l + r) / 2];
      while (cost > k)
        cost -= nums[(l + r + 1) / 2] - nums[l++];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",2968
2966,"class Solution {
 public:
  // Same as 2944. Minimum Number of Coins for Fruits
  int minimumCoins(vector<int>& prices) {
    const int n = prices.size();
    vector<int> dp(n + 1, INT_MAX);
    dp[n] = 0;

    for (int i = n - 1; i >= 0; --i)
      for (int j = i + 1; j <= min((i + 1) * 2, n); ++j)
        dp[i] = min(dp[i], prices[i] + dp[j]);

    return dp[0];
  }
};",2969
2967,"class Solution {
 public:
  int incremovableSubarrayCount(vector<int>& nums) {
    const int n = nums.size();
    const int startIndex = getStartIndexOfSuffix(nums);
    // If the complete array is strictly increasing, the total number of ways we
    // can remove elements equals the total number of possible subarrays.
    if (startIndex == 0)
      return n * (n + 1) / 2;

    // The valid removals starting from nums[0] include nums[0..startIndex - 1],
    // nums[0..startIndex], ..., nums[0..n).
    int ans = n - startIndex + 1;

    // Enumerate each prefix subarray that is strictly increasing.
    for (int i = 0; i < startIndex; ++i) {
      if (i > 0 && nums[i] <= nums[i - 1])
        break;
      // Since nums[0..i] is strictly increasing, find the first index j in
      // nums[startIndex..n) such that nums[j] > nums[i]. The valid removals
      // will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).
      ans += nums.end() -
             upper_bound(nums.begin() + startIndex, nums.end(), nums[i]) + 1;
    }

    return ans;
  }

 private:
  // Returns the start index i of the suffix subarray such that nums[i..n) is
  // strictly increasing.
  int getStartIndexOfSuffix(const vector<int>& nums) {
    for (int i = nums.size() - 2; i >= 0; --i)
      if (nums[i] >= nums[i + 1])
        return i + 1;
    return 0;
  }
};",2970
2968,"class Solution {
 public:
  long long largestPerimeter(vector<int>& nums) {
    long long prefix = accumulate(nums.begin(), nums.end(), 0LL);

    ranges::sort(nums);

    for (int i = nums.size() - 1; i >= 2; --i) {
      prefix -= nums[i];
      // Let nums[i] be the longest side. Check if the sum of all the edges with
      // length no longer than nums[i] > nums[i].
      if (prefix > nums[i])
        return prefix + nums[i];
    }

    return -1;
  }
};",2971
2969,"class Solution {
 public:
  // Same as 2970. Count the Number of Incremovable Subarrays I
  long long incremovableSubarrayCount(vector<int>& nums) {
    const int n = nums.size();
    const int startIndex = getStartIndexOfSuffix(nums);
    // If the complete array is strictly increasing, the total number of ways we
    // can remove elements equals the total number of possible subarrays.
    if (startIndex == 0)
      return static_cast<long long>(n) * (n + 1) / 2;

    // The valid removals starting from nums[0] include nums[0..startIndex - 1],
    // nums[0..startIndex], ..., nums[0..n).
    long long ans = n - startIndex + 1;

    // Enumerate each prefix subarray that is strictly increasing.
    for (int i = 0; i < startIndex; ++i) {
      if (i > 0 && nums[i] <= nums[i - 1])
        break;
      // Since nums[0..i] is strictly increasing, find the first index j in
      // nums[startIndex..n) such that nums[j] > nums[i]. The valid removals
      // will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).
      ans += nums.end() -
             upper_bound(nums.begin() + startIndex, nums.end(), nums[i]) + 1;
    }

    return ans;
  }

 private:
  // Returns the start index i of the suffix subarray such that nums[i..n) is
  // strictly increasing.
  int getStartIndexOfSuffix(const vector<int>& nums) {
    for (int i = nums.size() - 2; i >= 0; --i)
      if (nums[i] >= nums[i + 1])
        return i + 1;
    return 0;
  }
};",2972
2970,"class ChildCost {
 public:
  ChildCost(int cost) {
    numNodes = 1;
    if (cost > 0)
      maxPosCosts.push_back(cost);
    else
      minNegCosts.push_back(cost);
  }

  void update(ChildCost childCost) {
    numNodes += childCost.numNodes;
    ranges::copy(childCost.maxPosCosts, back_inserter(maxPosCosts));
    ranges::copy(childCost.minNegCosts, back_inserter(minNegCosts));
    ranges::sort(maxPosCosts, greater<int>());
    ranges::sort(minNegCosts);
    maxPosCosts.resize(min(static_cast<int>(maxPosCosts.size()), 3));
    minNegCosts.resize(min(static_cast<int>(minNegCosts.size()), 2));
  }

  long long maxProduct() {
    if (numNodes < 3)
      return 1;
    if (maxPosCosts.empty())
      return 0;
    long long res = 0;
    if (maxPosCosts.size() == 3)
      res = 1LL * maxPosCosts[0] * maxPosCosts[1] * maxPosCosts[2];
    if (minNegCosts.size() == 2)
      res = max(res, 1LL * minNegCosts[0] * minNegCosts[1] * maxPosCosts[0]);
    return res;
  }

 private:
  int numNodes;
  vector<int> maxPosCosts;
  vector<int> minNegCosts;
};

class Solution {
 public:
  vector<long long> placedCoins(vector<vector<int>>& edges, vector<int>& cost) {
    const int n = cost.size();
    vector<long long> ans(n);
    vector<vector<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, /*prev=*/-1, cost, ans);
    return ans;
  }

 private:
  ChildCost dfs(const vector<vector<int>>& tree, int u, int prev,
                const vector<int>& cost, vector<long long>& ans) {
    ChildCost res(cost[u]);
    for (const int v : tree[u])
      if (v != prev)
        res.update(dfs(tree, v, u, cost, ans));
    ans[u] = res.maxProduct();
    return res;
  }
};",2973
2971,"class Solution {
 public:
  vector<int> numberGame(vector<int>& nums) {
    ranges::sort(nums);
    for (int i = 0; i < nums.size(); i += 2)
      swap(nums[i], nums[i + 1]);
    return nums;
  }
};",2974
2972,"class Solution {
 public:
  int maximizeSquareArea(int m, int n, vector<int>& hFences,
                         vector<int>& vFences) {
    constexpr int kMod = 1'000'000'007;

    hFences.push_back(1);
    hFences.push_back(m);
    vFences.push_back(1);
    vFences.push_back(n);

    ranges::sort(hFences);
    ranges::sort(vFences);

    const unordered_set<int> hGaps = getGaps(hFences);
    const unordered_set<int> vGaps = getGaps(vFences);
    int maxGap = -1;

    for (const int hGap : hGaps)
      if (vGaps.count(hGap))
        maxGap = max(maxGap, hGap);

    return maxGap == -1 ? -1 : static_cast<long>(maxGap) * maxGap % kMod;
  }

 private:
  unordered_set<int> getGaps(const vector<int>& fences) {
    unordered_set<int> gaps;
    for (int i = 0; i < fences.size(); ++i)
      for (int j = 0; j < i; ++j)
        gaps.insert(fences[i] - fences[j]);
    return gaps;
  }
};",2975
2973,"class Solution {
 public:
  long long minimumCost(string source, string target, vector<char>& original,
                        vector<char>& changed, vector<int>& cost) {
    long long ans = 0;
    // dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)
    vector<vector<long long>> dist(26, vector<long long>(26, LLONG_MAX));

    for (int i = 0; i < cost.size(); ++i) {
      const int u = original[i] - 'a';
      const int v = changed[i] - 'a';
      dist[u][v] = min(dist[u][v], static_cast<long long>(cost[i]));
    }

    for (int k = 0; k < 26; ++k)
      for (int i = 0; i < 26; ++i)
        if (dist[i][k] < LLONG_MAX)
          for (int j = 0; j < 26; ++j)
            if (dist[k][j] < LLONG_MAX)
              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    for (int i = 0; i < source.length(); ++i) {
      if (source[i] == target[i])
        continue;
      const int u = source[i] - 'a';
      const int v = target[i] - 'a';
      if (dist[u][v] == LLONG_MAX)
        return -1;
      ans += dist[u][v];
    }

    return ans;
  }
};",2976
2974,"class Solution {
 public:
  long long minimumCost(string source, string target, vector<string>& original,
                        vector<string>& changed, vector<int>& cost) {
    const unordered_set<int> subLengths = getSubLengths(original);
    const unordered_map<string, int> subToId = getSubToId(original, changed);
    const int subCount = subToId.size();
    // dist[u][v] := the minimum distance to change the substring with id u to
    // the substring with id v
    vector<vector<long long>> dist(subCount,
                                   vector<long long>(subCount, LLONG_MAX));
    // dp[i] := the minimum cost to change the first i letters of `source` into
    // `target`, leaving the suffix untouched
    vector<long long> dp(source.length() + 1, LLONG_MAX);

    for (int i = 0; i < cost.size(); ++i) {
      const int u = subToId.at(original[i]);
      const int v = subToId.at(changed[i]);
      dist[u][v] = min(dist[u][v], static_cast<long long>(cost[i]));
    }

    for (int k = 0; k < subCount; ++k)
      for (int i = 0; i < subCount; ++i)
        if (dist[i][k] < LLONG_MAX)
          for (int j = 0; j < subCount; ++j)
            if (dist[k][j] < LLONG_MAX)
              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    dp[0] = 0;

    for (int i = 0; i < source.length(); ++i) {
      if (dp[i] == LLONG_MAX)
        continue;
      if (target[i] == source[i])
        dp[i + 1] = min(dp[i + 1], dp[i]);
      for (const int subLength : subLengths) {
        if (i + subLength > source.length())
          continue;
        const string subSource = source.substr(i, subLength);
        const string subTarget = target.substr(i, subLength);
        if (!subToId.count(subSource) || !subToId.count(subTarget))
          continue;
        const int u = subToId.at(subSource);
        const int v = subToId.at(subTarget);
        if (dist[u][v] < LLONG_MAX)
          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v]);
      }
    }

    return dp[source.length()] == LLONG_MAX ? -1 : dp[source.length()];
  }

 private:
  unordered_map<string, int> getSubToId(const vector<string>& original,
                                        const vector<string>& changed) {
    unordered_map<string, int> subToId;
    for (const string& s : original)
      if (!subToId.count(s))
        subToId[s] = subToId.size();
    for (const string& s : changed)
      if (!subToId.count(s))
        subToId[s] = subToId.size();
    return subToId;
  }

  unordered_set<int> getSubLengths(const vector<string>& original) {
    unordered_set<int> subLengths;
    for (const string& s : original)
      subLengths.insert(s.length());
    return subLengths;
  }
};",2977
2975,"WITH
  SymmetricCoordinates AS (
    SELECT DISTINCT C1.x, C1.y
    FROM Coordinates AS C1
    INNER JOIN Coordinates AS C2
      ON (C1.x, C1.y) = (C2.y, C2.x)
    WHERE C1.x < C1.y
    UNION ALL
    SELECT x, y
    FROM Coordinates
    WHERE x = y
    GROUP BY 1
    HAVING COUNT(*) > 1
  )
SELECT x, y
FROM SymmetricCoordinates
ORDER BY 1, 2;",2978
2976,"class Solution {
 public:
  int mostExpensiveItem(int primeOne, int primeTwo) {
    // https://en.wikipedia.org/wiki/Coin_problem
    return primeOne * primeTwo - primeOne - primeTwo;
  }
};",2979
2977,"class Solution {
 public:
  bool hasTrailingZeros(vector<int>& nums) {
    int countEven = 0;

    for (const int num : nums)
      if (num % 2 == 0)
        ++countEven;

    return countEven >= 2;
  }
};",2980
2978,"class Solution {
 public:
  int maximumLength(string s) {
    const int n = s.length();
    int ans = -1;
    int runningLen = 0;
    char prevLetter = '@';
    // counts[i][j] := the frequency of ('a' + i) repeating j times
    vector<vector<int>> counts(26, vector<int>(n + 1));

    for (const char c : s)
      if (c == prevLetter) {
        ++counts[c - 'a'][++runningLen];
      } else {
        runningLen = 1;
        ++counts[c - 'a'][runningLen];
        prevLetter = c;
      }

    for (const vector<int>& count : counts)
      ans = max(ans, getMaxFreq(count, n));

    return ans;
  }

 private:
  // Returns the maximum frequency that occurs more than three times.
  int getMaxFreq(const vector<int>& count, int maxFreq) {
    int times = 0;
    for (int freq = maxFreq; freq >= 1; --freq) {
      times += count[freq];
      if (times >= 3)
        return freq;
    }
    return -1;
  }
};",2981
2979,"class Solution {
 public:
  int maximumLength(string s) {
    const int n = s.length();
    int ans = -1;
    int runningLen = 0;
    char prevLetter = '@';
    // counts[i][j] := the frequency of ('a' + i) repeating j times
    vector<vector<int>> counts(26, vector<int>(n + 1));

    for (const char c : s)
      if (c == prevLetter) {
        ++counts[c - 'a'][++runningLen];
      } else {
        runningLen = 1;
        ++counts[c - 'a'][runningLen];
        prevLetter = c;
      }

    for (const vector<int>& count : counts)
      ans = max(ans, getMaxFreq(count, n));

    return ans;
  }

 private:
  // Returns the maximum frequency that occurs more than three times.
  int getMaxFreq(const vector<int>& count, int maxFreq) {
    int times = 0;
    for (int freq = maxFreq; freq >= 1; --freq) {
      times += count[freq];
      if (times >= 3)
        return freq;
    }
    return -1;
  }
};",2982
2980,"class Solution {
 public:
  vector<bool> canMakePalindromeQueries(string s,
                                        vector<vector<int>>& queries) {
    const int n = s.length();
    // mirroredDiffs[i] := the number of different letters between the first i
    // letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]
    const vector<int> mirroredDiffs = getMirroredDiffs(s);
    // counts[i] := the count of s[0..i)
    const vector<vector<int>> counts = getCounts(s);
    vector<bool> ans;

    for (const vector<int>& query : queries) {
      // Use left-closed, right-open intervals to facilitate the calculation.
      //   ...... [a, b) ...|... [rb, ra) ......
      //   .... [rd, rc) .....|..... [c, d) ....
      const int a = query[0];
      const int b = query[1] + 1;
      const int c = query[2];
      const int d = query[3] + 1;
      const int ra = n - a;  // the reflected index of a in s[n / 2..n)
      const int rb = n - b;  // the reflected index of b in s[n / 2..n)
      const int rc = n - c;  // the reflected index of c in s[n / 2..n)
      const int rd = n - d;  // the reflected index of d in s[n / 2..n)
      // No difference is allowed outside the query ranges.
      if (min(a, rd) > 0 && mirroredDiffs[min(a, rd)] > 0 ||
          n / 2 > max(b, rc) &&
              mirroredDiffs[n / 2] - mirroredDiffs[max(b, rc)] > 0 ||
          rd > b && mirroredDiffs[rd] - mirroredDiffs[b] > 0 ||
          a > rc && mirroredDiffs[a] - mirroredDiffs[rc] > 0) {
        ans.push_back(false);
      } else {
        // The `count` map of the intersection of [a, b) and [rd, rc) in
        // s[0..n / 2) must equate to the `count` map of the intersection of
        // [c, d) and [rb, ra) in s[n / 2..n).
        vector<int> leftRangeCount = subtractArrays(counts[b], counts[a]);
        vector<int> rightRangeCount = subtractArrays(counts[d], counts[c]);
        if (a > rd)
          rightRangeCount = subtractArrays(
              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]));
        if (rc > b)
          rightRangeCount = subtractArrays(
              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]));
        if (c > rb)
          leftRangeCount = subtractArrays(
              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]));
        if (ra > d)
          leftRangeCount = subtractArrays(
              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]));
        ans.push_back(ranges::all_of(leftRangeCount, [](int freq) {
          return freq >= 0;
        }) && ranges::all_of(rightRangeCount, [](int freq) {
          return freq >= 0;
        }) && leftRangeCount == rightRangeCount);
      }
    }

    return ans;
  }

 private:
  vector<int> getMirroredDiffs(const string& s) {
    vector<int> diffs(1);
    for (int i = 0, j = s.length() - 1; i < j; ++i, --j)
      diffs.push_back(diffs.back() + (s[i] != s[j] ? 1 : 0));
    return diffs;
  }

  vector<vector<int>> getCounts(const string& s) {
    vector<int> count(26);
    vector<vector<int>> counts{count};
    for (const char c : s) {
      ++count[c - 'a'];
      counts.push_back(count);
    }
    return counts;
  }

  vector<int> subtractArrays(const vector<int>& a, const vector<int>& b) {
    vector<int> res;
    for (int i = 0; i < a.size(); ++i)
      res.push_back(a[i] - b[i]);
    return res;
  }
};",2983
2981,"WITH
  CityHourCount AS (
    SELECT
      city,
      HOUR(call_time) AS call_hour,
      COUNT(*) AS number_of_calls
    FROM Calls
    GROUP BY 1, 2
  ),
  RankedCityHourCount AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY city
        ORDER BY number_of_calls DESC
      ) AS `rank`
    FROM CityHourCount
  )
SELECT
  city,
  call_hour AS peak_calling_hour,
  number_of_calls
FROM RankedCityHourCount
WHERE `rank` = 1
ORDER BY 2 DESC, 1 DESC;",2984
2982,"SELECT
  ROUND(
    SUM(item_count * order_occurrences) / SUM(order_occurrences),
    2
  ) AS average_items_per_order
FROM Orders;",2985
2983,"WITH
  TransactionNeighbors AS (
    SELECT
      user_id,
      spend,
      transaction_date,
      RANK() OVER(PARTITION BY user_id ORDER BY transaction_date) AS date_rank,
      FIRST_VALUE(spend) OVER(
        PARTITION BY user_id
        ORDER BY transaction_date
      ) AS first_spend,
      LAG(spend) OVER(
        PARTITION BY user_id
        ORDER BY transaction_date
      ) AS second_spend
    FROM Transactions
  )
SELECT
  user_id,
  spend AS third_transaction_spend,
  transaction_date AS third_transaction_date
FROM TransactionNeighbors
WHERE
  date_rank = 3
  AND spend > first_spend
  AND spend > second_spend
ORDER BY 1;",2986
2984,"SELECT city
FROM Listings
GROUP BY 1
HAVING AVG(price) > (SELECT AVG(price) FROM Listings)
ORDER BY 1;",2987
2985,"WITH
  RankedDepartments AS (
    SELECT
      dep_id,
      DENSE_RANK() OVER(
        ORDER BY COUNT(*) DESC
      ) AS `rank`
    FROM Employees
    GROUP BY 1
  )
SELECT
  Employees.emp_name AS manager_name,
  Employees.dep_id
FROM Employees
INNER JOIN RankedDepartments
  USING (dep_id)
WHERE
  Employees.position = 'Manager'
  AND RankedDepartments.`rank` = 1
ORDER BY dep_id;",2988
2986,"WITH
  TotalScores AS (
    SELECT assignment1 + assignment2 + assignment3 AS score
    FROM Scores
  )
SELECT MAX(score) - MIN(score) AS difference_in_score
FROM TotalScores;",2989
2987,"SELECT user_id
FROM Loans
WHERE loan_type IN ('Refinance', 'Mortgage')
GROUP BY 1
HAVING COUNT(DISTINCT loan_type) = 2
ORDER BY 1;",2990
2988,"WITH
  WineryToTotalPoints AS (
    SELECT
      country,
      winery,
      SUM(points) AS total_points
    FROM Wineries
    GROUP BY 1, 2
  ),
  RankedWineries AS (
    SELECT
      *,
      RANK() OVER(
        PARTITION BY country
        ORDER BY total_points DESC, winery
      ) AS `rank`
    FROM WineryToTotalPoints
  )
SELECT
  country,
  MAX(
    CASE WHEN `rank` = 1 THEN CONCAT(winery, ' (', total_points, ')') END
  ) AS top_winery,
  IFNULL(
    MAX(CASE WHEN `rank` = 2 THEN CONCAT(winery, ' (', total_points, ')') END),
    'No second winery'
  ) AS second_winery,
  IFNULL(
    MAX(CASE WHEN `rank` = 3 THEN CONCAT(winery, ' (', total_points, ')') END),
    'No third winery'
  ) AS third_winery
FROM RankedWineries
WHERE `rank` <= 3
GROUP BY 1
ORDER BY 1;",2991
2989,"class Solution {
 public:
  int selfDivisiblePermutationCount(int n) {
    return dfs(1, /*used=*/0, n);
  }

 private:
  int dfs(int num, int used, int n) {
    if (num > n)
      return 1;

    int count = 0;
    for (int i = 1; i <= n; ++i)
      if ((used >> i & 1) == 0 && (num % i == 0 || i % num == 0))
        count += dfs(num + 1, used | (1 << i), n);

    return count;
  }
};",2992
2990,"SELECT
  WEEK(purchase_date, 1) - WEEK('2023-11-01', 1) + 1 AS week_of_month,
  purchase_date,
  SUM(amount_spend) AS total_amount
FROM Purchases
WHERE
  DAYOFWEEK(purchase_date) = 6
  AND MONTH(purchase_date) = 11
  AND YEAR(purchase_date) = 2023
GROUP BY purchase_date
ORDER BY week_of_month;",2993
2991,"WITH
  Recursive Fridays AS (
     -- the first Friday of November 2023
    SELECT '2023-11-03' AS friday
    UNION ALL
    SELECT DATE_ADD(friday, INTERVAL 7 DAY)
    FROM Fridays
    -- the last day of November 2023 - 7 days
    WHERE friday < '2023-11-23'
  )
SELECT
  WEEK(Fridays.friday, 1) - WEEK('2023-11-01', 1) + 1 AS week_of_month,
  Fridays.friday AS purchase_date,
  IFNULL(SUM(Purchases.amount_spend), 0) AS total_amount
FROM Fridays
LEFT JOIN Purchases
  ON (Fridays.friday = Purchases.purchase_date)
GROUP BY Fridays.friday
ORDER BY week_of_month;",2994
2992,"WITH
  FirstSessions AS (
    SELECT
      user_id,
      session_type,
      RANK() OVER(PARTITION BY user_id ORDER BY session_start) AS session_rank
    FROM Sessions
  ),
  ViewerFirst AS (
    SELECT user_id
    FROM FirstSessions
    WHERE session_rank = 1 AND session_type = 'Viewer'
  )
SELECT
  Sessions.user_id,
  COUNT(*) AS sessions_count
FROM Sessions
INNER JOIN ViewerFirst
  USING (user_id)
WHERE Sessions.session_type = 'Streamer'
GROUP BY 1
ORDER BY sessions_count DESC, Sessions.user_id DESC;",2995
2993,"class Solution {
 public:
  int missingInteger(vector<int>& nums) {
    const unordered_set<int> numsSet{nums.begin(), nums.end()};
    int ans = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
      if (nums[i] != nums[i - 1] + 1)
        break;
      ans += nums[i];
    }

    while (numsSet.count(ans))
      ++ans;

    return ans;
  }
};",2996
2994,"class Solution {
 public:
  int minOperations(vector<int>& nums, int k) {
    const int xors = accumulate(nums.begin(), nums.end(), 0, bit_xor<>());
    return __builtin_popcount(k ^ xors);
  }
};",2997
2995,"class Solution {
 public:
  int minimumOperationsToMakeEqual(int x, int y) {
    if (x <= y)
      return y - x;

    queue<int> q{{x}};
    unordered_set<int> seen;

    for (int ans = 0; !q.empty(); ++ans) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int num = q.front();
        q.pop();
        if (num == y)
          return ans;
        if (seen.find(num) != seen.end())
          continue;
        seen.insert(num);
        if (num % 11 == 0)
          q.push(num / 11);
        if (num % 5 == 0)
          q.push(num / 5);
        q.push(num - 1);
        q.push(num + 1);
      }
    }

    throw;
  }
};",2998
2996,"class Solution {
 public:
  long long numberOfPowerfulInt(long long start, long long finish, int limit,
                                string s) {
    const string a = to_string(start);
    const string b = to_string(finish);
    const string aWithLeadingZeros = string(b.length() - a.length(), '0') + a;
    vector<vector<vector<long long>>> mem(
        b.length(), vector<vector<long long>>(2, vector<long long>(2, -1)));
    const string sWithLeadingZeros = string(b.length() - s.length(), '0') + s;
    return count(aWithLeadingZeros, b, 0, limit, s, true, true, mem);
  }

 private:
  // Returns the number of powerful integers, considering the i-th digit, where
  // `isTight1` indicates if the current digit is tightly bound for `a` and
  // `isTight2` indicates if the current digit is tightly bound for `b`.
  long long count(const string& a, const string& b, int i, int limit,
                  const string& s, bool isTight1, bool isTight2,
                  vector<vector<vector<long long>>>& mem) {
    if (i + s.length() == b.length()) {
      const string aMinSuffix = isTight1
                                    ? std::string(a.end() - s.length(), a.end())
                                    : string(s.length(), '0');
      const string bMaxSuffix = isTight2
                                    ? std::string(b.end() - s.length(), b.end())
                                    : string(s.length(), '9');
      const long long suffix = stoll(s);
      return stoll(aMinSuffix) <= suffix && suffix <= stoll(bMaxSuffix);
    }

    if (mem[i][isTight1][isTight2] != -1)
      return mem[i][isTight1][isTight2];

    long long res = 0;
    const int minDigit = isTight1 ? a[i] - '0' : 0;
    const int maxDigit = isTight2 ? b[i] - '0' : 9;

    for (int d = minDigit; d <= maxDigit; ++d) {
      if (d > limit)
        continue;
      const bool nextIsTight1 = isTight1 && (d == minDigit);
      const bool nextIsTight2 = isTight2 && (d == maxDigit);
      res += count(a, b, i + 1, limit, s, nextIsTight1, nextIsTight2, mem);
    }

    return mem[i][isTight1][isTight2] = res;
  }
};",2999
2997,"class Solution {
 public:
  int areaOfMaxDiagonal(vector<vector<int>>& dimensions) {
    const vector<int> maxDimension = *ranges::max_element(
        dimensions, [](const vector<int>& a, const vector<int>& b) {
      return (a[0] * a[0] + a[1] * a[1] == b[0] * b[0] + b[1] * b[1])
                 ? (a[0] * a[1] < b[0] * b[1])
                 : (a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1]);
    });
    return maxDimension[0] * maxDimension[1];
  }
};",3000
2998,"class Solution {
 public:
  int minMovesToCaptureTheQueen(int a, int b, int c, int d, int e, int f) {
    // The rook is in the same row as the queen.
    if (a == e)
      // The bishop blocks the rook or not.
      return (c == a && (b < d && d < f || b > d && d > f)) ? 2 : 1;
    // The rook is in the same column as the queen.
    if (b == f)
      // The bishop blocks the rook or not.
      return (d == f && (a < c && c < e || a > c && c > e)) ? 2 : 1;
    // The bishop is in the same up-diagonal as the queen.
    if (c + d == e + f)
      // The rook blocks the bishop or not.
      return (a + b == c + d && (c < a && a < e || c > a && a > e)) ? 2 : 1;
    // The bishop is in the same down-diagonal as the queen.
    if (c - d == e - f)
      // The rook blocks the bishop or not.
      return (a - b == c - d && (c < a && a < e || c > a && a > e)) ? 2 : 1;
    // The rook can always get the green in two steps.
    return 2;
  }
};",3001
2999,"class Solution {
 public:
  int maximumSetSize(vector<int>& nums1, vector<int>& nums2) {
    const unordered_set<int> set1{nums1.begin(), nums1.end()};
    const unordered_set<int> set2{nums2.begin(), nums2.end()};
    unordered_set<int> common;

    for (const int num1 : set1)
      if (set2.count(num1))
        common.insert(num1);

    const int n = nums1.size();
    const int n1 = set1.size();
    const int n2 = set2.size();
    const int nc = common.size();
    const int maxUniqueNums1 = min(n1 - nc, n / 2);
    const int maxUniqueNums2 = min(n2 - nc, n / 2);
    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc);
  }
};",3002
3000,"class Solution {
 public:
  int maxPartitionsAfterOperations(string s, int k) {
    unordered_map<long long, int> mem;
    return maxPartitionsAfterOperations(s, 0, true, 0, k, mem) + 1;
  }

 private:
  // Returns the maximum number of partitions of s[i..n), where `canChange` is
  // true if we can still change a letter, and `mask` is the bitmask of the
  // letters we've seen.
  int maxPartitionsAfterOperations(const string& s, int i, bool canChange,
                                   int mask, int k,
                                   unordered_map<long long, int>& mem) {
    if (i == s.length())
      return 0;

    long long key = static_cast<long long>(i) << 27 |
                    (canChange ? 1 : 0) << 26 | static_cast<long long>(mask);
    if (const auto it = mem.find(key); it != mem.end())
      return it->second;

    // Initialize the result based on the current letter.
    int res = getRes(s, i, canChange, mask, 1 << (s[i] - 'a'), k, mem);

    // If allowed, explore the option to change the current letter.
    if (canChange)
      for (int j = 0; j < 26; ++j)
        res = max(res, getRes(s, i, false, mask, 1 << j, k, mem));

    return mem[key] = res;
  }

  int getRes(const string& s, int i, bool nextCanChange, int mask, int newBit,
             int k, unordered_map<long long, int>& mem) {
    const int nextMask = mask | newBit;
    if (__builtin_popcount(nextMask) > k)  // fresh start
      return 1 + maxPartitionsAfterOperations(s, i + 1, nextCanChange, newBit,
                                              k, mem);
    return maxPartitionsAfterOperations(s, i + 1, nextCanChange, nextMask, k,
                                        mem);
  }
};",3003
3001,"class Solution {
 public:
  int maximumSubtreeSize(vector<vector<int>>& edges, vector<int>& colors) {
    int ans = 1;
    vector<vector<int>> tree(colors.size());

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
    }

    dfs(tree, 0, colors, ans);
    return ans;
  }

 private:
  // Returns the size of subtree of u if every node in the subtree has the same
  // color. Otherwise, returns -1.
  int dfs(const vector<vector<int>>& tree, int u, const vector<int>& colors,
          int& ans) {
    int res = 1;
    for (const int v : tree[u]) {
      if (colors[v] != colors[u])
        res = -1;
      // If any node in the subtree of v has a different color, the result of
      // the subtree of u will be -1 as well.
      const int subtreeSize = dfs(tree, v, colors, ans);
      if (subtreeSize == -1)
        res = -1;
      else if (res != -1)
        res += subtreeSize;
    }
    ans = max(ans, res);
    return res;
  }
};",3004
3002,"class Solution {
 public:
  int maxFrequencyElements(vector<int>& nums) {
    constexpr int kMax = 100;
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    const int maxFreq = ranges::max(count);
    return ranges::count(count, maxFreq) * maxFreq;
  }
};",3005
3003,"class Solution {
 public:
  vector<int> beautifulIndices(string s, string a, string b, int k) {
    vector<int> ans;
    const vector<int> indicesA = kmp(s, a);
    const vector<int> indicesB = kmp(s, b);
    int indicesBIndex = 0;  // indicesB's index

    for (const int i : indicesA) {
      // The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move
      // `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].
      while (indicesBIndex < indicesB.size() &&
             indicesB[indicesBIndex] - i < -k)
        ++indicesBIndex;
      if (indicesBIndex < indicesB.size() && indicesB[indicesBIndex] - i <= k)
        ans.push_back(i);
    }

    return ans;
  }

 private:
  // Returns the starting indices of all occurrences of the pattern in `s`.
  vector<int> kmp(const string& s, const string& pattern) {
    vector<int> res;
    const vector<int> lps = getLPS(pattern);
    int i = 0;  // s' index
    int j = 0;  // pattern's index
    while (i < s.length()) {
      if (s[i] == pattern[j]) {
        ++i;
        ++j;
        if (j == pattern.length()) {
          res.push_back(i - j);
          j = lps[j - 1];
        }
      }
      // Mismatch after j matches.
      else if (j > 0) {
        // Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1];
      } else {
        ++i;
      }
    }
    return res;
  }

  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const string& pattern) {
    vector<int> lps(pattern.length());
    for (int i = 1, j = 0; i < pattern.length(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }
};",3006
3004,"class Solution {
 public:
  long long findMaximumNumber(long long k, int x) {
    long long l = 1;
    long long r = 1e15;

    while (l < r) {
      long long m = (l + r + 1) / 2;
      if (getSumPrices(m, x) > k)
        r = m - 1;
      else
        l = m;
    }

    return l;
  }

 private:
  // Returns the sum of prices of all numbers from 1 to `num`.
  long long getSumPrices(long long num, int x) {
    long long sumPrices = 0;
    // Increment `num` to account the 0-th row in the count of groups.
    ++num;
    for (int i = leftmostColumnIndex(num); i > 0; --i)
      // If the current column is valid, count the number of 1s in this column.
      if (i % x == 0) {
        const long long groupSize = 1LL << i;
        const long long halfGroupSize = 1LL << i - 1;
        sumPrices += num / groupSize * halfGroupSize;
        sumPrices += max(0LL, (num % groupSize) - halfGroupSize);
      }
    return sumPrices;
  }

  // Returns the leftmost column index in 1-indexed.
  int leftmostColumnIndex(long long num) {
    return 63 - __builtin_clzll(num) + 1;
  }
};",3007
3005,"class Solution {
 public:
  // Same as 3006. Find Beautiful Indices in the Given Array I
  vector<int> beautifulIndices(string s, string a, string b, int k) {
    vector<int> ans;
    const vector<int> indicesA = kmp(s, a);
    const vector<int> indicesB = kmp(s, b);
    int indicesBIndex = 0;  // indicesB's index

    for (const int i : indicesA) {
      // The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move
      // `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].
      while (indicesBIndex < indicesB.size() &&
             indicesB[indicesBIndex] - i < -k)
        ++indicesBIndex;
      if (indicesBIndex < indicesB.size() && indicesB[indicesBIndex] - i <= k)
        ans.push_back(i);
    }

    return ans;
  }

 private:
  // Returns the starting indices of all occurrences of the pattern in `s`.
  vector<int> kmp(const string& s, const string& pattern) {
    vector<int> res;
    const vector<int> lps = getLPS(pattern);
    int i = 0;  // s' index
    int j = 0;  // pattern's index
    while (i < s.length()) {
      if (s[i] == pattern[j]) {
        ++i;
        ++j;
        if (j == pattern.length()) {
          res.push_back(i - j);
          j = lps[j - 1];
        }
      }
      // Mismatch after j matches.
      else if (j > 0) {
        // Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1];
      } else {
        ++i;
      }
    }
    return res;
  }

  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const string& pattern) {
    vector<int> lps(pattern.length());
    for (int i = 1, j = 0; i < pattern.length(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }
};",3008
3006,"class Solution {
 public:
  int maxIntersectionCount(vector<int>& y) {
    const int n = y.size();
    int ans = 0;
    int intersectionCount = 0;
    map<int, int> line;

    for (int i = 1; i < n; ++i) {
      const int start = 2 * y[i - 1];
      const int end = 2 * y[i] + (i == n - 1 ? 0 : y[i] > y[i - 1] ? -1 : 1);
      ++line[min(start, end)];
      --line[max(start, end) + 1];
    }

    for (const auto& [_, count] : line) {
      intersectionCount += count;
      ans = max(ans, intersectionCount);
    }

    return ans;
  }
};",3009
3007,"class Solution {
 public:
  int minimumCost(vector<int>& nums) {
    constexpr int kMax = 50;
    int min1 = kMax;
    int min2 = kMax;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < min1) {
        min2 = min1;
        min1 = nums[i];
      } else if (nums[i] < min2) {
        min2 = nums[i];
      }

    return nums[0] + min1 + min2;
  }
};",3010
3008,"class Solution {
 public:
  bool canSortArray(vector<int>& nums) {
    // Divide the array into distinct segments where each segment is comprised
    // of consecutive elements sharing an equal number of set bits. Ensure that
    // for each segment, when moving from left to right, the maximum of a
    // preceding segment is less than the minimum of the following segment.
    int prevSetBits = 0;
    int prevMax = INT_MIN;  // the maximum of the previous segment
    int currMax = INT_MIN;  // the maximum of the current segment
    int currMin = INT_MAX;  // the minimum of the current segment

    for (const int num : nums) {
      const int setBits = __builtin_popcount(num);
      if (setBits != prevSetBits) {  // Start a new segment.
        if (prevMax > currMin)
          return false;
        prevSetBits = setBits;
        prevMax = currMax;
        currMax = num;
        currMin = num;
      } else {  // Continue with the current segment.
        currMax = max(currMax, num);
        currMin = min(currMin, num);
      }
    }

    return prevMax <= currMin;
  }
};",3011
3009,"class Solution {
 public:
  int minimumArrayLength(vector<int>& nums) {
    // Let the minimum number in the array `nums` be x.
    // * If there exists any element nums[i] where nums[i] % x > 0, a new
    //   minimum can be generated and all other numbers can be removed.
    // * If not, count the frequency of x in `nums`. For each pair of x, a 0 is
    //   generated which cannot be removed. Therefore, the result will be
    //   (frequency of x + 1) / 2.
    const int minNum = ranges::min(nums);
    if (ranges::any_of(nums, [minNum](int num) { return num % minNum > 0; }))
      return 1;
    return (ranges::count(nums, minNum) + 1) / 2;
  }
};",3012
3010,"class Solution {
 public:
  long long minimumCost(vector<int>& nums, int k, int dist) {
    // Equivalently, the problem is to find nums[0] + the minimum sum of the top
    // k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.
    long long windowSum = 0;
    multiset<int> selected;
    multiset<int> candidates;

    for (int i = 1; i <= dist + 1; ++i) {
      windowSum += nums[i];
      selected.insert(nums[i]);
    }

    windowSum = balance(windowSum, selected, candidates, k);
    long long minWindowSum = windowSum;

    for (int i = dist + 2; i < nums.size(); ++i) {
      const int outOfScope = nums[i - dist - 1];
      if (selected.find(outOfScope) != selected.end()) {
        windowSum -= outOfScope;
        selected.erase(selected.find(outOfScope));
      } else {
        candidates.erase(candidates.find(outOfScope));
      }
      if (nums[i] < *selected.rbegin()) {  // nums[i] is a better number.
        windowSum += nums[i];
        selected.insert(nums[i]);
      } else {
        candidates.insert(nums[i]);
      }
      windowSum = balance(windowSum, selected, candidates, k);
      minWindowSum = min(minWindowSum, windowSum);
    }

    return nums[0] + minWindowSum;
  }

 private:
  // Returns the updated `windowSum` by balancing the multiset `selected` to
  // keep the top k - 1 numbers.
  long long balance(long long windowSum, multiset<int>& selected,
                    multiset<int>& candidates, int k) {
    while (selected.size() < k - 1) {
      const int minCandidate = *candidates.begin();
      windowSum += minCandidate;
      selected.insert(minCandidate);
      candidates.erase(candidates.find(minCandidate));
    }
    while (selected.size() > k - 1) {
      const int maxSelected = *selected.rbegin();
      windowSum -= maxSelected;
      selected.erase(selected.find(maxSelected));
      candidates.insert(maxSelected);
    }
    return windowSum;
  }
};",3013
3011,"class Solution {
 public:
  int minimumPushes(string word) {
    int ans = 0;
    vector<int> count(26);

    for (const char c : word)
      ++count[c - 'a'];

    ranges::sort(count, greater<>());

    for (int i = 0; i < 26; ++i)
      ans += count[i] * (i / 8 + 1);

    return ans;
  }
};",3014
3012,"class Solution {
 public:
  vector<int> countOfPairs(int n, int x, int y) {
    if (x > y)
      swap(x, y);

    const int ringLen = y - x + 1;
    const int leftLineLen = x - 1;
    const int rightLineLen = n - y;

    vector<int> ans(n);
    ans = addVectors(ans, bothInRing(n, ringLen));
    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));
    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));
    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));
    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));
    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));
    for (int& freq : ans)
      freq *= 2;
    return ans;
  }

 private:
  // Returns the contribution from the scenario where two houses are located in
  // the ring.
  vector<int> bothInRing(int n, int ringLen) {
    vector<int> res(n);
    for (int k = 1; k <= (ringLen - 1) / 2; ++k)
      res[k - 1] += ringLen;
    if (ringLen % 2 == 0)
      res[ringLen / 2 - 1] += ringLen / 2;
    return res;
  }

  // Returns the contribution from the scenario where two houses are either
  // located in the left line [1, x) or the right line (y, n].
  vector<int> bothInTheSameLine(int n, int lineLen) {
    vector<int> res(n);
    for (int k = 1; k <= lineLen; ++k)
      res[k - 1] += lineLen - k;
    return res;
  }

  // Returns the contribution from the scenario where one house is either
  // located in the left line [1, x) or the right line (y, n] and the other
  // house is located in the cycle.
  vector<int> lineToRing(int n, int lineLen, int ringLen) {
    vector<int> res(n);
    for (int k = 1; k <= lineLen + ringLen; ++k) {
      // min(
      //   at most k - 1 since we need to give 1 to the line,
      //   at most ringLen / 2 since for length > ringLen / 2, it can always be
      //     calculated as ringLen - ringLen / 2
      // )
      const int maxInRingLen = min(k - 1, ringLen / 2);
      // max(at least 0, at lest k - lineLen)
      const int minInRingLen = max(0, k - lineLen);
      if (minInRingLen <= maxInRingLen) {
        // Each ring length contributes 2 to the count due to the split of
        // paths when entering the ring: One path traverses the upper half of
        // the ring, and the other traverses the lower half.
        // This is illustrated as follows:
        //   Path 1: ... -- x -- (upper half of the ring)
        //   Path 2: ... -- x -- (lower half of the ring)
        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;
        if (minInRingLen == 0)
          // Subtract 1 since there's no split.
          res[k - 1] -= 1;
        if (maxInRingLen * 2 == ringLen)
          // Subtract 1 since the following case only contribute one:
          //   ... -- x -- (upper half of the ring) -- middle point
          //   ... -- x -- (upper half of the ring) -- middle point
          res[k - 1] -= 1;
      }
    }
    return res;
  }

  // Returns the contribution from the scenario where one house is in the left
  // line [1, x) and the other house is in the right line (y, n].
  vector<int> lineToLine(int n, int x, int y, int leftLineLen,
                         int rightLineLen) {
    vector<int> res(n);
    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {
      // min(
      //   at most leftLineLen,
      //   at most k - 1 - (x < y) since we need to give 1 to the right line
      //     and if x < y we need to give another 1 to ""x - y"".
      // )
      const int maxInLeft = min(leftLineLen, k - 1 - (x < y));
      // max(at least 1, at least k - rightLineLen - (x < y))
      const int minInLeft = max(1, k - rightLineLen - (x < y));
      if (minInLeft <= maxInLeft)
        res[k - 1] += maxInLeft - minInLeft + 1;
    }
    return res;
  }

  vector<int> addVectors(const vector<int>& a, const vector<int>& b) {
    vector<int> res(a.size());
    transform(a.begin(), a.end(), b.begin(), res.begin(), plus<int>());
    return res;
  };
};",3015
3013,"class Solution {
 public:
  // Same as 3014. Minimum Number of Pushes to Type Word I
  int minimumPushes(string word) {
    int ans = 0;
    vector<int> count(26);

    for (const char c : word)
      ++count[c - 'a'];

    ranges::sort(count, greater<>());

    for (int i = 0; i < 26; ++i)
      ans += count[i] * (i / 8 + 1);

    return ans;
  }
};",3016
3014,"class Solution {
 public:
  // Same as 3015. Count the Number of Houses at a Certain Distance I
  vector<long long> countOfPairs(int n, int x, int y) {
    if (x > y)
      swap(x, y);

    const int ringLen = y - x + 1;
    const int leftLineLen = x - 1;
    const int rightLineLen = n - y;

    vector<long long> ans(n);
    ans = addVectors(ans, bothInRing(n, ringLen));
    ans = addVectors(ans, bothInTheSameLine(n, leftLineLen));
    ans = addVectors(ans, bothInTheSameLine(n, rightLineLen));
    ans = addVectors(ans, lineToRing(n, leftLineLen, ringLen));
    ans = addVectors(ans, lineToRing(n, rightLineLen, ringLen));
    ans = addVectors(ans, lineToLine(n, x, y, leftLineLen, rightLineLen));
    for (long long& freq : ans)
      freq *= 2;
    return ans;
  }

 private:
  // Returns the contribution from the scenario where two houses are located in
  // the ring.
  vector<long long> bothInRing(int n, int ringLen) {
    vector<long long> res(n);
    for (int k = 1; k <= (ringLen - 1) / 2; ++k)
      res[k - 1] += ringLen;
    if (ringLen % 2 == 0)
      res[ringLen / 2 - 1] += ringLen / 2;
    return res;
  }

  // Returns the contribution from the scenario where two houses are either
  // located in the left line [1, x) or the right line (y, n].
  vector<long long> bothInTheSameLine(int n, int lineLen) {
    vector<long long> res(n);
    for (int k = 1; k <= lineLen; ++k)
      res[k - 1] += lineLen - k;
    return res;
  }

  // Returns the contribution from the scenario where one house is either
  // located in the left line [1, x) or the right line (y, n] and the other
  // house is located in the cycle.
  vector<long long> lineToRing(int n, int lineLen, int ringLen) {
    vector<long long> res(n);
    for (int k = 1; k <= lineLen + ringLen; ++k) {
      // min(
      //   at most k - 1 since we need to give 1 to the line,
      //   at most ringLen / 2 since for length > ringLen / 2, it can always be
      //     calculated as ringLen - ringLen / 2
      // )
      const int maxInRingLen = min(k - 1, ringLen / 2);
      // max(at least 0, at lest k - lineLen)
      const int minInRingLen = max(0, k - lineLen);
      if (minInRingLen <= maxInRingLen) {
        // Each ring length contributes 2 to the count due to the split of
        // paths when entering the ring: One path traverses the upper half of
        // the ring, and the other traverses the lower half.
        // This is illustrated as follows:
        //   Path 1: ... -- x -- (upper half of the ring)
        //   Path 2: ... -- x -- (lower half of the ring)
        res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2;
        if (minInRingLen == 0)
          // Subtract 1 since there's no split.
          res[k - 1] -= 1;
        if (maxInRingLen * 2 == ringLen)
          // Subtract 1 since the following case only contribute one:
          //   ... -- x -- (upper half of the ring) -- middle point
          //   ... -- x -- (upper half of the ring) -- middle point
          res[k - 1] -= 1;
      }
    }
    return res;
  }

  // Returns the contribution from the scenario where one house is in the left
  // line [1, x) and the other house is in the right line (y, n].
  vector<long long> lineToLine(int n, int x, int y, int leftLineLen,
                               int rightLineLen) {
    vector<long long> res(n);
    for (int k = 1; k <= leftLineLen + rightLineLen + 2; ++k) {
      // min(
      //   at most leftLineLen,
      //   at most k - 1 - (x < y) since we need to give 1 to the right line
      //     and if x < y we need to give another 1 to ""x - y"".
      // )
      const int maxInLeft = min(leftLineLen, k - 1 - (x < y));
      // max(at least 1, at least k - rightLineLen - (x < y))
      const int minInLeft = max(1, k - rightLineLen - (x < y));
      if (minInLeft <= maxInLeft)
        res[k - 1] += maxInLeft - minInLeft + 1;
    }
    return res;
  }

  vector<long long> addVectors(const vector<long long>& a,
                               const vector<long long>& b) {
    vector<long long> res(a.size());
    transform(a.begin(), a.end(), b.begin(), res.begin(), plus<int>());
    return res;
  };
};",3017
3015,"class Solution {
 public:
  int maximumProcessableQueries(vector<int>& nums, vector<int>& queries) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][j] := the maximum number of queries processed if nums[i..j] are not
    // removed after processing dp[i][j] queries
    vector<vector<int>> dp(n, vector<int>(n));

    for (int d = n - 1; d >= 0; --d) {
      for (int i = 0; i < n; ++i) {
        const int j = i + d;
        if (j >= n)
          continue;
        if (i > 0)
          // Remove nums[i - 1] from nums[i - 1..j] if possible.
          dp[i][j] = max(dp[i][j],
                         dp[i - 1][j] + (nums[i - 1] >= queries[dp[i - 1][j]]));
        if (j + 1 < n)
          // Remove nums[j + 1] from nums[i..j + 1] if possible.
          dp[i][j] = max(dp[i][j],
                         dp[i][j + 1] + (nums[j + 1] >= queries[dp[i][j + 1]]));
        if (dp[i][j] == queries.size())
          return queries.size();
      }
    }

    for (int i = 0; i < n; ++i)
      ans = max(ans, dp[i][i] + (nums[i] >= queries[dp[i][i]]));

    return ans;
  }
};",3018
3016,"class Solution {
 public:
  int countKeyChanges(string s) {
    int ans = 0;
    for (int i = 1; i < s.length(); ++i)
      if (tolower(s[i]) != tolower(s[i - 1]))
        ++ans;
    return ans;
  }
};",3019
3017,"class Solution {
 public:
  int maximumLength(vector<int>& nums) {
    const int maxNum = ranges::max(nums);
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    int ans = count.count(1) ? count[1] - (count[1] % 2 == 0) : 1;

    for (const int num : nums) {
      if (num == 1)
        continue;
      int length = 0;
      long x = num;
      while (x <= maxNum && count.count(x) && count[x] >= 2) {
        length += 2;
        x *= x;
      }
      // x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].
      // The goal is to determine if we can insert x^k in the middle of the
      // pattern to increase the length by 1. If not, we make x^(k/2) the middle
      // and decrease the length by 1.
      ans = max(ans, length + (count.count(x) ? 1 : -1));
    }

    return ans;
  }
};",3020
3018,"class Solution {
 public:
  long long flowerGame(int n, int m) {
    // Alice wins if x + y is odd, occurring when:
    //   1. x is even and y is odd, or
    //   2. y is even and x is odd.
    const int xEven = n / 2;
    const int yEven = m / 2;
    const int xOdd = (n + 1) / 2;
    const int yOdd = (m + 1) / 2;
    return static_cast<long long>(xEven) * yOdd +
           static_cast<long long>(yEven) * xOdd;
  }
};",3021
3019,"class Solution {
 public:
  int minOrAfterOperations(vector<int>& nums, int k) {
    constexpr int kMaxBit = 30;
    int ans = 0;
    int prefixMask = 0;  // Grows like: 10000 -> 11000 -> ... -> 11111.

    for (int i = kMaxBit; i >= 0; --i) {
      // Add the i-th bit to `prefixMask` and attempt to ""turn off"" the
      // currently added bit within k operations. If it's impossible, then we
      // add the i-th bit to the answer.
      prefixMask |= 1 << i;
      if (getMergeOps(nums, prefixMask, ans) > k)
        ans |= 1 << i;
    }

    return ans;
  }

 private:
  // Returns the number of merge operations to turn `prefixMask` to the target
  // by ANDing `nums`.
  int getMergeOps(const vector<int>& nums, int prefixMask, int target) {
    int mergeOps = 0;
    int ands = prefixMask;
    for (const int num : nums) {
      ands &= num;
      if ((ands | target) == target)
        ands = prefixMask;
      else
        ++mergeOps;  // Keep merging the next num.
    }
    return mergeOps;
  }
};",3022
3020,"/**
 * Definition for an infinite stream.
 * class InfiniteStream {
 *  public:
 *   InfiniteStream(vector<int> bits);
 *   int next();
 * };
 */

class Solution {
 public:
  int findPattern(InfiniteStream* stream, vector<int>& pattern) {
    const vector<int> lps = getLPS(pattern);
    int i = 0;    // stream's index
    int j = 0;    // pattern's index
    int bit = 0;  // the bit in the stream
    bool readNext = false;
    while (true) {
      if (!readNext) {
        bit = stream->next();
        readNext = true;
      }
      if (bit == pattern[j]) {
        ++i, readNext = false;
        ++j;
        if (j == pattern.size())
          return i - j;
      }
      // Mismatch after j matches.
      else if (j > 0) {
        // Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1];
      } else {
        ++i, readNext = false;
      }
    }
    throw;
  }

 private:
  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const vector<int>& pattern) {
    vector<int> lps(pattern.size());
    for (int i = 1, j = 0; i < pattern.size(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }
};",3023
3021,"class Solution {
 public:
  string triangleType(vector<int>& nums) {
    ranges::sort(nums);
    if (nums[0] + nums[1] <= nums[2])
      return ""none"";
    if (nums[0] == nums[1] && nums[1] == nums[2])
      return ""equilateral"";
    if (nums[0] == nums[1] || nums[1] == nums[2])
      return ""isosceles"";
    return ""scalene"";
  }
};",3024
3022,"class Solution {
 public:
  int numberOfPairs(vector<vector<int>>& points) {
    int ans = 0;

    ranges::sort(points, [](const vector<int>& a, const vector<int>& b) {
      return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
    });

    for (int i = 0; i < points.size(); ++i) {
      int maxY = INT_MIN;
      for (int j = i + 1; j < points.size(); ++j)
        if (points[i][1] >= points[j][1] && points[j][1] > maxY) {
          ++ans;
          maxY = points[j][1];
        }
    }

    return ans;
  }
};",3025
3023,"class Solution {
 public:
  long long maximumSubarraySum(vector<int>& nums, int k) {
    long long ans = LLONG_MIN;
    long long prefix = 0;
    // {num: the minimum prefix sum excluding `num`}
    unordered_map<int, long long> numToMinPrefix;

    for (const int num : nums) {
      if (const auto it = numToMinPrefix.find(num);
          it == numToMinPrefix.cend() || it->second > prefix) {
        numToMinPrefix[num] = prefix;
      }
      prefix += num;
      if (const auto it = numToMinPrefix.find(num + k);
          it != numToMinPrefix.cend())
        ans = max(ans, prefix - it->second);
      if (const auto it = numToMinPrefix.find(num - k);
          it != numToMinPrefix.cend())
        ans = max(ans, prefix - it->second);
    }

    return ans == LLONG_MIN ? 0 : ans;
  }
};",3026
3024,"class Solution {
 public:
  // Same as 3025. Find the Number of Ways to Place People I
  int numberOfPairs(vector<vector<int>>& points) {
    int ans = 0;

    ranges::sort(points, [](const vector<int>& a, const vector<int>& b) {
      return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
    });

    for (int i = 0; i < points.size(); ++i) {
      int maxY = INT_MIN;
      for (int j = i + 1; j < points.size(); ++j)
        if (points[i][1] >= points[j][1] && points[j][1] > maxY) {
          ++ans;
          maxY = points[j][1];
        }
    }

    return ans;
  }
};",3027
3025,"class Solution {
 public:
  int returnToBoundaryCount(vector<int>& nums) {
    partial_sum(nums.begin(), nums.end(), nums.begin());
    return ranges::count(nums, 0);
  }
};",3028
3026,"class Solution {
 public:
  // Same as 3029. Minimum Time to Revert Word to Initial State I
  int minimumTimeToInitialState(string word, int k) {
    const int n = word.length();
    const int maxOps = (n - 1) / k + 1;
    const vector<int> z = zFunction(word);
    for (int ans = 1; ans < maxOps; ++ans)
      if (z[ans * k] >= n - ans * k)
        return ans;
    return maxOps;
  }

  // Returns the z array, where z[i] is the length of the longest prefix of
  // s[i..n) which is also a prefix of s.
  //
  // https://cp-algorithms.com/string/z-function.html#implementation
  vector<int> zFunction(const string& s) {
    const int n = s.length();
    vector<int> z(n);
    int l = 0;
    int r = 0;
    for (int i = 1; i < n; ++i) {
      if (i < r)
        z[i] = min(r - i, z[i - l]);
      while (i + z[i] < n && s[z[i]] == s[i + z[i]])
        ++z[i];
      if (i + z[i] > r) {
        l = i;
        r = i + z[i];
      }
    }
    return z;
  }
};",3029
3027,"class Solution {
 public:
  vector<vector<int>> resultGrid(vector<vector<int>>& image, int threshold) {
    const int m = image.size();
    const int n = image[0].size();
    vector<vector<int>> sums(m, vector<int>(n));
    vector<vector<int>> counts(m, vector<int>(n));

    for (int i = 0; i < m - 2; ++i)
      for (int j = 0; j < n - 2; ++j)
        if (isRegion(image, i, j, threshold)) {
          const int subgridSum = getSubgridSum(image, i, j);
          for (int x = i; x < i + 3; ++x)
            for (int y = j; y < j + 3; ++y) {
              sums[x][y] += subgridSum / 9;
              counts[x][y] += 1;
            }
        }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (counts[i][j] > 0)
          image[i][j] = sums[i][j] / counts[i][j];

    return image;
  }

 private:
  // Returns true if image[i..i + 2][j..j + 2] is a region.
  bool isRegion(const vector<vector<int>>& image, int i, int j, int threshold) {
    for (int x = i; x < i + 3; ++x)
      for (int y = j; y < j + 3; ++y) {
        if (x > i && abs(image[x][y] - image[x - 1][y]) > threshold)
          return false;
        if (y > j && abs(image[x][y] - image[x][y - 1]) > threshold)
          return false;
      }
    return true;
  }

  // Returns the sum of image[i..i + 2][j..j + 2].
  int getSubgridSum(const vector<vector<int>>& image, int i, int j) {
    int subgridSum = 0;
    for (int x = i; x < i + 3; ++x)
      for (int y = j; y < j + 3; ++y)
        subgridSum += image[x][y];
    return subgridSum;
  }
};",3030
3028,"class Solution {
 public:
  // Same as 3029. Minimum Time to Revert Word to Initial State I
  int minimumTimeToInitialState(string word, int k) {
    const int n = word.length();
    const int maxOps = (n - 1) / k + 1;
    const vector<int> z = zFunction(word);
    for (int ans = 1; ans < maxOps; ++ans)
      if (z[ans * k] >= n - ans * k)
        return ans;
    return maxOps;
  }

  // Returns the z array, where z[i] is the length of the longest prefix of
  // s[i..n) which is also a prefix of s.
  //
  // https://cp-algorithms.com/string/z-function.html#implementation
  vector<int> zFunction(const string& s) {
    const int n = s.length();
    vector<int> z(n);
    int l = 0;
    int r = 0;
    for (int i = 1; i < n; ++i) {
      if (i < r)
        z[i] = min(r - i, z[i - l]);
      while (i + z[i] < n && s[z[i]] == s[i + z[i]])
        ++z[i];
      if (i + z[i] > r) {
        l = i;
        r = i + z[i];
      }
    }
    return z;
  }
};",3031
3029,"class Solution {
 public:
  int numberCount(int a, int b) {
    int ans = 0;
    for (int num = a; num <= b; ++num)
      if (isUniqueDigits(num))
        ++ans;
    return ans;
  }

 private:
  bool isUniqueDigits(int num) {
    vector<bool> seen(10);
    while (num > 0) {
      const int digit = num % 10;
      if (seen[digit])
        return false;
      seen[digit] = true;
      num /= 10;
    }
    return true;
  }
};",3032
3030,"class Solution {
 public:
  vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> ans = matrix;

    for (int j = 0; j < n; ++j) {
      int maxi = 0;
      for (int i = 0; i < m; ++i)
        maxi = max(maxi, matrix[i][j]);
      for (int i = 0; i < m; ++i)
        if (matrix[i][j] == -1)
          ans[i][j] = maxi;
    }

    return ans;
  }
};",3033
3031,"class Solution {
 public:
  int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {
    const vector<int> numsPattern = getNumsPattern(nums);
    return kmp(numsPattern, pattern);
  }

 private:
  int getNum(int a, int b) {
    if (a < b)
      return 1;
    if (a > b)
      return -1;
    return 0;
  }

  vector<int> getNumsPattern(const vector<int>& nums) {
    vector<int> numsPattern;
    for (int i = 1; i < nums.size(); ++i)
      numsPattern.push_back(getNum(nums[i - 1], nums[i]));
    return numsPattern;
  }

  // Returns the number of occurrences of the pattern in `nums`.
  int kmp(const vector<int>& nums, const vector<int>& pattern) {
    const vector<int> lps = getLPS(pattern);
    int res = 0;
    int i = 0;  // nums' index
    int j = 0;  // pattern's index
    while (i < nums.size()) {
      if (nums[i] == pattern[j]) {
        ++i;
        ++j;
        if (j == pattern.size()) {
          ++res;
          j = lps[j - 1];
        }
      }
      // Mismatch after j matches.
      else if (j > 0) {
        // Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1];
      } else {
        ++i;
      }
    }
    return res;
  }

  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const vector<int>& pattern) {
    vector<int> lps(pattern.size());
    for (int i = 1, j = 0; i < pattern.size(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }
};",3034
3032,"class Solution {
 public:
  int maxPalindromesAfterOperations(vector<string>& words) {
    int ans = 0;
    int pairs = getPairs(words);

    for (const int length : getSortedLengths(words)) {
      const int needPairs = length / 2;
      if (pairs < needPairs)
        return ans;
      ++ans;
      pairs -= needPairs;
    }

    return ans;
  }

 private:
  int getPairs(const vector<string>& words) {
    int pairs = 0;
    unordered_map<char, int> count;

    for (const string& word : words)
      for (const char c : word)
        ++count[c];

    for (const auto& [_, freq] : count)
      pairs += freq / 2;

    return pairs;
  }

  vector<int> getSortedLengths(const vector<string>& words) {
    vector<int> lengths;
    for (const string& word : words)
      lengths.push_back(word.length());
    ranges::sort(lengths);
    return lengths;
  }
};",3035
3033,"class Solution {
 public:
  // Same as 3034. Number of Subarrays That Match a Pattern I
  int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {
    const vector<int> numsPattern = getNumsPattern(nums);
    return kmp(numsPattern, pattern);
  }

 private:
  int getNum(int a, int b) {
    if (a < b)
      return 1;
    if (a > b)
      return -1;
    return 0;
  }

  vector<int> getNumsPattern(const vector<int>& nums) {
    vector<int> numsPattern;
    for (int i = 1; i < nums.size(); ++i)
      numsPattern.push_back(getNum(nums[i - 1], nums[i]));
    return numsPattern;
  }

  // Returns the number of occurrences of the pattern in `nums`.
  int kmp(const vector<int>& nums, const vector<int>& pattern) {
    const vector<int> lps = getLPS(pattern);
    int res = 0;
    int i = 0;  // nums' index
    int j = 0;  // pattern's index
    while (i < nums.size()) {
      if (nums[i] == pattern[j]) {
        ++i;
        ++j;
        if (j == pattern.size()) {
          ++res;
          j = lps[j - 1];
        }
      }
      // Mismatch after j matches.
      else if (j > 0) {
        // Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1];
      } else {
        ++i;
      }
    }
    return res;
  }

  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const vector<int>& pattern) {
    vector<int> lps(pattern.size());
    for (int i = 1, j = 0; i < pattern.size(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }
};",3036
3034,"/**
 * Definition for an infinite stream.
 * class InfiniteStream {
 *  public:
 *   InfiniteStream(vector<int> bits);
 *   int next();
 * };
 */

class Solution {
 public:
  // Same as 3023. Find Pattern in Infinite Stream I
  int findPattern(InfiniteStream* stream, vector<int>& pattern) {
    const vector<int> lps = getLPS(pattern);
    int i = 0;    // stream's index
    int j = 0;    // pattern's index
    int bit = 0;  // the bit in the stream
    bool readNext = false;
    while (true) {
      if (!readNext) {
        bit = stream->next();
        readNext = true;
      }
      if (bit == pattern[j]) {
        ++i, readNext = false;
        ++j;
        if (j == pattern.size())
          return i - j;
      }
      // Mismatch after j matches.
      else if (j > 0) {
        // Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1];
      } else {
        ++i, readNext = false;
      }
    }
    throw;
  }

 private:
  // Returns the lps array, where lps[i] is the length of the longest prefix of
  // pattern[0..i] which is also a suffix of this substring.
  vector<int> getLPS(const vector<int>& pattern) {
    vector<int> lps(pattern.size());
    for (int i = 1, j = 0; i < pattern.size(); ++i) {
      while (j > 0 && pattern[j] != pattern[i])
        j = lps[j - 1];
      if (pattern[i] == pattern[j])
        lps[i] = ++j;
    }
    return lps;
  }
};",3037
3035,"class Solution {
 public:
  int maxOperations(vector<int>& nums) {
    int ans = 1;
    int sum = nums[0] + nums[1];

    for (int i = 2; i + 1 < nums.size(); i += 2) {
      if (nums[i] + nums[i + 1] == sum)
        ++ans;
      else
        break;
    }

    return ans;
  }
};",3038
3036,"class Solution {
 public:
  string lastNonEmptyString(string s) {
    string ans;
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    const int maxFreq = ranges::max(count);

    for (int i = s.length() - 1; i >= 0; --i)
      if (count[s[i] - 'a']-- == maxFreq)
        ans += s[i];

    return {ans.rbegin(), ans.rend()};
  }
};",3039
3037,"class Solution {
 public:
  int maxOperations(vector<int>& nums) {
    const int n = nums.size();
    unordered_map<string, int> mem;
    return max({maxOperations(nums, 0, n - 1, nums[0] + nums[1], mem),
                maxOperations(nums, 0, n - 1, nums[n - 1] + nums[n - 2], mem),
                maxOperations(nums, 0, n - 1, nums[0] + nums[n - 1], mem)});
  }

 private:
  // Returns the maximum number of operations that can be performed for
  // nums[i..j], s.t. all operations have the same `score`.
  int maxOperations(const vector<int>& nums, int i, int j, int score,
                    unordered_map<string, int>& mem) {
    if (i >= j)
      return 0;
    const string key = hash(i, j, score);
    if (const auto it = mem.find(key); it != mem.end())
      return it->second;
    const int deleteFirstTwo =
        nums[i] + nums[i + 1] == score
            ? 1 + maxOperations(nums, i + 2, j, score, mem)
            : 0;
    const int deleteLastTwo =
        nums[j] + nums[j - 1] == score
            ? 1 + maxOperations(nums, i, j - 2, score, mem)
            : 0;
    const int deleteFirstAndLast =
        nums[i] + nums[j] == score
            ? 1 + maxOperations(nums, i + 1, j - 1, score, mem)
            : 0;
    return mem[key] = max({deleteFirstTwo, deleteLastTwo, deleteFirstAndLast});
  }

  string hash(int i, int j, int score) {
    return to_string(i) + "","" + to_string(j) + "","" + to_string(score);
  }
};",3040
3038,"class Solution {
 public:
  int maxSelectedElements(vector<int>& nums) {
    int ans = 0;
    // {num: the length of the longest consecutive elements ending at num}
    unordered_map<int, int> dp;

    ranges::sort(nums);

    for (const int num : nums) {
      dp[num + 1] = dp[num] + 1;
      dp[num] = dp[num - 1] + 1;
      ans = max({ans, dp[num], dp[num + 1]});
    }

    return ans;
  }
};",3041
3039,"struct TrieNode {
  unordered_map<int, shared_ptr<TrieNode>> children;
  int count = 0;
};

class Trie {
 public:
  int insert(const string& word) {
    const int n = word.length();
    int count = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = 0; i < n; ++i) {
      const int j = hash(word[i], word[n - 1 - i]);
      if (node->children[j] == nullptr)
        node->children[j] = make_shared<TrieNode>();
      node = node->children[j];
      count += node->count;
    }
    ++node->count;
    return count;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  static int hash(char prefix, char suffix) {
    return 26 * (prefix - 'a') + (suffix - 'a');
  }
};

class Solution {
 public:
  long long countPrefixSuffixPairs(vector<string>& words) {
    long long ans = 0;
    Trie trie;

    for (const string& word : words)
      ans += trie.insert(word);

    return ans;
  }
};",3042
3040,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  TrieNode() : children(10) {}
};

class Trie {
 public:
  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - '0';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
  }

  int search(const string& word) {
    int prefixLength = 0;
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - '0';
      if (node->children[i] == nullptr)
        break;
      node = node->children[i];
      ++prefixLength;
    }
    return prefixLength;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {
    int ans = 0;
    Trie trie;

    for (const int num : arr1)
      trie.insert(to_string(num));

    for (const int num : arr2)
      ans = max(ans, trie.search(to_string(num)));

    return ans;
  }
};",3043
3041,"class Solution {
 public:
  int mostFrequentPrime(vector<vector<int>>& mat) {
    constexpr int dirs[8][2] = {{1, 0},  {1, -1}, {0, -1}, {-1, -1},
                                {-1, 0}, {-1, 1}, {0, 1},  {1, 1}};
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = -1;
    int maxFreq = 0;
    unordered_map<int, int> count;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        for (const auto& [dx, dy] : dirs) {
          int num = 0;
          for (int x = i, y = j; 0 <= x && x < m && 0 <= y && y < n;
               x += dx, y += dy) {
            num = num * 10 + mat[x][y];
            if (num > 10 && isPrime(num))
              ++count[num];
          }
        }

    for (const auto& [prime, freq] : count)
      if (freq > maxFreq) {
        ans = prime;
        maxFreq = freq;
      } else if (freq == maxFreq) {
        ans = max(ans, prime);
      }

    return ans;
  }

 private:
  bool isPrime(int num) {
    for (int i = 2; i < sqrt(num) + 1; ++i)
      if (num % i == 0)
        return false;
    return true;
  }
};",3044
